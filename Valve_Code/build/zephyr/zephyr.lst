
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:

void i2c_dump_msgs(const char *name, const struct i2c_msg *msgs,
		   uint8_t num_msgs, uint16_t addr)
{
	LOG_DBG("I2C msg: %s, addr=%x", name, addr);
	for (unsigned int i = 0; i < num_msgs; i++) {
   0:	b8 42 00 20 fd 4f 00 00 51 75 01 00 b5 4f 00 00     .B. .O..Qu...O..
  10:	b5 4f 00 00 b5 4f 00 00 b5 4f 00 00 b5 4f 00 00     .O...O...O...O..
	...
  2c:	65 41 00 00 b5 4f 00 00 00 00 00 00 09 41 00 00     eA...O.......A..
  3c:	b5 4f 00 00                                         .O..

00000040 <_irq_vector_table>:
  40:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  50:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  60:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  70:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  80:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  90:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  a0:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  b0:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  c0:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  d0:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  e0:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
  f0:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
 100:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
 110:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
 120:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
 130:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
 140:	f5 41 00 00 f5 41 00 00 f5 41 00 00 f5 41 00 00     .A...A...A...A..
 150:	f5 41 00 00                                         .A..

Disassembly of section text:

00000154 <__aeabi_uldivmod>:
     154:	b953      	cbnz	r3, 16c <__aeabi_uldivmod+0x18>
     156:	b94a      	cbnz	r2, 16c <__aeabi_uldivmod+0x18>
     158:	2900      	cmp	r1, #0
     15a:	bf08      	it	eq
     15c:	2800      	cmpeq	r0, #0
     15e:	bf1c      	itt	ne
     160:	f04f 31ff 	movne.w	r1, #4294967295
     164:	f04f 30ff 	movne.w	r0, #4294967295
     168:	f000 b80c 	b.w	184 <__aeabi_idiv0>
     16c:	f1ad 0c08 	sub.w	ip, sp, #8
     170:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     174:	f000 f808 	bl	188 <__udivmoddi4>
     178:	f8dd e004 	ldr.w	lr, [sp, #4]
     17c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     180:	b004      	add	sp, #16
     182:	4770      	bx	lr

00000184 <__aeabi_idiv0>:
     184:	4770      	bx	lr
     186:	bf00      	nop

00000188 <__udivmoddi4>:
     188:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     18c:	4607      	mov	r7, r0
     18e:	468c      	mov	ip, r1
     190:	4608      	mov	r0, r1
     192:	9e09      	ldr	r6, [sp, #36]	; 0x24
     194:	4615      	mov	r5, r2
     196:	463c      	mov	r4, r7
     198:	4619      	mov	r1, r3
     19a:	2b00      	cmp	r3, #0
     19c:	f040 80c5 	bne.w	32a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x2a>
     1a0:	4282      	cmp	r2, r0
     1a2:	fab2 f782 	clz	r7, r2
     1a6:	d946      	bls.n	236 <CONFIG_SRAM_SIZE+0x76>
     1a8:	b14f      	cbz	r7, 1be <__udivmoddi4+0x36>
     1aa:	f1c7 0e20 	rsb	lr, r7, #32
     1ae:	fa00 f307 	lsl.w	r3, r0, r7
     1b2:	40bd      	lsls	r5, r7
     1b4:	fa24 fe0e 	lsr.w	lr, r4, lr
     1b8:	40bc      	lsls	r4, r7
     1ba:	ea4e 0c03 	orr.w	ip, lr, r3
     1be:	ea4f 4815 	mov.w	r8, r5, lsr #16
     1c2:	fa1f fe85 	uxth.w	lr, r5
     1c6:	0c22      	lsrs	r2, r4, #16
     1c8:	fbbc f9f8 	udiv	r9, ip, r8
     1cc:	fb08 c319 	mls	r3, r8, r9, ip
     1d0:	fb09 fa0e 	mul.w	sl, r9, lr
     1d4:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
     1d8:	459a      	cmp	sl, r3
     1da:	d928      	bls.n	22e <CONFIG_SRAM_SIZE+0x6e>
     1dc:	18eb      	adds	r3, r5, r3
     1de:	f109 30ff 	add.w	r0, r9, #4294967295
     1e2:	d204      	bcs.n	1ee <CONFIG_SRAM_SIZE+0x2e>
     1e4:	459a      	cmp	sl, r3
     1e6:	d902      	bls.n	1ee <CONFIG_SRAM_SIZE+0x2e>
     1e8:	f1a9 0002 	sub.w	r0, r9, #2
     1ec:	442b      	add	r3, r5
     1ee:	eba3 030a 	sub.w	r3, r3, sl
     1f2:	b2a4      	uxth	r4, r4
     1f4:	fbb3 f2f8 	udiv	r2, r3, r8
     1f8:	fb08 3312 	mls	r3, r8, r2, r3
     1fc:	fb02 fe0e 	mul.w	lr, r2, lr
     200:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     204:	45a6      	cmp	lr, r4
     206:	d914      	bls.n	232 <CONFIG_SRAM_SIZE+0x72>
     208:	192c      	adds	r4, r5, r4
     20a:	f102 33ff 	add.w	r3, r2, #4294967295
     20e:	d203      	bcs.n	218 <CONFIG_SRAM_SIZE+0x58>
     210:	45a6      	cmp	lr, r4
     212:	d901      	bls.n	218 <CONFIG_SRAM_SIZE+0x58>
     214:	1e93      	subs	r3, r2, #2
     216:	442c      	add	r4, r5
     218:	eba4 040e 	sub.w	r4, r4, lr
     21c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     220:	b11e      	cbz	r6, 22a <CONFIG_SRAM_SIZE+0x6a>
     222:	40fc      	lsrs	r4, r7
     224:	2300      	movs	r3, #0
     226:	6034      	str	r4, [r6, #0]
     228:	6073      	str	r3, [r6, #4]
     22a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     22e:	4648      	mov	r0, r9
     230:	e7dd      	b.n	1ee <CONFIG_SRAM_SIZE+0x2e>
     232:	4613      	mov	r3, r2
     234:	e7f0      	b.n	218 <CONFIG_SRAM_SIZE+0x58>
     236:	b902      	cbnz	r2, 23a <CONFIG_SRAM_SIZE+0x7a>
     238:	deff      	udf	#255	; 0xff
     23a:	bb87      	cbnz	r7, 29e <CONFIG_PM_PARTITION_SIZE_PROVISION+0x1e>
     23c:	1a83      	subs	r3, r0, r2
     23e:	2101      	movs	r1, #1
     240:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     244:	b2aa      	uxth	r2, r5
     246:	0c20      	lsrs	r0, r4, #16
     248:	fbb3 fcfe 	udiv	ip, r3, lr
     24c:	fb0e 331c 	mls	r3, lr, ip, r3
     250:	fb0c f802 	mul.w	r8, ip, r2
     254:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
     258:	4598      	cmp	r8, r3
     25a:	d962      	bls.n	322 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x22>
     25c:	18eb      	adds	r3, r5, r3
     25e:	f10c 30ff 	add.w	r0, ip, #4294967295
     262:	d204      	bcs.n	26e <CONFIG_SRAM_SIZE+0xae>
     264:	4598      	cmp	r8, r3
     266:	d902      	bls.n	26e <CONFIG_SRAM_SIZE+0xae>
     268:	f1ac 0002 	sub.w	r0, ip, #2
     26c:	442b      	add	r3, r5
     26e:	eba3 0308 	sub.w	r3, r3, r8
     272:	b2a4      	uxth	r4, r4
     274:	fbb3 fcfe 	udiv	ip, r3, lr
     278:	fb0e 331c 	mls	r3, lr, ip, r3
     27c:	fb0c f202 	mul.w	r2, ip, r2
     280:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     284:	42a2      	cmp	r2, r4
     286:	d94e      	bls.n	326 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x26>
     288:	192c      	adds	r4, r5, r4
     28a:	f10c 33ff 	add.w	r3, ip, #4294967295
     28e:	d204      	bcs.n	29a <CONFIG_PM_PARTITION_SIZE_PROVISION+0x1a>
     290:	42a2      	cmp	r2, r4
     292:	d902      	bls.n	29a <CONFIG_PM_PARTITION_SIZE_PROVISION+0x1a>
     294:	f1ac 0302 	sub.w	r3, ip, #2
     298:	442c      	add	r4, r5
     29a:	1aa4      	subs	r4, r4, r2
     29c:	e7be      	b.n	21c <CONFIG_SRAM_SIZE+0x5c>
     29e:	f1c7 0c20 	rsb	ip, r7, #32
     2a2:	40bd      	lsls	r5, r7
     2a4:	fa00 f307 	lsl.w	r3, r0, r7
     2a8:	fa20 f80c 	lsr.w	r8, r0, ip
     2ac:	ea4f 4e15 	mov.w	lr, r5, lsr #16
     2b0:	fa24 fc0c 	lsr.w	ip, r4, ip
     2b4:	40bc      	lsls	r4, r7
     2b6:	ea4c 0203 	orr.w	r2, ip, r3
     2ba:	b2ab      	uxth	r3, r5
     2bc:	fbb8 fcfe 	udiv	ip, r8, lr
     2c0:	0c11      	lsrs	r1, r2, #16
     2c2:	fb0e 801c 	mls	r0, lr, ip, r8
     2c6:	fb0c f903 	mul.w	r9, ip, r3
     2ca:	ea41 4000 	orr.w	r0, r1, r0, lsl #16
     2ce:	4581      	cmp	r9, r0
     2d0:	d923      	bls.n	31a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x1a>
     2d2:	1828      	adds	r0, r5, r0
     2d4:	f10c 31ff 	add.w	r1, ip, #4294967295
     2d8:	d204      	bcs.n	2e4 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x64>
     2da:	4581      	cmp	r9, r0
     2dc:	d902      	bls.n	2e4 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x64>
     2de:	f1ac 0102 	sub.w	r1, ip, #2
     2e2:	4428      	add	r0, r5
     2e4:	eba0 0009 	sub.w	r0, r0, r9
     2e8:	b292      	uxth	r2, r2
     2ea:	fbb0 fcfe 	udiv	ip, r0, lr
     2ee:	fb0e 001c 	mls	r0, lr, ip, r0
     2f2:	fb0c f803 	mul.w	r8, ip, r3
     2f6:	ea42 4300 	orr.w	r3, r2, r0, lsl #16
     2fa:	4598      	cmp	r8, r3
     2fc:	d90f      	bls.n	31e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x1e>
     2fe:	18eb      	adds	r3, r5, r3
     300:	f10c 32ff 	add.w	r2, ip, #4294967295
     304:	d204      	bcs.n	310 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x10>
     306:	4598      	cmp	r8, r3
     308:	d902      	bls.n	310 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x10>
     30a:	f1ac 0202 	sub.w	r2, ip, #2
     30e:	442b      	add	r3, r5
     310:	eba3 0308 	sub.w	r3, r3, r8
     314:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
     318:	e792      	b.n	240 <CONFIG_SRAM_SIZE+0x80>
     31a:	4661      	mov	r1, ip
     31c:	e7e2      	b.n	2e4 <CONFIG_PM_PARTITION_SIZE_PROVISION+0x64>
     31e:	4662      	mov	r2, ip
     320:	e7f6      	b.n	310 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x10>
     322:	4660      	mov	r0, ip
     324:	e7a3      	b.n	26e <CONFIG_SRAM_SIZE+0xae>
     326:	4663      	mov	r3, ip
     328:	e7b7      	b.n	29a <CONFIG_PM_PARTITION_SIZE_PROVISION+0x1a>
     32a:	4283      	cmp	r3, r0
     32c:	d905      	bls.n	33a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x3a>
     32e:	b10e      	cbz	r6, 334 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x34>
     330:	e9c6 7000 	strd	r7, r0, [r6]
     334:	2100      	movs	r1, #0
     336:	4608      	mov	r0, r1
     338:	e777      	b.n	22a <CONFIG_SRAM_SIZE+0x6a>
     33a:	fab3 f183 	clz	r1, r3
     33e:	b981      	cbnz	r1, 362 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x62>
     340:	4283      	cmp	r3, r0
     342:	d301      	bcc.n	348 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x48>
     344:	42ba      	cmp	r2, r7
     346:	d80a      	bhi.n	35e <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x5e>
     348:	1abc      	subs	r4, r7, r2
     34a:	eb60 0303 	sbc.w	r3, r0, r3
     34e:	2001      	movs	r0, #1
     350:	469c      	mov	ip, r3
     352:	2e00      	cmp	r6, #0
     354:	d067      	beq.n	426 <CONFIG_BT_HCI_TX_STACK_SIZE+0x26>
     356:	e9c6 4c00 	strd	r4, ip, [r6]
     35a:	2100      	movs	r1, #0
     35c:	e765      	b.n	22a <CONFIG_SRAM_SIZE+0x6a>
     35e:	4608      	mov	r0, r1
     360:	e7f7      	b.n	352 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x52>
     362:	f1c1 0c20 	rsb	ip, r1, #32
     366:	408b      	lsls	r3, r1
     368:	fa02 f501 	lsl.w	r5, r2, r1
     36c:	fa22 f40c 	lsr.w	r4, r2, ip
     370:	fa20 fb0c 	lsr.w	fp, r0, ip
     374:	fa27 f20c 	lsr.w	r2, r7, ip
     378:	408f      	lsls	r7, r1
     37a:	431c      	orrs	r4, r3
     37c:	fa00 f301 	lsl.w	r3, r0, r1
     380:	ea4f 4914 	mov.w	r9, r4, lsr #16
     384:	4313      	orrs	r3, r2
     386:	fa1f fe84 	uxth.w	lr, r4
     38a:	0c1a      	lsrs	r2, r3, #16
     38c:	fbbb f8f9 	udiv	r8, fp, r9
     390:	fb09 bb18 	mls	fp, r9, r8, fp
     394:	fb08 fa0e 	mul.w	sl, r8, lr
     398:	ea42 420b 	orr.w	r2, r2, fp, lsl #16
     39c:	4592      	cmp	sl, r2
     39e:	d93e      	bls.n	41e <CONFIG_BT_HCI_TX_STACK_SIZE+0x1e>
     3a0:	18a2      	adds	r2, r4, r2
     3a2:	f108 30ff 	add.w	r0, r8, #4294967295
     3a6:	d204      	bcs.n	3b2 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb2>
     3a8:	4592      	cmp	sl, r2
     3aa:	d902      	bls.n	3b2 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb2>
     3ac:	f1a8 0002 	sub.w	r0, r8, #2
     3b0:	4422      	add	r2, r4
     3b2:	eba2 020a 	sub.w	r2, r2, sl
     3b6:	b29b      	uxth	r3, r3
     3b8:	fbb2 f8f9 	udiv	r8, r2, r9
     3bc:	fb09 2218 	mls	r2, r9, r8, r2
     3c0:	fb08 fe0e 	mul.w	lr, r8, lr
     3c4:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
     3c8:	4596      	cmp	lr, r2
     3ca:	d92a      	bls.n	422 <CONFIG_BT_HCI_TX_STACK_SIZE+0x22>
     3cc:	18a2      	adds	r2, r4, r2
     3ce:	f108 33ff 	add.w	r3, r8, #4294967295
     3d2:	d204      	bcs.n	3de <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xde>
     3d4:	4596      	cmp	lr, r2
     3d6:	d902      	bls.n	3de <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xde>
     3d8:	f1a8 0302 	sub.w	r3, r8, #2
     3dc:	4422      	add	r2, r4
     3de:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
     3e2:	eba2 020e 	sub.w	r2, r2, lr
     3e6:	fba0 9305 	umull	r9, r3, r0, r5
     3ea:	429a      	cmp	r2, r3
     3ec:	46ce      	mov	lr, r9
     3ee:	4698      	mov	r8, r3
     3f0:	d302      	bcc.n	3f8 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x10>
     3f2:	d106      	bne.n	402 <CONFIG_BT_HCI_TX_STACK_SIZE+0x2>
     3f4:	454f      	cmp	r7, r9
     3f6:	d204      	bcs.n	402 <CONFIG_BT_HCI_TX_STACK_SIZE+0x2>
     3f8:	3801      	subs	r0, #1
     3fa:	ebb9 0e05 	subs.w	lr, r9, r5
     3fe:	eb63 0804 	sbc.w	r8, r3, r4
     402:	b186      	cbz	r6, 426 <CONFIG_BT_HCI_TX_STACK_SIZE+0x26>
     404:	ebb7 030e 	subs.w	r3, r7, lr
     408:	eb62 0708 	sbc.w	r7, r2, r8
     40c:	fa07 fc0c 	lsl.w	ip, r7, ip
     410:	40cb      	lsrs	r3, r1
     412:	40cf      	lsrs	r7, r1
     414:	ea4c 0303 	orr.w	r3, ip, r3
     418:	e9c6 3700 	strd	r3, r7, [r6]
     41c:	e79d      	b.n	35a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x5a>
     41e:	4640      	mov	r0, r8
     420:	e7c7      	b.n	3b2 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb2>
     422:	4643      	mov	r3, r8
     424:	e7db      	b.n	3de <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xde>
     426:	4631      	mov	r1, r6
     428:	e6ff      	b.n	22a <CONFIG_SRAM_SIZE+0x6a>
	...

0000042c <led_update>:
static bool led_state; /* Tracking state here supports GPIO expander-based LEDs. */
static bool led_ok;

void led_update(void)
{
	if (!led_ok) {
     42c:	4b40      	ldr	r3, [pc, #256]	; (530 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x1c>)
     42e:	781b      	ldrb	r3, [r3, #0]
     430:	2b00      	cmp	r3, #0
     432:	d07c      	beq.n	52e <CONFIG_BT_LONG_WQ_STACK_SIZE+0x1a>
{
     434:	b590      	push	{r4, r7, lr}
     436:	b083      	sub	sp, #12
     438:	af00      	add	r7, sp, #0
		return;
	}

	led_state = !led_state;
     43a:	4a3e      	ldr	r2, [pc, #248]	; (534 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x20>)
     43c:	7813      	ldrb	r3, [r2, #0]
     43e:	f083 0301 	eor.w	r3, r3, #1
     442:	7013      	strb	r3, [r2, #0]
	LOG_INF("Turn %s LED", led_state ? "on" : "off");
     444:	2b00      	cmp	r3, #0
     446:	d05a      	beq.n	4fe <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x16>
     448:	483b      	ldr	r0, [pc, #236]	; (538 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x24>)
     44a:	2302      	movs	r3, #2
     44c:	713b      	strb	r3, [r7, #4]
     44e:	466c      	mov	r4, sp
     450:	b088      	sub	sp, #32
     452:	466b      	mov	r3, sp
     454:	f113 0210 	adds.w	r2, r3, #16
     458:	d053      	beq.n	502 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1a>
     45a:	f04f 0c0d 	mov.w	ip, #13
     45e:	b122      	cbz	r2, 46a <led_update+0x3e>
     460:	f1bc 0f04 	cmp.w	ip, #4
     464:	dd01      	ble.n	46a <led_update+0x3e>
     466:	4935      	ldr	r1, [pc, #212]	; (53c <CONFIG_BT_LONG_WQ_STACK_SIZE+0x28>)
     468:	6159      	str	r1, [r3, #20]
     46a:	2102      	movs	r1, #2
     46c:	7039      	strb	r1, [r7, #0]
     46e:	b11a      	cbz	r2, 478 <led_update+0x4c>
     470:	f1bc 0f08 	cmp.w	ip, #8
     474:	dd00      	ble.n	478 <led_update+0x4c>
     476:	6198      	str	r0, [r3, #24]
     478:	b122      	cbz	r2, 484 <led_update+0x58>
     47a:	f103 011c 	add.w	r1, r3, #28
     47e:	2000      	movs	r0, #0
     480:	2800      	cmp	r0, #0
     482:	d041      	beq.n	508 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x20>
     484:	f1bc 0f0c 	cmp.w	ip, #12
     488:	dd47      	ble.n	51a <CONFIG_BT_LONG_WQ_STACK_SIZE+0x6>
     48a:	f04f 0c0d 	mov.w	ip, #13
     48e:	b142      	cbz	r2, 4a2 <led_update+0x76>
     490:	2103      	movs	r1, #3
     492:	7139      	strb	r1, [r7, #4]
     494:	2100      	movs	r1, #0
     496:	7179      	strb	r1, [r7, #5]
     498:	71b9      	strb	r1, [r7, #6]
     49a:	2101      	movs	r1, #1
     49c:	71f9      	strb	r1, [r7, #7]
     49e:	6878      	ldr	r0, [r7, #4]
     4a0:	6118      	str	r0, [r3, #16]
     4a2:	2100      	movs	r1, #0
     4a4:	f36f 0100 	bfc	r1, #0, #1
     4a8:	f36f 0141 	bfc	r1, #1, #1
     4ac:	f36f 0182 	bfc	r1, #2, #1
     4b0:	f36f 01c5 	bfc	r1, #3, #3
     4b4:	2303      	movs	r3, #3
     4b6:	f363 1188 	bfi	r1, r3, #6, #3
     4ba:	f3cc 0c09 	ubfx	ip, ip, #0, #10
     4be:	f36c 2152 	bfi	r1, ip, #9, #10
     4c2:	f36f 41de 	bfc	r1, #19, #12
     4c6:	f36f 71df 	bfc	r1, #31, #1
		(void) arch_syscall_invoke4(parm0.x, parm1.x, parm2.x, parm3.x, K_SYSCALL_Z_LOG_MSG_STATIC_CREATE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_z_log_msg_static_create(source, desc, package, data);
     4ca:	2300      	movs	r3, #0
     4cc:	481c      	ldr	r0, [pc, #112]	; (540 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x2c>)
     4ce:	f001 febb 	bl	2248 <z_impl_z_log_msg_static_create>
     4d2:	46a5      	mov	sp, r4
	gpio_pin_set(led.port, led.pin, led_state);
     4d4:	4b17      	ldr	r3, [pc, #92]	; (534 <CONFIG_BT_LONG_WQ_STACK_SIZE+0x20>)
     4d6:	781b      	ldrb	r3, [r3, #0]
static inline int gpio_pin_set(const struct device *port, gpio_pin_t pin,
			       int value)
{
	__unused const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	const struct gpio_driver_data *const data =
     4d8:	4a1a      	ldr	r2, [pc, #104]	; (544 <__data_size>)
     4da:	6912      	ldr	r2, [r2, #16]
			(const struct gpio_driver_data *)port->data;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
     4dc:	6812      	ldr	r2, [r2, #0]
     4de:	f412 4f80 	tst.w	r2, #16384	; 0x4000
     4e2:	d002      	beq.n	4ea <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x2>
		value = (value != 0) ? 0 : 1;
     4e4:	fab3 f383 	clz	r3, r3
     4e8:	095b      	lsrs	r3, r3, #5
	if (value != 0)	{
     4ea:	b1cb      	cbz	r3, 520 <CONFIG_BT_LONG_WQ_STACK_SIZE+0xc>
	const struct gpio_driver_api *api =
     4ec:	4815      	ldr	r0, [pc, #84]	; (544 <__data_size>)
     4ee:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
     4f0:	68db      	ldr	r3, [r3, #12]
     4f2:	f44f 4180 	mov.w	r1, #16384	; 0x4000
     4f6:	4798      	blx	r3
}
     4f8:	370c      	adds	r7, #12
     4fa:	46bd      	mov	sp, r7
     4fc:	bd90      	pop	{r4, r7, pc}
	LOG_INF("Turn %s LED", led_state ? "on" : "off");
     4fe:	4812      	ldr	r0, [pc, #72]	; (548 <__data_size+0x4>)
     500:	e7a3      	b.n	44a <led_update+0x1e>
     502:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
     506:	e7aa      	b.n	45e <led_update+0x32>
     508:	f107 0e08 	add.w	lr, r7, #8
     50c:	4486      	add	lr, r0
     50e:	f81e ec08 	ldrb.w	lr, [lr, #-8]
     512:	f801 eb01 	strb.w	lr, [r1], #1
     516:	3001      	adds	r0, #1
     518:	e7b2      	b.n	480 <led_update+0x54>
     51a:	f06f 0c1b 	mvn.w	ip, #27
     51e:	e7b6      	b.n	48e <led_update+0x62>
	const struct gpio_driver_api *api =
     520:	4808      	ldr	r0, [pc, #32]	; (544 <__data_size>)
     522:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
     524:	691b      	ldr	r3, [r3, #16]
     526:	f44f 4180 	mov.w	r1, #16384	; 0x4000
     52a:	4798      	blx	r3
	}

	return gpio_pin_set_raw(port, pin, value);
     52c:	e7e4      	b.n	4f8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x10>
     52e:	4770      	bx	lr
     530:	200028f6 	.word	0x200028f6
     534:	200028f7 	.word	0x200028f7
     538:	0001ef50 	.word	0x0001ef50
     53c:	0001d1fc 	.word	0x0001d1fc
     540:	0001d04c 	.word	0x0001d04c
     544:	0001cc2c 	.word	0x0001cc2c
     548:	0001d1f8 	.word	0x0001d1f8

0000054c <led_init>:

int led_init(void)
{
     54c:	b5f0      	push	{r4, r5, r6, r7, lr}
     54e:	b083      	sub	sp, #12
     550:	af00      	add	r7, sp, #0
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
     552:	4865      	ldr	r0, [pc, #404]	; (6e8 <CONFIG_BT_COMPANY_ID+0xf7>)
     554:	f01b fc3b 	bl	1bdce <z_device_is_ready>
	int ret;

	led_ok = device_is_ready(led.port);
     558:	4b64      	ldr	r3, [pc, #400]	; (6ec <CONFIG_BT_COMPANY_ID+0xfb>)
     55a:	7018      	strb	r0, [r3, #0]
	if (!led_ok) {
     55c:	b188      	cbz	r0, 582 <led_init+0x36>
	const struct gpio_driver_api *api =
     55e:	4862      	ldr	r0, [pc, #392]	; (6e8 <CONFIG_BT_COMPANY_ID+0xf7>)
     560:	6881      	ldr	r1, [r0, #8]
	struct gpio_driver_data *data =
     562:	6902      	ldr	r2, [r0, #16]
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     564:	6813      	ldr	r3, [r2, #0]
     566:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
     56a:	6013      	str	r3, [r2, #0]
	return api->pin_configure(port, pin, flags);
     56c:	680b      	ldr	r3, [r1, #0]
     56e:	f44f 22c0 	mov.w	r2, #393216	; 0x60000
     572:	210e      	movs	r1, #14
     574:	4798      	blx	r3
			led.port->name, led.pin);
		return -ENODEV;
	}

	ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_INACTIVE);
	if (ret < 0) {
     576:	1e04      	subs	r4, r0, #0
     578:	db5b      	blt.n	632 <CONFIG_BT_COMPANY_ID+0x41>
		LOG_ERR("Error %d: failed to configure GPIO %s pin %d",
			ret, led.port->name, led.pin);
	}

	return ret;
}
     57a:	4620      	mov	r0, r4
     57c:	370c      	adds	r7, #12
     57e:	46bd      	mov	sp, r7
     580:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("Error: LED on GPIO %s pin %d is not ready",
     582:	4b59      	ldr	r3, [pc, #356]	; (6e8 <CONFIG_BT_COMPANY_ID+0xf7>)
     584:	6818      	ldr	r0, [r3, #0]
     586:	2302      	movs	r3, #2
     588:	713b      	strb	r3, [r7, #4]
     58a:	466c      	mov	r4, sp
     58c:	b08a      	sub	sp, #40	; 0x28
     58e:	466b      	mov	r3, sp
     590:	f113 0210 	adds.w	r2, r3, #16
     594:	d03e      	beq.n	614 <CONFIG_BT_COMPANY_ID+0x23>
     596:	2511      	movs	r5, #17
     598:	b11a      	cbz	r2, 5a2 <led_init+0x56>
     59a:	2d04      	cmp	r5, #4
     59c:	dd01      	ble.n	5a2 <led_init+0x56>
     59e:	4954      	ldr	r1, [pc, #336]	; (6f0 <CONFIG_BT_COMPANY_ID+0xff>)
     5a0:	6159      	str	r1, [r3, #20]
     5a2:	2102      	movs	r1, #2
     5a4:	7039      	strb	r1, [r7, #0]
     5a6:	b112      	cbz	r2, 5ae <led_init+0x62>
     5a8:	2d08      	cmp	r5, #8
     5aa:	dd00      	ble.n	5ae <led_init+0x62>
     5ac:	6198      	str	r0, [r3, #24]
     5ae:	b11a      	cbz	r2, 5b8 <led_init+0x6c>
     5b0:	2d0c      	cmp	r5, #12
     5b2:	dd01      	ble.n	5b8 <led_init+0x6c>
     5b4:	210e      	movs	r1, #14
     5b6:	61d9      	str	r1, [r3, #28]
     5b8:	b11a      	cbz	r2, 5c2 <led_init+0x76>
     5ba:	f103 0120 	add.w	r1, r3, #32
     5be:	2000      	movs	r0, #0
     5c0:	b358      	cbz	r0, 61a <CONFIG_BT_COMPANY_ID+0x29>
     5c2:	2d10      	cmp	r5, #16
     5c4:	dd32      	ble.n	62c <CONFIG_BT_COMPANY_ID+0x3b>
     5c6:	2511      	movs	r5, #17
     5c8:	b142      	cbz	r2, 5dc <led_init+0x90>
     5ca:	2104      	movs	r1, #4
     5cc:	7139      	strb	r1, [r7, #4]
     5ce:	2100      	movs	r1, #0
     5d0:	7179      	strb	r1, [r7, #5]
     5d2:	71b9      	strb	r1, [r7, #6]
     5d4:	2101      	movs	r1, #1
     5d6:	71f9      	strb	r1, [r7, #7]
     5d8:	6878      	ldr	r0, [r7, #4]
     5da:	6118      	str	r0, [r3, #16]
     5dc:	2100      	movs	r1, #0
     5de:	f36f 0100 	bfc	r1, #0, #1
     5e2:	f36f 0141 	bfc	r1, #1, #1
     5e6:	f36f 0182 	bfc	r1, #2, #1
     5ea:	f36f 01c5 	bfc	r1, #3, #3
     5ee:	2301      	movs	r3, #1
     5f0:	f363 1188 	bfi	r1, r3, #6, #3
     5f4:	f3c5 0509 	ubfx	r5, r5, #0, #10
     5f8:	f365 2152 	bfi	r1, r5, #9, #10
     5fc:	f36f 41de 	bfc	r1, #19, #12
     600:	f36f 71df 	bfc	r1, #31, #1
     604:	2300      	movs	r3, #0
     606:	483b      	ldr	r0, [pc, #236]	; (6f4 <CONFIG_BT_COMPANY_ID+0x103>)
     608:	f001 fe1e 	bl	2248 <z_impl_z_log_msg_static_create>
     60c:	46a5      	mov	sp, r4
		return -ENODEV;
     60e:	f06f 0412 	mvn.w	r4, #18
     612:	e7b2      	b.n	57a <led_init+0x2e>
		LOG_ERR("Error: LED on GPIO %s pin %d is not ready",
     614:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
     618:	e7be      	b.n	598 <led_init+0x4c>
     61a:	f107 0608 	add.w	r6, r7, #8
     61e:	4406      	add	r6, r0
     620:	f816 6c08 	ldrb.w	r6, [r6, #-8]
     624:	f801 6b01 	strb.w	r6, [r1], #1
     628:	3001      	adds	r0, #1
     62a:	e7c9      	b.n	5c0 <led_init+0x74>
     62c:	f06f 051b 	mvn.w	r5, #27
     630:	e7ca      	b.n	5c8 <led_init+0x7c>
		LOG_ERR("Error %d: failed to configure GPIO %s pin %d",
     632:	4b2d      	ldr	r3, [pc, #180]	; (6e8 <CONFIG_BT_COMPANY_ID+0xf7>)
     634:	681e      	ldr	r6, [r3, #0]
     636:	2303      	movs	r3, #3
     638:	713b      	strb	r3, [r7, #4]
     63a:	466d      	mov	r5, sp
     63c:	b08a      	sub	sp, #40	; 0x28
     63e:	466b      	mov	r3, sp
     640:	f113 0210 	adds.w	r2, r3, #16
     644:	d040      	beq.n	6c8 <CONFIG_BT_COMPANY_ID+0xd7>
     646:	2015      	movs	r0, #21
     648:	b11a      	cbz	r2, 652 <CONFIG_BT_COMPANY_ID+0x61>
     64a:	2804      	cmp	r0, #4
     64c:	dd01      	ble.n	652 <CONFIG_BT_COMPANY_ID+0x61>
     64e:	492a      	ldr	r1, [pc, #168]	; (6f8 <CONFIG_BT_COMPANY_ID+0x107>)
     650:	6159      	str	r1, [r3, #20]
     652:	b112      	cbz	r2, 65a <CONFIG_BT_COMPANY_ID+0x69>
     654:	2808      	cmp	r0, #8
     656:	dd00      	ble.n	65a <CONFIG_BT_COMPANY_ID+0x69>
     658:	619c      	str	r4, [r3, #24]
     65a:	2103      	movs	r1, #3
     65c:	7039      	strb	r1, [r7, #0]
     65e:	b112      	cbz	r2, 666 <CONFIG_BT_COMPANY_ID+0x75>
     660:	280c      	cmp	r0, #12
     662:	dd00      	ble.n	666 <CONFIG_BT_COMPANY_ID+0x75>
     664:	61de      	str	r6, [r3, #28]
     666:	b11a      	cbz	r2, 670 <CONFIG_BT_COMPANY_ID+0x7f>
     668:	2810      	cmp	r0, #16
     66a:	dd01      	ble.n	670 <CONFIG_BT_COMPANY_ID+0x7f>
     66c:	210e      	movs	r1, #14
     66e:	6219      	str	r1, [r3, #32]
     670:	b11a      	cbz	r2, 67a <CONFIG_BT_COMPANY_ID+0x89>
     672:	f103 0124 	add.w	r1, r3, #36	; 0x24
     676:	2600      	movs	r6, #0
     678:	b34e      	cbz	r6, 6ce <CONFIG_BT_COMPANY_ID+0xdd>
     67a:	2814      	cmp	r0, #20
     67c:	dd30      	ble.n	6e0 <CONFIG_BT_COMPANY_ID+0xef>
     67e:	2615      	movs	r6, #21
     680:	b142      	cbz	r2, 694 <CONFIG_BT_COMPANY_ID+0xa3>
     682:	2105      	movs	r1, #5
     684:	7139      	strb	r1, [r7, #4]
     686:	2100      	movs	r1, #0
     688:	7179      	strb	r1, [r7, #5]
     68a:	71b9      	strb	r1, [r7, #6]
     68c:	2101      	movs	r1, #1
     68e:	71f9      	strb	r1, [r7, #7]
     690:	6878      	ldr	r0, [r7, #4]
     692:	6118      	str	r0, [r3, #16]
     694:	2100      	movs	r1, #0
     696:	f36f 0100 	bfc	r1, #0, #1
     69a:	f36f 0141 	bfc	r1, #1, #1
     69e:	f36f 0182 	bfc	r1, #2, #1
     6a2:	f36f 01c5 	bfc	r1, #3, #3
     6a6:	2301      	movs	r3, #1
     6a8:	f363 1188 	bfi	r1, r3, #6, #3
     6ac:	f3c6 0309 	ubfx	r3, r6, #0, #10
     6b0:	f363 2152 	bfi	r1, r3, #9, #10
     6b4:	f36f 41de 	bfc	r1, #19, #12
     6b8:	f36f 71df 	bfc	r1, #31, #1
     6bc:	2300      	movs	r3, #0
     6be:	480d      	ldr	r0, [pc, #52]	; (6f4 <CONFIG_BT_COMPANY_ID+0x103>)
     6c0:	f001 fdc2 	bl	2248 <z_impl_z_log_msg_static_create>
     6c4:	46ad      	mov	sp, r5
     6c6:	e758      	b.n	57a <led_init+0x2e>
     6c8:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
     6cc:	e7bc      	b.n	648 <CONFIG_BT_COMPANY_ID+0x57>
     6ce:	f107 0c08 	add.w	ip, r7, #8
     6d2:	44b4      	add	ip, r6
     6d4:	f81c cc08 	ldrb.w	ip, [ip, #-8]
     6d8:	f801 cb01 	strb.w	ip, [r1], #1
     6dc:	3601      	adds	r6, #1
     6de:	e7cb      	b.n	678 <CONFIG_BT_COMPANY_ID+0x87>
     6e0:	f06f 061b 	mvn.w	r6, #27
     6e4:	e7cc      	b.n	680 <CONFIG_BT_COMPANY_ID+0x8f>
     6e6:	bf00      	nop
     6e8:	0001cc2c 	.word	0x0001cc2c
     6ec:	200028f6 	.word	0x200028f6
     6f0:	0001d208 	.word	0x0001d208
     6f4:	0001d04c 	.word	0x0001d04c
     6f8:	0001d234 	.word	0x0001d234

000006fc <mpu_ccc_cfg_changed>:
struct bt_conn *conn;
/* Notification state */
volatile bool notify_enable;

static void mpu_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value)
{
     6fc:	b580      	push	{r7, lr}
     6fe:	b082      	sub	sp, #8
     700:	af00      	add	r7, sp, #0
	ARG_UNUSED(attr);
	notify_enable = (value == BT_GATT_CCC_NOTIFY);
     702:	2901      	cmp	r1, #1
     704:	bf14      	ite	ne
     706:	2100      	movne	r1, #0
     708:	2101      	moveq	r1, #1
     70a:	4b2e      	ldr	r3, [pc, #184]	; (7c4 <mpu_ccc_cfg_changed+0xc8>)
     70c:	7019      	strb	r1, [r3, #0]
	LOG_INF("Notification %s", notify_enable ? "enabled" : "disabled");
     70e:	781b      	ldrb	r3, [r3, #0]
     710:	2b00      	cmp	r3, #0
     712:	d045      	beq.n	7a0 <mpu_ccc_cfg_changed+0xa4>
     714:	482c      	ldr	r0, [pc, #176]	; (7c8 <mpu_ccc_cfg_changed+0xcc>)
     716:	2302      	movs	r3, #2
     718:	713b      	strb	r3, [r7, #4]
     71a:	b088      	sub	sp, #32
     71c:	466b      	mov	r3, sp
     71e:	f113 0210 	adds.w	r2, r3, #16
     722:	d03f      	beq.n	7a4 <mpu_ccc_cfg_changed+0xa8>
     724:	f04f 0c0d 	mov.w	ip, #13
     728:	b122      	cbz	r2, 734 <mpu_ccc_cfg_changed+0x38>
     72a:	f1bc 0f04 	cmp.w	ip, #4
     72e:	dd01      	ble.n	734 <mpu_ccc_cfg_changed+0x38>
     730:	4926      	ldr	r1, [pc, #152]	; (7cc <mpu_ccc_cfg_changed+0xd0>)
     732:	6159      	str	r1, [r3, #20]
     734:	2102      	movs	r1, #2
     736:	7039      	strb	r1, [r7, #0]
     738:	b11a      	cbz	r2, 742 <mpu_ccc_cfg_changed+0x46>
     73a:	f1bc 0f08 	cmp.w	ip, #8
     73e:	dd00      	ble.n	742 <mpu_ccc_cfg_changed+0x46>
     740:	6198      	str	r0, [r3, #24]
     742:	b11a      	cbz	r2, 74c <mpu_ccc_cfg_changed+0x50>
     744:	f103 011c 	add.w	r1, r3, #28
     748:	2000      	movs	r0, #0
     74a:	b370      	cbz	r0, 7aa <mpu_ccc_cfg_changed+0xae>
     74c:	f1bc 0f0c 	cmp.w	ip, #12
     750:	dd34      	ble.n	7bc <mpu_ccc_cfg_changed+0xc0>
     752:	f04f 0c0d 	mov.w	ip, #13
     756:	b142      	cbz	r2, 76a <mpu_ccc_cfg_changed+0x6e>
     758:	2103      	movs	r1, #3
     75a:	7139      	strb	r1, [r7, #4]
     75c:	2100      	movs	r1, #0
     75e:	7179      	strb	r1, [r7, #5]
     760:	71b9      	strb	r1, [r7, #6]
     762:	2101      	movs	r1, #1
     764:	71f9      	strb	r1, [r7, #7]
     766:	6878      	ldr	r0, [r7, #4]
     768:	6118      	str	r0, [r3, #16]
     76a:	2100      	movs	r1, #0
     76c:	f36f 0100 	bfc	r1, #0, #1
     770:	f36f 0141 	bfc	r1, #1, #1
     774:	f36f 0182 	bfc	r1, #2, #1
     778:	f36f 01c5 	bfc	r1, #3, #3
     77c:	2303      	movs	r3, #3
     77e:	f363 1188 	bfi	r1, r3, #6, #3
     782:	f3cc 0c09 	ubfx	ip, ip, #0, #10
     786:	f36c 2152 	bfi	r1, ip, #9, #10
     78a:	f36f 41de 	bfc	r1, #19, #12
     78e:	f36f 71df 	bfc	r1, #31, #1
     792:	2300      	movs	r3, #0
     794:	480e      	ldr	r0, [pc, #56]	; (7d0 <mpu_ccc_cfg_changed+0xd4>)
     796:	f001 fd57 	bl	2248 <z_impl_z_log_msg_static_create>
}
     79a:	3708      	adds	r7, #8
     79c:	46bd      	mov	sp, r7
     79e:	bd80      	pop	{r7, pc}
	LOG_INF("Notification %s", notify_enable ? "enabled" : "disabled");
     7a0:	480c      	ldr	r0, [pc, #48]	; (7d4 <mpu_ccc_cfg_changed+0xd8>)
     7a2:	e7b8      	b.n	716 <mpu_ccc_cfg_changed+0x1a>
     7a4:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
     7a8:	e7be      	b.n	728 <mpu_ccc_cfg_changed+0x2c>
     7aa:	f107 0e08 	add.w	lr, r7, #8
     7ae:	4486      	add	lr, r0
     7b0:	f81e ec08 	ldrb.w	lr, [lr, #-8]
     7b4:	f801 eb01 	strb.w	lr, [r1], #1
     7b8:	3001      	adds	r0, #1
     7ba:	e7c6      	b.n	74a <mpu_ccc_cfg_changed+0x4e>
     7bc:	f06f 0c1b 	mvn.w	ip, #27
     7c0:	e7c9      	b.n	756 <mpu_ccc_cfg_changed+0x5a>
     7c2:	bf00      	nop
     7c4:	200028f8 	.word	0x200028f8
     7c8:	0001d278 	.word	0x0001d278
     7cc:	0001d280 	.word	0x0001d280
     7d0:	0001d064 	.word	0x0001d064
     7d4:	0001d26c 	.word	0x0001d26c

000007d8 <disconnected>:
		}
	}
}

static void disconnected(struct bt_conn *disconn, uint8_t reason)
{
     7d8:	b590      	push	{r4, r7, lr}
     7da:	b083      	sub	sp, #12
     7dc:	af00      	add	r7, sp, #0
     7de:	460c      	mov	r4, r1
	if (conn) {
     7e0:	4b22      	ldr	r3, [pc, #136]	; (86c <CONFIG_ISR_STACK_SIZE+0x6c>)
     7e2:	6818      	ldr	r0, [r3, #0]
     7e4:	b120      	cbz	r0, 7f0 <disconnected+0x18>
		bt_conn_unref(conn);
     7e6:	f017 fc79 	bl	180dc <bt_conn_unref>
		conn = NULL;
     7ea:	4b20      	ldr	r3, [pc, #128]	; (86c <CONFIG_ISR_STACK_SIZE+0x6c>)
     7ec:	2200      	movs	r2, #0
     7ee:	601a      	str	r2, [r3, #0]
	}

	LOG_INF("Disconnected (reason %u)", reason);
     7f0:	b088      	sub	sp, #32
     7f2:	466b      	mov	r3, sp
     7f4:	f113 0210 	adds.w	r2, r3, #16
     7f8:	d031      	beq.n	85e <CONFIG_ISR_STACK_SIZE+0x5e>
     7fa:	200c      	movs	r0, #12
     7fc:	b11a      	cbz	r2, 806 <CONFIG_ISR_STACK_SIZE+0x6>
     7fe:	2804      	cmp	r0, #4
     800:	dd01      	ble.n	806 <CONFIG_ISR_STACK_SIZE+0x6>
     802:	491b      	ldr	r1, [pc, #108]	; (870 <CONFIG_ISR_STACK_SIZE+0x70>)
     804:	6159      	str	r1, [r3, #20]
     806:	b112      	cbz	r2, 80e <CONFIG_ISR_STACK_SIZE+0xe>
     808:	2808      	cmp	r0, #8
     80a:	dd00      	ble.n	80e <CONFIG_ISR_STACK_SIZE+0xe>
     80c:	619c      	str	r4, [r3, #24]
     80e:	280b      	cmp	r0, #11
     810:	dd28      	ble.n	864 <CONFIG_ISR_STACK_SIZE+0x64>
     812:	f04f 0c0c 	mov.w	ip, #12
     816:	b13a      	cbz	r2, 828 <CONFIG_ISR_STACK_SIZE+0x28>
     818:	2103      	movs	r1, #3
     81a:	7139      	strb	r1, [r7, #4]
     81c:	2100      	movs	r1, #0
     81e:	7179      	strb	r1, [r7, #5]
     820:	71b9      	strb	r1, [r7, #6]
     822:	71f9      	strb	r1, [r7, #7]
     824:	6878      	ldr	r0, [r7, #4]
     826:	6118      	str	r0, [r3, #16]
     828:	2100      	movs	r1, #0
     82a:	f36f 0100 	bfc	r1, #0, #1
     82e:	f36f 0141 	bfc	r1, #1, #1
     832:	f36f 0182 	bfc	r1, #2, #1
     836:	f36f 01c5 	bfc	r1, #3, #3
     83a:	2303      	movs	r3, #3
     83c:	f363 1188 	bfi	r1, r3, #6, #3
     840:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
     844:	f36c 2152 	bfi	r1, ip, #9, #10
     848:	f36f 41de 	bfc	r1, #19, #12
     84c:	f36f 71df 	bfc	r1, #31, #1
     850:	2300      	movs	r3, #0
     852:	4808      	ldr	r0, [pc, #32]	; (874 <CONFIG_ISR_STACK_SIZE+0x74>)
     854:	f001 fcf8 	bl	2248 <z_impl_z_log_msg_static_create>
}
     858:	370c      	adds	r7, #12
     85a:	46bd      	mov	sp, r7
     85c:	bd90      	pop	{r4, r7, pc}
	LOG_INF("Disconnected (reason %u)", reason);
     85e:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
     862:	e7cb      	b.n	7fc <disconnected+0x24>
     864:	f06f 0c1b 	mvn.w	ip, #27
     868:	e7d5      	b.n	816 <CONFIG_ISR_STACK_SIZE+0x16>
     86a:	bf00      	nop
     86c:	20001bd8 	.word	0x20001bd8
     870:	0001d290 	.word	0x0001d290
     874:	0001d064 	.word	0x0001d064

00000878 <connected>:
{
     878:	b5b0      	push	{r4, r5, r7, lr}
     87a:	b088      	sub	sp, #32
     87c:	af00      	add	r7, sp, #0
	if (err) {
     87e:	2900      	cmp	r1, #0
     880:	d03f      	beq.n	902 <connected+0x8a>
     882:	4608      	mov	r0, r1
		LOG_ERR("Connection failed (err %u)", err);
     884:	466c      	mov	r4, sp
     886:	b088      	sub	sp, #32
     888:	466b      	mov	r3, sp
     88a:	f113 0210 	adds.w	r2, r3, #16
     88e:	d032      	beq.n	8f6 <connected+0x7e>
     890:	210c      	movs	r1, #12
     892:	b11a      	cbz	r2, 89c <connected+0x24>
     894:	2904      	cmp	r1, #4
     896:	dd01      	ble.n	89c <connected+0x24>
     898:	4d30      	ldr	r5, [pc, #192]	; (95c <connected+0xe4>)
     89a:	615d      	str	r5, [r3, #20]
     89c:	b112      	cbz	r2, 8a4 <connected+0x2c>
     89e:	2908      	cmp	r1, #8
     8a0:	dd00      	ble.n	8a4 <connected+0x2c>
     8a2:	6198      	str	r0, [r3, #24]
     8a4:	290b      	cmp	r1, #11
     8a6:	dd29      	ble.n	8fc <connected+0x84>
     8a8:	f04f 0c0c 	mov.w	ip, #12
     8ac:	b13a      	cbz	r2, 8be <connected+0x46>
     8ae:	2103      	movs	r1, #3
     8b0:	7139      	strb	r1, [r7, #4]
     8b2:	2100      	movs	r1, #0
     8b4:	7179      	strb	r1, [r7, #5]
     8b6:	71b9      	strb	r1, [r7, #6]
     8b8:	71f9      	strb	r1, [r7, #7]
     8ba:	6878      	ldr	r0, [r7, #4]
     8bc:	6118      	str	r0, [r3, #16]
     8be:	2100      	movs	r1, #0
     8c0:	f36f 0100 	bfc	r1, #0, #1
     8c4:	f36f 0141 	bfc	r1, #1, #1
     8c8:	f36f 0182 	bfc	r1, #2, #1
     8cc:	f36f 01c5 	bfc	r1, #3, #3
     8d0:	2301      	movs	r3, #1
     8d2:	f363 1188 	bfi	r1, r3, #6, #3
     8d6:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
     8da:	f36c 2152 	bfi	r1, ip, #9, #10
     8de:	f36f 41de 	bfc	r1, #19, #12
     8e2:	f36f 71df 	bfc	r1, #31, #1
     8e6:	2300      	movs	r3, #0
     8e8:	481d      	ldr	r0, [pc, #116]	; (960 <connected+0xe8>)
     8ea:	f001 fcad 	bl	2248 <z_impl_z_log_msg_static_create>
     8ee:	46a5      	mov	sp, r4
}
     8f0:	3720      	adds	r7, #32
     8f2:	46bd      	mov	sp, r7
     8f4:	bdb0      	pop	{r4, r5, r7, pc}
		LOG_ERR("Connection failed (err %u)", err);
     8f6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
     8fa:	e7ca      	b.n	892 <connected+0x1a>
     8fc:	f06f 0c1b 	mvn.w	ip, #27
     900:	e7d4      	b.n	8ac <connected+0x34>
     902:	4604      	mov	r4, r0
		LOG_INF("Connected");
     904:	4b17      	ldr	r3, [pc, #92]	; (964 <connected+0xec>)
     906:	61fb      	str	r3, [r7, #28]
     908:	2302      	movs	r3, #2
     90a:	713b      	strb	r3, [r7, #4]
     90c:	2300      	movs	r3, #0
     90e:	717b      	strb	r3, [r7, #5]
     910:	71bb      	strb	r3, [r7, #6]
     912:	71fb      	strb	r3, [r7, #7]
     914:	687a      	ldr	r2, [r7, #4]
     916:	61ba      	str	r2, [r7, #24]
     918:	4619      	mov	r1, r3
     91a:	f363 0100 	bfi	r1, r3, #0, #1
     91e:	f363 0141 	bfi	r1, r3, #1, #1
     922:	f363 0182 	bfi	r1, r3, #2, #1
     926:	f363 01c5 	bfi	r1, r3, #3, #3
     92a:	2203      	movs	r2, #3
     92c:	f362 1188 	bfi	r1, r2, #6, #3
     930:	2208      	movs	r2, #8
     932:	f362 2152 	bfi	r1, r2, #9, #10
     936:	f363 41de 	bfi	r1, r3, #19, #12
     93a:	f363 71df 	bfi	r1, r3, #31, #1
     93e:	f107 0218 	add.w	r2, r7, #24
     942:	4807      	ldr	r0, [pc, #28]	; (960 <connected+0xe8>)
     944:	f001 fc80 	bl	2248 <z_impl_z_log_msg_static_create>
		if (!conn) {
     948:	4b07      	ldr	r3, [pc, #28]	; (968 <connected+0xf0>)
     94a:	681b      	ldr	r3, [r3, #0]
     94c:	2b00      	cmp	r3, #0
     94e:	d1cf      	bne.n	8f0 <connected+0x78>
			conn = bt_conn_ref(connected);
     950:	4620      	mov	r0, r4
     952:	f017 fba6 	bl	180a2 <bt_conn_ref>
     956:	4b04      	ldr	r3, [pc, #16]	; (968 <connected+0xf0>)
     958:	6018      	str	r0, [r3, #0]
}
     95a:	e7c9      	b.n	8f0 <connected+0x78>
     95c:	0001d2ac 	.word	0x0001d2ac
     960:	0001d064 	.word	0x0001d064
     964:	0001d2c8 	.word	0x0001d2c8
     968:	20001bd8 	.word	0x20001bd8

0000096c <bt_ready>:
{
     96c:	b5f0      	push	{r4, r5, r6, r7, lr}
     96e:	b095      	sub	sp, #84	; 0x54
     970:	af02      	add	r7, sp, #8
	if (err) {
     972:	2800      	cmp	r0, #0
     974:	d03e      	beq.n	9f4 <bt_ready+0x88>
     976:	4604      	mov	r4, r0
		LOG_ERR("Bluetooth init failed (err %d)", err);
     978:	466d      	mov	r5, sp
     97a:	b088      	sub	sp, #32
     97c:	ab02      	add	r3, sp, #8
     97e:	f113 0210 	adds.w	r2, r3, #16
     982:	d031      	beq.n	9e8 <bt_ready+0x7c>
     984:	210c      	movs	r1, #12
     986:	b11a      	cbz	r2, 990 <bt_ready+0x24>
     988:	2904      	cmp	r1, #4
     98a:	dd01      	ble.n	990 <bt_ready+0x24>
     98c:	4864      	ldr	r0, [pc, #400]	; (b20 <bt_ready+0x1b4>)
     98e:	6158      	str	r0, [r3, #20]
     990:	b112      	cbz	r2, 998 <bt_ready+0x2c>
     992:	2908      	cmp	r1, #8
     994:	dd00      	ble.n	998 <bt_ready+0x2c>
     996:	619c      	str	r4, [r3, #24]
     998:	290b      	cmp	r1, #11
     99a:	dd28      	ble.n	9ee <bt_ready+0x82>
     99c:	240c      	movs	r4, #12
     99e:	b13a      	cbz	r2, 9b0 <bt_ready+0x44>
     9a0:	2103      	movs	r1, #3
     9a2:	7039      	strb	r1, [r7, #0]
     9a4:	2100      	movs	r1, #0
     9a6:	7079      	strb	r1, [r7, #1]
     9a8:	70b9      	strb	r1, [r7, #2]
     9aa:	70f9      	strb	r1, [r7, #3]
     9ac:	6838      	ldr	r0, [r7, #0]
     9ae:	6118      	str	r0, [r3, #16]
     9b0:	2100      	movs	r1, #0
     9b2:	f36f 0100 	bfc	r1, #0, #1
     9b6:	f36f 0141 	bfc	r1, #1, #1
     9ba:	f36f 0182 	bfc	r1, #2, #1
     9be:	f36f 01c5 	bfc	r1, #3, #3
     9c2:	2301      	movs	r3, #1
     9c4:	f363 1188 	bfi	r1, r3, #6, #3
     9c8:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
     9cc:	f363 2152 	bfi	r1, r3, #9, #10
     9d0:	f36f 41de 	bfc	r1, #19, #12
     9d4:	f36f 71df 	bfc	r1, #31, #1
     9d8:	2300      	movs	r3, #0
     9da:	4852      	ldr	r0, [pc, #328]	; (b24 <bt_ready+0x1b8>)
     9dc:	f001 fc34 	bl	2248 <z_impl_z_log_msg_static_create>
     9e0:	46ad      	mov	sp, r5
}
     9e2:	374c      	adds	r7, #76	; 0x4c
     9e4:	46bd      	mov	sp, r7
     9e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LOG_ERR("Bluetooth init failed (err %d)", err);
     9e8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
     9ec:	e7cb      	b.n	986 <bt_ready+0x1a>
     9ee:	f06f 041b 	mvn.w	r4, #27
     9f2:	e7d4      	b.n	99e <bt_ready+0x32>
	LOG_INF("Bluetooth initialized");
     9f4:	4b4c      	ldr	r3, [pc, #304]	; (b28 <bt_ready+0x1bc>)
     9f6:	62fb      	str	r3, [r7, #44]	; 0x2c
     9f8:	2302      	movs	r3, #2
     9fa:	703b      	strb	r3, [r7, #0]
     9fc:	2400      	movs	r4, #0
     9fe:	707c      	strb	r4, [r7, #1]
     a00:	70bc      	strb	r4, [r7, #2]
     a02:	70fc      	strb	r4, [r7, #3]
     a04:	683b      	ldr	r3, [r7, #0]
     a06:	62bb      	str	r3, [r7, #40]	; 0x28
     a08:	4621      	mov	r1, r4
     a0a:	f364 0100 	bfi	r1, r4, #0, #1
     a0e:	f364 0141 	bfi	r1, r4, #1, #1
     a12:	f364 0182 	bfi	r1, r4, #2, #1
     a16:	f364 01c5 	bfi	r1, r4, #3, #3
     a1a:	2603      	movs	r6, #3
     a1c:	f366 1188 	bfi	r1, r6, #6, #3
     a20:	2308      	movs	r3, #8
     a22:	f363 2152 	bfi	r1, r3, #9, #10
     a26:	f364 41de 	bfi	r1, r4, #19, #12
     a2a:	f364 71df 	bfi	r1, r4, #31, #1
     a2e:	4623      	mov	r3, r4
     a30:	f107 0228 	add.w	r2, r7, #40	; 0x28
     a34:	483b      	ldr	r0, [pc, #236]	; (b24 <bt_ready+0x1b8>)
     a36:	f001 fc07 	bl	2248 <z_impl_z_log_msg_static_create>
	err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), NULL, 0);
     a3a:	f107 0c04 	add.w	ip, r7, #4
     a3e:	4d3b      	ldr	r5, [pc, #236]	; (b2c <bt_ready+0x1c0>)
     a40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
     a42:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
     a46:	682b      	ldr	r3, [r5, #0]
     a48:	f8cc 3000 	str.w	r3, [ip]
     a4c:	9400      	str	r4, [sp, #0]
     a4e:	4623      	mov	r3, r4
     a50:	4632      	mov	r2, r6
     a52:	4937      	ldr	r1, [pc, #220]	; (b30 <bt_ready+0x1c4>)
     a54:	1d38      	adds	r0, r7, #4
     a56:	f008 fd7f 	bl	9558 <bt_le_adv_start>
	if (err) {
     a5a:	4604      	mov	r4, r0
     a5c:	2800      	cmp	r0, #0
     a5e:	d03b      	beq.n	ad8 <bt_ready+0x16c>
		LOG_ERR("Advertising failed to start (err %d)", err);
     a60:	466d      	mov	r5, sp
     a62:	b088      	sub	sp, #32
     a64:	ab02      	add	r3, sp, #8
     a66:	f113 0210 	adds.w	r2, r3, #16
     a6a:	d02f      	beq.n	acc <bt_ready+0x160>
     a6c:	210c      	movs	r1, #12
     a6e:	b11a      	cbz	r2, a78 <bt_ready+0x10c>
     a70:	2904      	cmp	r1, #4
     a72:	dd01      	ble.n	a78 <bt_ready+0x10c>
     a74:	482f      	ldr	r0, [pc, #188]	; (b34 <bt_ready+0x1c8>)
     a76:	6158      	str	r0, [r3, #20]
     a78:	b112      	cbz	r2, a80 <bt_ready+0x114>
     a7a:	2908      	cmp	r1, #8
     a7c:	dd00      	ble.n	a80 <bt_ready+0x114>
     a7e:	619c      	str	r4, [r3, #24]
     a80:	290b      	cmp	r1, #11
     a82:	dd26      	ble.n	ad2 <bt_ready+0x166>
     a84:	240c      	movs	r4, #12
     a86:	b13a      	cbz	r2, a98 <bt_ready+0x12c>
     a88:	2103      	movs	r1, #3
     a8a:	7039      	strb	r1, [r7, #0]
     a8c:	2100      	movs	r1, #0
     a8e:	7079      	strb	r1, [r7, #1]
     a90:	70b9      	strb	r1, [r7, #2]
     a92:	70f9      	strb	r1, [r7, #3]
     a94:	6838      	ldr	r0, [r7, #0]
     a96:	6118      	str	r0, [r3, #16]
     a98:	2100      	movs	r1, #0
     a9a:	f36f 0100 	bfc	r1, #0, #1
     a9e:	f36f 0141 	bfc	r1, #1, #1
     aa2:	f36f 0182 	bfc	r1, #2, #1
     aa6:	f36f 01c5 	bfc	r1, #3, #3
     aaa:	2301      	movs	r3, #1
     aac:	f363 1188 	bfi	r1, r3, #6, #3
     ab0:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
     ab4:	f363 2152 	bfi	r1, r3, #9, #10
     ab8:	f36f 41de 	bfc	r1, #19, #12
     abc:	f36f 71df 	bfc	r1, #31, #1
     ac0:	2300      	movs	r3, #0
     ac2:	4818      	ldr	r0, [pc, #96]	; (b24 <bt_ready+0x1b8>)
     ac4:	f001 fbc0 	bl	2248 <z_impl_z_log_msg_static_create>
     ac8:	46ad      	mov	sp, r5
		return;
     aca:	e78a      	b.n	9e2 <bt_ready+0x76>
		LOG_ERR("Advertising failed to start (err %d)", err);
     acc:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
     ad0:	e7cd      	b.n	a6e <bt_ready+0x102>
     ad2:	f06f 041b 	mvn.w	r4, #27
     ad6:	e7d6      	b.n	a86 <bt_ready+0x11a>
	LOG_INF("Configuration mode: waiting connections...");
     ad8:	4b17      	ldr	r3, [pc, #92]	; (b38 <bt_ready+0x1cc>)
     ada:	647b      	str	r3, [r7, #68]	; 0x44
     adc:	2302      	movs	r3, #2
     ade:	703b      	strb	r3, [r7, #0]
     ae0:	2300      	movs	r3, #0
     ae2:	707b      	strb	r3, [r7, #1]
     ae4:	70bb      	strb	r3, [r7, #2]
     ae6:	70fb      	strb	r3, [r7, #3]
     ae8:	683a      	ldr	r2, [r7, #0]
     aea:	643a      	str	r2, [r7, #64]	; 0x40
     aec:	4619      	mov	r1, r3
     aee:	f363 0100 	bfi	r1, r3, #0, #1
     af2:	f363 0141 	bfi	r1, r3, #1, #1
     af6:	f363 0182 	bfi	r1, r3, #2, #1
     afa:	f363 01c5 	bfi	r1, r3, #3, #3
     afe:	2203      	movs	r2, #3
     b00:	f362 1188 	bfi	r1, r2, #6, #3
     b04:	2208      	movs	r2, #8
     b06:	f362 2152 	bfi	r1, r2, #9, #10
     b0a:	f363 41de 	bfi	r1, r3, #19, #12
     b0e:	f363 71df 	bfi	r1, r3, #31, #1
     b12:	f107 0240 	add.w	r2, r7, #64	; 0x40
     b16:	4803      	ldr	r0, [pc, #12]	; (b24 <bt_ready+0x1b8>)
     b18:	f001 fb96 	bl	2248 <z_impl_z_log_msg_static_create>
     b1c:	e761      	b.n	9e2 <bt_ready+0x76>
     b1e:	bf00      	nop
     b20:	0001d2d4 	.word	0x0001d2d4
     b24:	0001d064 	.word	0x0001d064
     b28:	0001d2f4 	.word	0x0001d2f4
     b2c:	0001d110 	.word	0x0001d110
     b30:	0001d378 	.word	0x0001d378
     b34:	0001d30c 	.word	0x0001d30c
     b38:	0001d334 	.word	0x0001d334

00000b3c <main>:
	.connected = connected,
	.disconnected = disconnected,
};

void main(void)
{
     b3c:	b5b0      	push	{r4, r5, r7, lr}
     b3e:	b082      	sub	sp, #8
     b40:	af00      	add	r7, sp, #0
	int err;

	err = led_init();
     b42:	f7ff fd03 	bl	54c <led_init>
	if (err) {
     b46:	b110      	cbz	r0, b4e <main+0x12>
	/* Initialize the Bluetooth Subsystem */
	err = bt_enable(bt_ready);
	if (err) {
		LOG_ERR("Bluetooth init failed (err %d)", err);
	}
}
     b48:	3708      	adds	r7, #8
     b4a:	46bd      	mov	sp, r7
     b4c:	bdb0      	pop	{r4, r5, r7, pc}
	err = bt_enable(bt_ready);
     b4e:	4821      	ldr	r0, [pc, #132]	; (bd4 <main+0x98>)
     b50:	f007 fdd2 	bl	86f8 <bt_enable>
	if (err) {
     b54:	4605      	mov	r5, r0
     b56:	2800      	cmp	r0, #0
     b58:	d0f6      	beq.n	b48 <main+0xc>
		LOG_ERR("Bluetooth init failed (err %d)", err);
     b5a:	466c      	mov	r4, sp
     b5c:	b088      	sub	sp, #32
     b5e:	466b      	mov	r3, sp
     b60:	f113 0210 	adds.w	r2, r3, #16
     b64:	d030      	beq.n	bc8 <main+0x8c>
     b66:	210c      	movs	r1, #12
     b68:	b11a      	cbz	r2, b72 <main+0x36>
     b6a:	2904      	cmp	r1, #4
     b6c:	dd01      	ble.n	b72 <main+0x36>
     b6e:	481a      	ldr	r0, [pc, #104]	; (bd8 <main+0x9c>)
     b70:	6158      	str	r0, [r3, #20]
     b72:	b112      	cbz	r2, b7a <main+0x3e>
     b74:	2908      	cmp	r1, #8
     b76:	dd00      	ble.n	b7a <main+0x3e>
     b78:	619d      	str	r5, [r3, #24]
     b7a:	290b      	cmp	r1, #11
     b7c:	dd27      	ble.n	bce <main+0x92>
     b7e:	f04f 0c0c 	mov.w	ip, #12
     b82:	b13a      	cbz	r2, b94 <main+0x58>
     b84:	2103      	movs	r1, #3
     b86:	7139      	strb	r1, [r7, #4]
     b88:	2100      	movs	r1, #0
     b8a:	7179      	strb	r1, [r7, #5]
     b8c:	71b9      	strb	r1, [r7, #6]
     b8e:	71f9      	strb	r1, [r7, #7]
     b90:	6878      	ldr	r0, [r7, #4]
     b92:	6118      	str	r0, [r3, #16]
     b94:	2100      	movs	r1, #0
     b96:	f36f 0100 	bfc	r1, #0, #1
     b9a:	f36f 0141 	bfc	r1, #1, #1
     b9e:	f36f 0182 	bfc	r1, #2, #1
     ba2:	f36f 01c5 	bfc	r1, #3, #3
     ba6:	2301      	movs	r3, #1
     ba8:	f363 1188 	bfi	r1, r3, #6, #3
     bac:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
     bb0:	f36c 2152 	bfi	r1, ip, #9, #10
     bb4:	f36f 41de 	bfc	r1, #19, #12
     bb8:	f36f 71df 	bfc	r1, #31, #1
     bbc:	2300      	movs	r3, #0
     bbe:	4807      	ldr	r0, [pc, #28]	; (bdc <main+0xa0>)
     bc0:	f001 fb42 	bl	2248 <z_impl_z_log_msg_static_create>
     bc4:	46a5      	mov	sp, r4
     bc6:	e7bf      	b.n	b48 <main+0xc>
     bc8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
     bcc:	e7cc      	b.n	b68 <main+0x2c>
     bce:	f06f 0c1b 	mvn.w	ip, #27
     bd2:	e7d6      	b.n	b82 <main+0x46>
     bd4:	0000096d 	.word	0x0000096d
     bd8:	0001d2d4 	.word	0x0001d2d4
     bdc:	0001d064 	.word	0x0001d064

00000be0 <cbprintf_package_convert>:
			     cbprintf_convert_cb cb,
			     void *ctx,
			     uint32_t flags,
			     uint16_t *strl,
			     size_t strl_len)
{
     be0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     be4:	b091      	sub	sp, #68	; 0x44
     be6:	4606      	mov	r6, r0
     be8:	4693      	mov	fp, r2
     bea:	9301      	str	r3, [sp, #4]
     bec:	9f1a      	ldr	r7, [sp, #104]	; 0x68
	unsigned int args_size, ros_nbr, rws_nbr;
	bool rw_cpy;
	bool ro_cpy;
	struct cbprintf_package_desc *in_desc = in_packaged;

	in_len = in_len != 0 ? in_len : get_package_len(in_packaged);
     bee:	9102      	str	r1, [sp, #8]
     bf0:	b159      	cbz	r1, c0a <cbprintf_package_convert+0x2a>

	/* Get number of RO string indexes in the package and check if copying
	 * includes appending those strings.
	 */
	ros_nbr = in_desc->ro_str_cnt;
     bf2:	f896 8002 	ldrb.w	r8, [r6, #2]
     bf6:	f8cd 8000 	str.w	r8, [sp]
	ro_cpy = ros_nbr &&
     bfa:	f1b8 0f00 	cmp.w	r8, #0
     bfe:	d008      	beq.n	c12 <cbprintf_package_convert+0x32>
     c00:	f017 0f01 	tst.w	r7, #1
     c04:	d110      	bne.n	c28 <cbprintf_package_convert+0x48>
     c06:	2300      	movs	r3, #0
     c08:	e004      	b.n	c14 <cbprintf_package_convert+0x34>
	in_len = in_len != 0 ? in_len : get_package_len(in_packaged);
     c0a:	f014 fccb 	bl	155a4 <get_package_len>
     c0e:	9002      	str	r0, [sp, #8]
     c10:	e7ef      	b.n	bf2 <cbprintf_package_convert+0x12>
	ro_cpy = ros_nbr &&
     c12:	2300      	movs	r3, #0
		(flags & CBPRINTF_PACKAGE_COPY_RO_STR) == CBPRINTF_PACKAGE_COPY_RO_STR;

	/* Get number of RW string indexes in the package and check if copying
	 * includes appending those strings.
	 */
	rws_nbr = in_desc->rw_str_cnt;
     c14:	f896 a003 	ldrb.w	sl, [r6, #3]
	rw_cpy = rws_nbr > 0 &&
     c18:	f1ba 0f00 	cmp.w	sl, #0
     c1c:	d006      	beq.n	c2c <cbprintf_package_convert+0x4c>
     c1e:	f017 0f02 	tst.w	r7, #2
     c22:	d11d      	bne.n	c60 <cbprintf_package_convert+0x80>
     c24:	2200      	movs	r2, #0
     c26:	e002      	b.n	c2e <cbprintf_package_convert+0x4e>
	ro_cpy = ros_nbr &&
     c28:	2301      	movs	r3, #1
     c2a:	e7f3      	b.n	c14 <cbprintf_package_convert+0x34>
	rw_cpy = rws_nbr > 0 &&
     c2c:	2200      	movs	r2, #0

	/* If flags are not set or appending request without rw string indexes
	 * present is chosen, just do a simple copy (or length calculation).
	 * Assuming that it is the most common case.
	 */
	if (!rw_cpy && !ro_cpy) {
     c2e:	b902      	cbnz	r2, c32 <cbprintf_package_convert+0x52>
     c30:	b1c3      	cbz	r3, c64 <cbprintf_package_convert+0x84>

	/* If we got here, it means that coping will be more complex and will be
	 * done with strings appending.
	 * Retrieve the size of the arg list.
	 */
	args_size = in_desc->len * sizeof(int);
     c32:	7835      	ldrb	r5, [r6, #0]
     c34:	00aa      	lsls	r2, r5, #2
     c36:	9203      	str	r2, [sp, #12]
	int out_len;

	/* Pointer to array with string locations. Array starts with read-only
	 * string locations.
	 */
	uint8_t *str_pos = &buf[args_size];
     c38:	eb06 0585 	add.w	r5, r6, r5, lsl #2
	size_t strl_cnt = 0;

	/* If null destination, just calculate output length. */
	if (cb == NULL) {
     c3c:	f1bb 0f00 	cmp.w	fp, #0
     c40:	d01c      	beq.n	c7c <cbprintf_package_convert+0x9c>

	/* If read-only strings shall be appended to the output package copy
	 * their indexes to the local array, otherwise indicate that indexes
	 * shall remain in the output package.
	 */
	if (ro_cpy) {
     c42:	2b00      	cmp	r3, #0
     c44:	f040 8086 	bne.w	d54 <cbprintf_package_convert+0x174>
		scpy_cnt = ros_nbr;
		keep_cnt = 0;
		dst = cpy_str_pos;
	} else if (ros_nbr && flags & CBPRINTF_PACKAGE_COPY_KEEP_RO_STR) {
     c48:	9b00      	ldr	r3, [sp, #0]
     c4a:	2b00      	cmp	r3, #0
     c4c:	f000 808e 	beq.w	d6c <cbprintf_package_convert+0x18c>
     c50:	f017 0f04 	tst.w	r7, #4
     c54:	f040 808e 	bne.w	d74 <cbprintf_package_convert+0x194>
		keep_cnt = ros_nbr;
		dst = keep_str_pos;
	} else {
		scpy_cnt = 0;
		keep_cnt = 0;
		dst = NULL;
     c58:	2000      	movs	r0, #0
		keep_cnt = 0;
     c5a:	4681      	mov	r9, r0
		scpy_cnt = 0;
     c5c:	4680      	mov	r8, r0
     c5e:	e07c      	b.n	d5a <cbprintf_package_convert+0x17a>
	rw_cpy = rws_nbr > 0 &&
     c60:	2201      	movs	r2, #1
     c62:	e7e4      	b.n	c2e <cbprintf_package_convert+0x4e>
		if (cb) {
     c64:	f1bb 0f00 	cmp.w	fp, #0
     c68:	d003      	beq.n	c72 <cbprintf_package_convert+0x92>
			cb(in_packaged, in_len, ctx);
     c6a:	9a01      	ldr	r2, [sp, #4]
     c6c:	9902      	ldr	r1, [sp, #8]
     c6e:	4630      	mov	r0, r6
     c70:	47d8      	blx	fp
		return in_len;
     c72:	9c02      	ldr	r4, [sp, #8]

	/* Empty call (can be interpreted as flushing) */
	(void)cb(NULL, 0, ctx);

	return out_len;
}
     c74:	4620      	mov	r0, r4
     c76:	b011      	add	sp, #68	; 0x44
     c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		out_len = (int)in_len;
     c7c:	9c02      	ldr	r4, [sp, #8]
		if (ro_cpy) {
     c7e:	bb03      	cbnz	r3, cc2 <cbprintf_package_convert+0xe2>
			if (ros_nbr && flags & CBPRINTF_PACKAGE_COPY_KEEP_RO_STR) {
     c80:	9b00      	ldr	r3, [sp, #0]
     c82:	b3a3      	cbz	r3, cee <cbprintf_package_convert+0x10e>
     c84:	f017 0904 	ands.w	r9, r7, #4
     c88:	d028      	beq.n	cdc <cbprintf_package_convert+0xfc>
				str_pos += ros_nbr;
     c8a:	441d      	add	r5, r3
	size_t strl_cnt = 0;
     c8c:	f04f 0900 	mov.w	r9, #0
     c90:	e024      	b.n	cdc <cbprintf_package_convert+0xfc>
				out_len += len;
     c92:	4404      	add	r4, r0
				str_pos++;
     c94:	3501      	adds	r5, #1
			for (int i = 0; i < ros_nbr; i++) {
     c96:	f108 0801 	add.w	r8, r8, #1
     c9a:	45d0      	cmp	r8, sl
     c9c:	d21b      	bcs.n	cd6 <cbprintf_package_convert+0xf6>
				const char *str = *(const char **)&buf32[*str_pos];
     c9e:	782a      	ldrb	r2, [r5, #0]
				int len = append_string(cb, NULL, str, 0);
     ca0:	2300      	movs	r3, #0
     ca2:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
     ca6:	4619      	mov	r1, r3
     ca8:	4658      	mov	r0, fp
     caa:	f014 fc90 	bl	155ce <append_string>
				if (strl && strl_cnt < strl_len) {
     cae:	2f00      	cmp	r7, #0
     cb0:	d0ef      	beq.n	c92 <cbprintf_package_convert+0xb2>
     cb2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
     cb4:	4599      	cmp	r9, r3
     cb6:	d2ec      	bcs.n	c92 <cbprintf_package_convert+0xb2>
					strl[strl_cnt++] = (uint16_t)len;
     cb8:	f827 0019 	strh.w	r0, [r7, r9, lsl #1]
     cbc:	f109 0901 	add.w	r9, r9, #1
     cc0:	e7e7      	b.n	c92 <cbprintf_package_convert+0xb2>
			for (int i = 0; i < ros_nbr; i++) {
     cc2:	f04f 0800 	mov.w	r8, #0
	size_t strl_cnt = 0;
     cc6:	46c1      	mov	r9, r8
     cc8:	f8cd a004 	str.w	sl, [sp, #4]
     ccc:	f8dd a000 	ldr.w	sl, [sp]
     cd0:	971a      	str	r7, [sp, #104]	; 0x68
     cd2:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
     cd4:	e7e1      	b.n	c9a <cbprintf_package_convert+0xba>
     cd6:	f8dd a004 	ldr.w	sl, [sp, #4]
     cda:	9f1a      	ldr	r7, [sp, #104]	; 0x68
		bool drop_ro_str_pos = !(flags &
     cdc:	f007 0305 	and.w	r3, r7, #5
     ce0:	9300      	str	r3, [sp, #0]
		for (int i = 0; i < rws_nbr; i++) {
     ce2:	f04f 0800 	mov.w	r8, #0
     ce6:	f8cd b004 	str.w	fp, [sp, #4]
     cea:	46b3      	mov	fp, r6
     cec:	e023      	b.n	d36 <cbprintf_package_convert+0x156>
	size_t strl_cnt = 0;
     cee:	f8dd 9000 	ldr.w	r9, [sp]
     cf2:	e7f3      	b.n	cdc <cbprintf_package_convert+0xfc>
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
     cf4:	2300      	movs	r3, #0
			if ((is_ro && flags & CBPRINTF_PACKAGE_COPY_RO_STR) ||
     cf6:	461e      	mov	r6, r3
     cf8:	b113      	cbz	r3, d00 <cbprintf_package_convert+0x120>
     cfa:	f017 0f01 	tst.w	r7, #1
     cfe:	d103      	bne.n	d08 <cbprintf_package_convert+0x128>
     d00:	b996      	cbnz	r6, d28 <cbprintf_package_convert+0x148>
			    (!is_ro && flags & CBPRINTF_PACKAGE_COPY_RW_STR)) {
     d02:	f017 0f02 	tst.w	r7, #2
     d06:	d00f      	beq.n	d28 <cbprintf_package_convert+0x148>
				int len = append_string(cb, NULL, str, 0);
     d08:	2300      	movs	r3, #0
     d0a:	4619      	mov	r1, r3
     d0c:	9801      	ldr	r0, [sp, #4]
     d0e:	f014 fc5e 	bl	155ce <append_string>
				if (strl && strl_cnt < strl_len) {
     d12:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
     d14:	b13b      	cbz	r3, d26 <cbprintf_package_convert+0x146>
     d16:	9b1c      	ldr	r3, [sp, #112]	; 0x70
     d18:	4599      	cmp	r9, r3
     d1a:	d204      	bcs.n	d26 <cbprintf_package_convert+0x146>
					strl[strl_cnt++] = (uint16_t)len;
     d1c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
     d1e:	f823 0019 	strh.w	r0, [r3, r9, lsl #1]
     d22:	f109 0901 	add.w	r9, r9, #1
				out_len += len;
     d26:	4404      	add	r4, r0
			if (is_ro && drop_ro_str_pos) {
     d28:	b116      	cbz	r6, d30 <cbprintf_package_convert+0x150>
     d2a:	9b00      	ldr	r3, [sp, #0]
     d2c:	b903      	cbnz	r3, d30 <cbprintf_package_convert+0x150>
				out_len--;
     d2e:	3c01      	subs	r4, #1
			str_pos++;
     d30:	3501      	adds	r5, #1
		for (int i = 0; i < rws_nbr; i++) {
     d32:	f108 0801 	add.w	r8, r8, #1
     d36:	45d0      	cmp	r8, sl
     d38:	d29c      	bcs.n	c74 <cbprintf_package_convert+0x94>
			const char *str = *(const char **)&buf32[*str_pos];
     d3a:	782b      	ldrb	r3, [r5, #0]
     d3c:	f85b 2023 	ldr.w	r2, [fp, r3, lsl #2]
     d40:	4b6b      	ldr	r3, [pc, #428]	; (ef0 <cbprintf_package_convert+0x310>)
     d42:	429a      	cmp	r2, r3
     d44:	d3d6      	bcc.n	cf4 <cbprintf_package_convert+0x114>
     d46:	4b6b      	ldr	r3, [pc, #428]	; (ef4 <cbprintf_package_convert+0x314>)
     d48:	429a      	cmp	r2, r3
     d4a:	d301      	bcc.n	d50 <cbprintf_package_convert+0x170>
     d4c:	2300      	movs	r3, #0
     d4e:	e7d2      	b.n	cf6 <cbprintf_package_convert+0x116>
     d50:	2301      	movs	r3, #1
     d52:	e7d0      	b.n	cf6 <cbprintf_package_convert+0x116>
		dst = cpy_str_pos;
     d54:	a80b      	add	r0, sp, #44	; 0x2c
		keep_cnt = 0;
     d56:	f04f 0900 	mov.w	r9, #0
	if (dst) {
     d5a:	b118      	cbz	r0, d64 <cbprintf_package_convert+0x184>
		memcpy(dst, str_pos, ros_nbr);
     d5c:	9a00      	ldr	r2, [sp, #0]
     d5e:	4629      	mov	r1, r5
     d60:	f016 fce6 	bl	17730 <memcpy>
	str_pos += ros_nbr;
     d64:	9b00      	ldr	r3, [sp, #0]
     d66:	441d      	add	r5, r3
	for (int i = 0; i < rws_nbr; i++) {
     d68:	2300      	movs	r3, #0
     d6a:	e017      	b.n	d9c <cbprintf_package_convert+0x1bc>
		dst = NULL;
     d6c:	2000      	movs	r0, #0
		keep_cnt = 0;
     d6e:	4681      	mov	r9, r0
		scpy_cnt = 0;
     d70:	4680      	mov	r8, r0
     d72:	e7f2      	b.n	d5a <cbprintf_package_convert+0x17a>
		keep_cnt = ros_nbr;
     d74:	46c1      	mov	r9, r8
		dst = keep_str_pos;
     d76:	a807      	add	r0, sp, #28
		scpy_cnt = 0;
     d78:	f04f 0800 	mov.w	r8, #0
     d7c:	e7ed      	b.n	d5a <cbprintf_package_convert+0x17a>
     d7e:	2100      	movs	r1, #0
		if (is_ro) {
     d80:	b339      	cbz	r1, dd2 <cbprintf_package_convert+0x1f2>
			if (flags & CBPRINTF_PACKAGE_COPY_RO_STR) {
     d82:	f017 0f01 	tst.w	r7, #1
     d86:	d018      	beq.n	dba <cbprintf_package_convert+0x1da>
				cpy_str_pos[scpy_cnt++] = *str_pos;
     d88:	f108 0101 	add.w	r1, r8, #1
     d8c:	a810      	add	r0, sp, #64	; 0x40
     d8e:	4480      	add	r8, r0
     d90:	f808 2c14 	strb.w	r2, [r8, #-20]
     d94:	fa5f f881 	uxtb.w	r8, r1
		str_pos++;
     d98:	3501      	adds	r5, #1
	for (int i = 0; i < rws_nbr; i++) {
     d9a:	3301      	adds	r3, #1
     d9c:	4553      	cmp	r3, sl
     d9e:	d22d      	bcs.n	dfc <cbprintf_package_convert+0x21c>
		const char *str = *(const char **)&buf32[*str_pos];
     da0:	782a      	ldrb	r2, [r5, #0]
     da2:	f856 1022 	ldr.w	r1, [r6, r2, lsl #2]
     da6:	4852      	ldr	r0, [pc, #328]	; (ef0 <cbprintf_package_convert+0x310>)
     da8:	4281      	cmp	r1, r0
     daa:	d3e8      	bcc.n	d7e <cbprintf_package_convert+0x19e>
     dac:	4851      	ldr	r0, [pc, #324]	; (ef4 <cbprintf_package_convert+0x314>)
     dae:	4281      	cmp	r1, r0
     db0:	d301      	bcc.n	db6 <cbprintf_package_convert+0x1d6>
     db2:	2100      	movs	r1, #0
     db4:	e7e4      	b.n	d80 <cbprintf_package_convert+0x1a0>
     db6:	2101      	movs	r1, #1
     db8:	e7e2      	b.n	d80 <cbprintf_package_convert+0x1a0>
			} else if (flags & CBPRINTF_PACKAGE_COPY_KEEP_RO_STR) {
     dba:	f017 0f04 	tst.w	r7, #4
     dbe:	d0eb      	beq.n	d98 <cbprintf_package_convert+0x1b8>
				keep_str_pos[keep_cnt++] = *str_pos;
     dc0:	f109 0101 	add.w	r1, r9, #1
     dc4:	a810      	add	r0, sp, #64	; 0x40
     dc6:	4481      	add	r9, r0
     dc8:	f809 2c24 	strb.w	r2, [r9, #-36]
     dcc:	fa5f f981 	uxtb.w	r9, r1
     dd0:	e7e2      	b.n	d98 <cbprintf_package_convert+0x1b8>
			if (flags & CBPRINTF_PACKAGE_COPY_RW_STR) {
     dd2:	f017 0f02 	tst.w	r7, #2
     dd6:	d008      	beq.n	dea <cbprintf_package_convert+0x20a>
				cpy_str_pos[scpy_cnt++] = *str_pos;
     dd8:	f108 0101 	add.w	r1, r8, #1
     ddc:	a810      	add	r0, sp, #64	; 0x40
     dde:	4480      	add	r8, r0
     de0:	f808 2c14 	strb.w	r2, [r8, #-20]
     de4:	fa5f f881 	uxtb.w	r8, r1
     de8:	e7d6      	b.n	d98 <cbprintf_package_convert+0x1b8>
				keep_str_pos[keep_cnt++] = *str_pos;
     dea:	f109 0101 	add.w	r1, r9, #1
     dee:	a810      	add	r0, sp, #64	; 0x40
     df0:	4481      	add	r9, r0
     df2:	f809 2c24 	strb.w	r2, [r9, #-36]
     df6:	fa5f f981 	uxtb.w	r9, r1
     dfa:	e7cd      	b.n	d98 <cbprintf_package_convert+0x1b8>
	out_desc.len = in_desc->len;
     dfc:	7833      	ldrb	r3, [r6, #0]
     dfe:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
	out_desc.str_cnt = in_desc->str_cnt + scpy_cnt;
     e02:	7873      	ldrb	r3, [r6, #1]
     e04:	4443      	add	r3, r8
     e06:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_COPY_RW_STR) ? 0 : keep_cnt;
     e0a:	f017 0f02 	tst.w	r7, #2
     e0e:	d00a      	beq.n	e26 <cbprintf_package_convert+0x246>
     e10:	2300      	movs	r3, #0
     e12:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_COPY_RO_STR) ? 0 :
     e16:	f017 0f01 	tst.w	r7, #1
     e1a:	d106      	bne.n	e2a <cbprintf_package_convert+0x24a>
     e1c:	f017 0f04 	tst.w	r7, #4
     e20:	d132      	bne.n	e88 <cbprintf_package_convert+0x2a8>
     e22:	2300      	movs	r3, #0
     e24:	e002      	b.n	e2c <cbprintf_package_convert+0x24c>
	out_desc.rw_str_cnt = (flags & CBPRINTF_PACKAGE_COPY_RW_STR) ? 0 : keep_cnt;
     e26:	464b      	mov	r3, r9
     e28:	e7f3      	b.n	e12 <cbprintf_package_convert+0x232>
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_COPY_RO_STR) ? 0 :
     e2a:	2300      	movs	r3, #0
     e2c:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
	struct cbprintf_package_desc in_desc_backup = *in_desc;
     e30:	6830      	ldr	r0, [r6, #0]
     e32:	9006      	str	r0, [sp, #24]
	*in_desc = out_desc;
     e34:	980f      	ldr	r0, [sp, #60]	; 0x3c
     e36:	6030      	str	r0, [r6, #0]
	rv = cb(in_packaged, args_size, ctx);
     e38:	9f01      	ldr	r7, [sp, #4]
     e3a:	463a      	mov	r2, r7
     e3c:	9903      	ldr	r1, [sp, #12]
     e3e:	4630      	mov	r0, r6
     e40:	47d8      	blx	fp
	if (rv < 0) {
     e42:	1e04      	subs	r4, r0, #0
     e44:	f6ff af16 	blt.w	c74 <cbprintf_package_convert+0x94>
	*in_desc = in_desc_backup;
     e48:	9806      	ldr	r0, [sp, #24]
     e4a:	6030      	str	r0, [r6, #0]
	rv = cb(keep_str_pos, keep_cnt, ctx);
     e4c:	9701      	str	r7, [sp, #4]
     e4e:	463a      	mov	r2, r7
     e50:	4649      	mov	r1, r9
     e52:	a807      	add	r0, sp, #28
     e54:	47d8      	blx	fp
	if (rv < 0) {
     e56:	2800      	cmp	r0, #0
     e58:	db43      	blt.n	ee2 <cbprintf_package_convert+0x302>
	out_len += rv;
     e5a:	1827      	adds	r7, r4, r0
	size_t strs_len = in_len - (args_size + ros_nbr + rws_nbr);
     e5c:	9800      	ldr	r0, [sp, #0]
     e5e:	9b03      	ldr	r3, [sp, #12]
     e60:	4418      	add	r0, r3
     e62:	4601      	mov	r1, r0
     e64:	4451      	add	r1, sl
	rv = cb(str_pos, strs_len, ctx);
     e66:	f8dd 9004 	ldr.w	r9, [sp, #4]
     e6a:	464a      	mov	r2, r9
     e6c:	9b02      	ldr	r3, [sp, #8]
     e6e:	1a59      	subs	r1, r3, r1
     e70:	4628      	mov	r0, r5
     e72:	47d8      	blx	fp
	if (rv < 0) {
     e74:	1e04      	subs	r4, r0, #0
     e76:	f6ff aefd 	blt.w	c74 <cbprintf_package_convert+0x94>
	out_len += rv;
     e7a:	193d      	adds	r5, r7, r4
	for (int i = 0; i < scpy_cnt; i++) {
     e7c:	2700      	movs	r7, #0
     e7e:	9600      	str	r6, [sp, #0]
     e80:	465e      	mov	r6, fp
     e82:	f8dd b06c 	ldr.w	fp, [sp, #108]	; 0x6c
     e86:	e015      	b.n	eb4 <cbprintf_package_convert+0x2d4>
	out_desc.ro_str_cnt = (flags & CBPRINTF_PACKAGE_COPY_RO_STR) ? 0 :
     e88:	464b      	mov	r3, r9
     e8a:	e7cf      	b.n	e2c <cbprintf_package_convert+0x24c>
		uint16_t str_len = strl ? strl[i] : 0;
     e8c:	f04f 0a00 	mov.w	sl, #0
		rv = cb(&loc, 1, ctx);
     e90:	464a      	mov	r2, r9
     e92:	2101      	movs	r1, #1
     e94:	f10d 0017 	add.w	r0, sp, #23
     e98:	47b0      	blx	r6
		if (rv < 0) {
     e9a:	2800      	cmp	r0, #0
     e9c:	db23      	blt.n	ee6 <cbprintf_package_convert+0x306>
		out_len += rv;
     e9e:	4405      	add	r5, r0
		rv = append_string(cb, ctx, str, str_len);
     ea0:	4653      	mov	r3, sl
     ea2:	4622      	mov	r2, r4
     ea4:	4649      	mov	r1, r9
     ea6:	4630      	mov	r0, r6
     ea8:	f014 fb91 	bl	155ce <append_string>
		if (rv < 0) {
     eac:	2800      	cmp	r0, #0
     eae:	db1c      	blt.n	eea <cbprintf_package_convert+0x30a>
		out_len += rv;
     eb0:	4405      	add	r5, r0
	for (int i = 0; i < scpy_cnt; i++) {
     eb2:	3701      	adds	r7, #1
     eb4:	45b8      	cmp	r8, r7
     eb6:	dd0e      	ble.n	ed6 <cbprintf_package_convert+0x2f6>
		uint8_t loc = cpy_str_pos[i];
     eb8:	ab10      	add	r3, sp, #64	; 0x40
     eba:	443b      	add	r3, r7
     ebc:	f813 3c14 	ldrb.w	r3, [r3, #-20]
     ec0:	f88d 3017 	strb.w	r3, [sp, #23]
		const char *str = *(const char **)&buf32[loc];
     ec4:	9a00      	ldr	r2, [sp, #0]
     ec6:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
		uint16_t str_len = strl ? strl[i] : 0;
     eca:	f1bb 0f00 	cmp.w	fp, #0
     ece:	d0dd      	beq.n	e8c <cbprintf_package_convert+0x2ac>
     ed0:	f83b a017 	ldrh.w	sl, [fp, r7, lsl #1]
     ed4:	e7dc      	b.n	e90 <cbprintf_package_convert+0x2b0>
	(void)cb(NULL, 0, ctx);
     ed6:	9a01      	ldr	r2, [sp, #4]
     ed8:	2100      	movs	r1, #0
     eda:	4608      	mov	r0, r1
     edc:	47b0      	blx	r6
	return out_len;
     ede:	462c      	mov	r4, r5
     ee0:	e6c8      	b.n	c74 <cbprintf_package_convert+0x94>
		return rv;
     ee2:	4604      	mov	r4, r0
     ee4:	e6c6      	b.n	c74 <cbprintf_package_convert+0x94>
     ee6:	4604      	mov	r4, r0
     ee8:	e6c4      	b.n	c74 <cbprintf_package_convert+0x94>
     eea:	4604      	mov	r4, r0
     eec:	e6c2      	b.n	c74 <cbprintf_package_convert+0x94>
     eee:	bf00      	nop
     ef0:	0001cb54 	.word	0x0001cb54
     ef4:	0002006c 	.word	0x0002006c

00000ef8 <char_out>:

	return c;
}

static int char_out(int c, void *ctx_p)
{
     ef8:	b508      	push	{r3, lr}
	(void) ctx_p;
	return _char_out(c);
     efa:	4b02      	ldr	r3, [pc, #8]	; (f04 <char_out+0xc>)
     efc:	681b      	ldr	r3, [r3, #0]
     efe:	4798      	blx	r3
}
     f00:	bd08      	pop	{r3, pc}
     f02:	bf00      	nop
     f04:	200001bc 	.word	0x200001bc

00000f08 <__printk_hook_install>:
	_char_out = fn;
     f08:	4b01      	ldr	r3, [pc, #4]	; (f10 <__printk_hook_install+0x8>)
     f0a:	6018      	str	r0, [r3, #0]
}
     f0c:	4770      	bx	lr
     f0e:	bf00      	nop
     f10:	200001bc 	.word	0x200001bc

00000f14 <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
     f14:	b500      	push	{lr}
     f16:	b083      	sub	sp, #12
     f18:	4602      	mov	r2, r0
     f1a:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
     f1c:	2100      	movs	r1, #0
     f1e:	9100      	str	r1, [sp, #0]
     f20:	4802      	ldr	r0, [pc, #8]	; (f2c <vprintk+0x18>)
     f22:	f000 fa53 	bl	13cc <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
     f26:	b003      	add	sp, #12
     f28:	f85d fb04 	ldr.w	pc, [sp], #4
     f2c:	00000ef9 	.word	0x00000ef9

00000f30 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
     f30:	b510      	push	{r4, lr}
     f32:	b086      	sub	sp, #24
     f34:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
     f36:	9003      	str	r0, [sp, #12]
     f38:	9104      	str	r1, [sp, #16]
     f3a:	2100      	movs	r1, #0
     f3c:	9105      	str	r1, [sp, #20]
     f3e:	9100      	str	r1, [sp, #0]
     f40:	a903      	add	r1, sp, #12
     f42:	4806      	ldr	r0, [pc, #24]	; (f5c <vsnprintk+0x2c>)
     f44:	f000 fa42 	bl	13cc <z_cbvprintf_impl>

	cbvprintf(str_out, &ctx, fmt, ap);

	if (ctx.count < ctx.max) {
     f48:	9b05      	ldr	r3, [sp, #20]
     f4a:	9a04      	ldr	r2, [sp, #16]
     f4c:	4293      	cmp	r3, r2
     f4e:	da01      	bge.n	f54 <vsnprintk+0x24>
		str[ctx.count] = '\0';
     f50:	2200      	movs	r2, #0
     f52:	54e2      	strb	r2, [r4, r3]
	}

	return ctx.count;
}
     f54:	9805      	ldr	r0, [sp, #20]
     f56:	b006      	add	sp, #24
     f58:	bd10      	pop	{r4, pc}
     f5a:	bf00      	nop
     f5c:	000156cf 	.word	0x000156cf

00000f60 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     f60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     f64:	b083      	sub	sp, #12
     f66:	4604      	mov	r4, r0
     f68:	4608      	mov	r0, r1
     f6a:	4615      	mov	r5, r2
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     f6c:	8b23      	ldrh	r3, [r4, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     f6e:	f013 0f08 	tst.w	r3, #8
     f72:	d105      	bne.n	f80 <process_event+0x20>
     f74:	f003 0607 	and.w	r6, r3, #7
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
     f78:	2300      	movs	r3, #0
     f7a:	9300      	str	r3, [sp, #0]
	list->tail = NULL;
     f7c:	9301      	str	r3, [sp, #4]
}
     f7e:	e069      	b.n	1054 <CONFIG_HEAP_MEM_POOL_SIZE+0x54>
		if (evt == EVT_COMPLETE) {
     f80:	2901      	cmp	r1, #1
     f82:	d009      	beq.n	f98 <process_event+0x38>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     f84:	f043 0320 	orr.w	r3, r3, #32
     f88:	8323      	strh	r3, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     f8a:	f385 8811 	msr	BASEPRI, r5
     f8e:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     f92:	b003      	add	sp, #12
     f94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     f98:	f043 0310 	orr.w	r3, r3, #16
     f9c:	8323      	strh	r3, [r4, #24]
     f9e:	e7f4      	b.n	f8a <process_event+0x2a>
			evt = process_recheck(mgr);
     fa0:	4620      	mov	r0, r4
     fa2:	f014 fbef 	bl	15784 <process_recheck>
     fa6:	e057      	b.n	1058 <CONFIG_HEAP_MEM_POOL_SIZE+0x58>
			res = mgr->last_res;
     fa8:	f8d4 9014 	ldr.w	r9, [r4, #20]
			process_complete(mgr, &clients, res);
     fac:	464a      	mov	r2, r9
     fae:	4669      	mov	r1, sp
     fb0:	4620      	mov	r0, r4
     fb2:	f014 fc00 	bl	157b6 <process_complete>
		onoff_transition_fn transit = NULL;
     fb6:	2700      	movs	r7, #0
     fb8:	e05a      	b.n	1070 <CONFIG_HEAP_MEM_POOL_SIZE+0x70>
			transit = mgr->transitions->start;
     fba:	6923      	ldr	r3, [r4, #16]
     fbc:	681f      	ldr	r7, [r3, #0]
			set_state(mgr, ONOFF_STATE_TO_ON);
     fbe:	2106      	movs	r1, #6
     fc0:	4620      	mov	r0, r4
     fc2:	f014 fbb8 	bl	15736 <set_state>
		res = 0;
     fc6:	f04f 0900 	mov.w	r9, #0
     fca:	e051      	b.n	1070 <CONFIG_HEAP_MEM_POOL_SIZE+0x70>
			transit = mgr->transitions->stop;
     fcc:	6923      	ldr	r3, [r4, #16]
     fce:	685f      	ldr	r7, [r3, #4]
			set_state(mgr, ONOFF_STATE_TO_OFF);
     fd0:	2104      	movs	r1, #4
     fd2:	4620      	mov	r0, r4
     fd4:	f014 fbaf 	bl	15736 <set_state>
		res = 0;
     fd8:	f04f 0900 	mov.w	r9, #0
     fdc:	e048      	b.n	1070 <CONFIG_HEAP_MEM_POOL_SIZE+0x70>
			transit = mgr->transitions->reset;
     fde:	6923      	ldr	r3, [r4, #16]
     fe0:	689f      	ldr	r7, [r3, #8]
			set_state(mgr, ONOFF_STATE_RESETTING);
     fe2:	2105      	movs	r1, #5
     fe4:	4620      	mov	r0, r4
     fe6:	f014 fba6 	bl	15736 <set_state>
		res = 0;
     fea:	f04f 0900 	mov.w	r9, #0
     fee:	e03f      	b.n	1070 <CONFIG_HEAP_MEM_POOL_SIZE+0x70>
				   && !sys_slist_is_empty(&mgr->monitors);
     ff0:	2200      	movs	r2, #0
     ff2:	e046      	b.n	1082 <CONFIG_HEAP_MEM_POOL_SIZE+0x82>
     ff4:	2200      	movs	r2, #0
     ff6:	e044      	b.n	1082 <CONFIG_HEAP_MEM_POOL_SIZE+0x82>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     ff8:	f043 0308 	orr.w	r3, r3, #8
			mgr->flags = flags;
     ffc:	8323      	strh	r3, [r4, #24]
     ffe:	f385 8811 	msr	BASEPRI, r5
    1002:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
    1006:	2900      	cmp	r1, #0
    1008:	d144      	bne.n	1094 <CONFIG_HEAP_MEM_POOL_SIZE+0x94>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    100a:	9b00      	ldr	r3, [sp, #0]
			if (!sys_slist_is_empty(&clients)) {
    100c:	b12b      	cbz	r3, 101a <CONFIG_HEAP_MEM_POOL_SIZE+0x1a>
				notify_all(mgr, &clients, state, res);
    100e:	464b      	mov	r3, r9
    1010:	4642      	mov	r2, r8
    1012:	4669      	mov	r1, sp
    1014:	4620      	mov	r0, r4
    1016:	f014 fc45 	bl	158a4 <notify_all>
			if (transit != NULL) {
    101a:	b117      	cbz	r7, 1022 <CONFIG_HEAP_MEM_POOL_SIZE+0x22>
				transit(mgr, transition_complete);
    101c:	4925      	ldr	r1, [pc, #148]	; (10b4 <CONFIG_HEAP_MEM_POOL_SIZE+0xb4>)
    101e:	4620      	mov	r0, r4
    1020:	47b8      	blx	r7
	__asm__ volatile(
    1022:	f04f 0320 	mov.w	r3, #32
    1026:	f3ef 8511 	mrs	r5, BASEPRI
    102a:	f383 8812 	msr	BASEPRI_MAX, r3
    102e:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
    1032:	8b23      	ldrh	r3, [r4, #24]
    1034:	f023 0308 	bic.w	r3, r3, #8
    1038:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
    103a:	8b23      	ldrh	r3, [r4, #24]
    103c:	f013 0f10 	tst.w	r3, #16
    1040:	d02e      	beq.n	10a0 <CONFIG_HEAP_MEM_POOL_SIZE+0xa0>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
    1042:	f023 0310 	bic.w	r3, r3, #16
    1046:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
    1048:	2001      	movs	r0, #1
		state = mgr->flags & ONOFF_STATE_MASK;
    104a:	8b26      	ldrh	r6, [r4, #24]
    104c:	f006 0607 	and.w	r6, r6, #7
	} while (evt != EVT_NOP);
    1050:	2800      	cmp	r0, #0
    1052:	d09a      	beq.n	f8a <process_event+0x2a>
		if (evt == EVT_RECHECK) {
    1054:	2802      	cmp	r0, #2
    1056:	d0a3      	beq.n	fa0 <process_event+0x40>
		if (evt == EVT_NOP) {
    1058:	2800      	cmp	r0, #0
    105a:	d096      	beq.n	f8a <process_event+0x2a>
		if (evt == EVT_COMPLETE) {
    105c:	2801      	cmp	r0, #1
    105e:	d0a3      	beq.n	fa8 <process_event+0x48>
		} else if (evt == EVT_START) {
    1060:	2803      	cmp	r0, #3
    1062:	d0aa      	beq.n	fba <process_event+0x5a>
		} else if (evt == EVT_STOP) {
    1064:	2804      	cmp	r0, #4
    1066:	d0b1      	beq.n	fcc <process_event+0x6c>
		} else if (evt == EVT_RESET) {
    1068:	2805      	cmp	r0, #5
    106a:	d0b8      	beq.n	fde <process_event+0x7e>
		onoff_transition_fn transit = NULL;
    106c:	2700      	movs	r7, #0
		res = 0;
    106e:	46b9      	mov	r9, r7
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
    1070:	8b23      	ldrh	r3, [r4, #24]
    1072:	f003 0807 	and.w	r8, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
    1076:	45b0      	cmp	r8, r6
    1078:	d0ba      	beq.n	ff0 <process_event+0x90>
    107a:	68a2      	ldr	r2, [r4, #8]
    107c:	2a00      	cmp	r2, #0
    107e:	d0b9      	beq.n	ff4 <process_event+0x94>
    1080:	2201      	movs	r2, #1
		if (do_monitors
    1082:	4611      	mov	r1, r2
    1084:	2a00      	cmp	r2, #0
    1086:	d1b7      	bne.n	ff8 <process_event+0x98>
    1088:	9a00      	ldr	r2, [sp, #0]
		    || !sys_slist_is_empty(&clients)
    108a:	2a00      	cmp	r2, #0
    108c:	d1b4      	bne.n	ff8 <process_event+0x98>
		    || (transit != NULL)) {
    108e:	2f00      	cmp	r7, #0
    1090:	d1b2      	bne.n	ff8 <process_event+0x98>
    1092:	e7d2      	b.n	103a <CONFIG_HEAP_MEM_POOL_SIZE+0x3a>
				notify_monitors(mgr, state, res);
    1094:	464a      	mov	r2, r9
    1096:	4641      	mov	r1, r8
    1098:	4620      	mov	r0, r4
    109a:	f014 fb54 	bl	15746 <notify_monitors>
    109e:	e7b4      	b.n	100a <CONFIG_HEAP_MEM_POOL_SIZE+0xa>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
    10a0:	f013 0f20 	tst.w	r3, #32
    10a4:	d004      	beq.n	10b0 <CONFIG_HEAP_MEM_POOL_SIZE+0xb0>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
    10a6:	f023 0320 	bic.w	r3, r3, #32
    10aa:	8323      	strh	r3, [r4, #24]
			evt = EVT_RECHECK;
    10ac:	2002      	movs	r0, #2
    10ae:	e7cc      	b.n	104a <CONFIG_HEAP_MEM_POOL_SIZE+0x4a>
		evt = EVT_NOP;
    10b0:	2000      	movs	r0, #0
    10b2:	e7ca      	b.n	104a <CONFIG_HEAP_MEM_POOL_SIZE+0x4a>
    10b4:	000158d3 	.word	0x000158d3

000010b8 <extract_conversion>:
 *
 * @return pointer to the first character that follows the specification.
 */
static inline const char *extract_conversion(struct conversion *conv,
					     const char *sp)
{
    10b8:	b570      	push	{r4, r5, r6, lr}
    10ba:	b082      	sub	sp, #8
    10bc:	4604      	mov	r4, r0
	*conv = (struct conversion) {
    10be:	2300      	movs	r3, #0
    10c0:	6003      	str	r3, [r0, #0]
    10c2:	6043      	str	r3, [r0, #4]
    10c4:	6083      	str	r3, [r0, #8]
	/* Skip over the opening %.  If the conversion specifier is %,
	 * that's the only thing that should be there, so
	 * fast-exit.
	 */
	++sp;
	if (*sp == '%') {
    10c6:	784b      	ldrb	r3, [r1, #1]
    10c8:	2b25      	cmp	r3, #37	; 0x25
    10ca:	d002      	beq.n	10d2 <extract_conversion+0x1a>
    10cc:	1c4e      	adds	r6, r1, #1
	bool loop = true;
    10ce:	2501      	movs	r5, #1
    10d0:	e01f      	b.n	1112 <extract_conversion+0x5a>
		conv->specifier = *sp++;
    10d2:	1c88      	adds	r0, r1, #2
    10d4:	70e3      	strb	r3, [r4, #3]
		return sp;
    10d6:	e145      	b.n	1364 <extract_conversion+0x2ac>
			conv->flag_dash = true;
    10d8:	7823      	ldrb	r3, [r4, #0]
    10da:	f043 0304 	orr.w	r3, r3, #4
    10de:	7023      	strb	r3, [r4, #0]
		if (loop) {
    10e0:	b1b5      	cbz	r5, 1110 <extract_conversion+0x58>
			++sp;
    10e2:	3601      	adds	r6, #1
    10e4:	e014      	b.n	1110 <extract_conversion+0x58>
			conv->flag_plus = true;
    10e6:	7823      	ldrb	r3, [r4, #0]
    10e8:	f043 0308 	orr.w	r3, r3, #8
    10ec:	7023      	strb	r3, [r4, #0]
			break;
    10ee:	e7f7      	b.n	10e0 <extract_conversion+0x28>
			conv->flag_space = true;
    10f0:	7823      	ldrb	r3, [r4, #0]
    10f2:	f043 0310 	orr.w	r3, r3, #16
    10f6:	7023      	strb	r3, [r4, #0]
			break;
    10f8:	e7f2      	b.n	10e0 <extract_conversion+0x28>
			conv->flag_hash = true;
    10fa:	7823      	ldrb	r3, [r4, #0]
    10fc:	f043 0320 	orr.w	r3, r3, #32
    1100:	7023      	strb	r3, [r4, #0]
			break;
    1102:	e7ed      	b.n	10e0 <extract_conversion+0x28>
			conv->flag_zero = true;
    1104:	7823      	ldrb	r3, [r4, #0]
    1106:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    110a:	7023      	strb	r3, [r4, #0]
			break;
    110c:	e7e8      	b.n	10e0 <extract_conversion+0x28>
		switch (*sp) {
    110e:	2500      	movs	r5, #0
	} while (loop);
    1110:	b345      	cbz	r5, 1164 <extract_conversion+0xac>
		switch (*sp) {
    1112:	7833      	ldrb	r3, [r6, #0]
    1114:	3b20      	subs	r3, #32
    1116:	2b10      	cmp	r3, #16
    1118:	d8f9      	bhi.n	110e <extract_conversion+0x56>
    111a:	a201      	add	r2, pc, #4	; (adr r2, 1120 <extract_conversion+0x68>)
    111c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1120:	000010f1 	.word	0x000010f1
    1124:	0000110f 	.word	0x0000110f
    1128:	0000110f 	.word	0x0000110f
    112c:	000010fb 	.word	0x000010fb
    1130:	0000110f 	.word	0x0000110f
    1134:	0000110f 	.word	0x0000110f
    1138:	0000110f 	.word	0x0000110f
    113c:	0000110f 	.word	0x0000110f
    1140:	0000110f 	.word	0x0000110f
    1144:	0000110f 	.word	0x0000110f
    1148:	0000110f 	.word	0x0000110f
    114c:	000010e7 	.word	0x000010e7
    1150:	0000110f 	.word	0x0000110f
    1154:	000010d9 	.word	0x000010d9
    1158:	0000110f 	.word	0x0000110f
    115c:	0000110f 	.word	0x0000110f
    1160:	00001105 	.word	0x00001105
	if (conv->flag_zero && conv->flag_dash) {
    1164:	7823      	ldrb	r3, [r4, #0]
    1166:	f003 0344 	and.w	r3, r3, #68	; 0x44
    116a:	2b44      	cmp	r3, #68	; 0x44
    116c:	d05f      	beq.n	122e <extract_conversion+0x176>
	}

	sp = extract_flags(conv, sp);
	sp = extract_width(conv, sp);
    116e:	9601      	str	r6, [sp, #4]
	conv->width_present = true;
    1170:	7823      	ldrb	r3, [r4, #0]
    1172:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1176:	7023      	strb	r3, [r4, #0]
	if (*sp == '*') {
    1178:	7833      	ldrb	r3, [r6, #0]
    117a:	2b2a      	cmp	r3, #42	; 0x2a
    117c:	d05c      	beq.n	1238 <extract_conversion+0x180>
	size_t width = extract_decimal(&sp);
    117e:	a801      	add	r0, sp, #4
    1180:	f014 fffd 	bl	1617e <extract_decimal>
	if (sp != wp) {
    1184:	9b01      	ldr	r3, [sp, #4]
    1186:	429e      	cmp	r6, r3
    1188:	d00f      	beq.n	11aa <extract_conversion+0xf2>
		conv->width_present = true;
    118a:	7823      	ldrb	r3, [r4, #0]
    118c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    1190:	7023      	strb	r3, [r4, #0]
		conv->width_value = width;
    1192:	6060      	str	r0, [r4, #4]
		conv->unsupported |= ((conv->width_value < 0)
    1194:	b2db      	uxtb	r3, r3
    1196:	f3c3 0340 	ubfx	r3, r3, #1, #1
				      || (width != (size_t)conv->width_value));
    119a:	2800      	cmp	r0, #0
    119c:	db54      	blt.n	1248 <extract_conversion+0x190>
    119e:	2200      	movs	r2, #0
		conv->unsupported |= ((conv->width_value < 0)
    11a0:	4313      	orrs	r3, r2
    11a2:	7822      	ldrb	r2, [r4, #0]
    11a4:	f363 0241 	bfi	r2, r3, #1, #1
    11a8:	7022      	strb	r2, [r4, #0]
	return sp;
    11aa:	9b01      	ldr	r3, [sp, #4]
	sp = extract_prec(conv, sp);
    11ac:	9301      	str	r3, [sp, #4]
	conv->prec_present = (*sp == '.');
    11ae:	781b      	ldrb	r3, [r3, #0]
    11b0:	2b2e      	cmp	r3, #46	; 0x2e
    11b2:	bf14      	ite	ne
    11b4:	2300      	movne	r3, #0
    11b6:	2301      	moveq	r3, #1
    11b8:	7862      	ldrb	r2, [r4, #1]
    11ba:	f363 0241 	bfi	r2, r3, #1, #1
    11be:	7062      	strb	r2, [r4, #1]
	if (!conv->prec_present) {
    11c0:	2b00      	cmp	r3, #0
    11c2:	d043      	beq.n	124c <extract_conversion+0x194>
	++sp;
    11c4:	9b01      	ldr	r3, [sp, #4]
    11c6:	1c5a      	adds	r2, r3, #1
    11c8:	9201      	str	r2, [sp, #4]
	if (*sp == '*') {
    11ca:	785b      	ldrb	r3, [r3, #1]
    11cc:	2b2a      	cmp	r3, #42	; 0x2a
    11ce:	d03f      	beq.n	1250 <extract_conversion+0x198>
	size_t prec = extract_decimal(&sp);
    11d0:	a801      	add	r0, sp, #4
    11d2:	f014 ffd4 	bl	1617e <extract_decimal>
	conv->prec_value = prec;
    11d6:	60a0      	str	r0, [r4, #8]
	conv->unsupported |= ((conv->prec_value < 0)
    11d8:	7823      	ldrb	r3, [r4, #0]
    11da:	f3c3 0340 	ubfx	r3, r3, #1, #1
			      || (prec != (size_t)conv->prec_value));
    11de:	2800      	cmp	r0, #0
    11e0:	db3e      	blt.n	1260 <extract_conversion+0x1a8>
    11e2:	2200      	movs	r2, #0
	conv->unsupported |= ((conv->prec_value < 0)
    11e4:	4313      	orrs	r3, r2
    11e6:	7822      	ldrb	r2, [r4, #0]
    11e8:	f363 0241 	bfi	r2, r3, #1, #1
    11ec:	7022      	strb	r2, [r4, #0]
	return sp;
    11ee:	9801      	ldr	r0, [sp, #4]
	switch (*sp) {
    11f0:	7803      	ldrb	r3, [r0, #0]
    11f2:	3b4c      	subs	r3, #76	; 0x4c
    11f4:	2b2e      	cmp	r3, #46	; 0x2e
    11f6:	f200 809d 	bhi.w	1334 <extract_conversion+0x27c>
    11fa:	e8df f003 	tbb	[pc, r3]
    11fe:	9b90      	.short	0x9b90
    1200:	9b9b9b9b 	.word	0x9b9b9b9b
    1204:	9b9b9b9b 	.word	0x9b9b9b9b
    1208:	9b9b9b9b 	.word	0x9b9b9b9b
    120c:	9b9b9b9b 	.word	0x9b9b9b9b
    1210:	9b9b9b9b 	.word	0x9b9b9b9b
    1214:	9b9b9b9b 	.word	0x9b9b9b9b
    1218:	9b339b9b 	.word	0x9b339b9b
    121c:	9b459b57 	.word	0x9b459b57
    1220:	9b9b9b9b 	.word	0x9b9b9b9b
    1224:	9b899b9b 	.word	0x9b899b9b
    1228:	9b9b9b9b 	.word	0x9b9b9b9b
    122c:	82          	.byte	0x82
    122d:	00          	.byte	0x00
		conv->flag_zero = false;
    122e:	7823      	ldrb	r3, [r4, #0]
    1230:	f36f 1386 	bfc	r3, #6, #1
    1234:	7023      	strb	r3, [r4, #0]
    1236:	e79a      	b.n	116e <extract_conversion+0xb6>
		conv->width_star = true;
    1238:	7863      	ldrb	r3, [r4, #1]
    123a:	f043 0301 	orr.w	r3, r3, #1
    123e:	7063      	strb	r3, [r4, #1]
		return ++sp;
    1240:	4633      	mov	r3, r6
    1242:	3301      	adds	r3, #1
    1244:	9301      	str	r3, [sp, #4]
    1246:	e7b1      	b.n	11ac <extract_conversion+0xf4>
				      || (width != (size_t)conv->width_value));
    1248:	2201      	movs	r2, #1
    124a:	e7a9      	b.n	11a0 <extract_conversion+0xe8>
		return sp;
    124c:	9801      	ldr	r0, [sp, #4]
    124e:	e7cf      	b.n	11f0 <extract_conversion+0x138>
		conv->prec_star = true;
    1250:	7863      	ldrb	r3, [r4, #1]
    1252:	f043 0304 	orr.w	r3, r3, #4
    1256:	7063      	strb	r3, [r4, #1]
		return ++sp;
    1258:	4610      	mov	r0, r2
    125a:	3001      	adds	r0, #1
    125c:	9001      	str	r0, [sp, #4]
    125e:	e7c7      	b.n	11f0 <extract_conversion+0x138>
			      || (prec != (size_t)conv->prec_value));
    1260:	2201      	movs	r2, #1
    1262:	e7bf      	b.n	11e4 <extract_conversion+0x12c>
		if (*++sp == 'h') {
    1264:	1c42      	adds	r2, r0, #1
    1266:	7843      	ldrb	r3, [r0, #1]
    1268:	2b68      	cmp	r3, #104	; 0x68
    126a:	d006      	beq.n	127a <extract_conversion+0x1c2>
			conv->length_mod = LENGTH_H;
    126c:	7863      	ldrb	r3, [r4, #1]
    126e:	2102      	movs	r1, #2
    1270:	f361 03c6 	bfi	r3, r1, #3, #4
    1274:	7063      	strb	r3, [r4, #1]
		if (*++sp == 'h') {
    1276:	4610      	mov	r0, r2
    1278:	e01e      	b.n	12b8 <extract_conversion+0x200>
			conv->length_mod = LENGTH_HH;
    127a:	7863      	ldrb	r3, [r4, #1]
    127c:	2201      	movs	r2, #1
    127e:	f362 03c6 	bfi	r3, r2, #3, #4
    1282:	7063      	strb	r3, [r4, #1]
			++sp;
    1284:	3002      	adds	r0, #2
    1286:	e017      	b.n	12b8 <extract_conversion+0x200>
		if (*++sp == 'l') {
    1288:	1c42      	adds	r2, r0, #1
    128a:	7843      	ldrb	r3, [r0, #1]
    128c:	2b6c      	cmp	r3, #108	; 0x6c
    128e:	d006      	beq.n	129e <extract_conversion+0x1e6>
			conv->length_mod = LENGTH_L;
    1290:	7863      	ldrb	r3, [r4, #1]
    1292:	2103      	movs	r1, #3
    1294:	f361 03c6 	bfi	r3, r1, #3, #4
    1298:	7063      	strb	r3, [r4, #1]
		if (*++sp == 'l') {
    129a:	4610      	mov	r0, r2
    129c:	e00c      	b.n	12b8 <extract_conversion+0x200>
			conv->length_mod = LENGTH_LL;
    129e:	7863      	ldrb	r3, [r4, #1]
    12a0:	2204      	movs	r2, #4
    12a2:	f362 03c6 	bfi	r3, r2, #3, #4
    12a6:	7063      	strb	r3, [r4, #1]
			++sp;
    12a8:	3002      	adds	r0, #2
    12aa:	e005      	b.n	12b8 <extract_conversion+0x200>
		conv->length_mod = LENGTH_J;
    12ac:	7863      	ldrb	r3, [r4, #1]
    12ae:	2205      	movs	r2, #5
    12b0:	f362 03c6 	bfi	r3, r2, #3, #4
    12b4:	7063      	strb	r3, [r4, #1]
		++sp;
    12b6:	3001      	adds	r0, #1
	conv->specifier = *sp++;
    12b8:	f810 3b01 	ldrb.w	r3, [r0], #1
    12bc:	70e3      	strb	r3, [r4, #3]
	switch (conv->specifier) {
    12be:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
    12c2:	2a37      	cmp	r2, #55	; 0x37
    12c4:	d87d      	bhi.n	13c2 <CONFIG_BT_CONN_PARAM_UPDATE_TIMEOUT+0x3a>
    12c6:	e8df f002 	tbb	[pc, r2]
    12ca:	7c5e      	.short	0x7c5e
    12cc:	5e5e7c7c 	.word	0x5e5e7c7c
    12d0:	7c7c7c5e 	.word	0x7c7c7c5e
    12d4:	7c7c7c7c 	.word	0x7c7c7c7c
    12d8:	7c7c7c7c 	.word	0x7c7c7c7c
    12dc:	7c7c7c7c 	.word	0x7c7c7c7c
    12e0:	7c7c4f7c 	.word	0x7c7c4f7c
    12e4:	7c7c7c7c 	.word	0x7c7c7c7c
    12e8:	7c5e7c7c 	.word	0x7c5e7c7c
    12ec:	5e5e3a4f 	.word	0x5e5e3a4f
    12f0:	7c3a7c5e 	.word	0x7c3a7c5e
    12f4:	657c7c7c 	.word	0x657c7c7c
    12f8:	7c7c714f 	.word	0x7c7c714f
    12fc:	7c4f7c71 	.word	0x7c4f7c71
    1300:	4f7c      	.short	0x4f7c
		conv->length_mod = LENGTH_Z;
    1302:	7863      	ldrb	r3, [r4, #1]
    1304:	2206      	movs	r2, #6
    1306:	f362 03c6 	bfi	r3, r2, #3, #4
    130a:	7063      	strb	r3, [r4, #1]
		++sp;
    130c:	3001      	adds	r0, #1
		break;
    130e:	e7d3      	b.n	12b8 <extract_conversion+0x200>
		conv->length_mod = LENGTH_T;
    1310:	7863      	ldrb	r3, [r4, #1]
    1312:	2207      	movs	r2, #7
    1314:	f362 03c6 	bfi	r3, r2, #3, #4
    1318:	7063      	strb	r3, [r4, #1]
		++sp;
    131a:	3001      	adds	r0, #1
		break;
    131c:	e7cc      	b.n	12b8 <extract_conversion+0x200>
		conv->length_mod = LENGTH_UPPER_L;
    131e:	7863      	ldrb	r3, [r4, #1]
    1320:	2208      	movs	r2, #8
    1322:	f362 03c6 	bfi	r3, r2, #3, #4
    1326:	7063      	strb	r3, [r4, #1]
		++sp;
    1328:	3001      	adds	r0, #1
		conv->unsupported = true;
    132a:	7823      	ldrb	r3, [r4, #0]
    132c:	f043 0302 	orr.w	r3, r3, #2
    1330:	7023      	strb	r3, [r4, #0]
		break;
    1332:	e7c1      	b.n	12b8 <extract_conversion+0x200>
		conv->length_mod = LENGTH_NONE;
    1334:	7863      	ldrb	r3, [r4, #1]
    1336:	f36f 03c6 	bfc	r3, #3, #4
    133a:	7063      	strb	r3, [r4, #1]
		break;
    133c:	e7bc      	b.n	12b8 <extract_conversion+0x200>
		conv->specifier_cat = SPECIFIER_SINT;
    133e:	78a2      	ldrb	r2, [r4, #2]
    1340:	2101      	movs	r1, #1
    1342:	f361 0202 	bfi	r2, r1, #0, #3
    1346:	70a2      	strb	r2, [r4, #2]
		if (conv->length_mod == LENGTH_UPPER_L) {
    1348:	7862      	ldrb	r2, [r4, #1]
    134a:	f002 0278 	and.w	r2, r2, #120	; 0x78
    134e:	2a40      	cmp	r2, #64	; 0x40
    1350:	d010      	beq.n	1374 <extract_conversion+0x2bc>
		if (conv->specifier == 'c') {
    1352:	2b63      	cmp	r3, #99	; 0x63
    1354:	d013      	beq.n	137e <extract_conversion+0x2c6>
	conv->unsupported |= unsupported;
    1356:	7823      	ldrb	r3, [r4, #0]
    1358:	f3c3 0240 	ubfx	r2, r3, #1, #1
    135c:	4315      	orrs	r5, r2
    135e:	f365 0341 	bfi	r3, r5, #1, #1
    1362:	7023      	strb	r3, [r4, #0]
	sp = extract_length(conv, sp);
	sp = extract_specifier(conv, sp);

	return sp;
}
    1364:	b002      	add	sp, #8
    1366:	bd70      	pop	{r4, r5, r6, pc}
		conv->specifier_cat = SPECIFIER_UINT;
    1368:	78a2      	ldrb	r2, [r4, #2]
    136a:	2102      	movs	r1, #2
    136c:	f361 0202 	bfi	r2, r1, #0, #3
    1370:	70a2      	strb	r2, [r4, #2]
    1372:	e7e9      	b.n	1348 <extract_conversion+0x290>
			conv->invalid = true;
    1374:	7821      	ldrb	r1, [r4, #0]
    1376:	f041 0101 	orr.w	r1, r1, #1
    137a:	7021      	strb	r1, [r4, #0]
    137c:	e7e9      	b.n	1352 <extract_conversion+0x29a>
			unsupported = (conv->length_mod != LENGTH_NONE);
    137e:	1e15      	subs	r5, r2, #0
    1380:	bf18      	it	ne
    1382:	2501      	movne	r5, #1
    1384:	e7e7      	b.n	1356 <extract_conversion+0x29e>
		conv->specifier_cat = SPECIFIER_FP;
    1386:	78a3      	ldrb	r3, [r4, #2]
    1388:	2204      	movs	r2, #4
    138a:	f362 0302 	bfi	r3, r2, #0, #3
    138e:	70a3      	strb	r3, [r4, #2]
			unsupported = true;
    1390:	2501      	movs	r5, #1
			break;
    1392:	e7e0      	b.n	1356 <extract_conversion+0x29e>
		conv->specifier_cat = SPECIFIER_PTR;
    1394:	78a3      	ldrb	r3, [r4, #2]
    1396:	2203      	movs	r2, #3
    1398:	f362 0302 	bfi	r3, r2, #0, #3
    139c:	70a3      	strb	r3, [r4, #2]
		if (conv->length_mod == LENGTH_UPPER_L) {
    139e:	7863      	ldrb	r3, [r4, #1]
    13a0:	f003 0378 	and.w	r3, r3, #120	; 0x78
    13a4:	2b40      	cmp	r3, #64	; 0x40
    13a6:	d1d6      	bne.n	1356 <extract_conversion+0x29e>
			unsupported = true;
    13a8:	2501      	movs	r5, #1
    13aa:	e7d4      	b.n	1356 <extract_conversion+0x29e>
		conv->specifier_cat = SPECIFIER_PTR;
    13ac:	78a3      	ldrb	r3, [r4, #2]
    13ae:	2203      	movs	r2, #3
    13b0:	f362 0302 	bfi	r3, r2, #0, #3
    13b4:	70a3      	strb	r3, [r4, #2]
		if (conv->length_mod != LENGTH_NONE) {
    13b6:	7863      	ldrb	r3, [r4, #1]
    13b8:	f013 0f78 	tst.w	r3, #120	; 0x78
    13bc:	d0cb      	beq.n	1356 <extract_conversion+0x29e>
			unsupported = true;
    13be:	2501      	movs	r5, #1
    13c0:	e7c9      	b.n	1356 <extract_conversion+0x29e>
		conv->invalid = true;
    13c2:	7823      	ldrb	r3, [r4, #0]
    13c4:	f043 0301 	orr.w	r3, r3, #1
    13c8:	7023      	strb	r3, [r4, #0]
		break;
    13ca:	e7c4      	b.n	1356 <extract_conversion+0x29e>

000013cc <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
    13cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    13d0:	b091      	sub	sp, #68	; 0x44
    13d2:	4606      	mov	r6, r0
    13d4:	460d      	mov	r5, r1
    13d6:	4691      	mov	r9, r2
    13d8:	9303      	str	r3, [sp, #12]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    13da:	2400      	movs	r4, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    13dc:	f899 0000 	ldrb.w	r0, [r9]
    13e0:	2800      	cmp	r0, #0
    13e2:	f000 82d5 	beq.w	1990 <z_cbvprintf_impl+0x5c4>
		if (*fp != '%') {
    13e6:	2825      	cmp	r0, #37	; 0x25
    13e8:	d008      	beq.n	13fc <z_cbvprintf_impl+0x30>
			OUTC(*fp++);
    13ea:	f109 0901 	add.w	r9, r9, #1
    13ee:	4629      	mov	r1, r5
    13f0:	47b0      	blx	r6
    13f2:	2800      	cmp	r0, #0
    13f4:	f2c0 82cd 	blt.w	1992 <z_cbvprintf_impl+0x5c6>
    13f8:	3401      	adds	r4, #1
			continue;
    13fa:	e7ef      	b.n	13dc <z_cbvprintf_impl+0x10>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
    13fc:	2300      	movs	r3, #0
    13fe:	9304      	str	r3, [sp, #16]
    1400:	9305      	str	r3, [sp, #20]
    1402:	9306      	str	r3, [sp, #24]
    1404:	9307      	str	r3, [sp, #28]
    1406:	9308      	str	r3, [sp, #32]
    1408:	9309      	str	r3, [sp, #36]	; 0x24
		int precision = -1;
		const char *bps = NULL;
		const char *bpe = buf + sizeof(buf);
		char sign = 0;

		fp = extract_conversion(conv, sp);
    140a:	4649      	mov	r1, r9
    140c:	a806      	add	r0, sp, #24
    140e:	f7ff fe53 	bl	10b8 <extract_conversion>
    1412:	9002      	str	r0, [sp, #8]

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
    1414:	f89d 3019 	ldrb.w	r3, [sp, #25]
    1418:	f013 0f01 	tst.w	r3, #1
    141c:	f000 8097 	beq.w	154e <z_cbvprintf_impl+0x182>
			width = va_arg(ap, int);
    1420:	9b03      	ldr	r3, [sp, #12]
    1422:	1d1a      	adds	r2, r3, #4
    1424:	9203      	str	r2, [sp, #12]
    1426:	681f      	ldr	r7, [r3, #0]

			if (width < 0) {
    1428:	2f00      	cmp	r7, #0
    142a:	f2c0 8088 	blt.w	153e <z_cbvprintf_impl+0x172>

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
    142e:	f89d 3019 	ldrb.w	r3, [sp, #25]
    1432:	f013 0f04 	tst.w	r3, #4
    1436:	f000 809c 	beq.w	1572 <z_cbvprintf_impl+0x1a6>
			int arg = va_arg(ap, int);
    143a:	9b03      	ldr	r3, [sp, #12]
    143c:	1d1a      	adds	r2, r3, #4
    143e:	9203      	str	r2, [sp, #12]
    1440:	f8d3 a000 	ldr.w	sl, [r3]

			if (arg < 0) {
    1444:	f1ba 0f00 	cmp.w	sl, #0
    1448:	f2c0 808a 	blt.w	1560 <z_cbvprintf_impl+0x194>
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
    144c:	2300      	movs	r3, #0
    144e:	9307      	str	r3, [sp, #28]
		conv->pad0_pre_exp = 0;
    1450:	9308      	str	r3, [sp, #32]
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
    1452:	f89d 301a 	ldrb.w	r3, [sp, #26]
    1456:	f003 0307 	and.w	r3, r3, #7
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
    145a:	f89d 1019 	ldrb.w	r1, [sp, #25]
    145e:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
    1462:	2b01      	cmp	r3, #1
    1464:	f000 808e 	beq.w	1584 <z_cbvprintf_impl+0x1b8>
			if (length_mod == LENGTH_HH) {
				value->sint = (signed char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
    1468:	2b02      	cmp	r3, #2
    146a:	f000 80d3 	beq.w	1614 <z_cbvprintf_impl+0x248>
			if (length_mod == LENGTH_HH) {
				value->uint = (unsigned char)value->uint;
			} else if (length_mod == LENGTH_H) {
				value->uint = (unsigned short)value->uint;
			}
		} else if (specifier_cat == SPECIFIER_FP) {
    146e:	2b04      	cmp	r3, #4
    1470:	f000 8124 	beq.w	16bc <z_cbvprintf_impl+0x2f0>
			if (length_mod == LENGTH_UPPER_L) {
				value->ldbl = va_arg(ap, long double);
			} else {
				value->dbl = va_arg(ap, double);
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
    1474:	2b03      	cmp	r3, #3
    1476:	f000 813b 	beq.w	16f0 <z_cbvprintf_impl+0x324>
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
    147a:	f89d 8018 	ldrb.w	r8, [sp, #24]
    147e:	f018 0b03 	ands.w	fp, r8, #3
    1482:	f040 813b 	bne.w	16fc <z_cbvprintf_impl+0x330>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
    1486:	f89d 301b 	ldrb.w	r3, [sp, #27]
    148a:	3b25      	subs	r3, #37	; 0x25
    148c:	2b53      	cmp	r3, #83	; 0x53
    148e:	f200 81e6 	bhi.w	185e <z_cbvprintf_impl+0x492>
    1492:	e8df f013 	tbh	[pc, r3, lsl #1]
    1496:	0140      	.short	0x0140
    1498:	01e401e4 	.word	0x01e401e4
    149c:	01e401e4 	.word	0x01e401e4
    14a0:	01e401e4 	.word	0x01e401e4
    14a4:	01e401e4 	.word	0x01e401e4
    14a8:	01e401e4 	.word	0x01e401e4
    14ac:	01e401e4 	.word	0x01e401e4
    14b0:	01e401e4 	.word	0x01e401e4
    14b4:	01e401e4 	.word	0x01e401e4
    14b8:	01e401e4 	.word	0x01e401e4
    14bc:	01e401e4 	.word	0x01e401e4
    14c0:	01e401e4 	.word	0x01e401e4
    14c4:	01e401e4 	.word	0x01e401e4
    14c8:	01e401e4 	.word	0x01e401e4
    14cc:	01e401e4 	.word	0x01e401e4
    14d0:	01e401e4 	.word	0x01e401e4
    14d4:	01e401e4 	.word	0x01e401e4
    14d8:	01e401e4 	.word	0x01e401e4
    14dc:	01e401e4 	.word	0x01e401e4
    14e0:	01e401e4 	.word	0x01e401e4
    14e4:	01e401e4 	.word	0x01e401e4
    14e8:	01e401e4 	.word	0x01e401e4
    14ec:	01e401e4 	.word	0x01e401e4
    14f0:	01e401e4 	.word	0x01e401e4
    14f4:	01e401e4 	.word	0x01e401e4
    14f8:	01e401e4 	.word	0x01e401e4
    14fc:	01e40181 	.word	0x01e40181
    1500:	01e401e4 	.word	0x01e401e4
    1504:	01e401e4 	.word	0x01e401e4
    1508:	01e401e4 	.word	0x01e401e4
    150c:	01e401e4 	.word	0x01e401e4
    1510:	015e01e4 	.word	0x015e01e4
    1514:	01e40167 	.word	0x01e40167
    1518:	01e401e4 	.word	0x01e401e4
    151c:	016701e4 	.word	0x016701e4
    1520:	01e401e4 	.word	0x01e401e4
    1524:	01e401e4 	.word	0x01e401e4
    1528:	018101be 	.word	0x018101be
    152c:	01e401a2 	.word	0x01e401a2
    1530:	014d01e4 	.word	0x014d01e4
    1534:	018101e4 	.word	0x018101e4
    1538:	01e401e4 	.word	0x01e401e4
    153c:	0181      	.short	0x0181
				conv->flag_dash = true;
    153e:	f89d 3018 	ldrb.w	r3, [sp, #24]
    1542:	f043 0304 	orr.w	r3, r3, #4
    1546:	f88d 3018 	strb.w	r3, [sp, #24]
				width = -width;
    154a:	427f      	negs	r7, r7
    154c:	e76f      	b.n	142e <z_cbvprintf_impl+0x62>
		} else if (conv->width_present) {
    154e:	f99d 3018 	ldrsb.w	r3, [sp, #24]
    1552:	2b00      	cmp	r3, #0
    1554:	db02      	blt.n	155c <z_cbvprintf_impl+0x190>
		int width = -1;
    1556:	f04f 37ff 	mov.w	r7, #4294967295
    155a:	e768      	b.n	142e <z_cbvprintf_impl+0x62>
			width = conv->width_value;
    155c:	9f07      	ldr	r7, [sp, #28]
    155e:	e766      	b.n	142e <z_cbvprintf_impl+0x62>
				conv->prec_present = false;
    1560:	f89d 3019 	ldrb.w	r3, [sp, #25]
    1564:	f36f 0341 	bfc	r3, #1, #1
    1568:	f88d 3019 	strb.w	r3, [sp, #25]
		int precision = -1;
    156c:	f04f 3aff 	mov.w	sl, #4294967295
    1570:	e76c      	b.n	144c <z_cbvprintf_impl+0x80>
		} else if (conv->prec_present) {
    1572:	f013 0f02 	tst.w	r3, #2
    1576:	d002      	beq.n	157e <z_cbvprintf_impl+0x1b2>
			precision = conv->prec_value;
    1578:	f8dd a020 	ldr.w	sl, [sp, #32]
    157c:	e766      	b.n	144c <z_cbvprintf_impl+0x80>
		int precision = -1;
    157e:	f04f 3aff 	mov.w	sl, #4294967295
    1582:	e763      	b.n	144c <z_cbvprintf_impl+0x80>
			switch (length_mod) {
    1584:	1ecb      	subs	r3, r1, #3
    1586:	2b04      	cmp	r3, #4
    1588:	d804      	bhi.n	1594 <z_cbvprintf_impl+0x1c8>
    158a:	e8df f003 	tbb	[pc, r3]
    158e:	1d0b      	.short	0x1d0b
    1590:	3529      	.short	0x3529
    1592:	35          	.byte	0x35
    1593:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
    1594:	9b03      	ldr	r3, [sp, #12]
    1596:	1d1a      	adds	r2, r3, #4
    1598:	9203      	str	r2, [sp, #12]
    159a:	681b      	ldr	r3, [r3, #0]
    159c:	17da      	asrs	r2, r3, #31
    159e:	9304      	str	r3, [sp, #16]
    15a0:	9205      	str	r2, [sp, #20]
				break;
    15a2:	e006      	b.n	15b2 <z_cbvprintf_impl+0x1e6>
					value->sint = va_arg(ap, long);
    15a4:	9b03      	ldr	r3, [sp, #12]
    15a6:	1d1a      	adds	r2, r3, #4
    15a8:	9203      	str	r2, [sp, #12]
    15aa:	681b      	ldr	r3, [r3, #0]
    15ac:	17da      	asrs	r2, r3, #31
    15ae:	9304      	str	r3, [sp, #16]
    15b0:	9205      	str	r2, [sp, #20]
			if (length_mod == LENGTH_HH) {
    15b2:	2901      	cmp	r1, #1
    15b4:	d028      	beq.n	1608 <z_cbvprintf_impl+0x23c>
			} else if (length_mod == LENGTH_H) {
    15b6:	2902      	cmp	r1, #2
    15b8:	f47f af5f 	bne.w	147a <z_cbvprintf_impl+0xae>
				value->sint = (short)value->sint;
    15bc:	f9bd 3010 	ldrsh.w	r3, [sp, #16]
    15c0:	17da      	asrs	r2, r3, #31
    15c2:	9304      	str	r3, [sp, #16]
    15c4:	9205      	str	r2, [sp, #20]
    15c6:	e758      	b.n	147a <z_cbvprintf_impl+0xae>
					(sint_value_type)va_arg(ap, long long);
    15c8:	9b03      	ldr	r3, [sp, #12]
    15ca:	3307      	adds	r3, #7
    15cc:	f023 0307 	bic.w	r3, r3, #7
    15d0:	f103 0208 	add.w	r2, r3, #8
    15d4:	9203      	str	r2, [sp, #12]
    15d6:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
    15da:	e9cd 2304 	strd	r2, r3, [sp, #16]
				break;
    15de:	e7e8      	b.n	15b2 <z_cbvprintf_impl+0x1e6>
					(sint_value_type)va_arg(ap, intmax_t);
    15e0:	9b03      	ldr	r3, [sp, #12]
    15e2:	3307      	adds	r3, #7
    15e4:	f023 0307 	bic.w	r3, r3, #7
    15e8:	f103 0208 	add.w	r2, r3, #8
    15ec:	9203      	str	r2, [sp, #12]
    15ee:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
    15f2:	e9cd 2304 	strd	r2, r3, [sp, #16]
				break;
    15f6:	e7dc      	b.n	15b2 <z_cbvprintf_impl+0x1e6>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    15f8:	9b03      	ldr	r3, [sp, #12]
    15fa:	1d1a      	adds	r2, r3, #4
    15fc:	9203      	str	r2, [sp, #12]
    15fe:	681b      	ldr	r3, [r3, #0]
    1600:	17da      	asrs	r2, r3, #31
				value->sint =
    1602:	9304      	str	r3, [sp, #16]
    1604:	9205      	str	r2, [sp, #20]
				break;
    1606:	e7d4      	b.n	15b2 <z_cbvprintf_impl+0x1e6>
				value->sint = (signed char)value->sint;
    1608:	f99d 3010 	ldrsb.w	r3, [sp, #16]
    160c:	17da      	asrs	r2, r3, #31
    160e:	9304      	str	r3, [sp, #16]
    1610:	9205      	str	r2, [sp, #20]
    1612:	e732      	b.n	147a <z_cbvprintf_impl+0xae>
			switch (length_mod) {
    1614:	1ecb      	subs	r3, r1, #3
    1616:	2b04      	cmp	r3, #4
    1618:	d804      	bhi.n	1624 <z_cbvprintf_impl+0x258>
    161a:	e8df f003 	tbb	[pc, r3]
    161e:	1f0b      	.short	0x1f0b
    1620:	4135      	.short	0x4135
    1622:	41          	.byte	0x41
    1623:	00          	.byte	0x00
				value->uint = va_arg(ap, unsigned int);
    1624:	9b03      	ldr	r3, [sp, #12]
    1626:	1d1a      	adds	r2, r3, #4
    1628:	9203      	str	r2, [sp, #12]
    162a:	681b      	ldr	r3, [r3, #0]
    162c:	9304      	str	r3, [sp, #16]
    162e:	2300      	movs	r3, #0
    1630:	9305      	str	r3, [sp, #20]
				break;
    1632:	e01e      	b.n	1672 <z_cbvprintf_impl+0x2a6>
				    && (conv->specifier == 'c')) {
    1634:	f89d 301b 	ldrb.w	r3, [sp, #27]
				if ((!WCHAR_IS_SIGNED)
    1638:	2b63      	cmp	r3, #99	; 0x63
    163a:	d007      	beq.n	164c <z_cbvprintf_impl+0x280>
					value->uint = va_arg(ap, unsigned long);
    163c:	9b03      	ldr	r3, [sp, #12]
    163e:	1d1a      	adds	r2, r3, #4
    1640:	9203      	str	r2, [sp, #12]
    1642:	681b      	ldr	r3, [r3, #0]
    1644:	9304      	str	r3, [sp, #16]
    1646:	2300      	movs	r3, #0
    1648:	9305      	str	r3, [sp, #20]
    164a:	e012      	b.n	1672 <z_cbvprintf_impl+0x2a6>
					value->uint = (wchar_t)va_arg(ap,
    164c:	9b03      	ldr	r3, [sp, #12]
    164e:	1d1a      	adds	r2, r3, #4
    1650:	9203      	str	r2, [sp, #12]
    1652:	681b      	ldr	r3, [r3, #0]
    1654:	9304      	str	r3, [sp, #16]
    1656:	2300      	movs	r3, #0
    1658:	9305      	str	r3, [sp, #20]
    165a:	e00a      	b.n	1672 <z_cbvprintf_impl+0x2a6>
					(uint_value_type)va_arg(ap,
    165c:	9b03      	ldr	r3, [sp, #12]
    165e:	3307      	adds	r3, #7
    1660:	f023 0307 	bic.w	r3, r3, #7
    1664:	f103 0208 	add.w	r2, r3, #8
    1668:	9203      	str	r2, [sp, #12]
    166a:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
    166e:	e9cd 2304 	strd	r2, r3, [sp, #16]
			if (length_mod == LENGTH_HH) {
    1672:	2901      	cmp	r1, #1
    1674:	d01c      	beq.n	16b0 <z_cbvprintf_impl+0x2e4>
			} else if (length_mod == LENGTH_H) {
    1676:	2902      	cmp	r1, #2
    1678:	f47f aeff 	bne.w	147a <z_cbvprintf_impl+0xae>
				value->uint = (unsigned short)value->uint;
    167c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    1680:	9304      	str	r3, [sp, #16]
    1682:	2300      	movs	r3, #0
    1684:	9305      	str	r3, [sp, #20]
    1686:	e6f8      	b.n	147a <z_cbvprintf_impl+0xae>
					(uint_value_type)va_arg(ap,
    1688:	9b03      	ldr	r3, [sp, #12]
    168a:	3307      	adds	r3, #7
    168c:	f023 0307 	bic.w	r3, r3, #7
    1690:	f103 0208 	add.w	r2, r3, #8
    1694:	9203      	str	r2, [sp, #12]
    1696:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
    169a:	e9cd 2304 	strd	r2, r3, [sp, #16]
				break;
    169e:	e7e8      	b.n	1672 <z_cbvprintf_impl+0x2a6>
					(uint_value_type)va_arg(ap, size_t);
    16a0:	9b03      	ldr	r3, [sp, #12]
    16a2:	1d1a      	adds	r2, r3, #4
    16a4:	9203      	str	r2, [sp, #12]
    16a6:	681b      	ldr	r3, [r3, #0]
				value->uint =
    16a8:	9304      	str	r3, [sp, #16]
    16aa:	2300      	movs	r3, #0
    16ac:	9305      	str	r3, [sp, #20]
				break;
    16ae:	e7e0      	b.n	1672 <z_cbvprintf_impl+0x2a6>
				value->uint = (unsigned char)value->uint;
    16b0:	f89d 3010 	ldrb.w	r3, [sp, #16]
    16b4:	9304      	str	r3, [sp, #16]
    16b6:	2300      	movs	r3, #0
    16b8:	9305      	str	r3, [sp, #20]
    16ba:	e6de      	b.n	147a <z_cbvprintf_impl+0xae>
			if (length_mod == LENGTH_UPPER_L) {
    16bc:	2908      	cmp	r1, #8
    16be:	d00b      	beq.n	16d8 <z_cbvprintf_impl+0x30c>
				value->dbl = va_arg(ap, double);
    16c0:	9b03      	ldr	r3, [sp, #12]
    16c2:	3307      	adds	r3, #7
    16c4:	f023 0307 	bic.w	r3, r3, #7
    16c8:	f103 0208 	add.w	r2, r3, #8
    16cc:	9203      	str	r2, [sp, #12]
    16ce:	e9d3 2300 	ldrd	r2, r3, [r3]
    16d2:	e9cd 2304 	strd	r2, r3, [sp, #16]
    16d6:	e6d0      	b.n	147a <z_cbvprintf_impl+0xae>
				value->ldbl = va_arg(ap, long double);
    16d8:	9b03      	ldr	r3, [sp, #12]
    16da:	3307      	adds	r3, #7
    16dc:	f023 0307 	bic.w	r3, r3, #7
    16e0:	f103 0208 	add.w	r2, r3, #8
    16e4:	9203      	str	r2, [sp, #12]
    16e6:	e9d3 2300 	ldrd	r2, r3, [r3]
    16ea:	e9cd 2304 	strd	r2, r3, [sp, #16]
    16ee:	e6c4      	b.n	147a <z_cbvprintf_impl+0xae>
			value->ptr = va_arg(ap, void *);
    16f0:	9b03      	ldr	r3, [sp, #12]
    16f2:	1d1a      	adds	r2, r3, #4
    16f4:	9203      	str	r2, [sp, #12]
    16f6:	681b      	ldr	r3, [r3, #0]
    16f8:	9304      	str	r3, [sp, #16]
    16fa:	e6be      	b.n	147a <z_cbvprintf_impl+0xae>
			OUTS(sp, fp);
    16fc:	9f02      	ldr	r7, [sp, #8]
    16fe:	463b      	mov	r3, r7
    1700:	464a      	mov	r2, r9
    1702:	4629      	mov	r1, r5
    1704:	4630      	mov	r0, r6
    1706:	f014 fdb6 	bl	16276 <outs>
    170a:	2800      	cmp	r0, #0
    170c:	f2c0 8141 	blt.w	1992 <z_cbvprintf_impl+0x5c6>
    1710:	4404      	add	r4, r0
		fp = extract_conversion(conv, sp);
    1712:	46b9      	mov	r9, r7
			continue;
    1714:	e662      	b.n	13dc <z_cbvprintf_impl+0x10>
		case '%':
			OUTC('%');
    1716:	4629      	mov	r1, r5
    1718:	2025      	movs	r0, #37	; 0x25
    171a:	47b0      	blx	r6
    171c:	2800      	cmp	r0, #0
    171e:	f2c0 8138 	blt.w	1992 <z_cbvprintf_impl+0x5c6>
    1722:	3401      	adds	r4, #1
		char sign = 0;
    1724:	46d8      	mov	r8, fp
		const char *bpe = buf + sizeof(buf);
    1726:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
		const char *bps = NULL;
    172a:	f04f 0900 	mov.w	r9, #0
			break;
    172e:	e09b      	b.n	1868 <z_cbvprintf_impl+0x49c>
		case 's': {
			bps = (const char *)value->ptr;
    1730:	f8dd 9010 	ldr.w	r9, [sp, #16]

			size_t len;

			if (precision >= 0) {
    1734:	f1ba 0f00 	cmp.w	sl, #0
    1738:	db07      	blt.n	174a <z_cbvprintf_impl+0x37e>
				len = strnlen(bps, precision);
    173a:	4651      	mov	r1, sl
    173c:	4648      	mov	r0, r9
    173e:	f015 ffbd 	bl	176bc <strnlen>
			} else {
				len = strlen(bps);
			}

			bpe = bps + len;
    1742:	eb09 0a00 	add.w	sl, r9, r0
		char sign = 0;
    1746:	46d8      	mov	r8, fp
			precision = -1;

			break;
    1748:	e08e      	b.n	1868 <z_cbvprintf_impl+0x49c>
				len = strlen(bps);
    174a:	4648      	mov	r0, r9
    174c:	f015 ffad 	bl	176aa <strlen>
    1750:	e7f7      	b.n	1742 <z_cbvprintf_impl+0x376>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    1752:	9b04      	ldr	r3, [sp, #16]
    1754:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
		char sign = 0;
    1758:	46d8      	mov	r8, fp
			bpe = buf + 1;
    175a:	f10d 0a29 	add.w	sl, sp, #41	; 0x29
			bps = buf;
    175e:	f10d 0928 	add.w	r9, sp, #40	; 0x28
			break;
    1762:	e081      	b.n	1868 <z_cbvprintf_impl+0x49c>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
    1764:	f018 0f08 	tst.w	r8, #8
    1768:	d105      	bne.n	1776 <z_cbvprintf_impl+0x3aa>
				sign = '+';
			} else if (conv->flag_space) {
    176a:	f018 0810 	ands.w	r8, r8, #16
    176e:	d004      	beq.n	177a <z_cbvprintf_impl+0x3ae>
				sign = ' ';
    1770:	f04f 0820 	mov.w	r8, #32
    1774:	e001      	b.n	177a <z_cbvprintf_impl+0x3ae>
				sign = '+';
    1776:	f04f 082b 	mov.w	r8, #43	; 0x2b

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    177a:	9a04      	ldr	r2, [sp, #16]
    177c:	9b05      	ldr	r3, [sp, #20]
			if (sint < 0) {
    177e:	2b00      	cmp	r3, #0
    1780:	db02      	blt.n	1788 <z_cbvprintf_impl+0x3bc>
				sign = '-';
				value->uint = (uint_value_type)-sint;
			} else {
				value->uint = (uint_value_type)sint;
    1782:	9204      	str	r2, [sp, #16]
    1784:	9305      	str	r3, [sp, #20]
    1786:	e008      	b.n	179a <z_cbvprintf_impl+0x3ce>
				value->uint = (uint_value_type)-sint;
    1788:	4252      	negs	r2, r2
    178a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    178e:	9204      	str	r2, [sp, #16]
    1790:	9305      	str	r3, [sp, #20]
				sign = '-';
    1792:	f04f 082d 	mov.w	r8, #45	; 0x2d
    1796:	e000      	b.n	179a <z_cbvprintf_impl+0x3ce>
		switch (conv->specifier) {
    1798:	46d8      	mov	r8, fp
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    179a:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
    179e:	9300      	str	r3, [sp, #0]
    17a0:	ab0a      	add	r3, sp, #40	; 0x28
    17a2:	aa06      	add	r2, sp, #24
    17a4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    17a8:	f014 fcfb 	bl	161a2 <encode_uint>
    17ac:	4681      	mov	r9, r0
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    17ae:	f1ba 0f00 	cmp.w	sl, #0
    17b2:	f2c0 8088 	blt.w	18c6 <z_cbvprintf_impl+0x4fa>
				size_t len = bpe - bps;
    17b6:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
    17ba:	eba3 0309 	sub.w	r3, r3, r9

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
    17be:	f89d 2018 	ldrb.w	r2, [sp, #24]
    17c2:	f36f 1286 	bfc	r2, #6, #1
    17c6:	f88d 2018 	strb.w	r2, [sp, #24]

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    17ca:	459a      	cmp	sl, r3
    17cc:	d97e      	bls.n	18cc <z_cbvprintf_impl+0x500>
					conv->pad0_value = precision - (int)len;
    17ce:	ebaa 0303 	sub.w	r3, sl, r3
    17d2:	9307      	str	r3, [sp, #28]
		const char *bpe = buf + sizeof(buf);
    17d4:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
    17d8:	e046      	b.n	1868 <z_cbvprintf_impl+0x49c>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    17da:	9804      	ldr	r0, [sp, #16]
    17dc:	b928      	cbnz	r0, 17ea <z_cbvprintf_impl+0x41e>
		char sign = 0;
    17de:	46d8      	mov	r8, fp

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    17e0:	f8df a1b4 	ldr.w	sl, [pc, #436]	; 1998 <z_cbvprintf_impl+0x5cc>
			bps = "(nil)";
    17e4:	f1aa 0905 	sub.w	r9, sl, #5
    17e8:	e03e      	b.n	1868 <z_cbvprintf_impl+0x49c>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    17ea:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
    17ee:	9300      	str	r3, [sp, #0]
    17f0:	ab0a      	add	r3, sp, #40	; 0x28
    17f2:	aa06      	add	r2, sp, #24
    17f4:	2100      	movs	r1, #0
    17f6:	f014 fcd4 	bl	161a2 <encode_uint>
    17fa:	4681      	mov	r9, r0
				conv->altform_0c = true;
    17fc:	f89d 301a 	ldrb.w	r3, [sp, #26]
    1800:	f043 0310 	orr.w	r3, r3, #16
    1804:	f88d 301a 	strb.w	r3, [sp, #26]
				conv->specifier = 'x';
    1808:	2378      	movs	r3, #120	; 0x78
    180a:	f88d 301b 	strb.w	r3, [sp, #27]
		char sign = 0;
    180e:	46d8      	mov	r8, fp
				goto prec_int_pad0;
    1810:	e7cd      	b.n	17ae <z_cbvprintf_impl+0x3e2>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    1812:	9a04      	ldr	r2, [sp, #16]
	switch ((enum length_mod_enum)conv->length_mod) {
    1814:	f89d 3019 	ldrb.w	r3, [sp, #25]
    1818:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    181c:	2b07      	cmp	r3, #7
    181e:	d806      	bhi.n	182e <z_cbvprintf_impl+0x462>
    1820:	e8df f003 	tbb	[pc, r3]
    1824:	0f0d0b04 	.word	0x0f0d0b04
    1828:	1b191511 	.word	0x1b191511
		*(int *)dp = count;
    182c:	6014      	str	r4, [r2, #0]
		char sign = 0;
    182e:	46d8      	mov	r8, fp
		const char *bpe = buf + sizeof(buf);
    1830:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
		const char *bps = NULL;
    1834:	f04f 0900 	mov.w	r9, #0
}
    1838:	e016      	b.n	1868 <z_cbvprintf_impl+0x49c>
		*(signed char *)dp = (signed char)count;
    183a:	7014      	strb	r4, [r2, #0]
		break;
    183c:	e7f7      	b.n	182e <z_cbvprintf_impl+0x462>
		*(short *)dp = (short)count;
    183e:	8014      	strh	r4, [r2, #0]
		break;
    1840:	e7f5      	b.n	182e <z_cbvprintf_impl+0x462>
		*(long *)dp = (long)count;
    1842:	6014      	str	r4, [r2, #0]
		break;
    1844:	e7f3      	b.n	182e <z_cbvprintf_impl+0x462>
		*(long long *)dp = (long long)count;
    1846:	17e3      	asrs	r3, r4, #31
    1848:	6014      	str	r4, [r2, #0]
    184a:	6053      	str	r3, [r2, #4]
		break;
    184c:	e7ef      	b.n	182e <z_cbvprintf_impl+0x462>
		*(intmax_t *)dp = (intmax_t)count;
    184e:	17e3      	asrs	r3, r4, #31
    1850:	6014      	str	r4, [r2, #0]
    1852:	6053      	str	r3, [r2, #4]
		break;
    1854:	e7eb      	b.n	182e <z_cbvprintf_impl+0x462>
		*(size_t *)dp = (size_t)count;
    1856:	6014      	str	r4, [r2, #0]
		break;
    1858:	e7e9      	b.n	182e <z_cbvprintf_impl+0x462>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    185a:	6014      	str	r4, [r2, #0]
		break;
    185c:	e7e7      	b.n	182e <z_cbvprintf_impl+0x462>
		switch (conv->specifier) {
    185e:	46d8      	mov	r8, fp
    1860:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
    1864:	f04f 0900 	mov.w	r9, #0
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    1868:	f1b9 0f00 	cmp.w	r9, #0
    186c:	f000 808d 	beq.w	198a <z_cbvprintf_impl+0x5be>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    1870:	ebaa 0309 	sub.w	r3, sl, r9
		int pad_len = 0;

		if (sign != 0) {
    1874:	f1b8 0f00 	cmp.w	r8, #0
    1878:	d000      	beq.n	187c <z_cbvprintf_impl+0x4b0>
			nj_len += 1U;
    187a:	3301      	adds	r3, #1
		}

		if (conv->altform_0c) {
    187c:	f89d 201a 	ldrb.w	r2, [sp, #26]
    1880:	f012 0f10 	tst.w	r2, #16
    1884:	d025      	beq.n	18d2 <z_cbvprintf_impl+0x506>
			nj_len += 2U;
    1886:	3302      	adds	r3, #2
		} else if (conv->altform_0) {
			nj_len += 1U;
		}

		nj_len += conv->pad0_value;
    1888:	9907      	ldr	r1, [sp, #28]
    188a:	440b      	add	r3, r1
		if (conv->pad_fp) {
    188c:	f012 0f40 	tst.w	r2, #64	; 0x40
    1890:	d001      	beq.n	1896 <z_cbvprintf_impl+0x4ca>
			nj_len += conv->pad0_pre_exp;
    1892:	9a08      	ldr	r2, [sp, #32]
    1894:	4413      	add	r3, r2
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    1896:	2f00      	cmp	r7, #0
    1898:	dd31      	ble.n	18fe <z_cbvprintf_impl+0x532>
			width -= (int)nj_len;
    189a:	1aff      	subs	r7, r7, r3

			if (!conv->flag_dash) {
    189c:	f89d 3018 	ldrb.w	r3, [sp, #24]
    18a0:	f013 0f04 	tst.w	r3, #4
    18a4:	d12b      	bne.n	18fe <z_cbvprintf_impl+0x532>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    18a6:	f013 0f40 	tst.w	r3, #64	; 0x40
    18aa:	d017      	beq.n	18dc <z_cbvprintf_impl+0x510>
					if (sign != 0) {
    18ac:	f1b8 0f00 	cmp.w	r8, #0
    18b0:	d017      	beq.n	18e2 <z_cbvprintf_impl+0x516>
						OUTC(sign);
    18b2:	4629      	mov	r1, r5
    18b4:	4640      	mov	r0, r8
    18b6:	47b0      	blx	r6
    18b8:	2800      	cmp	r0, #0
    18ba:	db6a      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    18bc:	3401      	adds	r4, #1
						sign = 0;
    18be:	46d8      	mov	r8, fp
					}
					pad = '0';
    18c0:	f04f 0b30 	mov.w	fp, #48	; 0x30
    18c4:	e00f      	b.n	18e6 <z_cbvprintf_impl+0x51a>
		const char *bpe = buf + sizeof(buf);
    18c6:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
    18ca:	e7cd      	b.n	1868 <z_cbvprintf_impl+0x49c>
    18cc:	f10d 0a3e 	add.w	sl, sp, #62	; 0x3e
    18d0:	e7ca      	b.n	1868 <z_cbvprintf_impl+0x49c>
		} else if (conv->altform_0) {
    18d2:	f012 0f08 	tst.w	r2, #8
    18d6:	d0d7      	beq.n	1888 <z_cbvprintf_impl+0x4bc>
			nj_len += 1U;
    18d8:	3301      	adds	r3, #1
    18da:	e7d5      	b.n	1888 <z_cbvprintf_impl+0x4bc>
				char pad = ' ';
    18dc:	f04f 0b20 	mov.w	fp, #32
    18e0:	e001      	b.n	18e6 <z_cbvprintf_impl+0x51a>
					pad = '0';
    18e2:	f04f 0b30 	mov.w	fp, #48	; 0x30
    18e6:	463b      	mov	r3, r7
				}

				while (width-- > 0) {
    18e8:	1e5f      	subs	r7, r3, #1
    18ea:	2b00      	cmp	r3, #0
    18ec:	dd07      	ble.n	18fe <z_cbvprintf_impl+0x532>
					OUTC(pad);
    18ee:	4629      	mov	r1, r5
    18f0:	4658      	mov	r0, fp
    18f2:	47b0      	blx	r6
    18f4:	2800      	cmp	r0, #0
    18f6:	db4c      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    18f8:	3401      	adds	r4, #1
				while (width-- > 0) {
    18fa:	463b      	mov	r3, r7
    18fc:	e7f4      	b.n	18e8 <z_cbvprintf_impl+0x51c>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    18fe:	f1b8 0f00 	cmp.w	r8, #0
    1902:	d005      	beq.n	1910 <z_cbvprintf_impl+0x544>
			OUTC(sign);
    1904:	4629      	mov	r1, r5
    1906:	4640      	mov	r0, r8
    1908:	47b0      	blx	r6
    190a:	2800      	cmp	r0, #0
    190c:	db41      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    190e:	3401      	adds	r4, #1
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    1910:	f89d 301a 	ldrb.w	r3, [sp, #26]
    1914:	f3c3 1200 	ubfx	r2, r3, #4, #1
    1918:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    191c:	4313      	orrs	r3, r2
    191e:	d005      	beq.n	192c <z_cbvprintf_impl+0x560>
				OUTC('0');
    1920:	4629      	mov	r1, r5
    1922:	2030      	movs	r0, #48	; 0x30
    1924:	47b0      	blx	r6
    1926:	2800      	cmp	r0, #0
    1928:	db33      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    192a:	3401      	adds	r4, #1
			}

			if (conv->altform_0c) {
    192c:	f89d 301a 	ldrb.w	r3, [sp, #26]
    1930:	f013 0f10 	tst.w	r3, #16
    1934:	d006      	beq.n	1944 <z_cbvprintf_impl+0x578>
				OUTC(conv->specifier);
    1936:	4629      	mov	r1, r5
    1938:	f89d 001b 	ldrb.w	r0, [sp, #27]
    193c:	47b0      	blx	r6
    193e:	2800      	cmp	r0, #0
    1940:	db27      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    1942:	3401      	adds	r4, #1
			}

			pad_len = conv->pad0_value;
    1944:	9b07      	ldr	r3, [sp, #28]
			while (pad_len-- > 0) {
    1946:	f103 38ff 	add.w	r8, r3, #4294967295
    194a:	2b00      	cmp	r3, #0
    194c:	dd07      	ble.n	195e <z_cbvprintf_impl+0x592>
				OUTC('0');
    194e:	4629      	mov	r1, r5
    1950:	2030      	movs	r0, #48	; 0x30
    1952:	47b0      	blx	r6
    1954:	2800      	cmp	r0, #0
    1956:	db1c      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    1958:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
    195a:	4643      	mov	r3, r8
    195c:	e7f3      	b.n	1946 <z_cbvprintf_impl+0x57a>
			}

			OUTS(bps, bpe);
    195e:	4653      	mov	r3, sl
    1960:	464a      	mov	r2, r9
    1962:	4629      	mov	r1, r5
    1964:	4630      	mov	r0, r6
    1966:	f014 fc86 	bl	16276 <outs>
    196a:	2800      	cmp	r0, #0
    196c:	db11      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    196e:	4404      	add	r4, r0
		}

		/* Finish left justification */
		while (width > 0) {
    1970:	2f00      	cmp	r7, #0
    1972:	dd07      	ble.n	1984 <z_cbvprintf_impl+0x5b8>
			OUTC(' ');
    1974:	4629      	mov	r1, r5
    1976:	2020      	movs	r0, #32
    1978:	47b0      	blx	r6
    197a:	2800      	cmp	r0, #0
    197c:	db09      	blt.n	1992 <z_cbvprintf_impl+0x5c6>
    197e:	3401      	adds	r4, #1
			--width;
    1980:	3f01      	subs	r7, #1
    1982:	e7f5      	b.n	1970 <z_cbvprintf_impl+0x5a4>
		fp = extract_conversion(conv, sp);
    1984:	f8dd 9008 	ldr.w	r9, [sp, #8]
    1988:	e528      	b.n	13dc <z_cbvprintf_impl+0x10>
    198a:	f8dd 9008 	ldr.w	r9, [sp, #8]
    198e:	e525      	b.n	13dc <z_cbvprintf_impl+0x10>
		}
	}

	return count;
    1990:	4620      	mov	r0, r4
#undef OUTS
#undef OUTC
}
    1992:	b011      	add	sp, #68	; 0x44
    1994:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1998:	0001d3e5 	.word	0x0001d3e5

0000199c <sys_reboot>:
#include <zephyr/sys/printk.h>

extern void sys_arch_reboot(int type);

FUNC_NORETURN void sys_reboot(int type)
{
    199c:	b508      	push	{r3, lr}
    199e:	f04f 0220 	mov.w	r2, #32
    19a2:	f3ef 8311 	mrs	r3, BASEPRI
    19a6:	f382 8812 	msr	BASEPRI_MAX, r2
    19aa:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
	sys_clock_disable();

	sys_arch_reboot(type);
    19ae:	f003 fb59 	bl	5064 <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
    19b2:	4803      	ldr	r0, [pc, #12]	; (19c0 <sys_reboot+0x24>)
    19b4:	f013 fea3 	bl	156fe <printk>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    19b8:	f002 f9ea 	bl	3d90 <arch_cpu_idle>
    19bc:	e7fc      	b.n	19b8 <sys_reboot+0x1c>
    19be:	bf00      	nop
    19c0:	0001d3e8 	.word	0x0001d3e8

000019c4 <nordicsemi_nrf53_init>:
    19c4:	f04f 0320 	mov.w	r3, #32
    19c8:	f3ef 8c11 	mrs	ip, BASEPRI
    19cc:	f383 8812 	msr	BASEPRI_MAX, r3
    19d0:	f3bf 8f6f 	isb	sy

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_cache_enable(NRF_CACHE_Type * p_reg)
{
    p_reg->ENABLE = CACHE_ENABLE_ENABLE_Enabled;
    19d4:	2101      	movs	r1, #1
    19d6:	4b1e      	ldr	r3, [pc, #120]	; (1a50 <nordicsemi_nrf53_init+0x8c>)
    19d8:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
    19dc:	4a1d      	ldr	r2, [pc, #116]	; (1a54 <nordicsemi_nrf53_init+0x90>)
    19de:	2302      	movs	r3, #2
    19e0:	f8c2 36d0 	str.w	r3, [r2, #1744]	; 0x6d0

#if NRF_GPIO_HAS_SEL
NRF_STATIC_INLINE void nrf_gpio_pin_control_select(uint32_t pin_number, nrf_gpio_pin_sel_t ctrl)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    19e4:	481c      	ldr	r0, [pc, #112]	; (1a58 <nordicsemi_nrf53_init+0x94>)
    19e6:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    19ea:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_MCUSEL_Pos);
    19ee:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
    19f2:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    19f6:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
    19fa:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_MCUSEL_Pos);
    19fe:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
    1a02:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
NRF_STATIC_INLINE void nrf_regulators_dcdcen_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
#if defined(REGULATORS_DCDCEN_DCDCEN_Msk)
    p_reg->DCDCEN = (enable ? REGULATORS_DCDCEN_DCDCEN_Msk : 0);
#else
    p_reg->VREGMAIN.DCDCEN = (enable ? REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk : 0);
    1a06:	f8c2 1704 	str.w	r1, [r2, #1796]	; 0x704
#endif

#if NRF_REGULATORS_HAS_DCDCEN_RADIO
NRF_STATIC_INLINE void nrf_regulators_dcdcen_radio_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.DCDCEN = (enable) ? REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled :
    1a0a:	f8c2 1904 	str.w	r1, [r2, #2308]	; 0x904
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
    1a0e:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
#if defined(NRF_GPIO_FORWARDER_FOR_NRF5340_CPUAPP_ENABLED)
	static const uint8_t forwarded_psels[] = {
		DT_FOREACH_STATUS_OKAY(nordic_nrf_gpio_forwarder, ALL_GPIOS_IN_FORWARDER)
	};

	for (int i = 0; i < ARRAY_SIZE(forwarded_psels); i++) {
    1a12:	2100      	movs	r1, #0
    1a14:	e00a      	b.n	1a2c <nordicsemi_nrf53_init+0x68>
        case 1: return NRF_P1;
    1a16:	4811      	ldr	r0, [pc, #68]	; (1a5c <nordicsemi_nrf53_init+0x98>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    1a18:	3280      	adds	r2, #128	; 0x80
    1a1a:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
    1a1e:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (ctrl << GPIO_PIN_CNF_MCUSEL_Pos);
    1a22:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    1a26:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
    1a2a:	3101      	adds	r1, #1
    1a2c:	2903      	cmp	r1, #3
    1a2e:	d808      	bhi.n	1a42 <nordicsemi_nrf53_init+0x7e>
		soc_secure_gpio_pin_mcu_select(forwarded_psels[i], NRF_GPIO_PIN_SEL_NETWORK);
    1a30:	4b0b      	ldr	r3, [pc, #44]	; (1a60 <nordicsemi_nrf53_init+0x9c>)
    1a32:	5c5b      	ldrb	r3, [r3, r1]
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    1a34:	f003 021f 	and.w	r2, r3, #31

    return pin_number >> 5;
    1a38:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    1a3a:	2b01      	cmp	r3, #1
    1a3c:	d0eb      	beq.n	1a16 <nordicsemi_nrf53_init+0x52>
        case 0: return NRF_P0;
    1a3e:	4806      	ldr	r0, [pc, #24]	; (1a58 <nordicsemi_nrf53_init+0x94>)
    1a40:	e7ea      	b.n	1a18 <nordicsemi_nrf53_init+0x54>
	__asm__ volatile(
    1a42:	f38c 8811 	msr	BASEPRI, ip
    1a46:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    1a4a:	2000      	movs	r0, #0
    1a4c:	4770      	bx	lr
    1a4e:	bf00      	nop
    1a50:	50001000 	.word	0x50001000
    1a54:	50004000 	.word	0x50004000
    1a58:	50842500 	.word	0x50842500
    1a5c:	50842800 	.word	0x50842800
    1a60:	0001d418 	.word	0x0001d418

00001a64 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    1a64:	b170      	cbz	r0, 1a84 <arch_busy_wait+0x20>

void arch_busy_wait(uint32_t time_us)
{
    1a66:	b508      	push	{r3, lr}
    1a68:	4602      	mov	r2, r0

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    1a6a:	4b07      	ldr	r3, [pc, #28]	; (1a88 <arch_busy_wait+0x24>)
    1a6c:	681b      	ldr	r3, [r3, #0]
    1a6e:	4807      	ldr	r0, [pc, #28]	; (1a8c <arch_busy_wait+0x28>)
    1a70:	fba0 1303 	umull	r1, r3, r0, r3
    1a74:	0c9b      	lsrs	r3, r3, #18
    delay_cycles(cycles);
    1a76:	fb03 f002 	mul.w	r0, r3, r2
    1a7a:	4b05      	ldr	r3, [pc, #20]	; (1a90 <arch_busy_wait+0x2c>)
    1a7c:	f043 0301 	orr.w	r3, r3, #1
    1a80:	4798      	blx	r3
	nrfx_coredep_delay_us(time_us);
}
    1a82:	bd08      	pop	{r3, pc}
    1a84:	4770      	bx	lr
    1a86:	bf00      	nop
    1a88:	20000424 	.word	0x20000424
    1a8c:	431bde83 	.word	0x431bde83
    1a90:	0001d1f0 	.word	0x0001d1f0

00001a94 <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
    1a94:	2806      	cmp	r0, #6
    1a96:	d000      	beq.n	1a9a <pm_state_set+0x6>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
    1a98:	4770      	bx	lr
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
    1a9a:	4b04      	ldr	r3, [pc, #16]	; (1aac <pm_state_set+0x18>)
    1a9c:	2201      	movs	r2, #1
    1a9e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    1aa2:	f3bf 8f4f 	dsb	sy
        __WFE();
    1aa6:	bf20      	wfe
    while (true)
    1aa8:	e7fd      	b.n	1aa6 <pm_state_set+0x12>
    1aaa:	bf00      	nop
    1aac:	50004000 	.word	0x50004000

00001ab0 <mbox_rx_init>:

	remote_callback(user_data);
}

static int mbox_rx_init(void *user_data)
{
    1ab0:	b510      	push	{r4, lr}
    1ab2:	b082      	sub	sp, #8
    1ab4:	4603      	mov	r3, r0
 * @param ch_id Channel ID
 */
static inline void mbox_init_channel(struct mbox_channel *channel, const struct device *dev,
				     uint32_t ch_id)
{
	channel->dev = dev;
    1ab6:	480d      	ldr	r0, [pc, #52]	; (1aec <mbox_rx_init+0x3c>)
    1ab8:	9000      	str	r0, [sp, #0]
	channel->id = ch_id;
    1aba:	2208      	movs	r2, #8
    1abc:	9201      	str	r2, [sp, #4]
 */
static inline int mbox_register_callback(const struct mbox_channel *channel,
					 mbox_callback_t cb,
					 void *user_data)
{
	const struct mbox_driver_api *api =
    1abe:	6882      	ldr	r2, [r0, #8]
		(const struct mbox_driver_api *)channel->dev->api;

	if (api->register_callback == NULL) {
    1ac0:	6854      	ldr	r4, [r2, #4]
    1ac2:	b16c      	cbz	r4, 1ae0 <mbox_rx_init+0x30>
		return -ENOSYS;
	}

	return api->register_callback(channel->dev, channel->id, cb, user_data);
    1ac4:	4a0a      	ldr	r2, [pc, #40]	; (1af0 <mbox_rx_init+0x40>)
    1ac6:	2108      	movs	r1, #8
    1ac8:	47a0      	blx	r4
	}

	mbox_init_channel(&channel, dev, CONFIG_NRF53_SYNC_RTC_IPM_IN);

	err = mbox_register_callback(&channel, mbox_callback, user_data);
	if (err < 0) {
    1aca:	2800      	cmp	r0, #0
    1acc:	db06      	blt.n	1adc <mbox_rx_init+0x2c>
__syscall int mbox_set_enabled(const struct mbox_channel *channel, bool enable);

static inline int z_impl_mbox_set_enabled(const struct mbox_channel *channel, bool enable)
{
	const struct mbox_driver_api *api =
		(const struct mbox_driver_api *)channel->dev->api;
    1ace:	9800      	ldr	r0, [sp, #0]
	const struct mbox_driver_api *api =
    1ad0:	6883      	ldr	r3, [r0, #8]

	if (api->set_enabled == NULL) {
    1ad2:	691b      	ldr	r3, [r3, #16]
    1ad4:	b13b      	cbz	r3, 1ae6 <mbox_rx_init+0x36>
		return -ENOSYS;
	}

	return api->set_enabled(channel->dev, channel->id, enable);
    1ad6:	2201      	movs	r2, #1
    1ad8:	9901      	ldr	r1, [sp, #4]
    1ada:	4798      	blx	r3
		return err;
	}

	return mbox_set_enabled(&channel, true);
}
    1adc:	b002      	add	sp, #8
    1ade:	bd10      	pop	{r4, pc}
		return -ENOSYS;
    1ae0:	f06f 0057 	mvn.w	r0, #87	; 0x57
    1ae4:	e7f1      	b.n	1aca <mbox_rx_init+0x1a>
		return -ENOSYS;
    1ae6:	f06f 0057 	mvn.w	r0, #87	; 0x57
	return mbox_set_enabled(&channel, true);
    1aea:	e7f7      	b.n	1adc <mbox_rx_init+0x2c>
    1aec:	0001cca4 	.word	0x0001cca4
    1af0:	00016809 	.word	0x00016809

00001af4 <free_resources>:
{
    1af4:	b510      	push	{r4, lr}
	nrfx_gppi_channels_disable(BIT(channels.ch.ppi));
    1af6:	b2c4      	uxtb	r4, r0
    1af8:	2301      	movs	r3, #1
    1afa:	40a3      	lsls	r3, r4
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_dppi_channels_disable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
    1afc:	4a05      	ldr	r2, [pc, #20]	; (1b14 <free_resources+0x20>)
    1afe:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
	z_nrf_rtc_timer_chan_free(channels.ch.rtc);
    1b02:	f3c0 2007 	ubfx	r0, r0, #8, #8
    1b06:	f00e fd63 	bl	105d0 <z_nrf_rtc_timer_chan_free>
	err = nrfx_dppi_channel_free(channels.ch.ppi);
    1b0a:	4620      	mov	r0, r4
    1b0c:	f00f fbf8 	bl	11300 <nrfx_dppi_channel_free>
}
    1b10:	bd10      	pop	{r4, pc}
    1b12:	bf00      	nop
    1b14:	50017000 	.word	0x50017000

00001b18 <ppi_rtc_to_ipc>:
{
    1b18:	b538      	push	{r3, r4, r5, lr}
    1b1a:	4604      	mov	r4, r0
    1b1c:	460d      	mov	r5, r1
	uint32_t evt_addr = z_nrf_rtc_timer_compare_evt_address_get(channels.ch.rtc);
    1b1e:	f3c0 2007 	ubfx	r0, r0, #8, #8
    1b22:	f00e fbfb 	bl	1031c <z_nrf_rtc_timer_compare_evt_address_get>
	nrf_ipc_task_t ipc_task = nrf_ipc_send_task_get(channels.ch.ipc_out);
    1b26:	f3c4 4307 	ubfx	r3, r4, #16, #8
}

NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_task_t)(NRFX_OFFSETOF(NRF_IPC_Type, TASKS_SEND[index]));
    1b2a:	009b      	lsls	r3, r3, #2
    1b2c:	b2db      	uxtb	r3, r3
	if (setup) {
    1b2e:	b13d      	cbz	r5, 1b40 <ppi_rtc_to_ipc+0x28>
		nrf_ipc_subscribe_set(NRF_IPC, ipc_task, channels.ch.ppi);
    1b30:	b2e4      	uxtb	r4, r4
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
    1b32:	4a06      	ldr	r2, [pc, #24]	; (1b4c <ppi_rtc_to_ipc+0x34>)
            ((uint32_t)channel | IPC_SUBSCRIBE_SEND_EN_Msk);
    1b34:	f044 4400 	orr.w	r4, r4, #2147483648	; 0x80000000
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
    1b38:	50d4      	str	r4, [r2, r3]
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    1b3a:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80
}
    1b3e:	bd38      	pop	{r3, r4, r5, pc}

__STATIC_INLINE void nrfx_gppi_event_endpoint_clear(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    (void)channel;
    *((volatile uint32_t *)(eep + 0x80uL)) = 0;
    1b40:	2100      	movs	r1, #0
    1b42:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
    1b46:	4a01      	ldr	r2, [pc, #4]	; (1b4c <ppi_rtc_to_ipc+0x34>)
    1b48:	50d1      	str	r1, [r2, r3]
    1b4a:	e7f8      	b.n	1b3e <ppi_rtc_to_ipc+0x26>
    1b4c:	5002a080 	.word	0x5002a080

00001b50 <ppi_ipc_to_rtc>:
{
    1b50:	b570      	push	{r4, r5, r6, lr}
    1b52:	4605      	mov	r5, r0
    1b54:	460e      	mov	r6, r1
	nrf_ipc_event_t ipc_evt = nrf_ipc_receive_event_get(channels.ch.ipc_in);
    1b56:	0e04      	lsrs	r4, r0, #24
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
    1b58:	00a4      	lsls	r4, r4, #2
    1b5a:	f504 7480 	add.w	r4, r4, #256	; 0x100
	uint32_t task_addr = z_nrf_rtc_timer_capture_task_address_get(channels.ch.rtc);
    1b5e:	f3c0 2007 	ubfx	r0, r0, #8, #8
    1b62:	f019 f87e 	bl	1ac62 <z_nrf_rtc_timer_capture_task_address_get>
	if (setup) {
    1b66:	b146      	cbz	r6, 1b7a <ppi_ipc_to_rtc+0x2a>
		nrfx_gppi_task_endpoint_setup(channels.ch.ppi, task_addr);
    1b68:	b2ed      	uxtb	r5, r5
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    1b6a:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
    1b6e:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
    1b72:	b2a4      	uxth	r4, r4
    1b74:	4b04      	ldr	r3, [pc, #16]	; (1b88 <ppi_ipc_to_rtc+0x38>)
    1b76:	511d      	str	r5, [r3, r4]
}
    1b78:	bd70      	pop	{r4, r5, r6, pc}

__STATIC_INLINE void nrfx_gppi_task_endpoint_clear(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    (void)channel;
    *((volatile uint32_t *)(tep + 0x80uL)) = 0;
    1b7a:	2200      	movs	r2, #0
    1b7c:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
    *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
    1b80:	b2a4      	uxth	r4, r4
    1b82:	4b01      	ldr	r3, [pc, #4]	; (1b88 <ppi_ipc_to_rtc+0x38>)
    1b84:	511a      	str	r2, [r3, r4]
    1b86:	e7f7      	b.n	1b78 <ppi_ipc_to_rtc+0x28>
    1b88:	5002a080 	.word	0x5002a080

00001b8c <remote_callback>:
{
    1b8c:	b570      	push	{r4, r5, r6, lr}
    1b8e:	b082      	sub	sp, #8
    1b90:	4604      	mov	r4, r0
	cc = z_nrf_rtc_timer_compare_read(channels.ch.rtc);
    1b92:	f3c0 2607 	ubfx	r6, r0, #8, #8
    1b96:	4630      	mov	r0, r6
    1b98:	f00e fbc8 	bl	1032c <z_nrf_rtc_timer_compare_read>
    1b9c:	4605      	mov	r5, r0
	ppi_ipc_to_rtc(channels, false);
    1b9e:	2100      	movs	r1, #0
    1ba0:	4620      	mov	r0, r4
    1ba2:	f7ff ffd5 	bl	1b50 <ppi_ipc_to_rtc>
		ppi_rtc_to_ipc(channels, true);
    1ba6:	2101      	movs	r1, #1
    1ba8:	4620      	mov	r0, r4
    1baa:	f7ff ffb5 	bl	1b18 <ppi_rtc_to_ipc>
		z_nrf_rtc_timer_set(channels.ch.rtc, cc + cc + RTC_SYNC_ARBITRARY_DELAY,
    1bae:	f105 0232 	add.w	r2, r5, #50	; 0x32
    1bb2:	9401      	str	r4, [sp, #4]
    1bb4:	4b04      	ldr	r3, [pc, #16]	; (1bc8 <remote_callback+0x3c>)
    1bb6:	9300      	str	r3, [sp, #0]
    1bb8:	0052      	lsls	r2, r2, #1
    1bba:	2300      	movs	r3, #0
    1bbc:	4630      	mov	r0, r6
    1bbe:	f019 f874 	bl	1acaa <z_nrf_rtc_timer_set>
}
    1bc2:	b002      	add	sp, #8
    1bc4:	bd70      	pop	{r4, r5, r6, pc}
    1bc6:	bf00      	nop
    1bc8:	000167f5 	.word	0x000167f5

00001bcc <sync_rtc_setup>:
	return ipm_set_enabled(ipm_dev, true);
}

/* Setup RTC synchronization. */
static int sync_rtc_setup(const struct device *unused)
{
    1bcc:	b5b0      	push	{r4, r5, r7, lr}
    1bce:	b082      	sub	sp, #8
    1bd0:	af00      	add	r7, sp, #0
	nrfx_err_t err;
	union rtc_sync_channels channels;
	int32_t sync_rtc_ch;
	int rv;

	err = nrfx_dppi_channel_alloc(&channels.ch.ppi);
    1bd2:	1d38      	adds	r0, r7, #4
    1bd4:	f00f fb8c 	bl	112f0 <nrfx_dppi_channel_alloc>
	if (err != NRFX_SUCCESS) {
    1bd8:	4b31      	ldr	r3, [pc, #196]	; (1ca0 <sync_rtc_setup+0xd4>)
    1bda:	4298      	cmp	r0, r3
    1bdc:	d03b      	beq.n	1c56 <sync_rtc_setup+0x8a>
		rv = -ENODEV;
    1bde:	f06f 0412 	mvn.w	r4, #18
		irq_unlock(key);
	}

bail:
	if (rv != 0) {
		LOG_ERR("Failed synchronized RTC setup (err: %d)", rv);
    1be2:	466d      	mov	r5, sp
    1be4:	b088      	sub	sp, #32
    1be6:	466b      	mov	r3, sp
    1be8:	f113 0210 	adds.w	r2, r3, #16
    1bec:	d052      	beq.n	1c94 <sync_rtc_setup+0xc8>
    1bee:	210c      	movs	r1, #12
    1bf0:	b11a      	cbz	r2, 1bfa <sync_rtc_setup+0x2e>
    1bf2:	2904      	cmp	r1, #4
    1bf4:	dd01      	ble.n	1bfa <sync_rtc_setup+0x2e>
    1bf6:	482b      	ldr	r0, [pc, #172]	; (1ca4 <sync_rtc_setup+0xd8>)
    1bf8:	6158      	str	r0, [r3, #20]
    1bfa:	b112      	cbz	r2, 1c02 <sync_rtc_setup+0x36>
    1bfc:	2908      	cmp	r1, #8
    1bfe:	dd00      	ble.n	1c02 <sync_rtc_setup+0x36>
    1c00:	619c      	str	r4, [r3, #24]
    1c02:	290b      	cmp	r1, #11
    1c04:	dd49      	ble.n	1c9a <sync_rtc_setup+0xce>
    1c06:	f04f 0c0c 	mov.w	ip, #12
    1c0a:	b13a      	cbz	r2, 1c1c <sync_rtc_setup+0x50>
    1c0c:	2103      	movs	r1, #3
    1c0e:	7039      	strb	r1, [r7, #0]
    1c10:	2100      	movs	r1, #0
    1c12:	7079      	strb	r1, [r7, #1]
    1c14:	70b9      	strb	r1, [r7, #2]
    1c16:	70f9      	strb	r1, [r7, #3]
    1c18:	6838      	ldr	r0, [r7, #0]
    1c1a:	6118      	str	r0, [r3, #16]
    1c1c:	2100      	movs	r1, #0
    1c1e:	f36f 0100 	bfc	r1, #0, #1
    1c22:	f36f 0141 	bfc	r1, #1, #1
    1c26:	f36f 0182 	bfc	r1, #2, #1
    1c2a:	f36f 01c5 	bfc	r1, #3, #3
    1c2e:	2301      	movs	r3, #1
    1c30:	f363 1188 	bfi	r1, r3, #6, #3
    1c34:	f40c 737b 	and.w	r3, ip, #1004	; 0x3ec
    1c38:	f363 2152 	bfi	r1, r3, #9, #10
    1c3c:	f36f 41de 	bfc	r1, #19, #12
    1c40:	f36f 71df 	bfc	r1, #31, #1
    1c44:	2300      	movs	r3, #0
    1c46:	4818      	ldr	r0, [pc, #96]	; (1ca8 <sync_rtc_setup+0xdc>)
    1c48:	f000 fafe 	bl	2248 <z_impl_z_log_msg_static_create>
    1c4c:	46ad      	mov	sp, r5
	}

	return rv;
}
    1c4e:	4620      	mov	r0, r4
    1c50:	3708      	adds	r7, #8
    1c52:	46bd      	mov	sp, r7
    1c54:	bdb0      	pop	{r4, r5, r7, pc}
	sync_rtc_ch = z_nrf_rtc_timer_chan_alloc();
    1c56:	f00e fc89 	bl	1056c <z_nrf_rtc_timer_chan_alloc>
	if (sync_rtc_ch < 0) {
    1c5a:	1e04      	subs	r4, r0, #0
    1c5c:	db16      	blt.n	1c8c <sync_rtc_setup+0xc0>
	channels.ch.rtc = (uint8_t)sync_rtc_ch;
    1c5e:	717c      	strb	r4, [r7, #5]
	channels.ch.ipc_out = CONFIG_NRF53_SYNC_RTC_IPM_OUT;
    1c60:	2307      	movs	r3, #7
    1c62:	71bb      	strb	r3, [r7, #6]
	channels.ch.ipc_in = CONFIG_NRF53_SYNC_RTC_IPM_IN;
    1c64:	2308      	movs	r3, #8
    1c66:	71fb      	strb	r3, [r7, #7]
	rv = IS_ENABLED(CONFIG_MBOX) ? mbox_rx_init((void *)channels.raw) :
    1c68:	6878      	ldr	r0, [r7, #4]
    1c6a:	f7ff ff21 	bl	1ab0 <mbox_rx_init>
	if (rv < 0) {
    1c6e:	1e04      	subs	r4, r0, #0
    1c70:	db09      	blt.n	1c86 <sync_rtc_setup+0xba>
	nrfx_gppi_channels_enable(BIT(channels.ch.ppi));
    1c72:	793b      	ldrb	r3, [r7, #4]
    1c74:	2101      	movs	r1, #1
    1c76:	fa01 f303 	lsl.w	r3, r1, r3
    p_reg->CHENSET = mask;
    1c7a:	4a0c      	ldr	r2, [pc, #48]	; (1cac <sync_rtc_setup+0xe0>)
    1c7c:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
		ppi_ipc_to_rtc(channels, true);
    1c80:	6878      	ldr	r0, [r7, #4]
    1c82:	f7ff ff65 	bl	1b50 <ppi_ipc_to_rtc>
	if (rv != 0) {
    1c86:	2c00      	cmp	r4, #0
    1c88:	d0e1      	beq.n	1c4e <sync_rtc_setup+0x82>
    1c8a:	e7aa      	b.n	1be2 <sync_rtc_setup+0x16>
		nrfx_dppi_channel_free(channels.ch.ppi);
    1c8c:	7938      	ldrb	r0, [r7, #4]
    1c8e:	f00f fb37 	bl	11300 <nrfx_dppi_channel_free>
		goto bail;
    1c92:	e7f8      	b.n	1c86 <sync_rtc_setup+0xba>
		LOG_ERR("Failed synchronized RTC setup (err: %d)", rv);
    1c94:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    1c98:	e7aa      	b.n	1bf0 <sync_rtc_setup+0x24>
    1c9a:	f06f 0c1b 	mvn.w	ip, #27
    1c9e:	e7b4      	b.n	1c0a <sync_rtc_setup+0x3e>
    1ca0:	0bad0000 	.word	0x0bad0000
    1ca4:	0001d41c 	.word	0x0001d41c
    1ca8:	0001d0ac 	.word	0x0001d0ac
    1cac:	50017000 	.word	0x50017000

00001cb0 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    1cb0:	f00f b910 	b.w	10ed4 <SystemInit>

00001cb4 <msg_process>:

	return (level <= backend_level);
}

static void msg_process(union log_msg_generic *msg)
{
    1cb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1cb6:	4606      	mov	r6, r0
	struct log_backend const *backend;

	for (int i = 0; i < log_backend_count_get(); i++) {
    1cb8:	2400      	movs	r4, #0
    1cba:	e000      	b.n	1cbe <msg_process+0xa>
    1cbc:	3401      	adds	r4, #1
    1cbe:	4b0e      	ldr	r3, [pc, #56]	; (1cf8 <msg_process+0x44>)
    1cc0:	4a0e      	ldr	r2, [pc, #56]	; (1cfc <msg_process+0x48>)
    1cc2:	1a9b      	subs	r3, r3, r2
    1cc4:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1cc8:	da14      	bge.n	1cf4 <msg_process+0x40>
 *
 * @return    Pointer to the backend instance.
 */
static inline const struct log_backend *log_backend_get(uint32_t idx)
{
	return &__log_backends_start[idx];
    1cca:	4d0c      	ldr	r5, [pc, #48]	; (1cfc <msg_process+0x48>)
    1ccc:	eb05 1504 	add.w	r5, r5, r4, lsl #4
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    1cd0:	686b      	ldr	r3, [r5, #4]
    1cd2:	795b      	ldrb	r3, [r3, #5]
		backend = log_backend_get(i);
		if (log_backend_is_active(backend) &&
    1cd4:	2b00      	cmp	r3, #0
    1cd6:	d0f1      	beq.n	1cbc <msg_process+0x8>
		    msg_filter_check(backend, msg)) {
    1cd8:	4631      	mov	r1, r6
    1cda:	4628      	mov	r0, r5
    1cdc:	f014 fdb8 	bl	16850 <msg_filter_check>
		if (log_backend_is_active(backend) &&
    1ce0:	2800      	cmp	r0, #0
    1ce2:	d0eb      	beq.n	1cbc <msg_process+0x8>
	backend->api->process(backend, msg);
    1ce4:	0127      	lsls	r7, r4, #4
    1ce6:	4b05      	ldr	r3, [pc, #20]	; (1cfc <msg_process+0x48>)
    1ce8:	59db      	ldr	r3, [r3, r7]
    1cea:	681b      	ldr	r3, [r3, #0]
    1cec:	4631      	mov	r1, r6
    1cee:	4628      	mov	r0, r5
    1cf0:	4798      	blx	r3
}
    1cf2:	e7e3      	b.n	1cbc <msg_process+0x8>
			log_backend_msg_process(backend, msg);
		}
	}
}
    1cf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1cf6:	bf00      	nop
    1cf8:	0001d0d4 	.word	0x0001d0d4
    1cfc:	0001d0c4 	.word	0x0001d0c4

00001d00 <log_backend_notify_all>:
	return mpsc_pbuf_get_max_utilization(&log_buffer, max);
}

static void log_backend_notify_all(enum log_backend_evt event,
				   union log_backend_evt_arg *arg)
{
    1d00:	b570      	push	{r4, r5, r6, lr}
    1d02:	4606      	mov	r6, r0
    1d04:	460d      	mov	r5, r1
	for (int i = 0; i < log_backend_count_get(); i++) {
    1d06:	2400      	movs	r4, #0
    1d08:	e003      	b.n	1d12 <log_backend_notify_all+0x12>
				      union log_backend_evt_arg *arg)
{
	__ASSERT_NO_MSG(backend != NULL);

	if (backend->api->notify) {
		backend->api->notify(backend, event, arg);
    1d0a:	462a      	mov	r2, r5
    1d0c:	4631      	mov	r1, r6
    1d0e:	4798      	blx	r3
    1d10:	3401      	adds	r4, #1
    1d12:	4b08      	ldr	r3, [pc, #32]	; (1d34 <log_backend_notify_all+0x34>)
    1d14:	4a08      	ldr	r2, [pc, #32]	; (1d38 <log_backend_notify_all+0x38>)
    1d16:	1a9b      	subs	r3, r3, r2
    1d18:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1d1c:	da08      	bge.n	1d30 <log_backend_notify_all+0x30>
	return &__log_backends_start[idx];
    1d1e:	0123      	lsls	r3, r4, #4
    1d20:	4a05      	ldr	r2, [pc, #20]	; (1d38 <log_backend_notify_all+0x38>)
    1d22:	eb02 1004 	add.w	r0, r2, r4, lsl #4
	if (backend->api->notify) {
    1d26:	589b      	ldr	r3, [r3, r2]
    1d28:	699b      	ldr	r3, [r3, #24]
    1d2a:	2b00      	cmp	r3, #0
    1d2c:	d1ed      	bne.n	1d0a <log_backend_notify_all+0xa>
    1d2e:	e7ef      	b.n	1d10 <log_backend_notify_all+0x10>
		const struct log_backend *backend = log_backend_get(i);

		log_backend_notify(backend, event, arg);
	}
}
    1d30:	bd70      	pop	{r4, r5, r6, pc}
    1d32:	bf00      	nop
    1d34:	0001d0d4 	.word	0x0001d0d4
    1d38:	0001d0c4 	.word	0x0001d0c4

00001d3c <activate_foreach_backend>:
{
    1d3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1d40:	4607      	mov	r7, r0
	uint32_t mask_cpy = mask;
    1d42:	4605      	mov	r5, r0
	while (mask_cpy) {
    1d44:	e00a      	b.n	1d5c <activate_foreach_backend+0x20>
			mask &= ~BIT(i);
    1d46:	ea07 0708 	and.w	r7, r7, r8
					   backend->cb->ctx,
    1d4a:	4b14      	ldr	r3, [pc, #80]	; (1d9c <activate_foreach_backend+0x60>)
    1d4c:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    1d50:	6873      	ldr	r3, [r6, #4]
			log_backend_enable(backend,
    1d52:	2204      	movs	r2, #4
    1d54:	6819      	ldr	r1, [r3, #0]
    1d56:	4620      	mov	r0, r4
    1d58:	f000 fa64 	bl	2224 <log_backend_enable>
	while (mask_cpy) {
    1d5c:	b1d5      	cbz	r5, 1d94 <activate_foreach_backend+0x58>
		uint32_t i = __builtin_ctz(mask_cpy);
    1d5e:	fa95 f6a5 	rbit	r6, r5
    1d62:	fab6 f686 	clz	r6, r6
	return &__log_backends_start[idx];
    1d66:	4c0d      	ldr	r4, [pc, #52]	; (1d9c <activate_foreach_backend+0x60>)
    1d68:	eb04 1406 	add.w	r4, r4, r6, lsl #4
		mask_cpy &= ~BIT(i);
    1d6c:	2301      	movs	r3, #1
    1d6e:	40b3      	lsls	r3, r6
    1d70:	ea6f 0803 	mvn.w	r8, r3
    1d74:	ea25 0503 	bic.w	r5, r5, r3
		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
    1d78:	7b23      	ldrb	r3, [r4, #12]
    1d7a:	2b00      	cmp	r3, #0
    1d7c:	d0ee      	beq.n	1d5c <activate_foreach_backend+0x20>
	if (backend->api->is_ready != NULL) {
    1d7e:	0133      	lsls	r3, r6, #4
    1d80:	4a06      	ldr	r2, [pc, #24]	; (1d9c <activate_foreach_backend+0x60>)
    1d82:	58d3      	ldr	r3, [r2, r3]
    1d84:	691b      	ldr	r3, [r3, #16]
    1d86:	2b00      	cmp	r3, #0
    1d88:	d0dd      	beq.n	1d46 <activate_foreach_backend+0xa>
		return backend->api->is_ready(backend);
    1d8a:	4620      	mov	r0, r4
    1d8c:	4798      	blx	r3
    1d8e:	2800      	cmp	r0, #0
    1d90:	d1e4      	bne.n	1d5c <activate_foreach_backend+0x20>
    1d92:	e7d8      	b.n	1d46 <activate_foreach_backend+0xa>
}
    1d94:	4638      	mov	r0, r7
    1d96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1d9a:	bf00      	nop
    1d9c:	0001d0c4 	.word	0x0001d0c4

00001da0 <z_log_init>:
{
    1da0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1da4:	4680      	mov	r8, r0
    1da6:	460f      	mov	r7, r1
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1da8:	4b26      	ldr	r3, [pc, #152]	; (1e44 <z_log_init+0xa4>)
    1daa:	e8d3 6fef 	ldaex	r6, [r3]
    1dae:	1c72      	adds	r2, r6, #1
    1db0:	e8c3 2fe1 	stlex	r1, r2, [r3]
    1db4:	2900      	cmp	r1, #0
    1db6:	d1f8      	bne.n	1daa <z_log_init+0xa>
	if (atomic_inc(&initialized) != 0) {
    1db8:	2e00      	cmp	r6, #0
    1dba:	d13e      	bne.n	1e3a <z_log_init+0x9a>
	for (i = 0; i < log_backend_count_get(); i++) {
    1dbc:	2400      	movs	r4, #0
    1dbe:	e00a      	b.n	1dd6 <z_log_init+0x36>
						   backend->cb->ctx,
    1dc0:	4b21      	ldr	r3, [pc, #132]	; (1e48 <z_log_init+0xa8>)
    1dc2:	eb03 1909 	add.w	r9, r3, r9, lsl #4
    1dc6:	f8d9 3004 	ldr.w	r3, [r9, #4]
				log_backend_enable(backend,
    1dca:	2204      	movs	r2, #4
    1dcc:	6819      	ldr	r1, [r3, #0]
    1dce:	4628      	mov	r0, r5
    1dd0:	f000 fa28 	bl	2224 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    1dd4:	3401      	adds	r4, #1
    1dd6:	4b1d      	ldr	r3, [pc, #116]	; (1e4c <z_log_init+0xac>)
    1dd8:	4a1b      	ldr	r2, [pc, #108]	; (1e48 <z_log_init+0xa8>)
    1dda:	1a9b      	subs	r3, r3, r2
    1ddc:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1de0:	da1b      	bge.n	1e1a <z_log_init+0x7a>
		const struct log_backend *backend = log_backend_get(i);
    1de2:	46a1      	mov	r9, r4
	return &__log_backends_start[idx];
    1de4:	4d18      	ldr	r5, [pc, #96]	; (1e48 <z_log_init+0xa8>)
    1de6:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (backend->autostart) {
    1dea:	7b2b      	ldrb	r3, [r5, #12]
    1dec:	2b00      	cmp	r3, #0
    1dee:	d0f1      	beq.n	1dd4 <z_log_init+0x34>
	if (backend->api->init) {
    1df0:	0123      	lsls	r3, r4, #4
    1df2:	4a15      	ldr	r2, [pc, #84]	; (1e48 <z_log_init+0xa8>)
    1df4:	f852 a003 	ldr.w	sl, [r2, r3]
    1df8:	f8da 300c 	ldr.w	r3, [sl, #12]
    1dfc:	b10b      	cbz	r3, 1e02 <z_log_init+0x62>
		backend->api->init(backend);
    1dfe:	4628      	mov	r0, r5
    1e00:	4798      	blx	r3
	if (backend->api->is_ready != NULL) {
    1e02:	f8da 3010 	ldr.w	r3, [sl, #16]
    1e06:	2b00      	cmp	r3, #0
    1e08:	d0da      	beq.n	1dc0 <z_log_init+0x20>
		return backend->api->is_ready(backend);
    1e0a:	4628      	mov	r0, r5
    1e0c:	4798      	blx	r3
			if (log_backend_is_ready(backend) == 0) {
    1e0e:	2800      	cmp	r0, #0
    1e10:	d0d6      	beq.n	1dc0 <z_log_init+0x20>
				mask |= BIT(i);
    1e12:	2301      	movs	r3, #1
    1e14:	40a3      	lsls	r3, r4
    1e16:	431e      	orrs	r6, r3
    1e18:	e7dc      	b.n	1dd4 <z_log_init+0x34>
	if (blocking) {
    1e1a:	f1b8 0f00 	cmp.w	r8, #0
    1e1e:	d00d      	beq.n	1e3c <z_log_init+0x9c>
		while (mask) {
    1e20:	b166      	cbz	r6, 1e3c <z_log_init+0x9c>
			mask = activate_foreach_backend(mask);
    1e22:	4630      	mov	r0, r6
    1e24:	f7ff ff8a 	bl	1d3c <activate_foreach_backend>
    1e28:	4606      	mov	r6, r0
			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
    1e2a:	2f00      	cmp	r7, #0
    1e2c:	d0f8      	beq.n	1e20 <z_log_init+0x80>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm0 = { .val = timeout };
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
    1e2e:	f44f 70a4 	mov.w	r0, #328	; 0x148
    1e32:	2100      	movs	r1, #0
    1e34:	f012 fc78 	bl	14728 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    1e38:	e7f2      	b.n	1e20 <z_log_init+0x80>
		return 0;
    1e3a:	2600      	movs	r6, #0
}
    1e3c:	4630      	mov	r0, r6
    1e3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1e42:	bf00      	nop
    1e44:	20001be4 	.word	0x20001be4
    1e48:	0001d0c4 	.word	0x0001d0c4
    1e4c:	0001d0d4 	.word	0x0001d0d4

00001e50 <thread_set>:
{
    1e50:	b508      	push	{r3, lr}
	proc_tid = process_tid;
    1e52:	4b06      	ldr	r3, [pc, #24]	; (1e6c <thread_set+0x1c>)
    1e54:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    1e56:	b118      	cbz	r0, 1e60 <thread_set+0x10>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    1e58:	4b05      	ldr	r3, [pc, #20]	; (1e70 <thread_set+0x20>)
    1e5a:	681b      	ldr	r3, [r3, #0]
	    process_tid &&
    1e5c:	2b09      	cmp	r3, #9
    1e5e:	dc00      	bgt.n	1e62 <thread_set+0x12>
}
    1e60:	bd08      	pop	{r3, pc}
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    1e62:	4804      	ldr	r0, [pc, #16]	; (1e74 <thread_set+0x24>)
    1e64:	f011 fe94 	bl	13b90 <z_impl_k_sem_give>
}
    1e68:	e7fa      	b.n	1e60 <thread_set+0x10>
    1e6a:	bf00      	nop
    1e6c:	20001c28 	.word	0x20001c28
    1e70:	20001bdc 	.word	0x20001bdc
    1e74:	2000063c 	.word	0x2000063c

00001e78 <log_process_thread_timer_expiry_fn>:

static void log_process_thread_timer_expiry_fn(struct k_timer *timer)
{
    1e78:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    1e7a:	4802      	ldr	r0, [pc, #8]	; (1e84 <log_process_thread_timer_expiry_fn+0xc>)
    1e7c:	f011 fe88 	bl	13b90 <z_impl_k_sem_give>
	k_sem_give(&log_process_thread_sem);
}
    1e80:	bd08      	pop	{r3, pc}
    1e82:	bf00      	nop
    1e84:	2000063c 	.word	0x2000063c

00001e88 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    1e88:	b530      	push	{r4, r5, lr}
    1e8a:	b089      	sub	sp, #36	; 0x24
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    1e8c:	2200      	movs	r2, #0
    1e8e:	490f      	ldr	r1, [pc, #60]	; (1ecc <enable_logger+0x44>)
    1e90:	480f      	ldr	r0, [pc, #60]	; (1ed0 <enable_logger+0x48>)
    1e92:	f01a fd6e 	bl	1c972 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    1e96:	4d0f      	ldr	r5, [pc, #60]	; (1ed4 <enable_logger+0x4c>)
    1e98:	2200      	movs	r2, #0
    1e9a:	2300      	movs	r3, #0
    1e9c:	e9cd 2306 	strd	r2, r3, [sp, #24]
    1ea0:	2400      	movs	r4, #0
    1ea2:	9404      	str	r4, [sp, #16]
    1ea4:	230e      	movs	r3, #14
    1ea6:	9303      	str	r3, [sp, #12]
    1ea8:	9402      	str	r4, [sp, #8]
    1eaa:	9401      	str	r4, [sp, #4]
    1eac:	9400      	str	r4, [sp, #0]
    1eae:	4b0a      	ldr	r3, [pc, #40]	; (1ed8 <enable_logger+0x50>)
    1eb0:	f44f 7240 	mov.w	r2, #768	; 0x300
    1eb4:	4909      	ldr	r1, [pc, #36]	; (1edc <enable_logger+0x54>)
    1eb6:	4628      	mov	r0, r5
    1eb8:	f01a f880 	bl	1bfbc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    1ebc:	4908      	ldr	r1, [pc, #32]	; (1ee0 <enable_logger+0x58>)
    1ebe:	4628      	mov	r0, r5
    1ec0:	f011 fc78 	bl	137b4 <z_impl_k_thread_name_set>
	} else {
		(void)z_log_init(false, false);
	}

	return 0;
}
    1ec4:	4620      	mov	r0, r4
    1ec6:	b009      	add	sp, #36	; 0x24
    1ec8:	bd30      	pop	{r4, r5, pc}
    1eca:	bf00      	nop
    1ecc:	00001e79 	.word	0x00001e79
    1ed0:	20000fb8 	.word	0x20000fb8
    1ed4:	20000ff0 	.word	0x20000ff0
    1ed8:	00002195 	.word	0x00002195
    1edc:	20002908 	.word	0x20002908
    1ee0:	0001d450 	.word	0x0001d450

00001ee4 <log_format_func_t_get>:
}
    1ee4:	4b01      	ldr	r3, [pc, #4]	; (1eec <log_format_func_t_get+0x8>)
    1ee6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    1eea:	4770      	bx	lr
    1eec:	0001d45c 	.word	0x0001d45c

00001ef0 <log_set_timestamp_func>:
	if (timestamp_getter == NULL) {
    1ef0:	b138      	cbz	r0, 1f02 <log_set_timestamp_func+0x12>
{
    1ef2:	b508      	push	{r3, lr}
	timestamp_func = timestamp_getter;
    1ef4:	4a04      	ldr	r2, [pc, #16]	; (1f08 <log_set_timestamp_func+0x18>)
    1ef6:	6010      	str	r0, [r2, #0]
		log_output_timestamp_freq_set(freq);
    1ef8:	4608      	mov	r0, r1
    1efa:	f000 fbef 	bl	26dc <log_output_timestamp_freq_set>
	return 0;
    1efe:	2000      	movs	r0, #0
}
    1f00:	bd08      	pop	{r3, pc}
		return -EINVAL;
    1f02:	f06f 0015 	mvn.w	r0, #21
}
    1f06:	4770      	bx	lr
    1f08:	200001c0 	.word	0x200001c0

00001f0c <z_log_notify_backend_enabled>:
{
    1f0c:	b508      	push	{r3, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    1f0e:	4b05      	ldr	r3, [pc, #20]	; (1f24 <z_log_notify_backend_enabled+0x18>)
    1f10:	781b      	ldrb	r3, [r3, #0]
    1f12:	b11b      	cbz	r3, 1f1c <z_log_notify_backend_enabled+0x10>
	backend_attached = true;
    1f14:	4b03      	ldr	r3, [pc, #12]	; (1f24 <z_log_notify_backend_enabled+0x18>)
    1f16:	2201      	movs	r2, #1
    1f18:	701a      	strb	r2, [r3, #0]
}
    1f1a:	bd08      	pop	{r3, pc}
	z_impl_k_sem_give(sem);
    1f1c:	4802      	ldr	r0, [pc, #8]	; (1f28 <z_log_notify_backend_enabled+0x1c>)
    1f1e:	f011 fe37 	bl	13b90 <z_impl_k_sem_give>
}
    1f22:	e7f7      	b.n	1f14 <z_log_notify_backend_enabled+0x8>
    1f24:	200028f9 	.word	0x200028f9
    1f28:	2000063c 	.word	0x2000063c

00001f2c <z_log_dropped>:
    1f2c:	4b09      	ldr	r3, [pc, #36]	; (1f54 <z_log_dropped+0x28>)
    1f2e:	e8d3 2fef 	ldaex	r2, [r3]
    1f32:	3201      	adds	r2, #1
    1f34:	e8c3 2fe1 	stlex	r1, r2, [r3]
    1f38:	2900      	cmp	r1, #0
    1f3a:	d1f8      	bne.n	1f2e <z_log_dropped+0x2>
	if (buffered) {
    1f3c:	b900      	cbnz	r0, 1f40 <z_log_dropped+0x14>
}
    1f3e:	4770      	bx	lr
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    1f40:	4b05      	ldr	r3, [pc, #20]	; (1f58 <z_log_dropped+0x2c>)
    1f42:	e8d3 2fef 	ldaex	r2, [r3]
    1f46:	3a01      	subs	r2, #1
    1f48:	e8c3 2fe1 	stlex	r1, r2, [r3]
    1f4c:	2900      	cmp	r1, #0
    1f4e:	d0f6      	beq.n	1f3e <z_log_dropped+0x12>
    1f50:	e7f7      	b.n	1f42 <z_log_dropped+0x16>
    1f52:	bf00      	nop
    1f54:	20001be0 	.word	0x20001be0
    1f58:	20001bdc 	.word	0x20001bdc

00001f5c <z_log_dropped_read_and_clear>:
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    1f5c:	4b04      	ldr	r3, [pc, #16]	; (1f70 <z_log_dropped_read_and_clear+0x14>)
}
    1f5e:	2000      	movs	r0, #0
    1f60:	4602      	mov	r2, r0
    1f62:	e8d3 0fef 	ldaex	r0, [r3]
    1f66:	e8c3 2fe1 	stlex	r1, r2, [r3]
    1f6a:	2900      	cmp	r1, #0
    1f6c:	d1f9      	bne.n	1f62 <z_log_dropped_read_and_clear+0x6>
    1f6e:	4770      	bx	lr
    1f70:	20001be0 	.word	0x20001be0

00001f74 <dropped_notify>:
{
    1f74:	b538      	push	{r3, r4, r5, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
    1f76:	f7ff fff1 	bl	1f5c <z_log_dropped_read_and_clear>
    1f7a:	4605      	mov	r5, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
    1f7c:	2400      	movs	r4, #0
    1f7e:	e000      	b.n	1f82 <dropped_notify+0xe>
    1f80:	3401      	adds	r4, #1
    1f82:	4b0b      	ldr	r3, [pc, #44]	; (1fb0 <dropped_notify+0x3c>)
    1f84:	4a0b      	ldr	r2, [pc, #44]	; (1fb4 <dropped_notify+0x40>)
    1f86:	1a9b      	subs	r3, r3, r2
    1f88:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1f8c:	da0f      	bge.n	1fae <dropped_notify+0x3a>
	return &__log_backends_start[idx];
    1f8e:	4809      	ldr	r0, [pc, #36]	; (1fb4 <dropped_notify+0x40>)
    1f90:	eb00 1004 	add.w	r0, r0, r4, lsl #4
	return backend->cb->active;
    1f94:	6843      	ldr	r3, [r0, #4]
    1f96:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    1f98:	2b00      	cmp	r3, #0
    1f9a:	d0f1      	beq.n	1f80 <dropped_notify+0xc>
	if (backend->api->dropped != NULL) {
    1f9c:	0123      	lsls	r3, r4, #4
    1f9e:	4a05      	ldr	r2, [pc, #20]	; (1fb4 <dropped_notify+0x40>)
    1fa0:	58d3      	ldr	r3, [r2, r3]
    1fa2:	685b      	ldr	r3, [r3, #4]
    1fa4:	2b00      	cmp	r3, #0
    1fa6:	d0eb      	beq.n	1f80 <dropped_notify+0xc>
		backend->api->dropped(backend, cnt);
    1fa8:	4629      	mov	r1, r5
    1faa:	4798      	blx	r3
    1fac:	e7e8      	b.n	1f80 <dropped_notify+0xc>
}
    1fae:	bd38      	pop	{r3, r4, r5, pc}
    1fb0:	0001d0d4 	.word	0x0001d0d4
    1fb4:	0001d0c4 	.word	0x0001d0c4

00001fb8 <z_log_dropped_pending>:
	return dropped_cnt > 0;
    1fb8:	4b03      	ldr	r3, [pc, #12]	; (1fc8 <z_log_dropped_pending+0x10>)
    1fba:	6818      	ldr	r0, [r3, #0]
}
    1fbc:	2800      	cmp	r0, #0
    1fbe:	bfd4      	ite	le
    1fc0:	2000      	movle	r0, #0
    1fc2:	2001      	movgt	r0, #1
    1fc4:	4770      	bx	lr
    1fc6:	bf00      	nop
    1fc8:	20001be0 	.word	0x20001be0

00001fcc <z_log_msg_init>:
{
    1fcc:	b508      	push	{r3, lr}
	mpsc_pbuf_init(&log_buffer, &mpsc_config);
    1fce:	4902      	ldr	r1, [pc, #8]	; (1fd8 <z_log_msg_init+0xc>)
    1fd0:	4802      	ldr	r0, [pc, #8]	; (1fdc <z_log_msg_init+0x10>)
    1fd2:	f014 fa2a 	bl	1642a <mpsc_pbuf_init>
}
    1fd6:	bd08      	pop	{r3, pc}
    1fd8:	0001d468 	.word	0x0001d468
    1fdc:	20001be8 	.word	0x20001be8

00001fe0 <log_core_init>:
{
    1fe0:	b508      	push	{r3, lr}
	panic_mode = false;
    1fe2:	2300      	movs	r3, #0
    1fe4:	4a05      	ldr	r2, [pc, #20]	; (1ffc <log_core_init+0x1c>)
    1fe6:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
    1fe8:	4a05      	ldr	r2, [pc, #20]	; (2000 <CONFIG_NRF_SPU_RAM_REGION_SIZE>)
    1fea:	6013      	str	r3, [r2, #0]
	log_set_timestamp_func(_timestamp_func, freq);
    1fec:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    1ff0:	4804      	ldr	r0, [pc, #16]	; (2004 <CONFIG_NRF_SPU_RAM_REGION_SIZE+0x4>)
    1ff2:	f7ff ff7d 	bl	1ef0 <log_set_timestamp_func>
		z_log_msg_init();
    1ff6:	f7ff ffe9 	bl	1fcc <z_log_msg_init>
}
    1ffa:	bd08      	pop	{r3, pc}
    1ffc:	200028fa 	.word	0x200028fa
    2000:	20001be0 	.word	0x20001be0
    2004:	00016855 	.word	0x00016855

00002008 <z_log_msg_alloc>:
{
    2008:	b508      	push	{r3, lr}
    200a:	4601      	mov	r1, r0
	return (struct log_msg *)mpsc_pbuf_alloc(&log_buffer, wlen,
    200c:	2200      	movs	r2, #0
    200e:	2300      	movs	r3, #0
    2010:	4801      	ldr	r0, [pc, #4]	; (2018 <z_log_msg_alloc+0x10>)
    2012:	f014 fa31 	bl	16478 <mpsc_pbuf_alloc>
}
    2016:	bd08      	pop	{r3, pc}
    2018:	20001be8 	.word	0x20001be8

0000201c <z_log_msg_claim>:
{
    201c:	b508      	push	{r3, lr}
	return (union log_msg_generic *)mpsc_pbuf_claim(&log_buffer);
    201e:	4802      	ldr	r0, [pc, #8]	; (2028 <z_log_msg_claim+0xc>)
    2020:	f014 fb27 	bl	16672 <mpsc_pbuf_claim>
}
    2024:	bd08      	pop	{r3, pc}
    2026:	bf00      	nop
    2028:	20001be8 	.word	0x20001be8

0000202c <z_log_msg_free>:
{
    202c:	b508      	push	{r3, lr}
    202e:	4601      	mov	r1, r0
	mpsc_pbuf_free(&log_buffer, (union mpsc_pbuf_generic *)msg);
    2030:	4801      	ldr	r0, [pc, #4]	; (2038 <z_log_msg_free+0xc>)
    2032:	f014 fb8f 	bl	16754 <mpsc_pbuf_free>
}
    2036:	bd08      	pop	{r3, pc}
    2038:	20001be8 	.word	0x20001be8

0000203c <z_log_msg_pending>:
{
    203c:	b508      	push	{r3, lr}
	return mpsc_pbuf_is_pending(&log_buffer);
    203e:	4802      	ldr	r0, [pc, #8]	; (2048 <z_log_msg_pending+0xc>)
    2040:	f014 fbc5 	bl	167ce <mpsc_pbuf_is_pending>
}
    2044:	bd08      	pop	{r3, pc}
    2046:	bf00      	nop
    2048:	20001be8 	.word	0x20001be8

0000204c <z_impl_log_process>:
	if (!backend_attached) {
    204c:	4b0f      	ldr	r3, [pc, #60]	; (208c <z_impl_log_process+0x40>)
    204e:	7818      	ldrb	r0, [r3, #0]
    2050:	b900      	cbnz	r0, 2054 <z_impl_log_process+0x8>
}
    2052:	4770      	bx	lr
{
    2054:	b510      	push	{r4, lr}
	msg = z_log_msg_claim();
    2056:	f7ff ffe1 	bl	201c <z_log_msg_claim>
	if (msg) {
    205a:	4604      	mov	r4, r0
    205c:	b168      	cbz	r0, 207a <z_impl_log_process+0x2e>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    205e:	4b0c      	ldr	r3, [pc, #48]	; (2090 <z_impl_log_process+0x44>)
    2060:	e8d3 2fef 	ldaex	r2, [r3]
    2064:	3a01      	subs	r2, #1
    2066:	e8c3 2fe1 	stlex	r1, r2, [r3]
    206a:	2900      	cmp	r1, #0
    206c:	d1f8      	bne.n	2060 <z_impl_log_process+0x14>
		msg_process(msg);
    206e:	4620      	mov	r0, r4
    2070:	f7ff fe20 	bl	1cb4 <msg_process>
		z_log_msg_free(msg);
    2074:	4620      	mov	r0, r4
    2076:	f7ff ffd9 	bl	202c <z_log_msg_free>
	if (z_log_dropped_pending()) {
    207a:	f7ff ff9d 	bl	1fb8 <z_log_dropped_pending>
    207e:	b910      	cbnz	r0, 2086 <z_impl_log_process+0x3a>
	return z_log_msg_pending();
    2080:	f7ff ffdc 	bl	203c <z_log_msg_pending>
}
    2084:	bd10      	pop	{r4, pc}
		dropped_notify();
    2086:	f7ff ff75 	bl	1f74 <dropped_notify>
    208a:	e7f9      	b.n	2080 <z_impl_log_process+0x34>
    208c:	200028f9 	.word	0x200028f9
    2090:	20001bdc 	.word	0x20001bdc

00002094 <z_impl_log_panic>:
	if (panic_mode) {
    2094:	4b13      	ldr	r3, [pc, #76]	; (20e4 <z_impl_log_panic+0x50>)
    2096:	781b      	ldrb	r3, [r3, #0]
    2098:	b103      	cbz	r3, 209c <z_impl_log_panic+0x8>
    209a:	4770      	bx	lr
{
    209c:	b510      	push	{r4, lr}
	(void)z_log_init(true, false);
    209e:	2100      	movs	r1, #0
    20a0:	2001      	movs	r0, #1
    20a2:	f7ff fe7d 	bl	1da0 <z_log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
    20a6:	2400      	movs	r4, #0
    20a8:	e000      	b.n	20ac <z_impl_log_panic+0x18>
    20aa:	3401      	adds	r4, #1
    20ac:	4b0e      	ldr	r3, [pc, #56]	; (20e8 <z_impl_log_panic+0x54>)
    20ae:	4a0f      	ldr	r2, [pc, #60]	; (20ec <z_impl_log_panic+0x58>)
    20b0:	1a9b      	subs	r3, r3, r2
    20b2:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    20b6:	da0c      	bge.n	20d2 <z_impl_log_panic+0x3e>
	return &__log_backends_start[idx];
    20b8:	480c      	ldr	r0, [pc, #48]	; (20ec <z_impl_log_panic+0x58>)
    20ba:	eb00 1004 	add.w	r0, r0, r4, lsl #4
	return backend->cb->active;
    20be:	6843      	ldr	r3, [r0, #4]
    20c0:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    20c2:	2b00      	cmp	r3, #0
    20c4:	d0f1      	beq.n	20aa <z_impl_log_panic+0x16>
	backend->api->panic(backend);
    20c6:	0123      	lsls	r3, r4, #4
    20c8:	4a08      	ldr	r2, [pc, #32]	; (20ec <z_impl_log_panic+0x58>)
    20ca:	58d3      	ldr	r3, [r2, r3]
    20cc:	689b      	ldr	r3, [r3, #8]
    20ce:	4798      	blx	r3
}
    20d0:	e7eb      	b.n	20aa <z_impl_log_panic+0x16>
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke0(K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process();
    20d2:	f7ff ffbb 	bl	204c <z_impl_log_process>
		while (log_process() == true) {
    20d6:	2800      	cmp	r0, #0
    20d8:	d1fb      	bne.n	20d2 <z_impl_log_panic+0x3e>
	panic_mode = true;
    20da:	4b02      	ldr	r3, [pc, #8]	; (20e4 <z_impl_log_panic+0x50>)
    20dc:	2201      	movs	r2, #1
    20de:	701a      	strb	r2, [r3, #0]
}
    20e0:	bd10      	pop	{r4, pc}
    20e2:	bf00      	nop
    20e4:	200028fa 	.word	0x200028fa
    20e8:	0001d0d4 	.word	0x0001d0d4
    20ec:	0001d0c4 	.word	0x0001d0c4

000020f0 <z_log_msg_post_finalize>:
{
    20f0:	b510      	push	{r4, lr}
    20f2:	b082      	sub	sp, #8
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    20f4:	4b19      	ldr	r3, [pc, #100]	; (215c <z_log_msg_post_finalize+0x6c>)
    20f6:	e8d3 2fef 	ldaex	r2, [r3]
    20fa:	1c51      	adds	r1, r2, #1
    20fc:	e8c3 1fe0 	stlex	r0, r1, [r3]
    2100:	2800      	cmp	r0, #0
    2102:	d1f8      	bne.n	20f6 <z_log_msg_post_finalize+0x6>
	if (panic_mode) {
    2104:	4b16      	ldr	r3, [pc, #88]	; (2160 <z_log_msg_post_finalize+0x70>)
    2106:	781b      	ldrb	r3, [r3, #0]
    2108:	b963      	cbnz	r3, 2124 <z_log_msg_post_finalize+0x34>
	} else if (proc_tid != NULL) {
    210a:	4b16      	ldr	r3, [pc, #88]	; (2164 <z_log_msg_post_finalize+0x74>)
    210c:	681b      	ldr	r3, [r3, #0]
    210e:	b1bb      	cbz	r3, 2140 <z_log_msg_post_finalize+0x50>
		if (cnt == 0) {
    2110:	b1c2      	cbz	r2, 2144 <z_log_msg_post_finalize+0x54>
		} else if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    2112:	2a0a      	cmp	r2, #10
    2114:	d114      	bne.n	2140 <z_log_msg_post_finalize+0x50>
	z_impl_k_timer_stop(timer);
    2116:	4814      	ldr	r0, [pc, #80]	; (2168 <z_log_msg_post_finalize+0x78>)
    2118:	f01a fc37 	bl	1c98a <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    211c:	4813      	ldr	r0, [pc, #76]	; (216c <z_log_msg_post_finalize+0x7c>)
    211e:	f011 fd37 	bl	13b90 <z_impl_k_sem_give>
}
    2122:	e00d      	b.n	2140 <z_log_msg_post_finalize+0x50>
	__asm__ volatile(
    2124:	f04f 0320 	mov.w	r3, #32
    2128:	f3ef 8411 	mrs	r4, BASEPRI
    212c:	f383 8812 	msr	BASEPRI_MAX, r3
    2130:	f3bf 8f6f 	isb	sy
    2134:	f7ff ff8a 	bl	204c <z_impl_log_process>
	__asm__ volatile(
    2138:	f384 8811 	msr	BASEPRI, r4
    213c:	f3bf 8f6f 	isb	sy
    2140:	b002      	add	sp, #8
    2142:	bd10      	pop	{r4, pc}
	z_impl_k_timer_start(timer, duration, period);
    2144:	2200      	movs	r2, #0
    2146:	2300      	movs	r3, #0
    2148:	e9cd 2300 	strd	r2, r3, [sp]
    214c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    2150:	2300      	movs	r3, #0
    2152:	4805      	ldr	r0, [pc, #20]	; (2168 <z_log_msg_post_finalize+0x78>)
    2154:	f012 fd46 	bl	14be4 <z_impl_k_timer_start>
    2158:	e7f2      	b.n	2140 <z_log_msg_post_finalize+0x50>
    215a:	bf00      	nop
    215c:	20001bdc 	.word	0x20001bdc
    2160:	200028fa 	.word	0x200028fa
    2164:	20001c28 	.word	0x20001c28
    2168:	20000fb8 	.word	0x20000fb8
    216c:	2000063c 	.word	0x2000063c

00002170 <z_log_msg_commit>:
{
    2170:	b510      	push	{r4, lr}
    2172:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
    2174:	4b05      	ldr	r3, [pc, #20]	; (218c <z_log_msg_commit+0x1c>)
    2176:	681b      	ldr	r3, [r3, #0]
    2178:	4798      	blx	r3
    217a:	60a0      	str	r0, [r4, #8]
	mpsc_pbuf_commit(&log_buffer, &m->buf);
    217c:	4621      	mov	r1, r4
    217e:	4804      	ldr	r0, [pc, #16]	; (2190 <z_log_msg_commit+0x20>)
    2180:	f014 fa16 	bl	165b0 <mpsc_pbuf_commit>
	z_log_msg_post_finalize();
    2184:	f7ff ffb4 	bl	20f0 <z_log_msg_post_finalize>
}
    2188:	bd10      	pop	{r4, pc}
    218a:	bf00      	nop
    218c:	200001c0 	.word	0x200001c0
    2190:	20001be8 	.word	0x20001be8

00002194 <log_process_thread_func>:
{
    2194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t activate_mask = z_log_init(false, false);
    2198:	2100      	movs	r1, #0
    219a:	4608      	mov	r0, r1
    219c:	f7ff fe00 	bl	1da0 <z_log_init>
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
    21a0:	4680      	mov	r8, r0
    21a2:	b140      	cbz	r0, 21b6 <log_process_thread_func+0x22>
    21a4:	f240 6667 	movw	r6, #1639	; 0x667
    21a8:	2700      	movs	r7, #0
	return z_impl_z_current_get();
    21aa:	f012 fae9 	bl	14780 <z_impl_z_current_get>
	thread_set(k_current_get());
    21ae:	f7ff fe4f 	bl	1e50 <thread_set>
	bool processed_any = false;
    21b2:	2500      	movs	r5, #0
    21b4:	e015      	b.n	21e2 <log_process_thread_func+0x4e>
	k_timeout_t timeout = (activate_mask != 0) ? K_MSEC(50) : K_FOREVER;
    21b6:	f04f 36ff 	mov.w	r6, #4294967295
    21ba:	f04f 37ff 	mov.w	r7, #4294967295
    21be:	e7f4      	b.n	21aa <log_process_thread_func+0x16>
			activate_mask = activate_foreach_backend(activate_mask);
    21c0:	4640      	mov	r0, r8
    21c2:	f7ff fdbb 	bl	1d3c <activate_foreach_backend>
			if (!activate_mask) {
    21c6:	4680      	mov	r8, r0
    21c8:	b970      	cbnz	r0, 21e8 <log_process_thread_func+0x54>
				timeout = K_FOREVER;
    21ca:	f04f 36ff 	mov.w	r6, #4294967295
    21ce:	f04f 37ff 	mov.w	r7, #4294967295
    21d2:	e009      	b.n	21e8 <log_process_thread_func+0x54>
    21d4:	462c      	mov	r4, r5
	return z_impl_k_sem_take(sem, timeout);
    21d6:	4632      	mov	r2, r6
    21d8:	463b      	mov	r3, r7
    21da:	4809      	ldr	r0, [pc, #36]	; (2200 <log_process_thread_func+0x6c>)
    21dc:	f011 fd00 	bl	13be0 <z_impl_k_sem_take>
{
    21e0:	4625      	mov	r5, r4
		if (activate_mask) {
    21e2:	f1b8 0f00 	cmp.w	r8, #0
    21e6:	d1eb      	bne.n	21c0 <log_process_thread_func+0x2c>
    21e8:	f7ff ff30 	bl	204c <z_impl_log_process>
		if (log_process() == false) {
    21ec:	4604      	mov	r4, r0
    21ee:	2800      	cmp	r0, #0
    21f0:	d1f6      	bne.n	21e0 <log_process_thread_func+0x4c>
			if (processed_any) {
    21f2:	2d00      	cmp	r5, #0
    21f4:	d0ee      	beq.n	21d4 <log_process_thread_func+0x40>
				log_backend_notify_all(LOG_BACKEND_EVT_PROCESS_THREAD_DONE, NULL);
    21f6:	2100      	movs	r1, #0
    21f8:	4608      	mov	r0, r1
    21fa:	f7ff fd81 	bl	1d00 <log_backend_notify_all>
    21fe:	e7ea      	b.n	21d6 <log_process_thread_func+0x42>
    2200:	2000063c 	.word	0x2000063c

00002204 <log_source_name_get>:
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    2204:	4b05      	ldr	r3, [pc, #20]	; (221c <log_source_name_get+0x18>)
    2206:	4a06      	ldr	r2, [pc, #24]	; (2220 <log_source_name_get+0x1c>)
    2208:	1a9b      	subs	r3, r3, r2
    220a:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
    220e:	d202      	bcs.n	2216 <log_source_name_get+0x12>
	return __log_const_start[source_id].name;
    2210:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
    2214:	4770      	bx	lr
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    2216:	2000      	movs	r0, #0
}
    2218:	4770      	bx	lr
    221a:	bf00      	nop
    221c:	0001d0c4 	.word	0x0001d0c4
    2220:	0001cfcc 	.word	0x0001cfcc

00002224 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			uint32_t level)
{
    2224:	b508      	push	{r3, lr}
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
    2226:	4b07      	ldr	r3, [pc, #28]	; (2244 <log_backend_enable+0x20>)
    2228:	1ac3      	subs	r3, r0, r3
    222a:	111b      	asrs	r3, r3, #4
    222c:	3301      	adds	r3, #1
	backend->cb->id = id;
    222e:	6842      	ldr	r2, [r0, #4]
    2230:	7113      	strb	r3, [r2, #4]
	backend->cb->ctx = ctx;
    2232:	6843      	ldr	r3, [r0, #4]
    2234:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    2236:	6843      	ldr	r3, [r0, #4]
    2238:	2201      	movs	r2, #1
    223a:	715a      	strb	r2, [r3, #5]

	log_backend_id_set(backend, id);
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
    223c:	f7ff fe66 	bl	1f0c <z_log_notify_backend_enabled>
}
    2240:	bd08      	pop	{r3, pc}
    2242:	bf00      	nop
    2244:	0001d0c4 	.word	0x0001d0c4

00002248 <z_impl_z_log_msg_static_create>:
}

void z_impl_z_log_msg_static_create(const void *source,
			      const struct log_msg_desc desc,
			      uint8_t *package, const void *data)
{
    2248:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    224c:	b08a      	sub	sp, #40	; 0x28
    224e:	4605      	mov	r5, r0
    2250:	461e      	mov	r6, r3

	if (!BACKENDS_IN_USE()) {
		return;
	}

	struct log_msg_desc out_desc = desc;
    2252:	460f      	mov	r7, r1
	int inlen = desc.package_len;
    2254:	f3c1 2449 	ubfx	r4, r1, #9, #10
	struct log_msg *msg;

	if (inlen > 0) {
    2258:	2c00      	cmp	r4, #0
    225a:	d035      	beq.n	22c8 <z_impl_z_log_msg_static_create+0x80>
    225c:	4690      	mov	r8, r2
	struct z_cbprintf_buf_desc buf_desc = {
    225e:	2200      	movs	r2, #0
    2260:	9207      	str	r2, [sp, #28]
    2262:	9208      	str	r2, [sp, #32]
    2264:	9209      	str	r2, [sp, #36]	; 0x24
	return cbprintf_package_convert(in_packaged, in_len,
    2266:	2304      	movs	r3, #4
    2268:	9302      	str	r3, [sp, #8]
    226a:	ab05      	add	r3, sp, #20
    226c:	9301      	str	r3, [sp, #4]
    226e:	2302      	movs	r3, #2
    2270:	9300      	str	r3, [sp, #0]
    2272:	ab07      	add	r3, sp, #28
    2274:	4621      	mov	r1, r4
    2276:	4640      	mov	r0, r8
    2278:	f7fe fcb2 	bl	be0 <cbprintf_package_convert>
					    strl, ARRAY_SIZE(strl));

		/* Update package length with calculated value (which may be extended
		 * when strings are copied into the package.
		 */
		out_desc.package_len = len;
    227c:	f3c0 0909 	ubfx	r9, r0, #0, #10
    2280:	f369 2752 	bfi	r7, r9, #9, #10
 *
 * @return Length.
 */
static inline uint32_t log_msg_get_total_wlen(const struct log_msg_desc desc)
{
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
    2284:	f3c7 40cb 	ubfx	r0, r7, #19, #12
    2288:	4448      	add	r0, r9
    228a:	3017      	adds	r0, #23
    228c:	f020 0007 	bic.w	r0, r0, #7
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
    2290:	0880      	lsrs	r0, r0, #2
    2292:	f7ff feb9 	bl	2008 <z_log_msg_alloc>
		if (msg) {
    2296:	4682      	mov	sl, r0
    2298:	b300      	cbz	r0, 22dc <z_impl_z_log_msg_static_create+0x94>
			len = cbprintf_package_copy(package, inlen,
						    msg->data, out_desc.package_len,
    229a:	f100 0310 	add.w	r3, r0, #16
	struct z_cbprintf_buf_desc buf_desc = {
    229e:	9307      	str	r3, [sp, #28]
    22a0:	f8cd 9020 	str.w	r9, [sp, #32]
    22a4:	2200      	movs	r2, #0
    22a6:	9209      	str	r2, [sp, #36]	; 0x24
	return cbprintf_package_convert(in_packaged, in_len,
    22a8:	b163      	cbz	r3, 22c4 <z_impl_z_log_msg_static_create+0x7c>
    22aa:	4a11      	ldr	r2, [pc, #68]	; (22f0 <z_impl_z_log_msg_static_create+0xa8>)
    22ac:	2304      	movs	r3, #4
    22ae:	9302      	str	r3, [sp, #8]
    22b0:	ab05      	add	r3, sp, #20
    22b2:	9301      	str	r3, [sp, #4]
    22b4:	2302      	movs	r3, #2
    22b6:	9300      	str	r3, [sp, #0]
    22b8:	ab07      	add	r3, sp, #28
    22ba:	4621      	mov	r1, r4
    22bc:	4640      	mov	r0, r8
    22be:	f7fe fc8f 	bl	be0 <cbprintf_package_convert>
    22c2:	e00b      	b.n	22dc <z_impl_z_log_msg_static_create+0x94>
    22c4:	2200      	movs	r2, #0
    22c6:	e7f1      	b.n	22ac <z_impl_z_log_msg_static_create+0x64>
    22c8:	f3c1 41cb 	ubfx	r1, r1, #19, #12
    22cc:	440c      	add	r4, r1
    22ce:	3417      	adds	r4, #23
    22d0:	f024 0407 	bic.w	r4, r4, #7
						    flags, strl, ARRAY_SIZE(strl));
			__ASSERT_NO_MSG(len >= 0);
		}
	} else {
		msg = z_log_msg_alloc(log_msg_get_total_wlen(out_desc));
    22d4:	08a0      	lsrs	r0, r4, #2
    22d6:	f7ff fe97 	bl	2008 <z_log_msg_alloc>
    22da:	4682      	mov	sl, r0
	}

	z_log_msg_finalize(msg, source, out_desc, data);
    22dc:	4633      	mov	r3, r6
    22de:	463a      	mov	r2, r7
    22e0:	4629      	mov	r1, r5
    22e2:	4650      	mov	r0, sl
    22e4:	f014 fad7 	bl	16896 <z_log_msg_finalize>
}
    22e8:	b00a      	add	sp, #40	; 0x28
    22ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    22ee:	bf00      	nop
    22f0:	0001686b 	.word	0x0001686b

000022f4 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
    22f4:	b40e      	push	{r1, r2, r3}
    22f6:	b500      	push	{lr}
    22f8:	b084      	sub	sp, #16
    22fa:	4601      	mov	r1, r0
    22fc:	ab05      	add	r3, sp, #20
    22fe:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list args;
	int length = 0;

	va_start(args, fmt);
    2302:	9303      	str	r3, [sp, #12]
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
    2304:	2000      	movs	r0, #0
    2306:	9000      	str	r0, [sp, #0]
    2308:	4803      	ldr	r0, [pc, #12]	; (2318 <print_formatted+0x24>)
    230a:	f7ff f85f 	bl	13cc <z_cbvprintf_impl>
	length = cbvprintf(out_func, (void *)output, fmt, args);
	va_end(args);

	return length;
}
    230e:	b004      	add	sp, #16
    2310:	f85d eb04 	ldr.w	lr, [sp], #4
    2314:	b003      	add	sp, #12
    2316:	4770      	bx	lr
    2318:	00016973 	.word	0x00016973

0000231c <timestamp_print>:
	output_date->day += seconds / SECONDS_IN_DAY;
}

static int timestamp_print(const struct log_output *output,
			   uint32_t flags, log_timestamp_t timestamp)
{
    231c:	b530      	push	{r4, r5, lr}
    231e:	b085      	sub	sp, #20
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
		(flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) |
		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP);


	if (!format) {
    2320:	f011 0f44 	tst.w	r1, #68	; 0x44
    2324:	d005      	beq.n	2332 <timestamp_print+0x16>
#ifndef CONFIG_LOG_TIMESTAMP_64BIT
		length = print_formatted(output, "[%08lu] ", timestamp);
#else
		length = print_formatted(output, "[%016llu] ", timestamp);
#endif
	} else if (freq != 0U) {
    2326:	4b1a      	ldr	r3, [pc, #104]	; (2390 <timestamp_print+0x74>)
    2328:	681c      	ldr	r4, [r3, #0]
    232a:	b934      	cbnz	r4, 233a <timestamp_print+0x1e>
							"[%02u:%02u:%02u.%03u,%03u] ",
							hours, mins, seconds, ms, us);
			}
		}
	} else {
		length = 0;
    232c:	2000      	movs	r0, #0
	}

	return length;
}
    232e:	b005      	add	sp, #20
    2330:	bd30      	pop	{r4, r5, pc}
		length = print_formatted(output, "[%08lu] ", timestamp);
    2332:	4918      	ldr	r1, [pc, #96]	; (2394 <timestamp_print+0x78>)
    2334:	f7ff ffde 	bl	22f4 <print_formatted>
    2338:	e7f9      	b.n	232e <timestamp_print+0x12>
		timestamp /= timestamp_div;
    233a:	4b17      	ldr	r3, [pc, #92]	; (2398 <timestamp_print+0x7c>)
    233c:	6819      	ldr	r1, [r3, #0]
    233e:	fbb2 f1f1 	udiv	r1, r2, r1
		total_seconds = timestamp / freq;
    2342:	fbb1 fcf4 	udiv	ip, r1, r4
		hours = seconds / 3600U;
    2346:	4a15      	ldr	r2, [pc, #84]	; (239c <timestamp_print+0x80>)
    2348:	fba2 320c 	umull	r3, r2, r2, ip
    234c:	0ad2      	lsrs	r2, r2, #11
		seconds -= hours * 3600U;
    234e:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
    2352:	fb0e ce12 	mls	lr, lr, r2, ip
		mins = seconds / 60U;
    2356:	4b12      	ldr	r3, [pc, #72]	; (23a0 <timestamp_print+0x84>)
    2358:	fba3 530e 	umull	r5, r3, r3, lr
    235c:	095b      	lsrs	r3, r3, #5
		remainder = timestamp % freq;
    235e:	fb04 111c 	mls	r1, r4, ip, r1
		ms = (remainder * 1000U) / freq;
    2362:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
    2366:	fb0c f101 	mul.w	r1, ip, r1
    236a:	fbb1 f5f4 	udiv	r5, r1, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    236e:	fb05 1114 	mls	r1, r5, r4, r1
    2372:	fb0c f101 	mul.w	r1, ip, r1
    2376:	fbb1 f1f4 	udiv	r1, r1, r4
				length = print_formatted(output,
    237a:	9102      	str	r1, [sp, #8]
    237c:	9501      	str	r5, [sp, #4]
    237e:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
    2382:	ebae 0181 	sub.w	r1, lr, r1, lsl #2
    2386:	9100      	str	r1, [sp, #0]
    2388:	4906      	ldr	r1, [pc, #24]	; (23a4 <timestamp_print+0x88>)
    238a:	f7ff ffb3 	bl	22f4 <print_formatted>
    238e:	e7ce      	b.n	232e <timestamp_print+0x12>
    2390:	20001c2c 	.word	0x20001c2c
    2394:	0001d47c 	.word	0x0001d47c
    2398:	20001c30 	.word	0x20001c30
    239c:	91a2b3c5 	.word	0x91a2b3c5
    23a0:	88888889 	.word	0x88888889
    23a4:	0001d488 	.word	0x0001d488

000023a8 <color_print>:

static void color_print(const struct log_output *output,
			bool color, bool start, uint32_t level)
{
	if (color) {
    23a8:	b161      	cbz	r1, 23c4 <color_print+0x1c>
{
    23aa:	b508      	push	{r3, lr}
		const char *log_color = start && (colors[level] != NULL) ?
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    23ac:	b12a      	cbz	r2, 23ba <color_print+0x12>
		const char *log_color = start && (colors[level] != NULL) ?
    23ae:	4a06      	ldr	r2, [pc, #24]	; (23c8 <color_print+0x20>)
    23b0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    23b4:	b912      	cbnz	r2, 23bc <color_print+0x14>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    23b6:	4a05      	ldr	r2, [pc, #20]	; (23cc <color_print+0x24>)
    23b8:	e000      	b.n	23bc <color_print+0x14>
    23ba:	4a04      	ldr	r2, [pc, #16]	; (23cc <color_print+0x24>)
		print_formatted(output, "%s", log_color);
    23bc:	4904      	ldr	r1, [pc, #16]	; (23d0 <color_print+0x28>)
    23be:	f7ff ff99 	bl	22f4 <print_formatted>
	}
}
    23c2:	bd08      	pop	{r3, pc}
    23c4:	4770      	bx	lr
    23c6:	bf00      	nop
    23c8:	0001d4fc 	.word	0x0001d4fc
    23cc:	0001d4a4 	.word	0x0001d4a4
    23d0:	0001e054 	.word	0x0001e054

000023d4 <ids_print>:
		     bool level_on,
		     bool func_on,
		     const char *domain,
		     const char *source,
		     uint32_t level)
{
    23d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    23d8:	4605      	mov	r5, r0
    23da:	4617      	mov	r7, r2
    23dc:	461e      	mov	r6, r3
    23de:	f8dd 8018 	ldr.w	r8, [sp, #24]
	int total = 0;

	if (level_on) {
    23e2:	b999      	cbnz	r1, 240c <ids_print+0x38>
	int total = 0;
    23e4:	2400      	movs	r4, #0
		total += print_formatted(output, "<%s> ", severity[level]);
	}

	if (domain) {
    23e6:	b12e      	cbz	r6, 23f4 <ids_print+0x20>
		total += print_formatted(output, "%s/", domain);
    23e8:	4632      	mov	r2, r6
    23ea:	4912      	ldr	r1, [pc, #72]	; (2434 <ids_print+0x60>)
    23ec:	4628      	mov	r0, r5
    23ee:	f7ff ff81 	bl	22f4 <print_formatted>
    23f2:	4404      	add	r4, r0
	}

	if (source) {
    23f4:	f1b8 0f00 	cmp.w	r8, #0
    23f8:	d017      	beq.n	242a <ids_print+0x56>
		total += print_formatted(output,
    23fa:	b187      	cbz	r7, 241e <ids_print+0x4a>
				(func_on &&
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    23fc:	2301      	movs	r3, #1
    23fe:	9a07      	ldr	r2, [sp, #28]
    2400:	4093      	lsls	r3, r2
				(func_on &&
    2402:	f013 0f10 	tst.w	r3, #16
    2406:	d113      	bne.n	2430 <ids_print+0x5c>
		total += print_formatted(output,
    2408:	490b      	ldr	r1, [pc, #44]	; (2438 <ids_print+0x64>)
    240a:	e009      	b.n	2420 <ids_print+0x4c>
		total += print_formatted(output, "<%s> ", severity[level]);
    240c:	4b0b      	ldr	r3, [pc, #44]	; (243c <ids_print+0x68>)
    240e:	9a07      	ldr	r2, [sp, #28]
    2410:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    2414:	490a      	ldr	r1, [pc, #40]	; (2440 <ids_print+0x6c>)
    2416:	f7ff ff6d 	bl	22f4 <print_formatted>
    241a:	4604      	mov	r4, r0
    241c:	e7e3      	b.n	23e6 <ids_print+0x12>
		total += print_formatted(output,
    241e:	4906      	ldr	r1, [pc, #24]	; (2438 <ids_print+0x64>)
    2420:	4642      	mov	r2, r8
    2422:	4628      	mov	r0, r5
    2424:	f7ff ff66 	bl	22f4 <print_formatted>
    2428:	4404      	add	r4, r0
				"%s." : "%s: ",
				source);
	}

	return total;
}
    242a:	4620      	mov	r0, r4
    242c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		total += print_formatted(output,
    2430:	4904      	ldr	r1, [pc, #16]	; (2444 <ids_print+0x70>)
    2432:	e7f5      	b.n	2420 <ids_print+0x4c>
    2434:	0001d4c0 	.word	0x0001d4c0
    2438:	0001d4ac 	.word	0x0001d4ac
    243c:	0001d538 	.word	0x0001d538
    2440:	0001d4b8 	.word	0x0001d4b8
    2444:	0001d4b4 	.word	0x0001d4b4

00002448 <prefix_print>:
			     bool func_on,
			     log_timestamp_t timestamp,
			     const char *domain,
			     const char *source,
			     uint8_t level)
{
    2448:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    244c:	b085      	sub	sp, #20
    244e:	4605      	mov	r5, r0
    2450:	460c      	mov	r4, r1
    2452:	4616      	mov	r6, r2
    2454:	9303      	str	r3, [sp, #12]
    2456:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
    245a:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    245e:	f001 0a01 	and.w	sl, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    2462:	f3c1 09c0 	ubfx	r9, r1, #3, #1
	const char *tag = z_log_get_tag();
    2466:	f014 f9fe 	bl	16866 <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
    246a:	b1d8      	cbz	r0, 24a4 <prefix_print+0x5c>
    246c:	4602      	mov	r2, r0
		length += print_formatted(output, "%s ", tag);
    246e:	4912      	ldr	r1, [pc, #72]	; (24b8 <prefix_print+0x70>)
    2470:	4628      	mov	r0, r5
    2472:	f7ff ff3f 	bl	22f4 <print_formatted>
    2476:	4607      	mov	r7, r0
	}

	if (stamp) {
    2478:	f1bb 0f00 	cmp.w	fp, #0
    247c:	d114      	bne.n	24a8 <prefix_print+0x60>
			output, "%s - - - - ",
			output->control_block->hostname ?
			output->control_block->hostname :
			"zephyr");
	} else {
		color_prefix(output, colors_on, level);
    247e:	4642      	mov	r2, r8
    2480:	4651      	mov	r1, sl
    2482:	4628      	mov	r0, r5
    2484:	f014 fa35 	bl	168f2 <color_prefix>
	}

	length += ids_print(output, level_on, func_on, domain, source, level);
    2488:	f8cd 8004 	str.w	r8, [sp, #4]
    248c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    248e:	9300      	str	r3, [sp, #0]
    2490:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    2492:	4632      	mov	r2, r6
    2494:	4649      	mov	r1, r9
    2496:	4628      	mov	r0, r5
    2498:	f7ff ff9c 	bl	23d4 <ids_print>

	return length;
}
    249c:	4438      	add	r0, r7
    249e:	b005      	add	sp, #20
    24a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
    24a4:	2700      	movs	r7, #0
    24a6:	e7e7      	b.n	2478 <prefix_print+0x30>
		length += timestamp_print(output, flags, timestamp);
    24a8:	9a03      	ldr	r2, [sp, #12]
    24aa:	4621      	mov	r1, r4
    24ac:	4628      	mov	r0, r5
    24ae:	f7ff ff35 	bl	231c <timestamp_print>
    24b2:	4407      	add	r7, r0
    24b4:	e7e3      	b.n	247e <prefix_print+0x36>
    24b6:	bf00      	nop
    24b8:	0001d4c4 	.word	0x0001d4c4

000024bc <newline_print>:
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    24bc:	f011 0f10 	tst.w	r1, #16
    24c0:	d10b      	bne.n	24da <newline_print+0x1e>
{
    24c2:	b508      	push	{r3, lr}
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    24c4:	f011 0f20 	tst.w	r1, #32
    24c8:	d003      	beq.n	24d2 <newline_print+0x16>
		print_formatted(ctx, "\n");
    24ca:	4904      	ldr	r1, [pc, #16]	; (24dc <newline_print+0x20>)
    24cc:	f7ff ff12 	bl	22f4 <print_formatted>
}
    24d0:	bd08      	pop	{r3, pc}
		print_formatted(ctx, "\r\n");
    24d2:	4903      	ldr	r1, [pc, #12]	; (24e0 <newline_print+0x24>)
    24d4:	f7ff ff0e 	bl	22f4 <print_formatted>
    24d8:	e7fa      	b.n	24d0 <newline_print+0x14>
    24da:	4770      	bx	lr
    24dc:	0001dd8c 	.word	0x0001dd8c
    24e0:	00020048 	.word	0x00020048

000024e4 <hexdump_line_print>:
{
    24e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    24e8:	4605      	mov	r5, r0
    24ea:	460f      	mov	r7, r1
    24ec:	4616      	mov	r6, r2
    24ee:	4698      	mov	r8, r3
	newline_print(output, flags);
    24f0:	9906      	ldr	r1, [sp, #24]
    24f2:	f7ff ffe3 	bl	24bc <newline_print>
	for (int i = 0; i < prefix_offset; i++) {
    24f6:	2400      	movs	r4, #0
    24f8:	4544      	cmp	r4, r8
    24fa:	da05      	bge.n	2508 <hexdump_line_print+0x24>
		print_formatted(output, " ");
    24fc:	4923      	ldr	r1, [pc, #140]	; (258c <hexdump_line_print+0xa8>)
    24fe:	4628      	mov	r0, r5
    2500:	f7ff fef8 	bl	22f4 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    2504:	3401      	adds	r4, #1
    2506:	e7f7      	b.n	24f8 <hexdump_line_print+0x14>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2508:	2400      	movs	r4, #0
    250a:	e009      	b.n	2520 <hexdump_line_print+0x3c>
			print_formatted(output, " ");
    250c:	491f      	ldr	r1, [pc, #124]	; (258c <hexdump_line_print+0xa8>)
    250e:	4628      	mov	r0, r5
    2510:	f7ff fef0 	bl	22f4 <print_formatted>
    2514:	e00b      	b.n	252e <hexdump_line_print+0x4a>
			print_formatted(output, "   ");
    2516:	491e      	ldr	r1, [pc, #120]	; (2590 <hexdump_line_print+0xac>)
    2518:	4628      	mov	r0, r5
    251a:	f7ff feeb 	bl	22f4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    251e:	3401      	adds	r4, #1
    2520:	2c0f      	cmp	r4, #15
    2522:	dc0c      	bgt.n	253e <hexdump_line_print+0x5a>
		if (i > 0 && !(i % 8)) {
    2524:	2c00      	cmp	r4, #0
    2526:	dd02      	ble.n	252e <hexdump_line_print+0x4a>
    2528:	f014 0f07 	tst.w	r4, #7
    252c:	d0ee      	beq.n	250c <hexdump_line_print+0x28>
		if (i < length) {
    252e:	42b4      	cmp	r4, r6
    2530:	d2f1      	bcs.n	2516 <hexdump_line_print+0x32>
			print_formatted(output, "%02x ", data[i]);
    2532:	5d3a      	ldrb	r2, [r7, r4]
    2534:	4917      	ldr	r1, [pc, #92]	; (2594 <hexdump_line_print+0xb0>)
    2536:	4628      	mov	r0, r5
    2538:	f7ff fedc 	bl	22f4 <print_formatted>
    253c:	e7ef      	b.n	251e <hexdump_line_print+0x3a>
	print_formatted(output, "|");
    253e:	4916      	ldr	r1, [pc, #88]	; (2598 <hexdump_line_print+0xb4>)
    2540:	4628      	mov	r0, r5
    2542:	f7ff fed7 	bl	22f4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2546:	2400      	movs	r4, #0
    2548:	e009      	b.n	255e <hexdump_line_print+0x7a>
			print_formatted(output, " ");
    254a:	4910      	ldr	r1, [pc, #64]	; (258c <hexdump_line_print+0xa8>)
    254c:	4628      	mov	r0, r5
    254e:	f7ff fed1 	bl	22f4 <print_formatted>
    2552:	e00b      	b.n	256c <hexdump_line_print+0x88>
			print_formatted(output, "%c",
    2554:	4911      	ldr	r1, [pc, #68]	; (259c <hexdump_line_print+0xb8>)
    2556:	4628      	mov	r0, r5
    2558:	f7ff fecc 	bl	22f4 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    255c:	3401      	adds	r4, #1
    255e:	2c0f      	cmp	r4, #15
    2560:	dc12      	bgt.n	2588 <hexdump_line_print+0xa4>
		if (i > 0 && !(i % 8)) {
    2562:	2c00      	cmp	r4, #0
    2564:	dd02      	ble.n	256c <hexdump_line_print+0x88>
    2566:	f014 0f07 	tst.w	r4, #7
    256a:	d0ee      	beq.n	254a <hexdump_line_print+0x66>
		if (i < length) {
    256c:	42b4      	cmp	r4, r6
    256e:	d206      	bcs.n	257e <hexdump_line_print+0x9a>
			char c = (char)data[i];
    2570:	5d3a      	ldrb	r2, [r7, r4]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
    2572:	f1a2 0320 	sub.w	r3, r2, #32
			print_formatted(output, "%c",
    2576:	2b5e      	cmp	r3, #94	; 0x5e
    2578:	d9ec      	bls.n	2554 <hexdump_line_print+0x70>
    257a:	222e      	movs	r2, #46	; 0x2e
    257c:	e7ea      	b.n	2554 <hexdump_line_print+0x70>
			print_formatted(output, " ");
    257e:	4903      	ldr	r1, [pc, #12]	; (258c <hexdump_line_print+0xa8>)
    2580:	4628      	mov	r0, r5
    2582:	f7ff feb7 	bl	22f4 <print_formatted>
    2586:	e7e9      	b.n	255c <hexdump_line_print+0x78>
}
    2588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    258c:	0001d4bc 	.word	0x0001d4bc
    2590:	0001d4d0 	.word	0x0001d4d0
    2594:	0001d4c8 	.word	0x0001d4c8
    2598:	0001d4d4 	.word	0x0001d4d4
    259c:	0001d4d8 	.word	0x0001d4d8

000025a0 <log_output_process>:
			uint8_t level,
			const uint8_t *package,
			const uint8_t *data,
			size_t data_len,
			uint32_t flags)
{
    25a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    25a4:	b084      	sub	sp, #16
    25a6:	4604      	mov	r4, r0
    25a8:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
    25ac:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    25ae:	9e0d      	ldr	r6, [sp, #52]	; 0x34
	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
	uint32_t prefix_offset;

	if (!raw_string) {
    25b0:	b98d      	cbnz	r5, 25d6 <log_output_process+0x36>
		prefix_offset = prefix_print(output, flags, 0, timestamp, domain, source, level);
	} else {
		prefix_offset = 0;
    25b2:	f04f 0800 	mov.w	r8, #0
	}

	if (package) {
    25b6:	b137      	cbz	r7, 25c6 <log_output_process+0x26>
		int err = cbpprintf(raw_string ? cr_out_func :  out_func,
    25b8:	b9bd      	cbnz	r5, 25ea <log_output_process+0x4a>
    25ba:	4814      	ldr	r0, [pc, #80]	; (260c <log_output_process+0x6c>)
		return cbpprintf_external(out, cbvprintf_tagged_args,
					  ctx, packaged);
	}
#endif

	return cbpprintf_external(out, cbvprintf, ctx, packaged);
    25bc:	463b      	mov	r3, r7
    25be:	4622      	mov	r2, r4
    25c0:	4913      	ldr	r1, [pc, #76]	; (2610 <log_output_process+0x70>)
    25c2:	f013 f81b 	bl	155fc <cbpprintf_external>

		(void)err;
		__ASSERT_NO_MSG(err >= 0);
	}

	if (data_len) {
    25c6:	b996      	cbnz	r6, 25ee <log_output_process+0x4e>
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
	}

	if (!raw_string) {
    25c8:	b9d5      	cbnz	r5, 2600 <log_output_process+0x60>
		postfix_print(output, flags, level);
	}

	log_output_flush(output);
    25ca:	4620      	mov	r0, r4
    25cc:	f014 f9c4 	bl	16958 <log_output_flush>
}
    25d0:	b004      	add	sp, #16
    25d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		prefix_offset = prefix_print(output, flags, 0, timestamp, domain, source, level);
    25d6:	9502      	str	r5, [sp, #8]
    25d8:	9301      	str	r3, [sp, #4]
    25da:	9200      	str	r2, [sp, #0]
    25dc:	460b      	mov	r3, r1
    25de:	2200      	movs	r2, #0
    25e0:	990e      	ldr	r1, [sp, #56]	; 0x38
    25e2:	f7ff ff31 	bl	2448 <prefix_print>
    25e6:	4680      	mov	r8, r0
    25e8:	e7e5      	b.n	25b6 <log_output_process+0x16>
		int err = cbpprintf(raw_string ? cr_out_func :  out_func,
    25ea:	480a      	ldr	r0, [pc, #40]	; (2614 <log_output_process+0x74>)
    25ec:	e7e6      	b.n	25bc <log_output_process+0x1c>
		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
    25ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    25f0:	9300      	str	r3, [sp, #0]
    25f2:	4643      	mov	r3, r8
    25f4:	4632      	mov	r2, r6
    25f6:	990c      	ldr	r1, [sp, #48]	; 0x30
    25f8:	4620      	mov	r0, r4
    25fa:	f014 f992 	bl	16922 <log_msg_hexdump>
    25fe:	e7e3      	b.n	25c8 <log_output_process+0x28>
		postfix_print(output, flags, level);
    2600:	462a      	mov	r2, r5
    2602:	990e      	ldr	r1, [sp, #56]	; 0x38
    2604:	4620      	mov	r0, r4
    2606:	f014 f980 	bl	1690a <postfix_print>
    260a:	e7de      	b.n	25ca <log_output_process+0x2a>
    260c:	000169a3 	.word	0x000169a3
    2610:	000168e3 	.word	0x000168e3
    2614:	00016973 	.word	0x00016973

00002618 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg, uint32_t flags)
{
    2618:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    261c:	b087      	sub	sp, #28
    261e:	4606      	mov	r6, r0
    2620:	460c      	mov	r4, r1
    2622:	4690      	mov	r8, r2
 *
 * @return Timestamp.
 */
static inline log_timestamp_t log_msg_get_timestamp(struct log_msg *msg)
{
	return msg->hdr.timestamp;
    2624:	f8d1 9008 	ldr.w	r9, [r1, #8]
	return msg->hdr.desc.level;
    2628:	880f      	ldrh	r7, [r1, #0]
    262a:	f3c7 1782 	ubfx	r7, r7, #6, #3
	return msg->hdr.source;
    262e:	684b      	ldr	r3, [r1, #4]
	return msg->hdr.desc.domain;
    2630:	7808      	ldrb	r0, [r1, #0]
    2632:	f3c0 00c2 	ubfx	r0, r0, #3, #3
	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
	uint8_t level = log_msg_get_level(msg);
	void *source = (void *)log_msg_get_source(msg);
	uint8_t domain_id = log_msg_get_domain(msg);
	int16_t source_id = source ?
    2636:	b133      	cbz	r3, 2646 <log_output_msg_process+0x2e>
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
    2638:	4911      	ldr	r1, [pc, #68]	; (2680 <log_output_msg_process+0x68>)
    263a:	1a59      	subs	r1, r3, r1
    263c:	f341 01cf 	sbfx	r1, r1, #3, #16
			(IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ?
				log_dynamic_source_id(source) :
				log_const_source_id(source)) :
			-1;
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
    2640:	2900      	cmp	r1, #0
    2642:	da19      	bge.n	2678 <log_output_msg_process+0x60>
    2644:	2300      	movs	r3, #0
 *
 * @return pointer to the package.
 */
static inline uint8_t *log_msg_get_package(struct log_msg *msg, size_t *len)
{
	*len = msg->hdr.desc.package_len;
    2646:	4621      	mov	r1, r4
    2648:	f851 5b10 	ldr.w	r5, [r1], #16
    264c:	f3c5 2549 	ubfx	r5, r5, #9, #10
	*len = msg->hdr.desc.data_len;
    2650:	8862      	ldrh	r2, [r4, #2]
    2652:	f3c2 02cb 	ubfx	r2, r2, #3, #12
	return msg->data + msg->hdr.desc.package_len;
    2656:	1948      	adds	r0, r1, r5
	size_t plen, dlen;
	uint8_t *package = log_msg_get_package(msg, &plen);
	uint8_t *data = log_msg_get_data(msg, &dlen);

	log_output_process(output, timestamp, NULL, sname, level,
    2658:	b905      	cbnz	r5, 265c <log_output_msg_process+0x44>
    265a:	2100      	movs	r1, #0
    265c:	f8cd 8010 	str.w	r8, [sp, #16]
    2660:	9203      	str	r2, [sp, #12]
    2662:	9002      	str	r0, [sp, #8]
    2664:	9101      	str	r1, [sp, #4]
    2666:	9700      	str	r7, [sp, #0]
    2668:	2200      	movs	r2, #0
    266a:	4649      	mov	r1, r9
    266c:	4630      	mov	r0, r6
    266e:	f7ff ff97 	bl	25a0 <log_output_process>
			   plen > 0 ? package : NULL, data, dlen, flags);
}
    2672:	b007      	add	sp, #28
    2674:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
    2678:	f7ff fdc4 	bl	2204 <log_source_name_get>
    267c:	4603      	mov	r3, r0
    267e:	e7e2      	b.n	2646 <log_output_msg_process+0x2e>
    2680:	0001cfcc 	.word	0x0001cfcc

00002684 <log_output_dropped_process>:

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    2684:	b570      	push	{r4, r5, r6, lr}
    2686:	b082      	sub	sp, #8
    2688:	4604      	mov	r4, r0
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;
    268a:	6805      	ldr	r5, [r0, #0]

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    268c:	f242 730f 	movw	r3, #9999	; 0x270f
    2690:	428b      	cmp	r3, r1
    2692:	bf28      	it	cs
    2694:	460b      	movcs	r3, r1
    2696:	4a0e      	ldr	r2, [pc, #56]	; (26d0 <log_output_dropped_process+0x4c>)
    2698:	2105      	movs	r1, #5
    269a:	4668      	mov	r0, sp
    269c:	f013 f83d 	bl	1571a <snprintk>
    26a0:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
		     output->control_block->ctx);
    26a2:	6863      	ldr	r3, [r4, #4]
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    26a4:	685b      	ldr	r3, [r3, #4]
    26a6:	220b      	movs	r2, #11
    26a8:	490a      	ldr	r1, [pc, #40]	; (26d4 <log_output_dropped_process+0x50>)
    26aa:	4628      	mov	r0, r5
    26ac:	f014 f90c 	bl	168c8 <buffer_write>
	buffer_write(outf, buf, len, output->control_block->ctx);
    26b0:	6863      	ldr	r3, [r4, #4]
    26b2:	685b      	ldr	r3, [r3, #4]
    26b4:	4632      	mov	r2, r6
    26b6:	4669      	mov	r1, sp
    26b8:	4628      	mov	r0, r5
    26ba:	f014 f905 	bl	168c8 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
		     output->control_block->ctx);
    26be:	6863      	ldr	r3, [r4, #4]
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    26c0:	685b      	ldr	r3, [r3, #4]
    26c2:	221b      	movs	r2, #27
    26c4:	4904      	ldr	r1, [pc, #16]	; (26d8 <log_output_dropped_process+0x54>)
    26c6:	4628      	mov	r0, r5
    26c8:	f014 f8fe 	bl	168c8 <buffer_write>
}
    26cc:	b002      	add	sp, #8
    26ce:	bd70      	pop	{r4, r5, r6, pc}
    26d0:	0001edf0 	.word	0x0001edf0
    26d4:	0001d52c 	.word	0x0001d52c
    26d8:	0001d510 	.word	0x0001d510

000026dc <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    26dc:	4b07      	ldr	r3, [pc, #28]	; (26fc <log_output_timestamp_freq_set+0x20>)
    26de:	2201      	movs	r2, #1
    26e0:	601a      	str	r2, [r3, #0]
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    26e2:	e004      	b.n	26ee <log_output_timestamp_freq_set+0x12>
		frequency /= 2U;
    26e4:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    26e6:	4a05      	ldr	r2, [pc, #20]	; (26fc <log_output_timestamp_freq_set+0x20>)
    26e8:	6813      	ldr	r3, [r2, #0]
    26ea:	005b      	lsls	r3, r3, #1
    26ec:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
    26ee:	4b04      	ldr	r3, [pc, #16]	; (2700 <log_output_timestamp_freq_set+0x24>)
    26f0:	4298      	cmp	r0, r3
    26f2:	d8f7      	bhi.n	26e4 <log_output_timestamp_freq_set+0x8>
	}

	freq = frequency;
    26f4:	4b03      	ldr	r3, [pc, #12]	; (2704 <log_output_timestamp_freq_set+0x28>)
    26f6:	6018      	str	r0, [r3, #0]
}
    26f8:	4770      	bx	lr
    26fa:	bf00      	nop
    26fc:	20001c30 	.word	0x20001c30
    2700:	000f4240 	.word	0x000f4240
    2704:	20001c2c 	.word	0x20001c2c

00002708 <char_out>:
		uart_poll_out(uart_dev, c);
	}
}

static int char_out(uint8_t *data, size_t length, void *ctx)
{
    2708:	b570      	push	{r4, r5, r6, lr}
    270a:	4606      	mov	r6, r0
    270c:	460d      	mov	r5, r1
		dict_char_out_hex(data, length);
		return length;
	}

	if (!IS_ENABLED(CONFIG_LOG_BACKEND_UART_ASYNC) || in_panic || !use_async) {
		for (size_t i = 0; i < length; i++) {
    270e:	2400      	movs	r4, #0
    2710:	e006      	b.n	2720 <char_out+0x18>
			uart_poll_out(uart_dev, data[i]);
    2712:	4b05      	ldr	r3, [pc, #20]	; (2728 <char_out+0x20>)
    2714:	6818      	ldr	r0, [r3, #0]
    2716:	5d31      	ldrb	r1, [r6, r4]
			     unsigned char out_char);

static inline void z_impl_uart_poll_out(const struct device *dev,
					unsigned char out_char)
{
	const struct uart_driver_api *api =
    2718:	6883      	ldr	r3, [r0, #8]
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    271a:	685b      	ldr	r3, [r3, #4]
    271c:	4798      	blx	r3
		for (size_t i = 0; i < length; i++) {
    271e:	3401      	adds	r4, #1
    2720:	42ac      	cmp	r4, r5
    2722:	d3f6      	bcc.n	2712 <char_out+0xa>
	__ASSERT_NO_MSG(err == 0);

	(void)err;

	return length;
}
    2724:	4628      	mov	r0, r5
    2726:	bd70      	pop	{r4, r5, r6, pc}
    2728:	20001c4c 	.word	0x20001c4c

0000272c <format_set>:
	log_output_func(&log_output_uart, &msg->log, flags);
}

static int format_set(const struct log_backend *const backend, uint32_t log_type)
{
	log_format_current = log_type;
    272c:	4b01      	ldr	r3, [pc, #4]	; (2734 <format_set+0x8>)
    272e:	6019      	str	r1, [r3, #0]
	return 0;
}
    2730:	2000      	movs	r0, #0
    2732:	4770      	bx	lr
    2734:	20001c3c 	.word	0x20001c3c

00002738 <log_backend_uart_init>:

static void log_backend_uart_init(struct log_backend const *const backend)
{
	uart_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    2738:	4b01      	ldr	r3, [pc, #4]	; (2740 <log_backend_uart_init+0x8>)
    273a:	4a02      	ldr	r2, [pc, #8]	; (2744 <log_backend_uart_init+0xc>)
    273c:	601a      	str	r2, [r3, #0]
		} else {
			LOG_WRN("Failed to initialize asynchronous mode (err:%d). "
				"Fallback to polling.", err);
		}
	}
}
    273e:	4770      	bx	lr
    2740:	20001c4c 	.word	0x20001c4c
    2744:	0001cc5c 	.word	0x0001cc5c

00002748 <panic>:

static void panic(struct log_backend const *const backend)
{
    2748:	b508      	push	{r3, lr}
	in_panic = true;
    274a:	4b03      	ldr	r3, [pc, #12]	; (2758 <panic+0x10>)
    274c:	2201      	movs	r2, #1
    274e:	701a      	strb	r2, [r3, #0]
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
    2750:	4802      	ldr	r0, [pc, #8]	; (275c <panic+0x14>)
    2752:	f014 f901 	bl	16958 <log_output_flush>
	log_backend_std_panic(&log_output_uart);
}
    2756:	bd08      	pop	{r3, pc}
    2758:	200028fb 	.word	0x200028fb
    275c:	0001d588 	.word	0x0001d588

00002760 <dropped>:

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    2760:	b508      	push	{r3, lr}
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
    2762:	4802      	ldr	r0, [pc, #8]	; (276c <dropped+0xc>)
    2764:	f7ff ff8e 	bl	2684 <log_output_dropped_process>
	if (IS_ENABLED(CONFIG_LOG_BACKEND_UART_OUTPUT_DICTIONARY)) {
		log_dict_output_dropped_process(&log_output_uart, cnt);
	} else {
		log_backend_std_dropped(&log_output_uart, cnt);
	}
}
    2768:	bd08      	pop	{r3, pc}
    276a:	bf00      	nop
    276c:	0001d588 	.word	0x0001d588

00002770 <process>:
{
    2770:	b510      	push	{r4, lr}
    2772:	460c      	mov	r4, r1
	log_format_func_t log_output_func = log_format_func_t_get(log_format_current);
    2774:	4b04      	ldr	r3, [pc, #16]	; (2788 <process+0x18>)
    2776:	6818      	ldr	r0, [r3, #0]
    2778:	f7ff fbb4 	bl	1ee4 <log_format_func_t_get>
    277c:	4603      	mov	r3, r0
	log_output_func(&log_output_uart, &msg->log, flags);
    277e:	220f      	movs	r2, #15
    2780:	4621      	mov	r1, r4
    2782:	4802      	ldr	r0, [pc, #8]	; (278c <process+0x1c>)
    2784:	4798      	blx	r3
}
    2786:	bd10      	pop	{r4, pc}
    2788:	20001c3c 	.word	0x20001c3c
    278c:	0001d588 	.word	0x0001d588

00002790 <ipc_service_open_instance>:
#include <zephyr/device.h>

LOG_MODULE_REGISTER(ipc_service, CONFIG_IPC_SERVICE_LOG_LEVEL);

int ipc_service_open_instance(const struct device *instance)
{
    2790:	b500      	push	{lr}
    2792:	b08f      	sub	sp, #60	; 0x3c
	const struct ipc_service_backend *backend;

	if (!instance) {
    2794:	b140      	cbz	r0, 27a8 <ipc_service_open_instance+0x18>
		LOG_ERR("Invalid instance");
		return -EINVAL;
	}

	backend = (const struct ipc_service_backend *) instance->api;
    2796:	6883      	ldr	r3, [r0, #8]

	if (!backend) {
    2798:	b373      	cbz	r3, 27f8 <ipc_service_open_instance+0x68>
		LOG_ERR("Invalid backend configuration");
		return -EIO;
	}

	if (!backend->open_instance) {
    279a:	681b      	ldr	r3, [r3, #0]
    279c:	2b00      	cmp	r3, #0
    279e:	d053      	beq.n	2848 <ipc_service_open_instance+0xb8>
		/* maybe not needed on backend */
		return 0;
	}

	return backend->open_instance(instance);
    27a0:	4798      	blx	r3
}
    27a2:	b00f      	add	sp, #60	; 0x3c
    27a4:	f85d fb04 	ldr.w	pc, [sp], #4
		LOG_ERR("Invalid instance");
    27a8:	4b28      	ldr	r3, [pc, #160]	; (284c <ipc_service_open_instance+0xbc>)
    27aa:	930d      	str	r3, [sp, #52]	; 0x34
    27ac:	2302      	movs	r3, #2
    27ae:	f88d 3004 	strb.w	r3, [sp, #4]
    27b2:	2300      	movs	r3, #0
    27b4:	f88d 3005 	strb.w	r3, [sp, #5]
    27b8:	f88d 3006 	strb.w	r3, [sp, #6]
    27bc:	f88d 3007 	strb.w	r3, [sp, #7]
    27c0:	9a01      	ldr	r2, [sp, #4]
    27c2:	920c      	str	r2, [sp, #48]	; 0x30
    27c4:	4619      	mov	r1, r3
    27c6:	f363 0100 	bfi	r1, r3, #0, #1
    27ca:	f363 0141 	bfi	r1, r3, #1, #1
    27ce:	f363 0182 	bfi	r1, r3, #2, #1
    27d2:	f363 01c5 	bfi	r1, r3, #3, #3
    27d6:	2201      	movs	r2, #1
    27d8:	f362 1188 	bfi	r1, r2, #6, #3
    27dc:	2208      	movs	r2, #8
    27de:	f362 2152 	bfi	r1, r2, #9, #10
    27e2:	f363 41de 	bfi	r1, r3, #19, #12
    27e6:	f363 71df 	bfi	r1, r3, #31, #1
    27ea:	aa0c      	add	r2, sp, #48	; 0x30
    27ec:	4818      	ldr	r0, [pc, #96]	; (2850 <ipc_service_open_instance+0xc0>)
    27ee:	f7ff fd2b 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    27f2:	f06f 0015 	mvn.w	r0, #21
    27f6:	e7d4      	b.n	27a2 <ipc_service_open_instance+0x12>
		LOG_ERR("Invalid backend configuration");
    27f8:	4b16      	ldr	r3, [pc, #88]	; (2854 <ipc_service_open_instance+0xc4>)
    27fa:	9307      	str	r3, [sp, #28]
    27fc:	2302      	movs	r3, #2
    27fe:	f88d 3004 	strb.w	r3, [sp, #4]
    2802:	2300      	movs	r3, #0
    2804:	f88d 3005 	strb.w	r3, [sp, #5]
    2808:	f88d 3006 	strb.w	r3, [sp, #6]
    280c:	f88d 3007 	strb.w	r3, [sp, #7]
    2810:	9a01      	ldr	r2, [sp, #4]
    2812:	9206      	str	r2, [sp, #24]
    2814:	4619      	mov	r1, r3
    2816:	f363 0100 	bfi	r1, r3, #0, #1
    281a:	f363 0141 	bfi	r1, r3, #1, #1
    281e:	f363 0182 	bfi	r1, r3, #2, #1
    2822:	f363 01c5 	bfi	r1, r3, #3, #3
    2826:	2201      	movs	r2, #1
    2828:	f362 1188 	bfi	r1, r2, #6, #3
    282c:	2208      	movs	r2, #8
    282e:	f362 2152 	bfi	r1, r2, #9, #10
    2832:	f363 41de 	bfi	r1, r3, #19, #12
    2836:	f363 71df 	bfi	r1, r3, #31, #1
    283a:	aa06      	add	r2, sp, #24
    283c:	4804      	ldr	r0, [pc, #16]	; (2850 <ipc_service_open_instance+0xc0>)
    283e:	f7ff fd03 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    2842:	f06f 0004 	mvn.w	r0, #4
    2846:	e7ac      	b.n	27a2 <ipc_service_open_instance+0x12>
		return 0;
    2848:	2000      	movs	r0, #0
    284a:	e7aa      	b.n	27a2 <ipc_service_open_instance+0x12>
    284c:	0001d598 	.word	0x0001d598
    2850:	0001d044 	.word	0x0001d044
    2854:	0001d5ac 	.word	0x0001d5ac

00002858 <ipc_service_register_endpoint>:

int ipc_service_register_endpoint(const struct device *instance,
				  struct ipc_ept *ept,
				  const struct ipc_ept_cfg *cfg)
{
    2858:	b510      	push	{r4, lr}
    285a:	b08e      	sub	sp, #56	; 0x38
	const struct ipc_service_backend *backend;

	if (!instance || !ept || !cfg) {
    285c:	b168      	cbz	r0, 287a <ipc_service_register_endpoint+0x22>
    285e:	4603      	mov	r3, r0
    2860:	b159      	cbz	r1, 287a <ipc_service_register_endpoint+0x22>
    2862:	b152      	cbz	r2, 287a <ipc_service_register_endpoint+0x22>
		LOG_ERR("Invalid instance, endpoint or configuration");
		return -EINVAL;
	}

	backend = (const struct ipc_service_backend *) instance->api;
    2864:	6880      	ldr	r0, [r0, #8]

	if (!backend || !backend->register_endpoint) {
    2866:	b380      	cbz	r0, 28ca <ipc_service_register_endpoint+0x72>
    2868:	6884      	ldr	r4, [r0, #8]
    286a:	b374      	cbz	r4, 28ca <ipc_service_register_endpoint+0x72>
		return -EIO;
	}

	LOG_DBG("Register endpoint %s", cfg->name ? cfg->name : "");

	ept->instance = instance;
    286c:	f841 3b04 	str.w	r3, [r1], #4

	return backend->register_endpoint(instance, &ept->token, cfg);
    2870:	6884      	ldr	r4, [r0, #8]
    2872:	4618      	mov	r0, r3
    2874:	47a0      	blx	r4
}
    2876:	b00e      	add	sp, #56	; 0x38
    2878:	bd10      	pop	{r4, pc}
		LOG_ERR("Invalid instance, endpoint or configuration");
    287a:	4b28      	ldr	r3, [pc, #160]	; (291c <ipc_service_register_endpoint+0xc4>)
    287c:	930d      	str	r3, [sp, #52]	; 0x34
    287e:	2302      	movs	r3, #2
    2880:	f88d 3004 	strb.w	r3, [sp, #4]
    2884:	2300      	movs	r3, #0
    2886:	f88d 3005 	strb.w	r3, [sp, #5]
    288a:	f88d 3006 	strb.w	r3, [sp, #6]
    288e:	f88d 3007 	strb.w	r3, [sp, #7]
    2892:	9a01      	ldr	r2, [sp, #4]
    2894:	920c      	str	r2, [sp, #48]	; 0x30
    2896:	4619      	mov	r1, r3
    2898:	f363 0100 	bfi	r1, r3, #0, #1
    289c:	f363 0141 	bfi	r1, r3, #1, #1
    28a0:	f363 0182 	bfi	r1, r3, #2, #1
    28a4:	f363 01c5 	bfi	r1, r3, #3, #3
    28a8:	2201      	movs	r2, #1
    28aa:	f362 1188 	bfi	r1, r2, #6, #3
    28ae:	2208      	movs	r2, #8
    28b0:	f362 2152 	bfi	r1, r2, #9, #10
    28b4:	f363 41de 	bfi	r1, r3, #19, #12
    28b8:	f363 71df 	bfi	r1, r3, #31, #1
    28bc:	aa0c      	add	r2, sp, #48	; 0x30
    28be:	4818      	ldr	r0, [pc, #96]	; (2920 <ipc_service_register_endpoint+0xc8>)
    28c0:	f7ff fcc2 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    28c4:	f06f 0015 	mvn.w	r0, #21
    28c8:	e7d5      	b.n	2876 <ipc_service_register_endpoint+0x1e>
		LOG_ERR("Invalid backend configuration");
    28ca:	4b16      	ldr	r3, [pc, #88]	; (2924 <ipc_service_register_endpoint+0xcc>)
    28cc:	9307      	str	r3, [sp, #28]
    28ce:	2302      	movs	r3, #2
    28d0:	f88d 3004 	strb.w	r3, [sp, #4]
    28d4:	2300      	movs	r3, #0
    28d6:	f88d 3005 	strb.w	r3, [sp, #5]
    28da:	f88d 3006 	strb.w	r3, [sp, #6]
    28de:	f88d 3007 	strb.w	r3, [sp, #7]
    28e2:	9a01      	ldr	r2, [sp, #4]
    28e4:	9206      	str	r2, [sp, #24]
    28e6:	4619      	mov	r1, r3
    28e8:	f363 0100 	bfi	r1, r3, #0, #1
    28ec:	f363 0141 	bfi	r1, r3, #1, #1
    28f0:	f363 0182 	bfi	r1, r3, #2, #1
    28f4:	f363 01c5 	bfi	r1, r3, #3, #3
    28f8:	2201      	movs	r2, #1
    28fa:	f362 1188 	bfi	r1, r2, #6, #3
    28fe:	2208      	movs	r2, #8
    2900:	f362 2152 	bfi	r1, r2, #9, #10
    2904:	f363 41de 	bfi	r1, r3, #19, #12
    2908:	f363 71df 	bfi	r1, r3, #31, #1
    290c:	aa06      	add	r2, sp, #24
    290e:	4804      	ldr	r0, [pc, #16]	; (2920 <ipc_service_register_endpoint+0xc8>)
    2910:	f7ff fc9a 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    2914:	f06f 0004 	mvn.w	r0, #4
    2918:	e7ad      	b.n	2876 <ipc_service_register_endpoint+0x1e>
    291a:	bf00      	nop
    291c:	0001d5cc 	.word	0x0001d5cc
    2920:	0001d044 	.word	0x0001d044
    2924:	0001d5ac 	.word	0x0001d5ac

00002928 <ipc_service_send>:

int ipc_service_send(struct ipc_ept *ept, const void *data, size_t len)
{
    2928:	b510      	push	{r4, lr}
    292a:	b094      	sub	sp, #80	; 0x50
	const struct ipc_service_backend *backend;

	if (!ept) {
    292c:	b180      	cbz	r0, 2950 <ipc_service_send+0x28>
    292e:	4613      	mov	r3, r2
    2930:	4684      	mov	ip, r0
		LOG_ERR("Invalid endpoint");
		return -EINVAL;
	}

	if (!ept->instance) {
    2932:	6800      	ldr	r0, [r0, #0]
    2934:	2800      	cmp	r0, #0
    2936:	d033      	beq.n	29a0 <ipc_service_send+0x78>
		LOG_ERR("Endpoint not registered\n");
		return -ENOENT;
	}

	backend = ept->instance->api;
    2938:	6882      	ldr	r2, [r0, #8]

	if (!backend || !backend->send) {
    293a:	2a00      	cmp	r2, #0
    293c:	d058      	beq.n	29f0 <ipc_service_send+0xc8>
    293e:	6854      	ldr	r4, [r2, #4]
    2940:	2c00      	cmp	r4, #0
    2942:	d055      	beq.n	29f0 <ipc_service_send+0xc8>
		LOG_ERR("Invalid backend configuration");
		return -EIO;
	}

	return backend->send(ept->instance, ept->token, data, len);
    2944:	460a      	mov	r2, r1
    2946:	f8dc 1004 	ldr.w	r1, [ip, #4]
    294a:	47a0      	blx	r4
}
    294c:	b014      	add	sp, #80	; 0x50
    294e:	bd10      	pop	{r4, pc}
		LOG_ERR("Invalid endpoint");
    2950:	4b3b      	ldr	r3, [pc, #236]	; (2a40 <ipc_service_send+0x118>)
    2952:	9313      	str	r3, [sp, #76]	; 0x4c
    2954:	2302      	movs	r3, #2
    2956:	f88d 3004 	strb.w	r3, [sp, #4]
    295a:	2300      	movs	r3, #0
    295c:	f88d 3005 	strb.w	r3, [sp, #5]
    2960:	f88d 3006 	strb.w	r3, [sp, #6]
    2964:	f88d 3007 	strb.w	r3, [sp, #7]
    2968:	9a01      	ldr	r2, [sp, #4]
    296a:	9212      	str	r2, [sp, #72]	; 0x48
    296c:	4619      	mov	r1, r3
    296e:	f363 0100 	bfi	r1, r3, #0, #1
    2972:	f363 0141 	bfi	r1, r3, #1, #1
    2976:	f363 0182 	bfi	r1, r3, #2, #1
    297a:	f363 01c5 	bfi	r1, r3, #3, #3
    297e:	2201      	movs	r2, #1
    2980:	f362 1188 	bfi	r1, r2, #6, #3
    2984:	2208      	movs	r2, #8
    2986:	f362 2152 	bfi	r1, r2, #9, #10
    298a:	f363 41de 	bfi	r1, r3, #19, #12
    298e:	f363 71df 	bfi	r1, r3, #31, #1
    2992:	aa12      	add	r2, sp, #72	; 0x48
    2994:	482b      	ldr	r0, [pc, #172]	; (2a44 <ipc_service_send+0x11c>)
    2996:	f7ff fc57 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    299a:	f06f 0015 	mvn.w	r0, #21
    299e:	e7d5      	b.n	294c <ipc_service_send+0x24>
		LOG_ERR("Endpoint not registered\n");
    29a0:	4b29      	ldr	r3, [pc, #164]	; (2a48 <ipc_service_send+0x120>)
    29a2:	930d      	str	r3, [sp, #52]	; 0x34
    29a4:	2302      	movs	r3, #2
    29a6:	f88d 3004 	strb.w	r3, [sp, #4]
    29aa:	2300      	movs	r3, #0
    29ac:	f88d 3005 	strb.w	r3, [sp, #5]
    29b0:	f88d 3006 	strb.w	r3, [sp, #6]
    29b4:	f88d 3007 	strb.w	r3, [sp, #7]
    29b8:	9a01      	ldr	r2, [sp, #4]
    29ba:	920c      	str	r2, [sp, #48]	; 0x30
    29bc:	4619      	mov	r1, r3
    29be:	f363 0100 	bfi	r1, r3, #0, #1
    29c2:	f363 0141 	bfi	r1, r3, #1, #1
    29c6:	f363 0182 	bfi	r1, r3, #2, #1
    29ca:	f363 01c5 	bfi	r1, r3, #3, #3
    29ce:	2201      	movs	r2, #1
    29d0:	f362 1188 	bfi	r1, r2, #6, #3
    29d4:	2208      	movs	r2, #8
    29d6:	f362 2152 	bfi	r1, r2, #9, #10
    29da:	f363 41de 	bfi	r1, r3, #19, #12
    29de:	f363 71df 	bfi	r1, r3, #31, #1
    29e2:	aa0c      	add	r2, sp, #48	; 0x30
    29e4:	4817      	ldr	r0, [pc, #92]	; (2a44 <ipc_service_send+0x11c>)
    29e6:	f7ff fc2f 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ENOENT;
    29ea:	f06f 0001 	mvn.w	r0, #1
    29ee:	e7ad      	b.n	294c <ipc_service_send+0x24>
		LOG_ERR("Invalid backend configuration");
    29f0:	4b16      	ldr	r3, [pc, #88]	; (2a4c <ipc_service_send+0x124>)
    29f2:	9307      	str	r3, [sp, #28]
    29f4:	2302      	movs	r3, #2
    29f6:	f88d 3004 	strb.w	r3, [sp, #4]
    29fa:	2300      	movs	r3, #0
    29fc:	f88d 3005 	strb.w	r3, [sp, #5]
    2a00:	f88d 3006 	strb.w	r3, [sp, #6]
    2a04:	f88d 3007 	strb.w	r3, [sp, #7]
    2a08:	9a01      	ldr	r2, [sp, #4]
    2a0a:	9206      	str	r2, [sp, #24]
    2a0c:	4619      	mov	r1, r3
    2a0e:	f363 0100 	bfi	r1, r3, #0, #1
    2a12:	f363 0141 	bfi	r1, r3, #1, #1
    2a16:	f363 0182 	bfi	r1, r3, #2, #1
    2a1a:	f363 01c5 	bfi	r1, r3, #3, #3
    2a1e:	2201      	movs	r2, #1
    2a20:	f362 1188 	bfi	r1, r2, #6, #3
    2a24:	2208      	movs	r2, #8
    2a26:	f362 2152 	bfi	r1, r2, #9, #10
    2a2a:	f363 41de 	bfi	r1, r3, #19, #12
    2a2e:	f363 71df 	bfi	r1, r3, #31, #1
    2a32:	aa06      	add	r2, sp, #24
    2a34:	4803      	ldr	r0, [pc, #12]	; (2a44 <ipc_service_send+0x11c>)
    2a36:	f7ff fc07 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    2a3a:	f06f 0004 	mvn.w	r0, #4
    2a3e:	e785      	b.n	294c <ipc_service_send+0x24>
    2a40:	0001d5f8 	.word	0x0001d5f8
    2a44:	0001d044 	.word	0x0001d044
    2a48:	0001d60c 	.word	0x0001d60c
    2a4c:	0001d5ac 	.word	0x0001d5ac

00002a50 <get_available_ept_slot>:

	return NULL;
}

static struct ipc_rpmsg_ept *get_available_ept_slot(struct ipc_rpmsg_instance *rpmsg_inst)
{
    2a50:	b508      	push	{r3, lr}
	return get_ept_slot_with_name(rpmsg_inst, "");
    2a52:	4902      	ldr	r1, [pc, #8]	; (2a5c <get_available_ept_slot+0xc>)
    2a54:	f014 f845 	bl	16ae2 <get_ept_slot_with_name>
}
    2a58:	bd08      	pop	{r3, pc}
    2a5a:	bf00      	nop
    2a5c:	0001d410 	.word	0x0001d410

00002a60 <advertise_ept>:
	return false;
}

static void advertise_ept(struct ipc_rpmsg_instance *rpmsg_inst, struct ipc_rpmsg_ept *rpmsg_ept,
			  const char *name, uint32_t dest)
{
    2a60:	b530      	push	{r4, r5, lr}
    2a62:	b085      	sub	sp, #20
    2a64:	4604      	mov	r4, r0
    2a66:	460d      	mov	r5, r1
	struct rpmsg_device *rdev;
	int err;

	rdev = rpmsg_virtio_get_rpmsg_device(&rpmsg_inst->rvdev);

	err = rpmsg_create_ept(&rpmsg_ept->ep, rdev, name, RPMSG_ADDR_ANY,
    2a68:	490b      	ldr	r1, [pc, #44]	; (2a98 <advertise_ept+0x38>)
    2a6a:	9102      	str	r1, [sp, #8]
    2a6c:	f8d0 1198 	ldr.w	r1, [r0, #408]	; 0x198
    2a70:	9101      	str	r1, [sp, #4]
    2a72:	9300      	str	r3, [sp, #0]
    2a74:	f04f 33ff 	mov.w	r3, #4294967295
    2a78:	f100 01e0 	add.w	r1, r0, #224	; 0xe0
    2a7c:	4628      	mov	r0, r5
    2a7e:	f010 f9cb 	bl	12e18 <rpmsg_create_ept>
			       dest, rpmsg_inst->cb, rpmsg_service_unbind);
	if (err != 0) {
    2a82:	b938      	cbnz	r0, 2a94 <advertise_ept+0x34>
		return;
	}

	rpmsg_ept->bound = true;
    2a84:	2301      	movs	r3, #1
    2a86:	f885 3064 	strb.w	r3, [r5, #100]	; 0x64
	if (rpmsg_inst->bound_cb) {
    2a8a:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
    2a8e:	b10b      	cbz	r3, 2a94 <advertise_ept+0x34>
		rpmsg_inst->bound_cb(rpmsg_ept);
    2a90:	4628      	mov	r0, r5
    2a92:	4798      	blx	r3
	}
}
    2a94:	b005      	add	sp, #20
    2a96:	bd30      	pop	{r4, r5, pc}
    2a98:	00016b3b 	.word	0x00016b3b

00002a9c <bound_cb>:
		k_mutex_unlock(&rpmsg_inst->mtx);
	}
}

static void bound_cb(struct ipc_rpmsg_ept *ept)
{
    2a9c:	b510      	push	{r4, lr}
    2a9e:	b082      	sub	sp, #8
    2aa0:	4604      	mov	r4, r0
 * Returns number of bytes it has sent or negative error value on failure.
 */
static inline int rpmsg_send(struct rpmsg_endpoint *ept, const void *data,
			     int len)
{
	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
    2aa2:	2301      	movs	r3, #1
    2aa4:	9301      	str	r3, [sp, #4]
    2aa6:	2300      	movs	r3, #0
    2aa8:	9300      	str	r3, [sp, #0]
    2aaa:	4b06      	ldr	r3, [pc, #24]	; (2ac4 <bound_cb+0x28>)
    2aac:	6a82      	ldr	r2, [r0, #40]	; 0x28
    2aae:	6a41      	ldr	r1, [r0, #36]	; 0x24
    2ab0:	f010 f950 	bl	12d54 <rpmsg_send_offchannel_raw>
	rpmsg_send(&ept->ep, (uint8_t *)"", 0);

	if (ept->cb->bound) {
    2ab4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    2ab6:	681b      	ldr	r3, [r3, #0]
    2ab8:	b10b      	cbz	r3, 2abe <bound_cb+0x22>
		ept->cb->bound(ept->priv);
    2aba:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    2abc:	4798      	blx	r3
	}
}
    2abe:	b002      	add	sp, #8
    2ac0:	bd10      	pop	{r4, pc}
    2ac2:	bf00      	nop
    2ac4:	0001d410 	.word	0x0001d410

00002ac8 <mbox_init>:

	k_work_submit_to_queue(&data->mbox_wq, &data->mbox_work);
}

static int mbox_init(const struct device *instance)
{
    2ac8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2aca:	b083      	sub	sp, #12
	const struct backend_config_t *conf = instance->config;
    2acc:	6844      	ldr	r4, [r0, #4]
	struct backend_data_t *data = instance->data;
    2ace:	6905      	ldr	r5, [r0, #16]
	int prio, err;

	prio = (conf->wq_prio_type == PRIO_COOP) ? K_PRIO_COOP(conf->wq_prio) :
    2ad0:	69e3      	ldr	r3, [r4, #28]
    2ad2:	2b01      	cmp	r3, #1
    2ad4:	d023      	beq.n	2b1e <mbox_init+0x56>
						   K_PRIO_PREEMPT(conf->wq_prio);
    2ad6:	6a27      	ldr	r7, [r4, #32]

	k_work_queue_init(&data->mbox_wq);
    2ad8:	f505 762a 	add.w	r6, r5, #680	; 0x2a8
    2adc:	4630      	mov	r0, r6
    2ade:	f019 fc47 	bl	1c370 <k_work_queue_init>
	k_work_queue_start(&data->mbox_wq, mbox_stack[conf->id], WQ_STACK_SIZE, prio, NULL);
    2ae2:	6a60      	ldr	r0, [r4, #36]	; 0x24
    2ae4:	2300      	movs	r3, #0
    2ae6:	9300      	str	r3, [sp, #0]
    2ae8:	463b      	mov	r3, r7
    2aea:	f44f 6280 	mov.w	r2, #1024	; 0x400
    2aee:	4914      	ldr	r1, [pc, #80]	; (2b40 <mbox_init+0x78>)
    2af0:	eb01 2180 	add.w	r1, r1, r0, lsl #10
    2af4:	4630      	mov	r0, r6
    2af6:	f011 fa1b 	bl	13f30 <k_work_queue_start>

	k_work_init(&data->mbox_work, mbox_callback_process);
    2afa:	4912      	ldr	r1, [pc, #72]	; (2b44 <mbox_init+0x7c>)
    2afc:	f505 7026 	add.w	r0, r5, #664	; 0x298
    2b00:	f019 fc08 	bl	1c314 <k_work_init>

	err = mbox_register_callback(&conf->mbox_rx, mbox_callback, data);
    2b04:	f104 0714 	add.w	r7, r4, #20
		(const struct mbox_driver_api *)channel->dev->api;
    2b08:	6960      	ldr	r0, [r4, #20]
	const struct mbox_driver_api *api =
    2b0a:	6883      	ldr	r3, [r0, #8]
	if (api->register_callback == NULL) {
    2b0c:	685e      	ldr	r6, [r3, #4]
    2b0e:	b14e      	cbz	r6, 2b24 <mbox_init+0x5c>
	return api->register_callback(channel->dev, channel->id, cb, user_data);
    2b10:	462b      	mov	r3, r5
    2b12:	4a0d      	ldr	r2, [pc, #52]	; (2b48 <mbox_init+0x80>)
    2b14:	6879      	ldr	r1, [r7, #4]
    2b16:	47b0      	blx	r6
	if (err != 0) {
    2b18:	b138      	cbz	r0, 2b2a <mbox_init+0x62>
		return err;
	}

	return mbox_set_enabled(&conf->mbox_rx, 1);
}
    2b1a:	b003      	add	sp, #12
    2b1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	prio = (conf->wq_prio_type == PRIO_COOP) ? K_PRIO_COOP(conf->wq_prio) :
    2b1e:	6a27      	ldr	r7, [r4, #32]
    2b20:	3f10      	subs	r7, #16
    2b22:	e7d9      	b.n	2ad8 <mbox_init+0x10>
		return -ENOSYS;
    2b24:	f06f 0057 	mvn.w	r0, #87	; 0x57
    2b28:	e7f6      	b.n	2b18 <mbox_init+0x50>
		(const struct mbox_driver_api *)channel->dev->api;
    2b2a:	6960      	ldr	r0, [r4, #20]
	const struct mbox_driver_api *api =
    2b2c:	6883      	ldr	r3, [r0, #8]
	if (api->set_enabled == NULL) {
    2b2e:	691b      	ldr	r3, [r3, #16]
    2b30:	b11b      	cbz	r3, 2b3a <mbox_init+0x72>
	return api->set_enabled(channel->dev, channel->id, enable);
    2b32:	2201      	movs	r2, #1
    2b34:	6879      	ldr	r1, [r7, #4]
    2b36:	4798      	blx	r3
    2b38:	e7ef      	b.n	2b1a <mbox_init+0x52>
		return -ENOSYS;
    2b3a:	f06f 0057 	mvn.w	r0, #87	; 0x57
	return mbox_set_enabled(&conf->mbox_rx, 1);
    2b3e:	e7ec      	b.n	2b1a <mbox_init+0x52>
    2b40:	20002c08 	.word	0x20002c08
    2b44:	00016d91 	.word	0x00016d91
    2b48:	00016d81 	.word	0x00016d81

00002b4c <open>:

	return rpmsg_send_nocopy(&rpmsg_ept->ep, msg, len);
}

static int open(const struct device *instance)
{
    2b4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2b50:	b085      	sub	sp, #20
    2b52:	4604      	mov	r4, r0
	const struct backend_config_t *conf = instance->config;
    2b54:	6846      	ldr	r6, [r0, #4]
	struct backend_data_t *data = instance->data;
    2b56:	6905      	ldr	r5, [r0, #16]
	struct ipc_rpmsg_instance *rpmsg_inst;
	struct rpmsg_device *rdev;
	int err;

	if (!atomic_cas(&data->state, STATE_READY, STATE_BUSY)) {
    2b58:	f505 7961 	add.w	r9, r5, #900	; 0x384
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    2b5c:	2301      	movs	r3, #1
    2b5e:	e8d9 2fef 	ldaex	r2, [r9]
    2b62:	2a00      	cmp	r2, #0
    2b64:	d103      	bne.n	2b6e <open+0x22>
    2b66:	e8c9 3fe1 	stlex	r1, r3, [r9]
    2b6a:	2900      	cmp	r1, #0
    2b6c:	d1f7      	bne.n	2b5e <open+0x12>
    2b6e:	d152      	bne.n	2c16 <open+0xca>
		return -EALREADY;
	}

	err = vr_shm_configure(&data->vr, conf);
    2b70:	f505 78d8 	add.w	r8, r5, #432	; 0x1b0
    2b74:	4631      	mov	r1, r6
    2b76:	4640      	mov	r0, r8
    2b78:	f014 f8af 	bl	16cda <vr_shm_configure>
	if (err != 0) {
    2b7c:	4607      	mov	r7, r0
    2b7e:	b150      	cbz	r0, 2b96 <open+0x4a>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    2b80:	2300      	movs	r3, #0
    2b82:	e8d9 2fef 	ldaex	r2, [r9]
    2b86:	e8c9 3fe1 	stlex	r1, r3, [r9]
    2b8a:	2900      	cmp	r1, #0
    2b8c:	d1f9      	bne.n	2b82 <open+0x36>
error:
	/* Back to the ready state */
	atomic_set(&data->state, STATE_READY);
	return err;

}
    2b8e:	4638      	mov	r0, r7
    2b90:	b005      	add	sp, #20
    2b92:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->vr.notify_cb = virtio_notify_cb;
    2b96:	4b21      	ldr	r3, [pc, #132]	; (2c1c <open+0xd0>)
    2b98:	f8c5 3290 	str.w	r3, [r5, #656]	; 0x290
	data->vr.priv = (void *) conf;
    2b9c:	f8c5 628c 	str.w	r6, [r5, #652]	; 0x28c
	err = ipc_static_vrings_init(&data->vr, conf->role);
    2ba0:	6831      	ldr	r1, [r6, #0]
    2ba2:	4640      	mov	r0, r8
    2ba4:	f000 f9a2 	bl	2eec <ipc_static_vrings_init>
	if (err != 0) {
    2ba8:	4607      	mov	r7, r0
    2baa:	2800      	cmp	r0, #0
    2bac:	d1e8      	bne.n	2b80 <open+0x34>
	err = mbox_init(instance);
    2bae:	4620      	mov	r0, r4
    2bb0:	f7ff ff8a 	bl	2ac8 <mbox_init>
	if (err != 0) {
    2bb4:	4607      	mov	r7, r0
    2bb6:	2800      	cmp	r0, #0
    2bb8:	d1e2      	bne.n	2b80 <open+0x34>
	rpmsg_inst->bound_cb = bound_cb;
    2bba:	4b19      	ldr	r3, [pc, #100]	; (2c20 <open+0xd4>)
    2bbc:	f8c5 3194 	str.w	r3, [r5, #404]	; 0x194
	rpmsg_inst->cb = ept_cb;
    2bc0:	4b18      	ldr	r3, [pc, #96]	; (2c24 <open+0xd8>)
    2bc2:	f8c5 3198 	str.w	r3, [r5, #408]	; 0x198
	err = ipc_rpmsg_init(rpmsg_inst, data->role, conf->buffer_size,
    2bc6:	f8d5 3250 	ldr.w	r3, [r5, #592]	; 0x250
    2bca:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    2bcc:	f8d5 1380 	ldr.w	r1, [r5, #896]	; 0x380
    2bd0:	4815      	ldr	r0, [pc, #84]	; (2c28 <open+0xdc>)
    2bd2:	9003      	str	r0, [sp, #12]
    2bd4:	f8d5 01f8 	ldr.w	r0, [r5, #504]	; 0x1f8
    2bd8:	9002      	str	r0, [sp, #8]
    2bda:	f8d5 01f0 	ldr.w	r0, [r5, #496]	; 0x1f0
    2bde:	9001      	str	r0, [sp, #4]
    2be0:	f8cd 8000 	str.w	r8, [sp]
    2be4:	4628      	mov	r0, r5
    2be6:	f000 f8cb 	bl	2d80 <ipc_rpmsg_init>
	if (err != 0) {
    2bea:	4607      	mov	r7, r0
    2bec:	2800      	cmp	r0, #0
    2bee:	d1c7      	bne.n	2b80 <open+0x34>
	data->tx_buffer_size = rpmsg_virtio_get_buffer_size(rdev);
    2bf0:	f105 00e0 	add.w	r0, r5, #224	; 0xe0
    2bf4:	f010 f9c6 	bl	12f84 <rpmsg_virtio_get_buffer_size>
    2bf8:	f8c5 0388 	str.w	r0, [r5, #904]	; 0x388
	if (data->tx_buffer_size < 0) {
    2bfc:	2800      	cmp	r0, #0
    2bfe:	db07      	blt.n	2c10 <open+0xc4>
    2c00:	2302      	movs	r3, #2
    2c02:	e8d9 2fef 	ldaex	r2, [r9]
    2c06:	e8c9 3fe1 	stlex	r1, r3, [r9]
    2c0a:	2900      	cmp	r1, #0
    2c0c:	d0bf      	beq.n	2b8e <open+0x42>
    2c0e:	e7f8      	b.n	2c02 <open+0xb6>
		err = -EINVAL;
    2c10:	f06f 0715 	mvn.w	r7, #21
    2c14:	e7b4      	b.n	2b80 <open+0x34>
		return -EALREADY;
    2c16:	f06f 0777 	mvn.w	r7, #119	; 0x77
    2c1a:	e7b8      	b.n	2b8e <open+0x42>
    2c1c:	000169bf 	.word	0x000169bf
    2c20:	00002a9d 	.word	0x00002a9d
    2c24:	00016cad 	.word	0x00016cad
    2c28:	00016bb5 	.word	0x00016bb5

00002c2c <shared_memory_prepare>:

#define BACKEND_CONFIG_DEFINE(i) BACKEND_CONFIG_POPULATE(i),

#if defined(CONFIG_IPC_SERVICE_BACKEND_RPMSG_SHMEM_RESET)
static int shared_memory_prepare(const struct device *arg)
{
    2c2c:	b510      	push	{r4, lr}
    2c2e:	b08c      	sub	sp, #48	; 0x30
	const struct backend_config_t *backend_config;
	const struct backend_config_t backend_configs[] = {
    2c30:	f10d 0c04 	add.w	ip, sp, #4
    2c34:	4c0d      	ldr	r4, [pc, #52]	; (2c6c <shared_memory_prepare+0x40>)
    2c36:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2c38:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2c3c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    2c3e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    2c42:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    2c46:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		DT_INST_FOREACH_STATUS_OKAY(BACKEND_CONFIG_DEFINE)
	};

	for (backend_config = backend_configs;
    2c4a:	ac01      	add	r4, sp, #4
    2c4c:	ab0c      	add	r3, sp, #48	; 0x30
    2c4e:	429c      	cmp	r4, r3
    2c50:	d302      	bcc.n	2c58 <shared_memory_prepare+0x2c>
			memset((void *) backend_config->shm_addr, 0, VDEV_STATUS_SIZE);
		}
	}

	return 0;
}
    2c52:	2000      	movs	r0, #0
    2c54:	b00c      	add	sp, #48	; 0x30
    2c56:	bd10      	pop	{r4, pc}
		if (backend_config->role == ROLE_HOST) {
    2c58:	6823      	ldr	r3, [r4, #0]
    2c5a:	b10b      	cbz	r3, 2c60 <shared_memory_prepare+0x34>
	     backend_config++) {
    2c5c:	342c      	adds	r4, #44	; 0x2c
    2c5e:	e7f5      	b.n	2c4c <shared_memory_prepare+0x20>
			memset((void *) backend_config->shm_addr, 0, VDEV_STATUS_SIZE);
    2c60:	2204      	movs	r2, #4
    2c62:	2100      	movs	r1, #0
    2c64:	6860      	ldr	r0, [r4, #4]
    2c66:	f014 fd92 	bl	1778e <memset>
    2c6a:	e7f7      	b.n	2c5c <shared_memory_prepare+0x30>
    2c6c:	0001d124 	.word	0x0001d124

00002c70 <send>:
{
    2c70:	b510      	push	{r4, lr}
    2c72:	b082      	sub	sp, #8
    2c74:	460c      	mov	r4, r1
	struct backend_data_t *data = instance->data;
    2c76:	6901      	ldr	r1, [r0, #16]
	if (atomic_get(&data->state) != STATE_INITED) {
    2c78:	f501 7161 	add.w	r1, r1, #900	; 0x384
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    2c7c:	e8d1 1faf 	lda	r1, [r1]
    2c80:	2902      	cmp	r1, #2
    2c82:	d10f      	bne.n	2ca4 <send+0x34>
	if (len == 0) {
    2c84:	b18b      	cbz	r3, 2caa <send+0x3a>
	if (!rpmsg_ept) {
    2c86:	b19c      	cbz	r4, 2cb0 <send+0x40>
    2c88:	2101      	movs	r1, #1
    2c8a:	9101      	str	r1, [sp, #4]
    2c8c:	9300      	str	r3, [sp, #0]
    2c8e:	4613      	mov	r3, r2
    2c90:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    2c92:	6a61      	ldr	r1, [r4, #36]	; 0x24
    2c94:	4620      	mov	r0, r4
    2c96:	f010 f85d 	bl	12d54 <rpmsg_send_offchannel_raw>
	if (ret == RPMSG_ERR_NO_BUFF) {
    2c9a:	4b08      	ldr	r3, [pc, #32]	; (2cbc <send+0x4c>)
    2c9c:	4298      	cmp	r0, r3
    2c9e:	d00a      	beq.n	2cb6 <send+0x46>
}
    2ca0:	b002      	add	sp, #8
    2ca2:	bd10      	pop	{r4, pc}
		return -EBUSY;
    2ca4:	f06f 000f 	mvn.w	r0, #15
    2ca8:	e7fa      	b.n	2ca0 <send+0x30>
		return -EBADMSG;
    2caa:	f06f 004c 	mvn.w	r0, #76	; 0x4c
    2cae:	e7f7      	b.n	2ca0 <send+0x30>
		return -ENOENT;
    2cb0:	f06f 0001 	mvn.w	r0, #1
    2cb4:	e7f4      	b.n	2ca0 <send+0x30>
		return -ENOMEM;
    2cb6:	f06f 000b 	mvn.w	r0, #11
    2cba:	e7f1      	b.n	2ca0 <send+0x30>
    2cbc:	fffff82e 	.word	0xfffff82e

00002cc0 <ns_bind_cb>:
{
	rpmsg_destroy_ept(ep);
}

static void ns_bind_cb(struct rpmsg_device *rdev, const char *name, uint32_t dest)
{
    2cc0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2cc4:	b085      	sub	sp, #20
    2cc6:	4607      	mov	r7, r0
    2cc8:	460e      	mov	r6, r1
    2cca:	4691      	mov	r9, r2
	struct ipc_rpmsg_instance *instance;
	struct ipc_rpmsg_ept *ept;
	int err;

	p_rvdev = CONTAINER_OF(rdev, struct rpmsg_virtio_device, rdev);
	instance = CONTAINER_OF(p_rvdev->shpool, struct ipc_rpmsg_instance, shm_pool);
    2ccc:	f8d0 80a4 	ldr.w	r8, [r0, #164]	; 0xa4

	for (size_t i = 0; i < NUM_ENDPOINTS; i++) {
    2cd0:	2400      	movs	r4, #0
    2cd2:	e000      	b.n	2cd6 <ns_bind_cb+0x16>
    2cd4:	3401      	adds	r4, #1
    2cd6:	2c01      	cmp	r4, #1
    2cd8:	d828      	bhi.n	2d2c <ns_bind_cb+0x6c>
		ept = &instance->endpoint[i];
    2cda:	f5a8 71c4 	sub.w	r1, r8, #392	; 0x188
    2cde:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
    2ce2:	eb01 1505 	add.w	r5, r1, r5, lsl #4

		if (strcmp(name, ept->name) == 0) {
    2ce6:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
    2cea:	011b      	lsls	r3, r3, #4
    2cec:	3340      	adds	r3, #64	; 0x40
    2cee:	4419      	add	r1, r3
    2cf0:	4630      	mov	r0, r6
    2cf2:	f014 fced 	bl	176d0 <strcmp>
    2cf6:	2800      	cmp	r0, #0
    2cf8:	d1ec      	bne.n	2cd4 <ns_bind_cb+0x14>
			 * The destination address is 'dest' so ns_bind_cb() is
			 * *NOT* called on the REMOTE side. The bound_cb()
			 * function will eventually take care of notifying the
			 * REMOTE side if needed.
			 */
			err = rpmsg_create_ept(&ept->ep, rdev, name, RPMSG_ADDR_ANY,
    2cfa:	4b0e      	ldr	r3, [pc, #56]	; (2d34 <ns_bind_cb+0x74>)
    2cfc:	9302      	str	r3, [sp, #8]
    2cfe:	f8d8 3010 	ldr.w	r3, [r8, #16]
    2d02:	9301      	str	r3, [sp, #4]
    2d04:	f8cd 9000 	str.w	r9, [sp]
    2d08:	f04f 33ff 	mov.w	r3, #4294967295
    2d0c:	4632      	mov	r2, r6
    2d0e:	4639      	mov	r1, r7
    2d10:	4628      	mov	r0, r5
    2d12:	f010 f881 	bl	12e18 <rpmsg_create_ept>
					       dest, instance->cb, rpmsg_service_unbind);
			if (err != 0) {
    2d16:	b948      	cbnz	r0, 2d2c <ns_bind_cb+0x6c>
				return;
			}

			ept->bound = true;
    2d18:	2101      	movs	r1, #1
    2d1a:	f885 1064 	strb.w	r1, [r5, #100]	; 0x64
			if (instance->bound_cb) {
    2d1e:	f8d8 300c 	ldr.w	r3, [r8, #12]
    2d22:	2b00      	cmp	r3, #0
    2d24:	d0d6      	beq.n	2cd4 <ns_bind_cb+0x14>
				instance->bound_cb(ept);
    2d26:	4628      	mov	r0, r5
    2d28:	4798      	blx	r3
    2d2a:	e7d3      	b.n	2cd4 <ns_bind_cb+0x14>
			}
		}
	}
}
    2d2c:	b005      	add	sp, #20
    2d2e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2d32:	bf00      	nop
    2d34:	00016dd7 	.word	0x00016dd7

00002d38 <ipc_rpmsg_register_ept>:
int ipc_rpmsg_register_ept(struct ipc_rpmsg_instance *instance, unsigned int role,
			   struct ipc_rpmsg_ept *ept)
{
	struct rpmsg_device *rdev;

	if (!instance || !ept) {
    2d38:	b1c8      	cbz	r0, 2d6e <ipc_rpmsg_register_ept+0x36>
{
    2d3a:	b510      	push	{r4, lr}
    2d3c:	b084      	sub	sp, #16
    2d3e:	4614      	mov	r4, r2
    2d40:	4603      	mov	r3, r0
	if (!instance || !ept) {
    2d42:	b1ba      	cbz	r2, 2d74 <ipc_rpmsg_register_ept+0x3c>
 * @return - RPMsg device pointed by RPMsg virtio device
 */
static inline struct rpmsg_device *
rpmsg_virtio_get_rpmsg_device(struct rpmsg_virtio_device *rvdev)
{
	return &rvdev->rdev;
    2d44:	30e0      	adds	r0, #224	; 0xe0
		return -EINVAL;
	}

	rdev = rpmsg_virtio_get_rpmsg_device(&instance->rvdev);

	if (role == RPMSG_REMOTE) {
    2d46:	2901      	cmp	r1, #1
    2d48:	d002      	beq.n	2d50 <ipc_rpmsg_register_ept+0x18>
		 */
		return rpmsg_create_ept(&ept->ep, rdev, ept->name, RPMSG_ADDR_ANY,
					RPMSG_ADDR_ANY, instance->cb, rpmsg_service_unbind);
	}

	return RPMSG_SUCCESS;
    2d4a:	2000      	movs	r0, #0
}
    2d4c:	b004      	add	sp, #16
    2d4e:	bd10      	pop	{r4, pc}
		return rpmsg_create_ept(&ept->ep, rdev, ept->name, RPMSG_ADDR_ANY,
    2d50:	4a0a      	ldr	r2, [pc, #40]	; (2d7c <ipc_rpmsg_register_ept+0x44>)
    2d52:	9202      	str	r2, [sp, #8]
    2d54:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
    2d58:	9301      	str	r3, [sp, #4]
    2d5a:	f04f 33ff 	mov.w	r3, #4294967295
    2d5e:	9300      	str	r3, [sp, #0]
    2d60:	f104 0240 	add.w	r2, r4, #64	; 0x40
    2d64:	4601      	mov	r1, r0
    2d66:	4620      	mov	r0, r4
    2d68:	f010 f856 	bl	12e18 <rpmsg_create_ept>
    2d6c:	e7ee      	b.n	2d4c <ipc_rpmsg_register_ept+0x14>
		return -EINVAL;
    2d6e:	f06f 0015 	mvn.w	r0, #21
}
    2d72:	4770      	bx	lr
		return -EINVAL;
    2d74:	f06f 0015 	mvn.w	r0, #21
    2d78:	e7e8      	b.n	2d4c <ipc_rpmsg_register_ept+0x14>
    2d7a:	bf00      	nop
    2d7c:	00016dd7 	.word	0x00016dd7

00002d80 <ipc_rpmsg_init>:
		   unsigned int buffer_size,
		   struct metal_io_region *shm_io,
		   struct virtio_device *vdev,
		   void *shb, size_t size,
		   rpmsg_ns_bind_cb p_bind_cb)
{
    2d80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2d84:	b084      	sub	sp, #16
    2d86:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    2d88:	9c0d      	ldr	r4, [sp, #52]	; 0x34
	rpmsg_ns_bind_cb bind_cb = p_bind_cb;

	if (!instance || !shb) {
    2d8a:	b338      	cbz	r0, 2ddc <ipc_rpmsg_init+0x5c>
    2d8c:	461f      	mov	r7, r3
    2d8e:	4606      	mov	r6, r0
    2d90:	b33d      	cbz	r5, 2de2 <ipc_rpmsg_init+0x62>
		return -EINVAL;
	}

	if (p_bind_cb == NULL) {
    2d92:	b1bc      	cbz	r4, 2dc4 <ipc_rpmsg_init+0x44>
		bind_cb = ns_bind_cb;
	}

	if (role == RPMSG_HOST) {
    2d94:	b9c1      	cbnz	r1, 2dc8 <ipc_rpmsg_init+0x48>
		struct rpmsg_virtio_config config;

		config.h2r_buf_size = (uint32_t) buffer_size;
    2d96:	9202      	str	r2, [sp, #8]
		config.r2h_buf_size = (uint32_t) buffer_size;
    2d98:	9203      	str	r2, [sp, #12]

		rpmsg_virtio_init_shm_pool(&instance->shm_pool, shb, size);
    2d9a:	f506 78c4 	add.w	r8, r6, #392	; 0x188
    2d9e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    2da0:	4629      	mov	r1, r5
    2da2:	4640      	mov	r0, r8
    2da4:	f019 f80e 	bl	1bdc4 <rpmsg_virtio_init_shm_pool>

		return rpmsg_init_vdev_with_config(&instance->rvdev, vdev, bind_cb,
    2da8:	ab02      	add	r3, sp, #8
    2daa:	9301      	str	r3, [sp, #4]
    2dac:	f8cd 8000 	str.w	r8, [sp]
    2db0:	463b      	mov	r3, r7
    2db2:	4622      	mov	r2, r4
    2db4:	990a      	ldr	r1, [sp, #40]	; 0x28
    2db6:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
    2dba:	f010 f8fd 	bl	12fb8 <rpmsg_init_vdev_with_config>
						   shm_io, &instance->shm_pool,
						   &config);
	} else {
		return rpmsg_init_vdev(&instance->rvdev, vdev, bind_cb, shm_io, NULL);
	}
}
    2dbe:	b004      	add	sp, #16
    2dc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bind_cb = ns_bind_cb;
    2dc4:	4c08      	ldr	r4, [pc, #32]	; (2de8 <ipc_rpmsg_init+0x68>)
    2dc6:	e7e5      	b.n	2d94 <ipc_rpmsg_init+0x14>
		return rpmsg_init_vdev(&instance->rvdev, vdev, bind_cb, shm_io, NULL);
    2dc8:	2300      	movs	r3, #0
    2dca:	9300      	str	r3, [sp, #0]
    2dcc:	463b      	mov	r3, r7
    2dce:	4622      	mov	r2, r4
    2dd0:	990a      	ldr	r1, [sp, #40]	; 0x28
    2dd2:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
    2dd6:	f010 f9f1 	bl	131bc <rpmsg_init_vdev>
    2dda:	e7f0      	b.n	2dbe <ipc_rpmsg_init+0x3e>
		return -EINVAL;
    2ddc:	f06f 0015 	mvn.w	r0, #21
    2de0:	e7ed      	b.n	2dbe <ipc_rpmsg_init+0x3e>
    2de2:	f06f 0015 	mvn.w	r0, #21
    2de6:	e7ea      	b.n	2dbe <ipc_rpmsg_init+0x3e>
    2de8:	00002cc1 	.word	0x00002cc1

00002dec <libmetal_setup>:
	.set_features = virtio_set_features,
	.notify = virtio_notify,
};

static int libmetal_setup(struct ipc_static_vrings *vr)
{
    2dec:	b510      	push	{r4, lr}
    2dee:	b084      	sub	sp, #16
    2df0:	4604      	mov	r4, r0
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
    2df2:	4a11      	ldr	r2, [pc, #68]	; (2e38 <libmetal_setup+0x4c>)
    2df4:	ab02      	add	r3, sp, #8
    2df6:	e892 0003 	ldmia.w	r2, {r0, r1}
    2dfa:	e883 0003 	stmia.w	r3, {r0, r1}
	struct metal_device *device;
	int err;

	err = metal_init(&metal_params);
    2dfe:	4618      	mov	r0, r3
    2e00:	f00f fec6 	bl	12b90 <metal_init>
	if (err != 0) {
    2e04:	b108      	cbz	r0, 2e0a <libmetal_setup+0x1e>
	if (vr->shm_io == NULL) {
		return err;
	}

	return 0;
}
    2e06:	b004      	add	sp, #16
    2e08:	bd10      	pop	{r4, pc}
	err = metal_register_generic_device(&vr->shm_device);
    2e0a:	f104 0034 	add.w	r0, r4, #52	; 0x34
    2e0e:	f00f fe9f 	bl	12b50 <metal_register_generic_device>
	if (err != 0) {
    2e12:	2800      	cmp	r0, #0
    2e14:	d1f7      	bne.n	2e06 <libmetal_setup+0x1a>
	err = metal_device_open("generic", SHM_DEVICE_NAME, &device);
    2e16:	aa01      	add	r2, sp, #4
    2e18:	4908      	ldr	r1, [pc, #32]	; (2e3c <libmetal_setup+0x50>)
    2e1a:	4809      	ldr	r0, [pc, #36]	; (2e40 <libmetal_setup+0x54>)
    2e1c:	f018 f98c 	bl	1b138 <metal_device_open>
	if (err != 0) {
    2e20:	2800      	cmp	r0, #0
    2e22:	d1f0      	bne.n	2e06 <libmetal_setup+0x1a>
	vr->shm_io = metal_device_io_region(device, 0);
    2e24:	9b01      	ldr	r3, [sp, #4]
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned int index)
{
	return (index < device->num_regions
    2e26:	689a      	ldr	r2, [r3, #8]
		? &device->regions[index]
		: NULL);
    2e28:	b11a      	cbz	r2, 2e32 <libmetal_setup+0x46>
    2e2a:	330c      	adds	r3, #12
    2e2c:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	if (vr->shm_io == NULL) {
    2e30:	e7e9      	b.n	2e06 <libmetal_setup+0x1a>
    2e32:	2300      	movs	r3, #0
    2e34:	e7fa      	b.n	2e2c <libmetal_setup+0x40>
    2e36:	bf00      	nop
    2e38:	0001d150 	.word	0x0001d150
    2e3c:	0001d660 	.word	0x0001d660
    2e40:	0001d66c 	.word	0x0001d66c

00002e44 <vq_setup>:

static int vq_setup(struct ipc_static_vrings *vr, unsigned int role)
{
    2e44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e46:	4604      	mov	r4, r0
    2e48:	460e      	mov	r6, r1
	vr->vq[RPMSG_VQ_0] = virtqueue_allocate(vr->vring_size);
    2e4a:	f8d0 5094 	ldr.w	r5, [r0, #148]	; 0x94

static inline struct virtqueue *virtqueue_allocate(unsigned int num_desc_extra)
{
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
		 num_desc_extra * sizeof(struct vq_desc_extra);
    2e4e:	00ed      	lsls	r5, r5, #3
	uint32_t vq_size = sizeof(struct virtqueue) +
    2e50:	3534      	adds	r5, #52	; 0x34
#endif

#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
static inline void *metal_allocate_memory(unsigned int size)
{
	return k_malloc(size);
    2e52:	4628      	mov	r0, r5
    2e54:	f019 fe72 	bl	1cb3c <k_malloc>

	vqs = (struct virtqueue *)metal_allocate_memory(vq_size);
	if (vqs) {
    2e58:	4607      	mov	r7, r0
    2e5a:	b118      	cbz	r0, 2e64 <vq_setup+0x20>
		memset(vqs, 0x00, vq_size);
    2e5c:	462a      	mov	r2, r5
    2e5e:	2100      	movs	r1, #0
    2e60:	f014 fc95 	bl	1778e <memset>
    2e64:	f8c4 70d4 	str.w	r7, [r4, #212]	; 0xd4
	if (vr->vq[RPMSG_VQ_0] == NULL) {
    2e68:	b3c7      	cbz	r7, 2edc <vq_setup+0x98>
		return -ENOMEM;
	}

	vr->vq[RPMSG_VQ_1] = virtqueue_allocate(vr->vring_size);
    2e6a:	f8d4 5094 	ldr.w	r5, [r4, #148]	; 0x94
		 num_desc_extra * sizeof(struct vq_desc_extra);
    2e6e:	00ed      	lsls	r5, r5, #3
	uint32_t vq_size = sizeof(struct virtqueue) +
    2e70:	3534      	adds	r5, #52	; 0x34
    2e72:	4628      	mov	r0, r5
    2e74:	f019 fe62 	bl	1cb3c <k_malloc>
	if (vqs) {
    2e78:	4607      	mov	r7, r0
    2e7a:	b118      	cbz	r0, 2e84 <vq_setup+0x40>
		memset(vqs, 0x00, vq_size);
    2e7c:	462a      	mov	r2, r5
    2e7e:	2100      	movs	r1, #0
    2e80:	f014 fc85 	bl	1778e <memset>
    2e84:	f8c4 70d8 	str.w	r7, [r4, #216]	; 0xd8
	if (vr->vq[RPMSG_VQ_1] == NULL) {
    2e88:	b35f      	cbz	r7, 2ee2 <vq_setup+0x9e>
		return -ENOMEM;
	}

	vr->rvrings[RPMSG_VQ_0].io = vr->shm_io;
    2e8a:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
    2e8e:	f8c4 10b8 	str.w	r1, [r4, #184]	; 0xb8
	vr->rvrings[RPMSG_VQ_0].info.vaddr = (void *) vr->tx_addr;
    2e92:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
    2e96:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	vr->rvrings[RPMSG_VQ_0].info.num_descs = vr->vring_size;
    2e9a:	f8b4 2094 	ldrh.w	r2, [r4, #148]	; 0x94
    2e9e:	f8a4 20b0 	strh.w	r2, [r4, #176]	; 0xb0
	vr->rvrings[RPMSG_VQ_0].info.align = VRING_ALIGNMENT;
    2ea2:	2304      	movs	r3, #4
    2ea4:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
	vr->rvrings[RPMSG_VQ_0].vq = vr->vq[RPMSG_VQ_0];
    2ea8:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
    2eac:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4

	vr->rvrings[RPMSG_VQ_1].io = vr->shm_io;
    2eb0:	f8c4 10d0 	str.w	r1, [r4, #208]	; 0xd0
	vr->rvrings[RPMSG_VQ_1].info.vaddr = (void *) vr->rx_addr;
    2eb4:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
    2eb8:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	vr->rvrings[RPMSG_VQ_1].info.num_descs = vr->vring_size;
    2ebc:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
	vr->rvrings[RPMSG_VQ_1].info.align = VRING_ALIGNMENT;
    2ec0:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	vr->rvrings[RPMSG_VQ_1].vq = vr->vq[RPMSG_VQ_1];
    2ec4:	f8c4 70bc 	str.w	r7, [r4, #188]	; 0xbc

	vr->vdev.role = role;
    2ec8:	61a6      	str	r6, [r4, #24]

	vr->vdev.vrings_num = VRING_COUNT;
    2eca:	2302      	movs	r3, #2
    2ecc:	62a3      	str	r3, [r4, #40]	; 0x28
	vr->vdev.func = &dispatch;
    2ece:	4b06      	ldr	r3, [pc, #24]	; (2ee8 <vq_setup+0xa4>)
    2ed0:	6223      	str	r3, [r4, #32]
	vr->vdev.vrings_info = &vr->rvrings[0];
    2ed2:	f104 03a4 	add.w	r3, r4, #164	; 0xa4
    2ed6:	62e3      	str	r3, [r4, #44]	; 0x2c

	return 0;
    2ed8:	2000      	movs	r0, #0
}
    2eda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOMEM;
    2edc:	f06f 000b 	mvn.w	r0, #11
    2ee0:	e7fb      	b.n	2eda <vq_setup+0x96>
		return -ENOMEM;
    2ee2:	f06f 000b 	mvn.w	r0, #11
    2ee6:	e7f8      	b.n	2eda <vq_setup+0x96>
    2ee8:	0001d674 	.word	0x0001d674

00002eec <ipc_static_vrings_init>:

int ipc_static_vrings_init(struct ipc_static_vrings *vr, unsigned int role)
{
	int err = 0;

	if (!vr) {
    2eec:	b310      	cbz	r0, 2f34 <ipc_static_vrings_init+0x48>
{
    2eee:	b530      	push	{r4, r5, lr}
    2ef0:	b085      	sub	sp, #20
    2ef2:	460d      	mov	r5, r1
    2ef4:	4604      	mov	r4, r0
		return -EINVAL;
	}

	vr->shm_device.name = SHM_DEVICE_NAME;
    2ef6:	4b11      	ldr	r3, [pc, #68]	; (2f3c <ipc_static_vrings_init+0x50>)
    2ef8:	6343      	str	r3, [r0, #52]	; 0x34
	vr->shm_device.num_regions = 1;
    2efa:	2301      	movs	r3, #1
    2efc:	63c3      	str	r3, [r0, #60]	; 0x3c
	vr->shm_physmap[0] = vr->shm_addr;
    2efe:	f8d0 1098 	ldr.w	r1, [r0, #152]	; 0x98
    2f02:	6301      	str	r1, [r0, #48]	; 0x30

	metal_io_init(vr->shm_device.regions, (void *) vr->shm_addr,
    2f04:	2300      	movs	r3, #0
    2f06:	9302      	str	r3, [sp, #8]
    2f08:	9301      	str	r3, [sp, #4]
    2f0a:	f04f 33ff 	mov.w	r3, #4294967295
    2f0e:	9300      	str	r3, [sp, #0]
    2f10:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
    2f14:	f100 0230 	add.w	r2, r0, #48	; 0x30
    2f18:	3040      	adds	r0, #64	; 0x40
    2f1a:	f018 f932 	bl	1b182 <metal_io_init>
		      vr->shm_physmap, vr->shm_size, -1, 0, NULL);

	err = libmetal_setup(vr);
    2f1e:	4620      	mov	r0, r4
    2f20:	f7ff ff64 	bl	2dec <libmetal_setup>
	if (err != 0) {
    2f24:	b108      	cbz	r0, 2f2a <ipc_static_vrings_init+0x3e>
		return err;
	}

	return vq_setup(vr, role);
}
    2f26:	b005      	add	sp, #20
    2f28:	bd30      	pop	{r4, r5, pc}
	return vq_setup(vr, role);
    2f2a:	4629      	mov	r1, r5
    2f2c:	4620      	mov	r0, r4
    2f2e:	f7ff ff89 	bl	2e44 <vq_setup>
    2f32:	e7f8      	b.n	2f26 <ipc_static_vrings_init+0x3a>
		return -EINVAL;
    2f34:	f06f 0015 	mvn.w	r0, #21
}
    2f38:	4770      	bx	lr
    2f3a:	bf00      	nop
    2f3c:	0001d660 	.word	0x0001d660

00002f40 <pm_system_resume>:
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}

void pm_system_resume(void)
{
    2f40:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
    2f42:	4b28      	ldr	r3, [pc, #160]	; (2fe4 <pm_system_resume+0xa4>)
    2f44:	7d1d      	ldrb	r5, [r3, #20]
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    2f46:	f005 031f 	and.w	r3, r5, #31
    2f4a:	2201      	movs	r2, #1
    2f4c:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    2f4e:	0969      	lsrs	r1, r5, #5
    2f50:	4b25      	ldr	r3, [pc, #148]	; (2fe8 <pm_system_resume+0xa8>)
    2f52:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    2f56:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    2f58:	e8d3 1fef 	ldaex	r1, [r3]
    2f5c:	ea01 0400 	and.w	r4, r1, r0
    2f60:	e8c3 4fe6 	stlex	r6, r4, [r3]
    2f64:	2e00      	cmp	r6, #0
    2f66:	d1f7      	bne.n	2f58 <pm_system_resume+0x18>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    2f68:	420a      	tst	r2, r1
    2f6a:	d100      	bne.n	2f6e <pm_system_resume+0x2e>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
			0, 0};
	}
}
    2f6c:	bd70      	pop	{r4, r5, r6, pc}
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
    2f6e:	481f      	ldr	r0, [pc, #124]	; (2fec <pm_system_resume+0xac>)
    2f70:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    2f74:	0093      	lsls	r3, r2, #2
    2f76:	18c1      	adds	r1, r0, r3
	if (pm_state_exit_post_ops != NULL) {
    2f78:	4a1d      	ldr	r2, [pc, #116]	; (2ff0 <pm_system_resume+0xb0>)
    2f7a:	b172      	cbz	r2, 2f9a <pm_system_resume+0x5a>
		pm_state_exit_post_ops(info->state, info->substate_id);
    2f7c:	7849      	ldrb	r1, [r1, #1]
    2f7e:	5cc0      	ldrb	r0, [r0, r3]
    2f80:	f013 fc32 	bl	167e8 <pm_state_exit_post_ops>
	__asm__ volatile(
    2f84:	f04f 0320 	mov.w	r3, #32
    2f88:	f3ef 8611 	mrs	r6, BASEPRI
    2f8c:	f383 8812 	msr	BASEPRI_MAX, r3
    2f90:	f3bf 8f6f 	isb	sy
    2f94:	4b17      	ldr	r3, [pc, #92]	; (2ff4 <pm_system_resume+0xb4>)
    2f96:	681c      	ldr	r4, [r3, #0]
    2f98:	e010      	b.n	2fbc <pm_system_resume+0x7c>
	__asm__ volatile(
    2f9a:	2300      	movs	r3, #0
    2f9c:	f383 8811 	msr	BASEPRI, r3
    2fa0:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    2fa4:	e7ee      	b.n	2f84 <pm_system_resume+0x44>
			callback(z_cpus_pm_state[_current_cpu->id].state);
    2fa6:	4b0f      	ldr	r3, [pc, #60]	; (2fe4 <pm_system_resume+0xa4>)
    2fa8:	7d1b      	ldrb	r3, [r3, #20]
    2faa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2fae:	0099      	lsls	r1, r3, #2
    2fb0:	4b0e      	ldr	r3, [pc, #56]	; (2fec <pm_system_resume+0xac>)
    2fb2:	5c58      	ldrb	r0, [r3, r1]
    2fb4:	4790      	blx	r2
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    2fb6:	b10c      	cbz	r4, 2fbc <pm_system_resume+0x7c>
	return node->next;
    2fb8:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2fba:	b124      	cbz	r4, 2fc6 <pm_system_resume+0x86>
    2fbc:	b11c      	cbz	r4, 2fc6 <pm_system_resume+0x86>
			callback = notifier->state_exit;
    2fbe:	68a2      	ldr	r2, [r4, #8]
		if (callback) {
    2fc0:	2a00      	cmp	r2, #0
    2fc2:	d1f0      	bne.n	2fa6 <pm_system_resume+0x66>
    2fc4:	e7f7      	b.n	2fb6 <pm_system_resume+0x76>
	__asm__ volatile(
    2fc6:	f386 8811 	msr	BASEPRI, r6
    2fca:	f3bf 8f6f 	isb	sy
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    2fce:	4807      	ldr	r0, [pc, #28]	; (2fec <pm_system_resume+0xac>)
    2fd0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    2fd4:	00aa      	lsls	r2, r5, #2
    2fd6:	1881      	adds	r1, r0, r2
    2fd8:	2300      	movs	r3, #0
    2fda:	5083      	str	r3, [r0, r2]
    2fdc:	604b      	str	r3, [r1, #4]
    2fde:	608b      	str	r3, [r1, #8]
}
    2fe0:	e7c4      	b.n	2f6c <pm_system_resume+0x2c>
    2fe2:	bf00      	nop
    2fe4:	200026d8 	.word	0x200026d8
    2fe8:	20001c74 	.word	0x20001c74
    2fec:	20001c68 	.word	0x20001c68
    2ff0:	000167e9 	.word	0x000167e9
    2ff4:	20001c54 	.word	0x20001c54

00002ff8 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
    2ff8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ffa:	4604      	mov	r4, r0
	uint8_t id = CURRENT_CPU;
    2ffc:	4b4b      	ldr	r3, [pc, #300]	; (312c <pm_system_suspend+0x134>)
    2ffe:	7d1d      	ldrb	r5, [r3, #20]
	__asm__ volatile(
    3000:	f04f 0320 	mov.w	r3, #32
    3004:	f3ef 8611 	mrs	r6, BASEPRI
    3008:	f383 8812 	msr	BASEPRI_MAX, r3
    300c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
    3010:	eb05 0245 	add.w	r2, r5, r5, lsl #1
    3014:	4b46      	ldr	r3, [pc, #280]	; (3130 <pm_system_suspend+0x138>)
    3016:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
    301a:	b34b      	cbz	r3, 3070 <pm_system_suspend+0x78>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
    301c:	4b45      	ldr	r3, [pc, #276]	; (3134 <pm_system_suspend+0x13c>)
    301e:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
    3022:	4f43      	ldr	r7, [pc, #268]	; (3130 <pm_system_suspend+0x138>)
    3024:	ea4f 0e82 	mov.w	lr, r2, lsl #2
    3028:	eb07 0382 	add.w	r3, r7, r2, lsl #2
    302c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    3030:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
    3034:	2300      	movs	r3, #0
    3036:	f807 300e 	strb.w	r3, [r7, lr]
	__asm__ volatile(
    303a:	f386 8811 	msr	BASEPRI, r6
    303e:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
    3042:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    3046:	4a3b      	ldr	r2, [pc, #236]	; (3134 <pm_system_suspend+0x13c>)
    3048:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    304c:	2b00      	cmp	r3, #0
    304e:	d06a      	beq.n	3126 <pm_system_suspend+0x12e>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
    3050:	f1b4 3fff 	cmp.w	r4, #4294967295
    3054:	d11b      	bne.n	308e <pm_system_suspend+0x96>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    3056:	f011 f833 	bl	140c0 <k_sched_lock>
	__asm__ volatile(
    305a:	f04f 0320 	mov.w	r3, #32
    305e:	f3ef 8611 	mrs	r6, BASEPRI
    3062:	f383 8812 	msr	BASEPRI_MAX, r3
    3066:	f3bf 8f6f 	isb	sy
	return list->head;
    306a:	4b33      	ldr	r3, [pc, #204]	; (3138 <pm_system_suspend+0x140>)
    306c:	681c      	ldr	r4, [r3, #0]
    306e:	e02e      	b.n	30ce <pm_system_suspend+0xd6>
		info = pm_policy_next_state(id, ticks);
    3070:	4601      	mov	r1, r0
    3072:	4628      	mov	r0, r5
    3074:	f000 f86a 	bl	314c <pm_policy_next_state>
		if (info != NULL) {
    3078:	2800      	cmp	r0, #0
    307a:	d0de      	beq.n	303a <pm_system_suspend+0x42>
			z_cpus_pm_state[id] = *info;
    307c:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    3080:	4a2c      	ldr	r2, [pc, #176]	; (3134 <pm_system_suspend+0x13c>)
    3082:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3086:	c807      	ldmia	r0, {r0, r1, r2}
    3088:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    308c:	e7d5      	b.n	303a <pm_system_suspend+0x42>
		     k_us_to_ticks_ceil32(
    308e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    3092:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    3096:	6898      	ldr	r0, [r3, #8]
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    3098:	0c41      	lsrs	r1, r0, #17
    309a:	03c0      	lsls	r0, r0, #15
    309c:	4b27      	ldr	r3, [pc, #156]	; (313c <pm_system_suspend+0x144>)
    309e:	18c0      	adds	r0, r0, r3
    30a0:	4a27      	ldr	r2, [pc, #156]	; (3140 <pm_system_suspend+0x148>)
    30a2:	f04f 0300 	mov.w	r3, #0
    30a6:	f141 0100 	adc.w	r1, r1, #0
    30aa:	f7fd f853 	bl	154 <__aeabi_uldivmod>
		z_set_timeout_expiry(ticks -
    30ae:	2101      	movs	r1, #1
    30b0:	1a20      	subs	r0, r4, r0
    30b2:	f019 fbf9 	bl	1c8a8 <z_set_timeout_expiry>
    30b6:	e7ce      	b.n	3056 <pm_system_suspend+0x5e>
			callback(z_cpus_pm_state[_current_cpu->id].state);
    30b8:	4b1c      	ldr	r3, [pc, #112]	; (312c <pm_system_suspend+0x134>)
    30ba:	7d1b      	ldrb	r3, [r3, #20]
    30bc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    30c0:	491c      	ldr	r1, [pc, #112]	; (3134 <pm_system_suspend+0x13c>)
    30c2:	f811 0023 	ldrb.w	r0, [r1, r3, lsl #2]
    30c6:	4790      	blx	r2
Z_GENLIST_PEEK_NEXT(slist, snode)
    30c8:	b10c      	cbz	r4, 30ce <pm_system_suspend+0xd6>
	return node->next;
    30ca:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    30cc:	b124      	cbz	r4, 30d8 <pm_system_suspend+0xe0>
    30ce:	b11c      	cbz	r4, 30d8 <pm_system_suspend+0xe0>
			callback = notifier->state_entry;
    30d0:	6862      	ldr	r2, [r4, #4]
		if (callback) {
    30d2:	2a00      	cmp	r2, #0
    30d4:	d1f0      	bne.n	30b8 <pm_system_suspend+0xc0>
    30d6:	e7f7      	b.n	30c8 <pm_system_suspend+0xd0>
	__asm__ volatile(
    30d8:	f386 8811 	msr	BASEPRI, r6
    30dc:	f3bf 8f6f 	isb	sy
 * @param target Address of atomic variable or array.
 * @param bit Bit number (starting from 0).
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    30e0:	f005 031f 	and.w	r3, r5, #31
    30e4:	2101      	movs	r1, #1
    30e6:	4099      	lsls	r1, r3

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    30e8:	096b      	lsrs	r3, r5, #5
    30ea:	4a16      	ldr	r2, [pc, #88]	; (3144 <pm_system_suspend+0x14c>)
    30ec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    30f0:	e8d3 2fef 	ldaex	r2, [r3]
    30f4:	430a      	orrs	r2, r1
    30f6:	e8c3 2fe0 	stlex	r0, r2, [r3]
    30fa:	2800      	cmp	r0, #0
    30fc:	d1f8      	bne.n	30f0 <pm_system_suspend+0xf8>
	if (pm_state_set != NULL) {
    30fe:	4b12      	ldr	r3, [pc, #72]	; (3148 <pm_system_suspend+0x150>)
    3100:	b15b      	cbz	r3, 311a <pm_system_suspend+0x122>
		pm_state_set(info->state, info->substate_id);
    3102:	4a0c      	ldr	r2, [pc, #48]	; (3134 <pm_system_suspend+0x13c>)
    3104:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    3108:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    310c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    3110:	7859      	ldrb	r1, [r3, #1]
    3112:	f812 0025 	ldrb.w	r0, [r2, r5, lsl #2]
    3116:	f7fe fcbd 	bl	1a94 <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
    311a:	f7ff ff11 	bl	2f40 <pm_system_resume>
	k_sched_unlock();
    311e:	f011 f9f1 	bl	14504 <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
    3122:	2001      	movs	r0, #1
}
    3124:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return false;
    3126:	2000      	movs	r0, #0
    3128:	e7fc      	b.n	3124 <pm_system_suspend+0x12c>
    312a:	bf00      	nop
    312c:	200026d8 	.word	0x200026d8
    3130:	20001c5c 	.word	0x20001c5c
    3134:	20001c68 	.word	0x20001c68
    3138:	20001c54 	.word	0x20001c54
    313c:	000f423f 	.word	0x000f423f
    3140:	000f4240 	.word	0x000f4240
    3144:	20001c74 	.word	0x20001c74
    3148:	00001a95 	.word	0x00001a95

0000314c <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
    314c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3150:	b082      	sub	sp, #8
    3152:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
    3154:	a901      	add	r1, sp, #4
    3156:	f000 f845 	bl	31e4 <pm_state_cpu_get_all>

	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    315a:	1e44      	subs	r4, r0, #1
    315c:	b224      	sxth	r4, r4
    315e:	e007      	b.n	3170 <pm_policy_next_state+0x24>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
		    (exit_latency >= max_latency_ticks)) {
			continue;
		}

		if ((ticks == K_TICKS_FOREVER) ||
    3160:	f1b6 3fff 	cmp.w	r6, #4294967295
    3164:	d033      	beq.n	31ce <pm_policy_next_state+0x82>
		    (ticks >= (min_residency + exit_latency))) {
    3166:	4440      	add	r0, r8
		if ((ticks == K_TICKS_FOREVER) ||
    3168:	42b0      	cmp	r0, r6
    316a:	d930      	bls.n	31ce <pm_policy_next_state+0x82>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
    316c:	3c01      	subs	r4, #1
    316e:	b224      	sxth	r4, r4
    3170:	2c00      	cmp	r4, #0
    3172:	db2b      	blt.n	31cc <pm_policy_next_state+0x80>
		const struct pm_state_info *state = &cpu_states[i];
    3174:	9b01      	ldr	r3, [sp, #4]
    3176:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    317a:	eb03 0582 	add.w	r5, r3, r2, lsl #2
		if (pm_policy_state_lock_is_active(state->state, state->substate_id)) {
    317e:	7869      	ldrb	r1, [r5, #1]
    3180:	f813 0022 	ldrb.w	r0, [r3, r2, lsl #2]
    3184:	f013 fe47 	bl	16e16 <pm_policy_state_lock_is_active>
    3188:	2800      	cmp	r0, #0
    318a:	d1ef      	bne.n	316c <pm_policy_next_state+0x20>
		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
    318c:	6868      	ldr	r0, [r5, #4]
    318e:	0c41      	lsrs	r1, r0, #17
    3190:	03c0      	lsls	r0, r0, #15
    3192:	4f11      	ldr	r7, [pc, #68]	; (31d8 <pm_policy_next_state+0x8c>)
    3194:	19c0      	adds	r0, r0, r7
    3196:	4a11      	ldr	r2, [pc, #68]	; (31dc <pm_policy_next_state+0x90>)
    3198:	f04f 0300 	mov.w	r3, #0
    319c:	f141 0100 	adc.w	r1, r1, #0
    31a0:	f7fc ffd8 	bl	154 <__aeabi_uldivmod>
    31a4:	4680      	mov	r8, r0
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);
    31a6:	68ab      	ldr	r3, [r5, #8]
    31a8:	0c59      	lsrs	r1, r3, #17
    31aa:	03db      	lsls	r3, r3, #15
    31ac:	19d8      	adds	r0, r3, r7
    31ae:	4a0b      	ldr	r2, [pc, #44]	; (31dc <pm_policy_next_state+0x90>)
    31b0:	f04f 0300 	mov.w	r3, #0
    31b4:	f141 0100 	adc.w	r1, r1, #0
    31b8:	f7fc ffcc 	bl	154 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
    31bc:	4b08      	ldr	r3, [pc, #32]	; (31e0 <pm_policy_next_state+0x94>)
    31be:	681b      	ldr	r3, [r3, #0]
    31c0:	f1b3 3fff 	cmp.w	r3, #4294967295
    31c4:	d0cc      	beq.n	3160 <pm_policy_next_state+0x14>
    31c6:	4283      	cmp	r3, r0
    31c8:	d8ca      	bhi.n	3160 <pm_policy_next_state+0x14>
    31ca:	e7cf      	b.n	316c <pm_policy_next_state+0x20>
			return state;
		}
	}

	return NULL;
    31cc:	2500      	movs	r5, #0
}
    31ce:	4628      	mov	r0, r5
    31d0:	b002      	add	sp, #8
    31d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    31d6:	bf00      	nop
    31d8:	000f423f 	.word	0x000f423f
    31dc:	000f4240 	.word	0x000f4240
    31e0:	200001f0 	.word	0x200001f0

000031e4 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD(DT_PATH(cpus), NUM_CPU_STATES)
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
    31e4:	b908      	cbnz	r0, 31ea <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
    31e6:	4b02      	ldr	r3, [pc, #8]	; (31f0 <pm_state_cpu_get_all+0xc>)
    31e8:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
    31ea:	2000      	movs	r0, #0
    31ec:	4770      	bx	lr
    31ee:	bf00      	nop
    31f0:	0001d69c 	.word	0x0001d69c

000031f4 <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
    31f4:	b470      	push	{r4, r5, r6}
    31f6:	b08d      	sub	sp, #52	; 0x34
    31f8:	4606      	mov	r6, r0
    31fa:	460d      	mov	r5, r1
	const unsigned int rconst[11] = {
    31fc:	f10d 0c04 	add.w	ip, sp, #4
    3200:	4c2b      	ldr	r4, [pc, #172]	; (32b0 <tc_aes128_set_encrypt_key+0xbc>)
    3202:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    3204:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    3208:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    320a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    320e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    3212:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
    3216:	2e00      	cmp	r6, #0
    3218:	d045      	beq.n	32a6 <tc_aes128_set_encrypt_key+0xb2>
    321a:	4630      	mov	r0, r6
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
    321c:	2d00      	cmp	r5, #0
    321e:	d044      	beq.n	32aa <tc_aes128_set_encrypt_key+0xb6>
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
    3220:	2300      	movs	r3, #0
    3222:	e00f      	b.n	3244 <tc_aes128_set_encrypt_key+0x50>
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    3224:	f815 4023 	ldrb.w	r4, [r5, r3, lsl #2]
    3228:	eb05 0183 	add.w	r1, r5, r3, lsl #2
    322c:	784a      	ldrb	r2, [r1, #1]
    322e:	0412      	lsls	r2, r2, #16
    3230:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    3234:	788c      	ldrb	r4, [r1, #2]
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    3236:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
    323a:	78c9      	ldrb	r1, [r1, #3]
    323c:	430a      	orrs	r2, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
    323e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	for (i = 0; i < Nk; ++i) {
    3242:	3301      	adds	r3, #1
    3244:	2b03      	cmp	r3, #3
    3246:	d9ed      	bls.n	3224 <tc_aes128_set_encrypt_key+0x30>
    3248:	e006      	b.n	3258 <tc_aes128_set_encrypt_key+0x64>
	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
		}
		s->words[i] = s->words[i-Nk] ^ t;
    324a:	1f19      	subs	r1, r3, #4
    324c:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    3250:	404a      	eors	r2, r1
    3252:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	for (; i < (Nb * (Nr + 1)); ++i) {
    3256:	3301      	adds	r3, #1
    3258:	2b2b      	cmp	r3, #43	; 0x2b
    325a:	d820      	bhi.n	329e <tc_aes128_set_encrypt_key+0xaa>
		t = s->words[i-1];
    325c:	1e5a      	subs	r2, r3, #1
    325e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
		if ((i % Nk) == 0) {
    3262:	f013 0f03 	tst.w	r3, #3
    3266:	d1f0      	bne.n	324a <tc_aes128_set_encrypt_key+0x56>
	return (((a) >> 24)|((a) << 8));
    3268:	ea4f 6232 	mov.w	r2, r2, ror #24
			t = subword(rotword(t)) ^ rconst[i/Nk];
    326c:	0e11      	lsrs	r1, r2, #24
    326e:	4c11      	ldr	r4, [pc, #68]	; (32b4 <tc_aes128_set_encrypt_key+0xc0>)
    3270:	5c65      	ldrb	r5, [r4, r1]
    3272:	f3c2 4107 	ubfx	r1, r2, #16, #8
    3276:	5c61      	ldrb	r1, [r4, r1]
    3278:	0409      	lsls	r1, r1, #16
    327a:	ea41 6105 	orr.w	r1, r1, r5, lsl #24
    327e:	f3c2 2507 	ubfx	r5, r2, #8, #8
    3282:	5d65      	ldrb	r5, [r4, r5]
    3284:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
    3288:	b2d2      	uxtb	r2, r2
    328a:	5ca2      	ldrb	r2, [r4, r2]
    328c:	4311      	orrs	r1, r2
    328e:	f023 0203 	bic.w	r2, r3, #3
    3292:	ac0c      	add	r4, sp, #48	; 0x30
    3294:	4422      	add	r2, r4
    3296:	f852 2c2c 	ldr.w	r2, [r2, #-44]
    329a:	404a      	eors	r2, r1
    329c:	e7d5      	b.n	324a <tc_aes128_set_encrypt_key+0x56>
	}

	return TC_CRYPTO_SUCCESS;
    329e:	2001      	movs	r0, #1
}
    32a0:	b00d      	add	sp, #52	; 0x34
    32a2:	bc70      	pop	{r4, r5, r6}
    32a4:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
    32a6:	2000      	movs	r0, #0
    32a8:	e7fa      	b.n	32a0 <tc_aes128_set_encrypt_key+0xac>
		return TC_CRYPTO_FAIL;
    32aa:	2000      	movs	r0, #0
    32ac:	e7f8      	b.n	32a0 <tc_aes128_set_encrypt_key+0xac>
    32ae:	bf00      	nop
    32b0:	0001d158 	.word	0x0001d158
    32b4:	0001d69c 	.word	0x0001d69c

000032b8 <tc_aes_encrypt>:
int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
    32b8:	2800      	cmp	r0, #0
    32ba:	f000 8366 	beq.w	398a <tc_aes_encrypt+0x6d2>
{
    32be:	b5f0      	push	{r4, r5, r6, r7, lr}
    32c0:	b089      	sub	sp, #36	; 0x24
    32c2:	4615      	mov	r5, r2
    32c4:	4606      	mov	r6, r0
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
    32c6:	2900      	cmp	r1, #0
    32c8:	f000 8361 	beq.w	398e <tc_aes_encrypt+0x6d6>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
    32cc:	2a00      	cmp	r2, #0
    32ce:	f000 8360 	beq.w	3992 <tc_aes_encrypt+0x6da>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
    32d2:	2310      	movs	r3, #16
    32d4:	460a      	mov	r2, r1
    32d6:	4619      	mov	r1, r3
    32d8:	eb0d 0003 	add.w	r0, sp, r3
    32dc:	f013 fd9d 	bl	16e1a <_copy>
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    32e0:	682b      	ldr	r3, [r5, #0]
    32e2:	f89d 2010 	ldrb.w	r2, [sp, #16]
    32e6:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
    32ea:	f88d 2010 	strb.w	r2, [sp, #16]
    32ee:	f3c3 4207 	ubfx	r2, r3, #16, #8
    32f2:	f89d 1011 	ldrb.w	r1, [sp, #17]
    32f6:	404a      	eors	r2, r1
    32f8:	f88d 2011 	strb.w	r2, [sp, #17]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    32fc:	f3c3 2207 	ubfx	r2, r3, #8, #8
    3300:	f89d 1012 	ldrb.w	r1, [sp, #18]
    3304:	404a      	eors	r2, r1
    3306:	f88d 2012 	strb.w	r2, [sp, #18]
    330a:	b2db      	uxtb	r3, r3
    330c:	f89d 2013 	ldrb.w	r2, [sp, #19]
    3310:	4053      	eors	r3, r2
    3312:	f88d 3013 	strb.w	r3, [sp, #19]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    3316:	686b      	ldr	r3, [r5, #4]
    3318:	f89d 2014 	ldrb.w	r2, [sp, #20]
    331c:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
    3320:	f88d 2014 	strb.w	r2, [sp, #20]
    3324:	f3c3 4207 	ubfx	r2, r3, #16, #8
    3328:	f89d 1015 	ldrb.w	r1, [sp, #21]
    332c:	404a      	eors	r2, r1
    332e:	f88d 2015 	strb.w	r2, [sp, #21]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    3332:	f3c3 2207 	ubfx	r2, r3, #8, #8
    3336:	f89d 1016 	ldrb.w	r1, [sp, #22]
    333a:	404a      	eors	r2, r1
    333c:	f88d 2016 	strb.w	r2, [sp, #22]
    3340:	b2db      	uxtb	r3, r3
    3342:	f89d 2017 	ldrb.w	r2, [sp, #23]
    3346:	4053      	eors	r3, r2
    3348:	f88d 3017 	strb.w	r3, [sp, #23]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    334c:	68ab      	ldr	r3, [r5, #8]
    334e:	f89d 2018 	ldrb.w	r2, [sp, #24]
    3352:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
    3356:	f88d 2018 	strb.w	r2, [sp, #24]
    335a:	f3c3 4207 	ubfx	r2, r3, #16, #8
    335e:	f89d 1019 	ldrb.w	r1, [sp, #25]
    3362:	404a      	eors	r2, r1
    3364:	f88d 2019 	strb.w	r2, [sp, #25]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    3368:	f3c3 2207 	ubfx	r2, r3, #8, #8
    336c:	f89d 101a 	ldrb.w	r1, [sp, #26]
    3370:	404a      	eors	r2, r1
    3372:	f88d 201a 	strb.w	r2, [sp, #26]
    3376:	b2db      	uxtb	r3, r3
    3378:	f89d 201b 	ldrb.w	r2, [sp, #27]
    337c:	4053      	eors	r3, r2
    337e:	f88d 301b 	strb.w	r3, [sp, #27]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    3382:	68eb      	ldr	r3, [r5, #12]
    3384:	f89d 201c 	ldrb.w	r2, [sp, #28]
    3388:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
    338c:	f88d 201c 	strb.w	r2, [sp, #28]
    3390:	f3c3 4207 	ubfx	r2, r3, #16, #8
    3394:	f89d 101d 	ldrb.w	r1, [sp, #29]
    3398:	404a      	eors	r2, r1
    339a:	f88d 201d 	strb.w	r2, [sp, #29]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    339e:	f3c3 2207 	ubfx	r2, r3, #8, #8
    33a2:	f89d 101e 	ldrb.w	r1, [sp, #30]
    33a6:	404a      	eors	r2, r1
    33a8:	f88d 201e 	strb.w	r2, [sp, #30]
    33ac:	b2db      	uxtb	r3, r3
    33ae:	f89d 201f 	ldrb.w	r2, [sp, #31]
    33b2:	4053      	eors	r3, r2
    33b4:	f88d 301f 	strb.w	r3, [sp, #31]
	add_round_key(state, s->words);

	for (i = 0; i < (Nr - 1); ++i) {
    33b8:	2400      	movs	r4, #0
}
    33ba:	e211      	b.n	37e0 <tc_aes_encrypt+0x528>
		s[i] = sbox[s[i]];
    33bc:	a904      	add	r1, sp, #16
    33be:	5cc8      	ldrb	r0, [r1, r3]
    33c0:	4a02      	ldr	r2, [pc, #8]	; (33cc <tc_aes_encrypt+0x114>)
    33c2:	5c10      	ldrb	r0, [r2, r0]
    33c4:	54c8      	strb	r0, [r1, r3]
	for (i = 0; i < (Nb * Nk); ++i) {
    33c6:	3301      	adds	r3, #1
    33c8:	e002      	b.n	33d0 <tc_aes_encrypt+0x118>
    33ca:	bf00      	nop
    33cc:	0001d69c 	.word	0x0001d69c
    33d0:	2b0f      	cmp	r3, #15
    33d2:	d9f3      	bls.n	33bc <tc_aes_encrypt+0x104>
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    33d4:	f89d 3010 	ldrb.w	r3, [sp, #16]
    33d8:	f88d 3000 	strb.w	r3, [sp]
    33dc:	f89d 3015 	ldrb.w	r3, [sp, #21]
    33e0:	f88d 3001 	strb.w	r3, [sp, #1]
    33e4:	f89d 301a 	ldrb.w	r3, [sp, #26]
    33e8:	f88d 3002 	strb.w	r3, [sp, #2]
    33ec:	f89d 301f 	ldrb.w	r3, [sp, #31]
    33f0:	f88d 3003 	strb.w	r3, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
    33f4:	f89d 3014 	ldrb.w	r3, [sp, #20]
    33f8:	f88d 3004 	strb.w	r3, [sp, #4]
    33fc:	f89d 3019 	ldrb.w	r3, [sp, #25]
    3400:	f88d 3005 	strb.w	r3, [sp, #5]
    3404:	f89d 301e 	ldrb.w	r3, [sp, #30]
    3408:	f88d 3006 	strb.w	r3, [sp, #6]
    340c:	f89d 3013 	ldrb.w	r3, [sp, #19]
    3410:	f88d 3007 	strb.w	r3, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
    3414:	f89d 3018 	ldrb.w	r3, [sp, #24]
    3418:	f88d 3008 	strb.w	r3, [sp, #8]
    341c:	f89d 301d 	ldrb.w	r3, [sp, #29]
    3420:	f88d 3009 	strb.w	r3, [sp, #9]
    3424:	f89d 3012 	ldrb.w	r3, [sp, #18]
    3428:	f88d 300a 	strb.w	r3, [sp, #10]
    342c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3430:	f88d 300b 	strb.w	r3, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
    3434:	f89d 301c 	ldrb.w	r3, [sp, #28]
    3438:	f88d 300c 	strb.w	r3, [sp, #12]
    343c:	f89d 3011 	ldrb.w	r3, [sp, #17]
    3440:	f88d 300d 	strb.w	r3, [sp, #13]
    3444:	f89d 3016 	ldrb.w	r3, [sp, #22]
    3448:	f88d 300e 	strb.w	r3, [sp, #14]
    344c:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3450:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
    3454:	2310      	movs	r3, #16
    3456:	466a      	mov	r2, sp
    3458:	4619      	mov	r1, r3
    345a:	eb0d 0003 	add.w	r0, sp, r3
    345e:	f013 fcdc 	bl	16e1a <_copy>
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    3462:	f89d 0010 	ldrb.w	r0, [sp, #16]
    3466:	f013 fce9 	bl	16e3c <_double_byte>
    346a:	4607      	mov	r7, r0
    346c:	f89d 0011 	ldrb.w	r0, [sp, #17]
    3470:	f013 fce4 	bl	16e3c <_double_byte>
    3474:	4601      	mov	r1, r0
    3476:	f89d 0011 	ldrb.w	r0, [sp, #17]
    347a:	f89d 2012 	ldrb.w	r2, [sp, #18]
    347e:	f89d 3013 	ldrb.w	r3, [sp, #19]
    3482:	4041      	eors	r1, r0
    3484:	404f      	eors	r7, r1
    3486:	407a      	eors	r2, r7
    3488:	4053      	eors	r3, r2
    348a:	f88d 3000 	strb.w	r3, [sp]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    348e:	f89d 7010 	ldrb.w	r7, [sp, #16]
    3492:	f013 fcd3 	bl	16e3c <_double_byte>
    3496:	4047      	eors	r7, r0
    3498:	b2ff      	uxtb	r7, r7
    349a:	f89d 0012 	ldrb.w	r0, [sp, #18]
    349e:	f013 fccd 	bl	16e3c <_double_byte>
    34a2:	4602      	mov	r2, r0
    34a4:	f89d 0012 	ldrb.w	r0, [sp, #18]
    34a8:	f89d 3013 	ldrb.w	r3, [sp, #19]
    34ac:	4042      	eors	r2, r0
    34ae:	4057      	eors	r7, r2
    34b0:	405f      	eors	r7, r3
    34b2:	f88d 7001 	strb.w	r7, [sp, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    34b6:	f89d 7010 	ldrb.w	r7, [sp, #16]
    34ba:	f89d 3011 	ldrb.w	r3, [sp, #17]
    34be:	405f      	eors	r7, r3
    34c0:	f013 fcbc 	bl	16e3c <_double_byte>
    34c4:	4047      	eors	r7, r0
    34c6:	b2ff      	uxtb	r7, r7
    34c8:	f89d 0013 	ldrb.w	r0, [sp, #19]
    34cc:	f013 fcb6 	bl	16e3c <_double_byte>
    34d0:	f89d 3013 	ldrb.w	r3, [sp, #19]
    34d4:	4058      	eors	r0, r3
    34d6:	4047      	eors	r7, r0
    34d8:	f88d 7002 	strb.w	r7, [sp, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    34dc:	f89d 0010 	ldrb.w	r0, [sp, #16]
    34e0:	f013 fcac 	bl	16e3c <_double_byte>
    34e4:	f89d 2010 	ldrb.w	r2, [sp, #16]
    34e8:	f89d 3011 	ldrb.w	r3, [sp, #17]
    34ec:	f89d 7012 	ldrb.w	r7, [sp, #18]
    34f0:	4050      	eors	r0, r2
    34f2:	4043      	eors	r3, r0
    34f4:	405f      	eors	r7, r3
    34f6:	b2ff      	uxtb	r7, r7
    34f8:	f89d 0013 	ldrb.w	r0, [sp, #19]
    34fc:	f013 fc9e 	bl	16e3c <_double_byte>
    3500:	4047      	eors	r7, r0
    3502:	f88d 7003 	strb.w	r7, [sp, #3]
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    3506:	f89d 0014 	ldrb.w	r0, [sp, #20]
    350a:	f013 fc97 	bl	16e3c <_double_byte>
    350e:	4607      	mov	r7, r0
    3510:	f89d 0015 	ldrb.w	r0, [sp, #21]
    3514:	f013 fc92 	bl	16e3c <_double_byte>
    3518:	4601      	mov	r1, r0
    351a:	f89d 0015 	ldrb.w	r0, [sp, #21]
    351e:	f89d 2016 	ldrb.w	r2, [sp, #22]
    3522:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3526:	4041      	eors	r1, r0
    3528:	404f      	eors	r7, r1
    352a:	407a      	eors	r2, r7
    352c:	4053      	eors	r3, r2
    352e:	f88d 3004 	strb.w	r3, [sp, #4]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    3532:	f89d 7014 	ldrb.w	r7, [sp, #20]
    3536:	f013 fc81 	bl	16e3c <_double_byte>
    353a:	4047      	eors	r7, r0
    353c:	b2ff      	uxtb	r7, r7
    353e:	f89d 0016 	ldrb.w	r0, [sp, #22]
    3542:	f013 fc7b 	bl	16e3c <_double_byte>
    3546:	4602      	mov	r2, r0
    3548:	f89d 0016 	ldrb.w	r0, [sp, #22]
    354c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3550:	4042      	eors	r2, r0
    3552:	4057      	eors	r7, r2
    3554:	405f      	eors	r7, r3
    3556:	f88d 7005 	strb.w	r7, [sp, #5]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    355a:	f89d 7014 	ldrb.w	r7, [sp, #20]
    355e:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3562:	405f      	eors	r7, r3
    3564:	f013 fc6a 	bl	16e3c <_double_byte>
    3568:	4047      	eors	r7, r0
    356a:	b2ff      	uxtb	r7, r7
    356c:	f89d 0017 	ldrb.w	r0, [sp, #23]
    3570:	f013 fc64 	bl	16e3c <_double_byte>
    3574:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3578:	4058      	eors	r0, r3
    357a:	4047      	eors	r7, r0
    357c:	f88d 7006 	strb.w	r7, [sp, #6]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    3580:	f89d 0014 	ldrb.w	r0, [sp, #20]
    3584:	f013 fc5a 	bl	16e3c <_double_byte>
    3588:	f89d 2014 	ldrb.w	r2, [sp, #20]
    358c:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3590:	f89d 7016 	ldrb.w	r7, [sp, #22]
    3594:	4050      	eors	r0, r2
    3596:	4043      	eors	r3, r0
    3598:	405f      	eors	r7, r3
    359a:	b2ff      	uxtb	r7, r7
    359c:	f89d 0017 	ldrb.w	r0, [sp, #23]
    35a0:	f013 fc4c 	bl	16e3c <_double_byte>
    35a4:	4047      	eors	r7, r0
    35a6:	f88d 7007 	strb.w	r7, [sp, #7]
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    35aa:	f89d 0018 	ldrb.w	r0, [sp, #24]
    35ae:	f013 fc45 	bl	16e3c <_double_byte>
    35b2:	4607      	mov	r7, r0
    35b4:	f89d 0019 	ldrb.w	r0, [sp, #25]
    35b8:	f013 fc40 	bl	16e3c <_double_byte>
    35bc:	4601      	mov	r1, r0
    35be:	f89d 0019 	ldrb.w	r0, [sp, #25]
    35c2:	f89d 201a 	ldrb.w	r2, [sp, #26]
    35c6:	f89d 301b 	ldrb.w	r3, [sp, #27]
    35ca:	4041      	eors	r1, r0
    35cc:	404f      	eors	r7, r1
    35ce:	407a      	eors	r2, r7
    35d0:	4053      	eors	r3, r2
    35d2:	f88d 3008 	strb.w	r3, [sp, #8]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    35d6:	f89d 7018 	ldrb.w	r7, [sp, #24]
    35da:	f013 fc2f 	bl	16e3c <_double_byte>
    35de:	4047      	eors	r7, r0
    35e0:	b2ff      	uxtb	r7, r7
    35e2:	f89d 001a 	ldrb.w	r0, [sp, #26]
    35e6:	f013 fc29 	bl	16e3c <_double_byte>
    35ea:	4602      	mov	r2, r0
    35ec:	f89d 001a 	ldrb.w	r0, [sp, #26]
    35f0:	f89d 301b 	ldrb.w	r3, [sp, #27]
    35f4:	4042      	eors	r2, r0
    35f6:	4057      	eors	r7, r2
    35f8:	405f      	eors	r7, r3
    35fa:	f88d 7009 	strb.w	r7, [sp, #9]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    35fe:	f89d 7018 	ldrb.w	r7, [sp, #24]
    3602:	f89d 3019 	ldrb.w	r3, [sp, #25]
    3606:	405f      	eors	r7, r3
    3608:	f013 fc18 	bl	16e3c <_double_byte>
    360c:	4047      	eors	r7, r0
    360e:	b2ff      	uxtb	r7, r7
    3610:	f89d 001b 	ldrb.w	r0, [sp, #27]
    3614:	f013 fc12 	bl	16e3c <_double_byte>
    3618:	f89d 301b 	ldrb.w	r3, [sp, #27]
    361c:	4058      	eors	r0, r3
    361e:	4047      	eors	r7, r0
    3620:	f88d 700a 	strb.w	r7, [sp, #10]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    3624:	f89d 0018 	ldrb.w	r0, [sp, #24]
    3628:	f013 fc08 	bl	16e3c <_double_byte>
    362c:	f89d 2018 	ldrb.w	r2, [sp, #24]
    3630:	f89d 3019 	ldrb.w	r3, [sp, #25]
    3634:	f89d 701a 	ldrb.w	r7, [sp, #26]
    3638:	4050      	eors	r0, r2
    363a:	4043      	eors	r3, r0
    363c:	405f      	eors	r7, r3
    363e:	b2ff      	uxtb	r7, r7
    3640:	f89d 001b 	ldrb.w	r0, [sp, #27]
    3644:	f013 fbfa 	bl	16e3c <_double_byte>
    3648:	4047      	eors	r7, r0
    364a:	f88d 700b 	strb.w	r7, [sp, #11]
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
    364e:	f89d 001c 	ldrb.w	r0, [sp, #28]
    3652:	f013 fbf3 	bl	16e3c <_double_byte>
    3656:	4607      	mov	r7, r0
    3658:	f89d 001d 	ldrb.w	r0, [sp, #29]
    365c:	f013 fbee 	bl	16e3c <_double_byte>
    3660:	4601      	mov	r1, r0
    3662:	f89d 001d 	ldrb.w	r0, [sp, #29]
    3666:	f89d 201e 	ldrb.w	r2, [sp, #30]
    366a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    366e:	4041      	eors	r1, r0
    3670:	404f      	eors	r7, r1
    3672:	407a      	eors	r2, r7
    3674:	4053      	eors	r3, r2
    3676:	f88d 300c 	strb.w	r3, [sp, #12]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
    367a:	f89d 701c 	ldrb.w	r7, [sp, #28]
    367e:	f013 fbdd 	bl	16e3c <_double_byte>
    3682:	4047      	eors	r7, r0
    3684:	b2ff      	uxtb	r7, r7
    3686:	f89d 001e 	ldrb.w	r0, [sp, #30]
    368a:	f013 fbd7 	bl	16e3c <_double_byte>
    368e:	4602      	mov	r2, r0
    3690:	f89d 001e 	ldrb.w	r0, [sp, #30]
    3694:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3698:	4042      	eors	r2, r0
    369a:	4057      	eors	r7, r2
    369c:	405f      	eors	r7, r3
    369e:	f88d 700d 	strb.w	r7, [sp, #13]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
    36a2:	f89d 701c 	ldrb.w	r7, [sp, #28]
    36a6:	f89d 301d 	ldrb.w	r3, [sp, #29]
    36aa:	405f      	eors	r7, r3
    36ac:	f013 fbc6 	bl	16e3c <_double_byte>
    36b0:	4047      	eors	r7, r0
    36b2:	b2ff      	uxtb	r7, r7
    36b4:	f89d 001f 	ldrb.w	r0, [sp, #31]
    36b8:	f013 fbc0 	bl	16e3c <_double_byte>
    36bc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    36c0:	4058      	eors	r0, r3
    36c2:	4047      	eors	r7, r0
    36c4:	f88d 700e 	strb.w	r7, [sp, #14]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
    36c8:	f89d 001c 	ldrb.w	r0, [sp, #28]
    36cc:	f013 fbb6 	bl	16e3c <_double_byte>
    36d0:	f89d 201c 	ldrb.w	r2, [sp, #28]
    36d4:	f89d 301d 	ldrb.w	r3, [sp, #29]
    36d8:	f89d 701e 	ldrb.w	r7, [sp, #30]
    36dc:	4050      	eors	r0, r2
    36de:	4043      	eors	r3, r0
    36e0:	405f      	eors	r7, r3
    36e2:	b2ff      	uxtb	r7, r7
    36e4:	f89d 001f 	ldrb.w	r0, [sp, #31]
    36e8:	f013 fba8 	bl	16e3c <_double_byte>
    36ec:	4047      	eors	r7, r0
    36ee:	f88d 700f 	strb.w	r7, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
    36f2:	2310      	movs	r3, #16
    36f4:	466a      	mov	r2, sp
    36f6:	4619      	mov	r1, r3
    36f8:	eb0d 0003 	add.w	r0, sp, r3
    36fc:	f013 fb8d 	bl	16e1a <_copy>
		sub_bytes(state);
		shift_rows(state);
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
    3700:	3401      	adds	r4, #1
    3702:	0123      	lsls	r3, r4, #4
    3704:	eb05 1204 	add.w	r2, r5, r4, lsl #4
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    3708:	58eb      	ldr	r3, [r5, r3]
    370a:	f89d 1010 	ldrb.w	r1, [sp, #16]
    370e:	ea81 6113 	eor.w	r1, r1, r3, lsr #24
    3712:	f88d 1010 	strb.w	r1, [sp, #16]
    3716:	f3c3 4107 	ubfx	r1, r3, #16, #8
    371a:	f89d 0011 	ldrb.w	r0, [sp, #17]
    371e:	4041      	eors	r1, r0
    3720:	f88d 1011 	strb.w	r1, [sp, #17]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    3724:	f3c3 2107 	ubfx	r1, r3, #8, #8
    3728:	f89d 0012 	ldrb.w	r0, [sp, #18]
    372c:	4041      	eors	r1, r0
    372e:	f88d 1012 	strb.w	r1, [sp, #18]
    3732:	b2db      	uxtb	r3, r3
    3734:	f89d 1013 	ldrb.w	r1, [sp, #19]
    3738:	404b      	eors	r3, r1
    373a:	f88d 3013 	strb.w	r3, [sp, #19]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    373e:	6853      	ldr	r3, [r2, #4]
    3740:	f89d 1014 	ldrb.w	r1, [sp, #20]
    3744:	ea81 6113 	eor.w	r1, r1, r3, lsr #24
    3748:	f88d 1014 	strb.w	r1, [sp, #20]
    374c:	f3c3 4107 	ubfx	r1, r3, #16, #8
    3750:	f89d 0015 	ldrb.w	r0, [sp, #21]
    3754:	4041      	eors	r1, r0
    3756:	f88d 1015 	strb.w	r1, [sp, #21]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    375a:	f3c3 2107 	ubfx	r1, r3, #8, #8
    375e:	f89d 0016 	ldrb.w	r0, [sp, #22]
    3762:	4041      	eors	r1, r0
    3764:	f88d 1016 	strb.w	r1, [sp, #22]
    3768:	b2db      	uxtb	r3, r3
    376a:	f89d 1017 	ldrb.w	r1, [sp, #23]
    376e:	404b      	eors	r3, r1
    3770:	f88d 3017 	strb.w	r3, [sp, #23]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    3774:	6893      	ldr	r3, [r2, #8]
    3776:	f89d 1018 	ldrb.w	r1, [sp, #24]
    377a:	ea81 6113 	eor.w	r1, r1, r3, lsr #24
    377e:	f88d 1018 	strb.w	r1, [sp, #24]
    3782:	f3c3 4107 	ubfx	r1, r3, #16, #8
    3786:	f89d 0019 	ldrb.w	r0, [sp, #25]
    378a:	4041      	eors	r1, r0
    378c:	f88d 1019 	strb.w	r1, [sp, #25]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    3790:	f3c3 2107 	ubfx	r1, r3, #8, #8
    3794:	f89d 001a 	ldrb.w	r0, [sp, #26]
    3798:	4041      	eors	r1, r0
    379a:	f88d 101a 	strb.w	r1, [sp, #26]
    379e:	b2db      	uxtb	r3, r3
    37a0:	f89d 101b 	ldrb.w	r1, [sp, #27]
    37a4:	404b      	eors	r3, r1
    37a6:	f88d 301b 	strb.w	r3, [sp, #27]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    37aa:	68d3      	ldr	r3, [r2, #12]
    37ac:	f89d 201c 	ldrb.w	r2, [sp, #28]
    37b0:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
    37b4:	f88d 201c 	strb.w	r2, [sp, #28]
    37b8:	f3c3 4207 	ubfx	r2, r3, #16, #8
    37bc:	f89d 101d 	ldrb.w	r1, [sp, #29]
    37c0:	404a      	eors	r2, r1
    37c2:	f88d 201d 	strb.w	r2, [sp, #29]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    37c6:	f3c3 2207 	ubfx	r2, r3, #8, #8
    37ca:	f89d 101e 	ldrb.w	r1, [sp, #30]
    37ce:	404a      	eors	r2, r1
    37d0:	f88d 201e 	strb.w	r2, [sp, #30]
    37d4:	b2db      	uxtb	r3, r3
    37d6:	f89d 201f 	ldrb.w	r2, [sp, #31]
    37da:	4053      	eors	r3, r2
    37dc:	f88d 301f 	strb.w	r3, [sp, #31]
	for (i = 0; i < (Nr - 1); ++i) {
    37e0:	2c08      	cmp	r4, #8
    37e2:	d801      	bhi.n	37e8 <tc_aes_encrypt+0x530>
	for (i = 0; i < (Nb * Nk); ++i) {
    37e4:	2300      	movs	r3, #0
    37e6:	e5f3      	b.n	33d0 <tc_aes_encrypt+0x118>
    37e8:	2300      	movs	r3, #0
    37ea:	e005      	b.n	37f8 <tc_aes_encrypt+0x540>
		s[i] = sbox[s[i]];
    37ec:	aa04      	add	r2, sp, #16
    37ee:	5cd1      	ldrb	r1, [r2, r3]
    37f0:	4869      	ldr	r0, [pc, #420]	; (3998 <tc_aes_encrypt+0x6e0>)
    37f2:	5c41      	ldrb	r1, [r0, r1]
    37f4:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < (Nb * Nk); ++i) {
    37f6:	3301      	adds	r3, #1
    37f8:	2b0f      	cmp	r3, #15
    37fa:	d9f7      	bls.n	37ec <tc_aes_encrypt+0x534>
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
    37fc:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3800:	f88d 3000 	strb.w	r3, [sp]
    3804:	f89d 3015 	ldrb.w	r3, [sp, #21]
    3808:	f88d 3001 	strb.w	r3, [sp, #1]
    380c:	f89d 301a 	ldrb.w	r3, [sp, #26]
    3810:	f88d 3002 	strb.w	r3, [sp, #2]
    3814:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3818:	f88d 3003 	strb.w	r3, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
    381c:	f89d 3014 	ldrb.w	r3, [sp, #20]
    3820:	f88d 3004 	strb.w	r3, [sp, #4]
    3824:	f89d 3019 	ldrb.w	r3, [sp, #25]
    3828:	f88d 3005 	strb.w	r3, [sp, #5]
    382c:	f89d 301e 	ldrb.w	r3, [sp, #30]
    3830:	f88d 3006 	strb.w	r3, [sp, #6]
    3834:	f89d 3013 	ldrb.w	r3, [sp, #19]
    3838:	f88d 3007 	strb.w	r3, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
    383c:	f89d 3018 	ldrb.w	r3, [sp, #24]
    3840:	f88d 3008 	strb.w	r3, [sp, #8]
    3844:	f89d 301d 	ldrb.w	r3, [sp, #29]
    3848:	f88d 3009 	strb.w	r3, [sp, #9]
    384c:	f89d 3012 	ldrb.w	r3, [sp, #18]
    3850:	f88d 300a 	strb.w	r3, [sp, #10]
    3854:	f89d 3017 	ldrb.w	r3, [sp, #23]
    3858:	f88d 300b 	strb.w	r3, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
    385c:	f89d 301c 	ldrb.w	r3, [sp, #28]
    3860:	f88d 300c 	strb.w	r3, [sp, #12]
    3864:	f89d 3011 	ldrb.w	r3, [sp, #17]
    3868:	f88d 300d 	strb.w	r3, [sp, #13]
    386c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    3870:	f88d 300e 	strb.w	r3, [sp, #14]
    3874:	f89d 301b 	ldrb.w	r3, [sp, #27]
    3878:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
    387c:	2310      	movs	r3, #16
    387e:	466a      	mov	r2, sp
    3880:	4619      	mov	r1, r3
    3882:	eb0d 0003 	add.w	r0, sp, r3
    3886:	f013 fac8 	bl	16e1a <_copy>
	}

	sub_bytes(state);
	shift_rows(state);
	add_round_key(state, s->words + Nb*(i+1));
    388a:	1c63      	adds	r3, r4, #1
    388c:	011a      	lsls	r2, r3, #4
    388e:	eb05 1303 	add.w	r3, r5, r3, lsl #4
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
    3892:	58aa      	ldr	r2, [r5, r2]
    3894:	f89d 1010 	ldrb.w	r1, [sp, #16]
    3898:	ea81 6112 	eor.w	r1, r1, r2, lsr #24
    389c:	f88d 1010 	strb.w	r1, [sp, #16]
    38a0:	f3c2 4107 	ubfx	r1, r2, #16, #8
    38a4:	f89d 0011 	ldrb.w	r0, [sp, #17]
    38a8:	4041      	eors	r1, r0
    38aa:	f88d 1011 	strb.w	r1, [sp, #17]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
    38ae:	f3c2 2107 	ubfx	r1, r2, #8, #8
    38b2:	f89d 0012 	ldrb.w	r0, [sp, #18]
    38b6:	4041      	eors	r1, r0
    38b8:	f88d 1012 	strb.w	r1, [sp, #18]
    38bc:	b2d2      	uxtb	r2, r2
    38be:	f89d 1013 	ldrb.w	r1, [sp, #19]
    38c2:	404a      	eors	r2, r1
    38c4:	f88d 2013 	strb.w	r2, [sp, #19]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
    38c8:	685a      	ldr	r2, [r3, #4]
    38ca:	f89d 1014 	ldrb.w	r1, [sp, #20]
    38ce:	ea81 6112 	eor.w	r1, r1, r2, lsr #24
    38d2:	f88d 1014 	strb.w	r1, [sp, #20]
    38d6:	f3c2 4107 	ubfx	r1, r2, #16, #8
    38da:	f89d 0015 	ldrb.w	r0, [sp, #21]
    38de:	4041      	eors	r1, r0
    38e0:	f88d 1015 	strb.w	r1, [sp, #21]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
    38e4:	f3c2 2107 	ubfx	r1, r2, #8, #8
    38e8:	f89d 0016 	ldrb.w	r0, [sp, #22]
    38ec:	4041      	eors	r1, r0
    38ee:	f88d 1016 	strb.w	r1, [sp, #22]
    38f2:	b2d2      	uxtb	r2, r2
    38f4:	f89d 1017 	ldrb.w	r1, [sp, #23]
    38f8:	404a      	eors	r2, r1
    38fa:	f88d 2017 	strb.w	r2, [sp, #23]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
    38fe:	689a      	ldr	r2, [r3, #8]
    3900:	f89d 1018 	ldrb.w	r1, [sp, #24]
    3904:	ea81 6112 	eor.w	r1, r1, r2, lsr #24
    3908:	f88d 1018 	strb.w	r1, [sp, #24]
    390c:	f3c2 4107 	ubfx	r1, r2, #16, #8
    3910:	f89d 0019 	ldrb.w	r0, [sp, #25]
    3914:	4041      	eors	r1, r0
    3916:	f88d 1019 	strb.w	r1, [sp, #25]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
    391a:	f3c2 2107 	ubfx	r1, r2, #8, #8
    391e:	f89d 001a 	ldrb.w	r0, [sp, #26]
    3922:	4041      	eors	r1, r0
    3924:	f88d 101a 	strb.w	r1, [sp, #26]
    3928:	b2d2      	uxtb	r2, r2
    392a:	f89d 101b 	ldrb.w	r1, [sp, #27]
    392e:	404a      	eors	r2, r1
    3930:	f88d 201b 	strb.w	r2, [sp, #27]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
    3934:	68db      	ldr	r3, [r3, #12]
    3936:	f89d 201c 	ldrb.w	r2, [sp, #28]
    393a:	ea82 6213 	eor.w	r2, r2, r3, lsr #24
    393e:	f88d 201c 	strb.w	r2, [sp, #28]
    3942:	f3c3 4207 	ubfx	r2, r3, #16, #8
    3946:	f89d 101d 	ldrb.w	r1, [sp, #29]
    394a:	404a      	eors	r2, r1
    394c:	f88d 201d 	strb.w	r2, [sp, #29]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
    3950:	f3c3 2207 	ubfx	r2, r3, #8, #8
    3954:	f89d 101e 	ldrb.w	r1, [sp, #30]
    3958:	404a      	eors	r2, r1
    395a:	f88d 201e 	strb.w	r2, [sp, #30]
    395e:	b2db      	uxtb	r3, r3
    3960:	f89d 201f 	ldrb.w	r2, [sp, #31]
    3964:	4053      	eors	r3, r2
    3966:	f88d 301f 	strb.w	r3, [sp, #31]

	(void)_copy(out, sizeof(state), state, sizeof(state));
    396a:	2310      	movs	r3, #16
    396c:	eb0d 0203 	add.w	r2, sp, r3
    3970:	4619      	mov	r1, r3
    3972:	4630      	mov	r0, r6
    3974:	f013 fa51 	bl	16e1a <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
    3978:	2210      	movs	r2, #16
    397a:	2100      	movs	r1, #0
    397c:	eb0d 0002 	add.w	r0, sp, r2
    3980:	f013 fa58 	bl	16e34 <_set>

	return TC_CRYPTO_SUCCESS;
    3984:	2001      	movs	r0, #1
}
    3986:	b009      	add	sp, #36	; 0x24
    3988:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
    398a:	2000      	movs	r0, #0
}
    398c:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
    398e:	2000      	movs	r0, #0
    3990:	e7f9      	b.n	3986 <tc_aes_encrypt+0x6ce>
		return TC_CRYPTO_FAIL;
    3992:	2000      	movs	r0, #0
    3994:	e7f7      	b.n	3986 <tc_aes_encrypt+0x6ce>
    3996:	bf00      	nop
    3998:	0001d69c 	.word	0x0001d69c

0000399c <compress>:
	n |= ((unsigned int)(*((*c)++)));
	return n;
}

static void compress(unsigned int *iv, const uint8_t *data)
{
    399c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39a0:	b093      	sub	sp, #76	; 0x4c
    39a2:	468a      	mov	sl, r1
	unsigned int t1, t2;
	unsigned int work_space[16];
	unsigned int n;
	unsigned int i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
    39a4:	f8d0 e000 	ldr.w	lr, [r0]
    39a8:	6845      	ldr	r5, [r0, #4]
    39aa:	6884      	ldr	r4, [r0, #8]
    39ac:	f8d0 c00c 	ldr.w	ip, [r0, #12]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
    39b0:	6902      	ldr	r2, [r0, #16]
    39b2:	6947      	ldr	r7, [r0, #20]
    39b4:	6986      	ldr	r6, [r0, #24]
    39b6:	69c1      	ldr	r1, [r0, #28]

	for (i = 0; i < 16; ++i) {
    39b8:	f04f 0800 	mov.w	r8, #0
    39bc:	e046      	b.n	3a4c <compress+0xb0>
	n = (((unsigned int)(*((*c)++))) << 24);
    39be:	46d1      	mov	r9, sl
    39c0:	f819 bb01 	ldrb.w	fp, [r9], #1
	n |= ((unsigned int)(*((*c)++)) << 16);
    39c4:	f89a 3001 	ldrb.w	r3, [sl, #1]
    39c8:	041b      	lsls	r3, r3, #16
    39ca:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
	n |= ((unsigned int)(*((*c)++)) << 8);
    39ce:	f899 a001 	ldrb.w	sl, [r9, #1]
    39d2:	ea43 230a 	orr.w	r3, r3, sl, lsl #8
	n |= ((unsigned int)(*((*c)++)));
    39d6:	f109 0a03 	add.w	sl, r9, #3
    39da:	f899 9002 	ldrb.w	r9, [r9, #2]
    39de:	ea43 0309 	orr.w	r3, r3, r9
		n = BigEndian(&data);
		t1 = work_space[i] = n;
    39e2:	f10d 0948 	add.w	r9, sp, #72	; 0x48
    39e6:	eb09 0988 	add.w	r9, r9, r8, lsl #2
    39ea:	f849 3c40 	str.w	r3, [r9, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
    39ee:	ea4f 29f2 	mov.w	r9, r2, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    39f2:	ea89 19b2 	eor.w	r9, r9, r2, ror #6
    39f6:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    39fa:	4449      	add	r1, r9
    39fc:	ea02 0907 	and.w	r9, r2, r7
    3a00:	ea26 0b02 	bic.w	fp, r6, r2
    3a04:	ea89 090b 	eor.w	r9, r9, fp
    3a08:	4449      	add	r1, r9
    3a0a:	f8df 914c 	ldr.w	r9, [pc, #332]	; 3b58 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc0>
    3a0e:	f859 9028 	ldr.w	r9, [r9, r8, lsl #2]
    3a12:	4449      	add	r1, r9
    3a14:	440b      	add	r3, r1
	return (((a) >> n) | ((a) << (32 - n)));
    3a16:	ea4f 317e 	mov.w	r1, lr, ror #13
		t2 = Sigma0(a) + Maj(a, b, c);
    3a1a:	ea81 01be 	eor.w	r1, r1, lr, ror #2
    3a1e:	ea81 51be 	eor.w	r1, r1, lr, ror #22
    3a22:	ea85 0904 	eor.w	r9, r5, r4
    3a26:	ea09 090e 	and.w	r9, r9, lr
    3a2a:	ea05 0b04 	and.w	fp, r5, r4
    3a2e:	ea89 090b 	eor.w	r9, r9, fp
    3a32:	4489      	add	r9, r1
	for (i = 0; i < 16; ++i) {
    3a34:	f108 0801 	add.w	r8, r8, #1
		h = g; g = f; f = e; e = d + t1;
    3a38:	4631      	mov	r1, r6
    3a3a:	463e      	mov	r6, r7
    3a3c:	4617      	mov	r7, r2
    3a3e:	eb0c 0203 	add.w	r2, ip, r3
		d = c; c = b; b = a; a = t1 + t2;
    3a42:	46a4      	mov	ip, r4
    3a44:	462c      	mov	r4, r5
    3a46:	4675      	mov	r5, lr
    3a48:	eb03 0e09 	add.w	lr, r3, r9
	for (i = 0; i < 16; ++i) {
    3a4c:	f1b8 0f0f 	cmp.w	r8, #15
    3a50:	d9b5      	bls.n	39be <compress+0x22>
	}

	for ( ; i < 64; ++i) {
    3a52:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
    3a56:	d863      	bhi.n	3b20 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x88>
		s0 = work_space[(i+1)&0x0f];
    3a58:	f108 0901 	add.w	r9, r8, #1
    3a5c:	f009 030f 	and.w	r3, r9, #15
    3a60:	f10d 0a48 	add.w	sl, sp, #72	; 0x48
    3a64:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
    3a68:	f853 3c40 	ldr.w	r3, [r3, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
    3a6c:	ea4f 4bb3 	mov.w	fp, r3, ror #18
		s0 = sigma0(s0);
    3a70:	ea8b 1bf3 	eor.w	fp, fp, r3, ror #7
    3a74:	ea8b 0bd3 	eor.w	fp, fp, r3, lsr #3
		s1 = work_space[(i+14)&0x0f];
    3a78:	f108 030e 	add.w	r3, r8, #14
    3a7c:	f003 030f 	and.w	r3, r3, #15
    3a80:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
    3a84:	f853 ac40 	ldr.w	sl, [r3, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
    3a88:	ea4f 43fa 	mov.w	r3, sl, ror #19
		s1 = sigma1(s1);
    3a8c:	ea83 437a 	eor.w	r3, r3, sl, ror #17
    3a90:	ea83 239a 	eor.w	r3, r3, sl, lsr #10

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
    3a94:	f008 0a0f 	and.w	sl, r8, #15
    3a98:	445b      	add	r3, fp
    3a9a:	9301      	str	r3, [sp, #4]
    3a9c:	f108 0b09 	add.w	fp, r8, #9
    3aa0:	f00b 0b0f 	and.w	fp, fp, #15
    3aa4:	ab12      	add	r3, sp, #72	; 0x48
    3aa6:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
    3aaa:	f85b bc40 	ldr.w	fp, [fp, #-64]
    3aae:	9b01      	ldr	r3, [sp, #4]
    3ab0:	449b      	add	fp, r3
    3ab2:	ab12      	add	r3, sp, #72	; 0x48
    3ab4:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
    3ab8:	f85a 3c40 	ldr.w	r3, [sl, #-64]
    3abc:	445b      	add	r3, fp
    3abe:	f84a 3c40 	str.w	r3, [sl, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
    3ac2:	ea4f 2af2 	mov.w	sl, r2, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
    3ac6:	ea8a 1ab2 	eor.w	sl, sl, r2, ror #6
    3aca:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    3ace:	4451      	add	r1, sl
    3ad0:	ea02 0a07 	and.w	sl, r2, r7
    3ad4:	ea26 0b02 	bic.w	fp, r6, r2
    3ad8:	ea8a 0a0b 	eor.w	sl, sl, fp
    3adc:	4451      	add	r1, sl
    3ade:	f8df a078 	ldr.w	sl, [pc, #120]	; 3b58 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0xc0>
    3ae2:	f85a 8028 	ldr.w	r8, [sl, r8, lsl #2]
    3ae6:	4441      	add	r1, r8
    3ae8:	440b      	add	r3, r1
	return (((a) >> n) | ((a) << (32 - n)));
    3aea:	ea4f 3a7e 	mov.w	sl, lr, ror #13
		t2 = Sigma0(a) + Maj(a, b, c);
    3aee:	ea8a 0abe 	eor.w	sl, sl, lr, ror #2
    3af2:	ea8a 5abe 	eor.w	sl, sl, lr, ror #22
    3af6:	ea85 0104 	eor.w	r1, r5, r4
    3afa:	ea01 010e 	and.w	r1, r1, lr
    3afe:	ea05 0804 	and.w	r8, r5, r4
    3b02:	ea81 0108 	eor.w	r1, r1, r8
    3b06:	448a      	add	sl, r1
	for ( ; i < 64; ++i) {
    3b08:	46c8      	mov	r8, r9
		h = g; g = f; f = e; e = d + t1;
    3b0a:	4631      	mov	r1, r6
    3b0c:	463e      	mov	r6, r7
    3b0e:	4617      	mov	r7, r2
    3b10:	eb0c 0203 	add.w	r2, ip, r3
		d = c; c = b; b = a; a = t1 + t2;
    3b14:	46a4      	mov	ip, r4
    3b16:	462c      	mov	r4, r5
    3b18:	4675      	mov	r5, lr
    3b1a:	eb03 0e0a 	add.w	lr, r3, sl
    3b1e:	e798      	b.n	3a52 <compress+0xb6>
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
    3b20:	6803      	ldr	r3, [r0, #0]
    3b22:	4473      	add	r3, lr
    3b24:	6003      	str	r3, [r0, #0]
    3b26:	6843      	ldr	r3, [r0, #4]
    3b28:	442b      	add	r3, r5
    3b2a:	6043      	str	r3, [r0, #4]
    3b2c:	6883      	ldr	r3, [r0, #8]
    3b2e:	4423      	add	r3, r4
    3b30:	6083      	str	r3, [r0, #8]
    3b32:	68c3      	ldr	r3, [r0, #12]
    3b34:	4463      	add	r3, ip
    3b36:	60c3      	str	r3, [r0, #12]
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
    3b38:	6903      	ldr	r3, [r0, #16]
    3b3a:	4413      	add	r3, r2
    3b3c:	6103      	str	r3, [r0, #16]
    3b3e:	6943      	ldr	r3, [r0, #20]
    3b40:	443b      	add	r3, r7
    3b42:	6143      	str	r3, [r0, #20]
    3b44:	6983      	ldr	r3, [r0, #24]
    3b46:	4433      	add	r3, r6
    3b48:	6183      	str	r3, [r0, #24]
    3b4a:	69c3      	ldr	r3, [r0, #28]
    3b4c:	440b      	add	r3, r1
    3b4e:	61c3      	str	r3, [r0, #28]
}
    3b50:	b013      	add	sp, #76	; 0x4c
    3b52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3b56:	bf00      	nop
    3b58:	0001d79c 	.word	0x0001d79c

00003b5c <tc_sha256_init>:
	if (s == (TCSha256State_t) 0) {
    3b5c:	b1e0      	cbz	r0, 3b98 <tc_sha256_init+0x3c>
{
    3b5e:	b510      	push	{r4, lr}
    3b60:	4604      	mov	r4, r0
	_set((uint8_t *) s, 0x00, sizeof(*s));
    3b62:	2270      	movs	r2, #112	; 0x70
    3b64:	2100      	movs	r1, #0
    3b66:	f013 f965 	bl	16e34 <_set>
	s->iv[0] = 0x6a09e667;
    3b6a:	4b0c      	ldr	r3, [pc, #48]	; (3b9c <tc_sha256_init+0x40>)
    3b6c:	6023      	str	r3, [r4, #0]
	s->iv[1] = 0xbb67ae85;
    3b6e:	4b0c      	ldr	r3, [pc, #48]	; (3ba0 <tc_sha256_init+0x44>)
    3b70:	6063      	str	r3, [r4, #4]
	s->iv[2] = 0x3c6ef372;
    3b72:	4b0c      	ldr	r3, [pc, #48]	; (3ba4 <tc_sha256_init+0x48>)
    3b74:	60a3      	str	r3, [r4, #8]
	s->iv[3] = 0xa54ff53a;
    3b76:	4b0c      	ldr	r3, [pc, #48]	; (3ba8 <tc_sha256_init+0x4c>)
    3b78:	60e3      	str	r3, [r4, #12]
	s->iv[4] = 0x510e527f;
    3b7a:	4b0c      	ldr	r3, [pc, #48]	; (3bac <tc_sha256_init+0x50>)
    3b7c:	6123      	str	r3, [r4, #16]
	s->iv[5] = 0x9b05688c;
    3b7e:	4b0c      	ldr	r3, [pc, #48]	; (3bb0 <tc_sha256_init+0x54>)
    3b80:	6163      	str	r3, [r4, #20]
	s->iv[6] = 0x1f83d9ab;
    3b82:	4b0c      	ldr	r3, [pc, #48]	; (3bb4 <tc_sha256_init+0x58>)
    3b84:	61a3      	str	r3, [r4, #24]
	s->iv[7] = 0x5be0cd19;
    3b86:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
    3b8a:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
    3b8e:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
    3b92:	61e3      	str	r3, [r4, #28]
	return TC_CRYPTO_SUCCESS;
    3b94:	2001      	movs	r0, #1
}
    3b96:	bd10      	pop	{r4, pc}
		return TC_CRYPTO_FAIL;
    3b98:	2000      	movs	r0, #0
}
    3b9a:	4770      	bx	lr
    3b9c:	6a09e667 	.word	0x6a09e667
    3ba0:	bb67ae85 	.word	0xbb67ae85
    3ba4:	3c6ef372 	.word	0x3c6ef372
    3ba8:	a54ff53a 	.word	0xa54ff53a
    3bac:	510e527f 	.word	0x510e527f
    3bb0:	9b05688c 	.word	0x9b05688c
    3bb4:	1f83d9ab 	.word	0x1f83d9ab

00003bb8 <nrf_cc3xx_platform_abort_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform abort APIs.
 */
void nrf_cc3xx_platform_abort_init(void)
{
    3bb8:	b508      	push	{r3, lr}
	nrf_cc3xx_platform_set_abort(&apis);
    3bba:	4802      	ldr	r0, [pc, #8]	; (3bc4 <nrf_cc3xx_platform_abort_init+0xc>)
    3bbc:	f011 fbbc 	bl	15338 <nrf_cc3xx_platform_set_abort>
}
    3bc0:	bd08      	pop	{r3, pc}
    3bc2:	bf00      	nop
    3bc4:	0001d89c 	.word	0x0001d89c

00003bc8 <mutex_unlock_platform>:
 */
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    3bc8:	b308      	cbz	r0, 3c0e <mutex_unlock_platform+0x46>
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    3bca:	b508      	push	{r3, lr}
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    }

    switch (mutex->flags)
    3bcc:	6843      	ldr	r3, [r0, #4]
    3bce:	2b04      	cmp	r3, #4
    3bd0:	d007      	beq.n	3be2 <mutex_unlock_platform+0x1a>
    3bd2:	2b08      	cmp	r3, #8
    3bd4:	d012      	beq.n	3bfc <mutex_unlock_platform+0x34>

#endif /* defined(NRF5340_XXAA_APPLICATION) */

    default:
        /* Ensure that the mutex has been initialized */
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    3bd6:	b1fb      	cbz	r3, 3c18 <mutex_unlock_platform+0x50>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
        }

        p_mutex = (struct k_mutex *)mutex->mutex;
    3bd8:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_unlock(mutex);
    3bda:	f00f ff61 	bl	13aa0 <z_impl_k_mutex_unlock>

        k_mutex_unlock(p_mutex);
        return NRF_CC3XX_PLATFORM_SUCCESS;
    3bde:	2000      	movs	r0, #0
    3be0:	e014      	b.n	3c0c <mutex_unlock_platform+0x44>
        return atomic_cas((atomic_t *)mutex->mutex, 1, 0) ?
    3be2:	6803      	ldr	r3, [r0, #0]
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    3be4:	2200      	movs	r2, #0
    3be6:	e8d3 1fef 	ldaex	r1, [r3]
    3bea:	2901      	cmp	r1, #1
    3bec:	d103      	bne.n	3bf6 <mutex_unlock_platform+0x2e>
    3bee:	e8c3 2fe0 	stlex	r0, r2, [r3]
    3bf2:	2800      	cmp	r0, #0
    3bf4:	d1f7      	bne.n	3be6 <mutex_unlock_platform+0x1e>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    3bf6:	d10d      	bne.n	3c14 <mutex_unlock_platform+0x4c>
    3bf8:	4610      	mov	r0, r2
    3bfa:	e007      	b.n	3c0c <mutex_unlock_platform+0x44>
        nrf_mutex_unlock(NRF_MUTEX, *((uint8_t *)mutex->mutex));
    3bfc:	6803      	ldr	r3, [r0, #0]
    3bfe:	781b      	ldrb	r3, [r3, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
}

NRF_STATIC_INLINE void nrf_mutex_unlock(NRF_MUTEX_Type * p_reg, uint8_t mutex)
{
    p_reg->MUTEX[mutex] = MUTEX_MUTEX_MUTEX_Unlocked;
    3c00:	f503 7380 	add.w	r3, r3, #256	; 0x100
    3c04:	2000      	movs	r0, #0
    3c06:	4a05      	ldr	r2, [pc, #20]	; (3c1c <mutex_unlock_platform+0x54>)
    3c08:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    }
}
    3c0c:	bd08      	pop	{r3, pc}
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    3c0e:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
}
    3c12:	4770      	bx	lr
                       NRF_CC3XX_PLATFORM_SUCCESS :
    3c14:	4802      	ldr	r0, [pc, #8]	; (3c20 <mutex_unlock_platform+0x58>)
    3c16:	e7f9      	b.n	3c0c <mutex_unlock_platform+0x44>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    3c18:	4802      	ldr	r0, [pc, #8]	; (3c24 <mutex_unlock_platform+0x5c>)
    3c1a:	e7f7      	b.n	3c0c <mutex_unlock_platform+0x44>
    3c1c:	50030000 	.word	0x50030000
    3c20:	ffff8fe9 	.word	0xffff8fe9
    3c24:	ffff8fea 	.word	0xffff8fea

00003c28 <mutex_lock_platform>:
    if(mutex == NULL) {
    3c28:	b370      	cbz	r0, 3c88 <mutex_lock_platform+0x60>
static int32_t mutex_lock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    3c2a:	b508      	push	{r3, lr}
    switch (mutex->flags) {
    3c2c:	6843      	ldr	r3, [r0, #4]
    3c2e:	2b04      	cmp	r3, #4
    3c30:	d004      	beq.n	3c3c <mutex_lock_platform+0x14>
    3c32:	2b08      	cmp	r3, #8
    3c34:	d00f      	beq.n	3c56 <mutex_lock_platform+0x2e>
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    3c36:	b9c3      	cbnz	r3, 3c6a <mutex_lock_platform+0x42>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    3c38:	4815      	ldr	r0, [pc, #84]	; (3c90 <mutex_lock_platform+0x68>)
    3c3a:	e00b      	b.n	3c54 <mutex_lock_platform+0x2c>
        return atomic_cas((atomic_t *)mutex->mutex, 0, 1) ?
    3c3c:	6803      	ldr	r3, [r0, #0]
    3c3e:	2201      	movs	r2, #1
    3c40:	e8d3 1fef 	ldaex	r1, [r3]
    3c44:	2900      	cmp	r1, #0
    3c46:	d103      	bne.n	3c50 <mutex_lock_platform+0x28>
    3c48:	e8c3 2fe0 	stlex	r0, r2, [r3]
    3c4c:	2800      	cmp	r0, #0
    3c4e:	d1f7      	bne.n	3c40 <mutex_lock_platform+0x18>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    3c50:	d116      	bne.n	3c80 <mutex_lock_platform+0x58>
    3c52:	2000      	movs	r0, #0
}
    3c54:	bd08      	pop	{r3, pc}
        return nrf_mutex_lock(NRF_MUTEX, *((uint8_t *)mutex->mutex)) ?
    3c56:	6803      	ldr	r3, [r0, #0]
    3c58:	781b      	ldrb	r3, [r3, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
    3c5a:	f503 7380 	add.w	r3, r3, #256	; 0x100
    3c5e:	4a0d      	ldr	r2, [pc, #52]	; (3c94 <mutex_lock_platform+0x6c>)
    3c60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
                       NRF_CC3XX_PLATFORM_SUCCESS :
    3c64:	b973      	cbnz	r3, 3c84 <mutex_lock_platform+0x5c>
    3c66:	2000      	movs	r0, #0
    3c68:	e7f4      	b.n	3c54 <mutex_lock_platform+0x2c>
        p_mutex = (struct k_mutex *)mutex->mutex;
    3c6a:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    3c6c:	f04f 32ff 	mov.w	r2, #4294967295
    3c70:	f04f 33ff 	mov.w	r3, #4294967295
    3c74:	f00f fe8a 	bl	1398c <z_impl_k_mutex_lock>
        if (ret == 0) {
    3c78:	2800      	cmp	r0, #0
    3c7a:	d0eb      	beq.n	3c54 <mutex_lock_platform+0x2c>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_FAILED;
    3c7c:	4806      	ldr	r0, [pc, #24]	; (3c98 <mutex_lock_platform+0x70>)
    3c7e:	e7e9      	b.n	3c54 <mutex_lock_platform+0x2c>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    3c80:	4805      	ldr	r0, [pc, #20]	; (3c98 <mutex_lock_platform+0x70>)
    3c82:	e7e7      	b.n	3c54 <mutex_lock_platform+0x2c>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    3c84:	4804      	ldr	r0, [pc, #16]	; (3c98 <mutex_lock_platform+0x70>)
    3c86:	e7e5      	b.n	3c54 <mutex_lock_platform+0x2c>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    3c88:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
}
    3c8c:	4770      	bx	lr
    3c8e:	bf00      	nop
    3c90:	ffff8fea 	.word	0xffff8fea
    3c94:	50030000 	.word	0x50030000
    3c98:	ffff8fe9 	.word	0xffff8fe9

00003c9c <mutex_free_platform>:
static void mutex_free_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    3c9c:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    3c9e:	4604      	mov	r4, r0
    3ca0:	b188      	cbz	r0, 3cc6 <mutex_free_platform+0x2a>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    3ca2:	6863      	ldr	r3, [r4, #4]
    3ca4:	2b04      	cmp	r3, #4
    3ca6:	d00d      	beq.n	3cc4 <mutex_free_platform+0x28>
    3ca8:	2b08      	cmp	r3, #8
    3caa:	d00b      	beq.n	3cc4 <mutex_free_platform+0x28>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    3cac:	b153      	cbz	r3, 3cc4 <mutex_free_platform+0x28>
    if ((mutex->flags & NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED) != 0) {
    3cae:	f013 0f02 	tst.w	r3, #2
    3cb2:	d00d      	beq.n	3cd0 <mutex_free_platform+0x34>
        k_mem_slab_free(&mutex_slab, &mutex->mutex);
    3cb4:	4621      	mov	r1, r4
    3cb6:	4809      	ldr	r0, [pc, #36]	; (3cdc <mutex_free_platform+0x40>)
    3cb8:	f018 f931 	bl	1bf1e <k_mem_slab_free>
        mutex->mutex = NULL;
    3cbc:	2300      	movs	r3, #0
    3cbe:	6023      	str	r3, [r4, #0]
    mutex->flags = NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID;
    3cc0:	2300      	movs	r3, #0
    3cc2:	6063      	str	r3, [r4, #4]
}
    3cc4:	bd10      	pop	{r4, pc}
        platform_abort_apis.abort_fn(
    3cc6:	4b06      	ldr	r3, [pc, #24]	; (3ce0 <mutex_free_platform+0x44>)
    3cc8:	685b      	ldr	r3, [r3, #4]
    3cca:	4806      	ldr	r0, [pc, #24]	; (3ce4 <mutex_free_platform+0x48>)
    3ccc:	4798      	blx	r3
    3cce:	e7e8      	b.n	3ca2 <mutex_free_platform+0x6>
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    3cd0:	2214      	movs	r2, #20
    3cd2:	2100      	movs	r1, #0
    3cd4:	6820      	ldr	r0, [r4, #0]
    3cd6:	f013 fd5a 	bl	1778e <memset>
    3cda:	e7f1      	b.n	3cc0 <mutex_free_platform+0x24>
    3cdc:	20001c78 	.word	0x20001c78
    3ce0:	200004e4 	.word	0x200004e4
    3ce4:	0001d8a4 	.word	0x0001d8a4

00003ce8 <mutex_init_platform>:
static void mutex_init_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    3ce8:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    3cea:	4604      	mov	r4, r0
    3cec:	b178      	cbz	r0, 3d0e <mutex_init_platform+0x26>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    3cee:	6863      	ldr	r3, [r4, #4]
    3cf0:	2b04      	cmp	r3, #4
    3cf2:	d00b      	beq.n	3d0c <mutex_init_platform+0x24>
    3cf4:	2b08      	cmp	r3, #8
    3cf6:	d009      	beq.n	3d0c <mutex_init_platform+0x24>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID &&
    3cf8:	b90b      	cbnz	r3, 3cfe <mutex_init_platform+0x16>
        mutex->mutex == NULL) {
    3cfa:	6823      	ldr	r3, [r4, #0]
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID &&
    3cfc:	b163      	cbz	r3, 3d18 <mutex_init_platform+0x30>
    p_mutex = (struct k_mutex *)mutex->mutex;
    3cfe:	6820      	ldr	r0, [r4, #0]
	return z_impl_k_mutex_init(mutex);
    3d00:	f018 f99a 	bl	1c038 <z_impl_k_mutex_init>
    mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_VALID;
    3d04:	6863      	ldr	r3, [r4, #4]
    3d06:	f043 0301 	orr.w	r3, r3, #1
    3d0a:	6063      	str	r3, [r4, #4]
}
    3d0c:	bd10      	pop	{r4, pc}
        platform_abort_apis.abort_fn(
    3d0e:	4b0f      	ldr	r3, [pc, #60]	; (3d4c <mutex_init_platform+0x64>)
    3d10:	685b      	ldr	r3, [r3, #4]
    3d12:	480f      	ldr	r0, [pc, #60]	; (3d50 <mutex_init_platform+0x68>)
    3d14:	4798      	blx	r3
    3d16:	e7ea      	b.n	3cee <mutex_init_platform+0x6>
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    3d18:	f04f 32ff 	mov.w	r2, #4294967295
    3d1c:	f04f 33ff 	mov.w	r3, #4294967295
    3d20:	4621      	mov	r1, r4
    3d22:	480c      	ldr	r0, [pc, #48]	; (3d54 <mutex_init_platform+0x6c>)
    3d24:	f00f fcf2 	bl	1370c <k_mem_slab_alloc>
        if(ret != 0 || mutex->mutex == NULL)
    3d28:	b908      	cbnz	r0, 3d2e <mutex_init_platform+0x46>
    3d2a:	6823      	ldr	r3, [r4, #0]
    3d2c:	b91b      	cbnz	r3, 3d36 <mutex_init_platform+0x4e>
            platform_abort_apis.abort_fn(
    3d2e:	4b07      	ldr	r3, [pc, #28]	; (3d4c <mutex_init_platform+0x64>)
    3d30:	685b      	ldr	r3, [r3, #4]
    3d32:	4809      	ldr	r0, [pc, #36]	; (3d58 <mutex_init_platform+0x70>)
    3d34:	4798      	blx	r3
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    3d36:	2214      	movs	r2, #20
    3d38:	2100      	movs	r1, #0
    3d3a:	6820      	ldr	r0, [r4, #0]
    3d3c:	f013 fd27 	bl	1778e <memset>
        mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    3d40:	6863      	ldr	r3, [r4, #4]
    3d42:	f043 0302 	orr.w	r3, r3, #2
    3d46:	6063      	str	r3, [r4, #4]
    3d48:	e7d9      	b.n	3cfe <mutex_init_platform+0x16>
    3d4a:	bf00      	nop
    3d4c:	200004e4 	.word	0x200004e4
    3d50:	0001d8a4 	.word	0x0001d8a4
    3d54:	20001c78 	.word	0x20001c78
    3d58:	0001d8cc 	.word	0x0001d8cc

00003d5c <nrf_cc3xx_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform mutex APIs
 */
void nrf_cc3xx_platform_mutex_init(void)
{
    3d5c:	b508      	push	{r3, lr}
    k_mem_slab_init(&mutex_slab,
    3d5e:	2340      	movs	r3, #64	; 0x40
    3d60:	2214      	movs	r2, #20
    3d62:	4904      	ldr	r1, [pc, #16]	; (3d74 <nrf_cc3xx_platform_mutex_init+0x18>)
    3d64:	4804      	ldr	r0, [pc, #16]	; (3d78 <nrf_cc3xx_platform_mutex_init+0x1c>)
    3d66:	f018 f8cc 	bl	1bf02 <k_mem_slab_init>
                mutex_slab_buffer,
                sizeof(struct k_mutex),
                NUM_MUTEXES);

    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
    3d6a:	4904      	ldr	r1, [pc, #16]	; (3d7c <nrf_cc3xx_platform_mutex_init+0x20>)
    3d6c:	4804      	ldr	r0, [pc, #16]	; (3d80 <nrf_cc3xx_platform_mutex_init+0x24>)
    3d6e:	f011 fb45 	bl	153fc <nrf_cc3xx_platform_set_mutexes>
}
    3d72:	bd08      	pop	{r3, pc}
    3d74:	20001c94 	.word	0x20001c94
    3d78:	20001c78 	.word	0x20001c78
    3d7c:	0001d90c 	.word	0x0001d90c
    3d80:	0001d8fc 	.word	0x0001d8fc

00003d84 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    3d84:	4901      	ldr	r1, [pc, #4]	; (3d8c <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    3d86:	2210      	movs	r2, #16
	str	r2, [r1]
    3d88:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    3d8a:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    3d8c:	e000ed10 	.word	0xe000ed10

00003d90 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    3d90:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    3d92:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    3d94:	f380 8811 	msr	BASEPRI, r0
	isb
    3d98:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    3d9c:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    3da0:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    3da2:	b662      	cpsie	i
	isb
    3da4:	f3bf 8f6f 	isb	sy

	bx	lr
    3da8:	4770      	bx	lr
    3daa:	bf00      	nop

00003dac <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    3dac:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    3dae:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    3db0:	f381 8811 	msr	BASEPRI, r1

	wfe
    3db4:	bf20      	wfe

	msr	BASEPRI, r0
    3db6:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    3dba:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    3dbc:	4770      	bx	lr
    3dbe:	bf00      	nop

00003dc0 <esf_dump>:
#include <kernel_arch_data.h>
#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

static void esf_dump(const z_arch_esf_t *esf)
{
    3dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
    3dc2:	b083      	sub	sp, #12
    3dc4:	af00      	add	r7, sp, #0
    3dc6:	4604      	mov	r4, r0
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    3dc8:	f8d0 c000 	ldr.w	ip, [r0]
    3dcc:	6845      	ldr	r5, [r0, #4]
    3dce:	6880      	ldr	r0, [r0, #8]
    3dd0:	466e      	mov	r6, sp
    3dd2:	b08a      	sub	sp, #40	; 0x28
    3dd4:	466b      	mov	r3, sp
    3dd6:	f113 0210 	adds.w	r2, r3, #16
    3dda:	f000 80f0 	beq.w	3fbe <esf_dump+0x1fe>
    3dde:	2114      	movs	r1, #20
    3de0:	b12a      	cbz	r2, 3dee <esf_dump+0x2e>
    3de2:	2904      	cmp	r1, #4
    3de4:	dd03      	ble.n	3dee <esf_dump+0x2e>
    3de6:	f8df e208 	ldr.w	lr, [pc, #520]	; 3ff0 <esf_dump+0x230>
    3dea:	f8c3 e014 	str.w	lr, [r3, #20]
    3dee:	b11a      	cbz	r2, 3df8 <esf_dump+0x38>
    3df0:	2908      	cmp	r1, #8
    3df2:	dd01      	ble.n	3df8 <esf_dump+0x38>
    3df4:	f8c3 c018 	str.w	ip, [r3, #24]
    3df8:	b112      	cbz	r2, 3e00 <esf_dump+0x40>
    3dfa:	290c      	cmp	r1, #12
    3dfc:	dd00      	ble.n	3e00 <esf_dump+0x40>
    3dfe:	61dd      	str	r5, [r3, #28]
    3e00:	b112      	cbz	r2, 3e08 <esf_dump+0x48>
    3e02:	2910      	cmp	r1, #16
    3e04:	dd00      	ble.n	3e08 <esf_dump+0x48>
    3e06:	6218      	str	r0, [r3, #32]
    3e08:	2913      	cmp	r1, #19
    3e0a:	f340 80db 	ble.w	3fc4 <esf_dump+0x204>
    3e0e:	2514      	movs	r5, #20
    3e10:	b13a      	cbz	r2, 3e22 <esf_dump+0x62>
    3e12:	2105      	movs	r1, #5
    3e14:	7139      	strb	r1, [r7, #4]
    3e16:	2100      	movs	r1, #0
    3e18:	7179      	strb	r1, [r7, #5]
    3e1a:	71b9      	strb	r1, [r7, #6]
    3e1c:	71f9      	strb	r1, [r7, #7]
    3e1e:	6878      	ldr	r0, [r7, #4]
    3e20:	6118      	str	r0, [r3, #16]
    3e22:	2100      	movs	r1, #0
    3e24:	f36f 0100 	bfc	r1, #0, #1
    3e28:	f36f 0141 	bfc	r1, #1, #1
    3e2c:	f36f 0182 	bfc	r1, #2, #1
    3e30:	f36f 01c5 	bfc	r1, #3, #3
    3e34:	2301      	movs	r3, #1
    3e36:	f363 1188 	bfi	r1, r3, #6, #3
    3e3a:	f405 757d 	and.w	r5, r5, #1012	; 0x3f4
    3e3e:	f365 2152 	bfi	r1, r5, #9, #10
    3e42:	f36f 41de 	bfc	r1, #19, #12
    3e46:	f36f 71df 	bfc	r1, #31, #1
    3e4a:	2300      	movs	r3, #0
    3e4c:	4869      	ldr	r0, [pc, #420]	; (3ff4 <esf_dump+0x234>)
    3e4e:	f7fe f9fb 	bl	2248 <z_impl_z_log_msg_static_create>
    3e52:	46b5      	mov	sp, r6
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    3e54:	f8d4 c00c 	ldr.w	ip, [r4, #12]
    3e58:	6926      	ldr	r6, [r4, #16]
    3e5a:	6960      	ldr	r0, [r4, #20]
    3e5c:	466d      	mov	r5, sp
    3e5e:	b08a      	sub	sp, #40	; 0x28
    3e60:	466b      	mov	r3, sp
    3e62:	f113 0210 	adds.w	r2, r3, #16
    3e66:	f000 80b0 	beq.w	3fca <esf_dump+0x20a>
    3e6a:	2114      	movs	r1, #20
    3e6c:	b12a      	cbz	r2, 3e7a <esf_dump+0xba>
    3e6e:	2904      	cmp	r1, #4
    3e70:	dd03      	ble.n	3e7a <esf_dump+0xba>
    3e72:	f8df e184 	ldr.w	lr, [pc, #388]	; 3ff8 <esf_dump+0x238>
    3e76:	f8c3 e014 	str.w	lr, [r3, #20]
    3e7a:	b11a      	cbz	r2, 3e84 <esf_dump+0xc4>
    3e7c:	2908      	cmp	r1, #8
    3e7e:	dd01      	ble.n	3e84 <esf_dump+0xc4>
    3e80:	f8c3 c018 	str.w	ip, [r3, #24]
    3e84:	b112      	cbz	r2, 3e8c <esf_dump+0xcc>
    3e86:	290c      	cmp	r1, #12
    3e88:	dd00      	ble.n	3e8c <esf_dump+0xcc>
    3e8a:	61de      	str	r6, [r3, #28]
    3e8c:	b112      	cbz	r2, 3e94 <esf_dump+0xd4>
    3e8e:	2910      	cmp	r1, #16
    3e90:	dd00      	ble.n	3e94 <esf_dump+0xd4>
    3e92:	6218      	str	r0, [r3, #32]
    3e94:	2913      	cmp	r1, #19
    3e96:	f340 809b 	ble.w	3fd0 <esf_dump+0x210>
    3e9a:	f04f 0c14 	mov.w	ip, #20
    3e9e:	b13a      	cbz	r2, 3eb0 <esf_dump+0xf0>
    3ea0:	2105      	movs	r1, #5
    3ea2:	7139      	strb	r1, [r7, #4]
    3ea4:	2100      	movs	r1, #0
    3ea6:	7179      	strb	r1, [r7, #5]
    3ea8:	71b9      	strb	r1, [r7, #6]
    3eaa:	71f9      	strb	r1, [r7, #7]
    3eac:	6878      	ldr	r0, [r7, #4]
    3eae:	6118      	str	r0, [r3, #16]
    3eb0:	2100      	movs	r1, #0
    3eb2:	f36f 0100 	bfc	r1, #0, #1
    3eb6:	f36f 0141 	bfc	r1, #1, #1
    3eba:	f36f 0182 	bfc	r1, #2, #1
    3ebe:	f36f 01c5 	bfc	r1, #3, #3
    3ec2:	2301      	movs	r3, #1
    3ec4:	f363 1188 	bfi	r1, r3, #6, #3
    3ec8:	f40c 7c7d 	and.w	ip, ip, #1012	; 0x3f4
    3ecc:	f36c 2152 	bfi	r1, ip, #9, #10
    3ed0:	f36f 41de 	bfc	r1, #19, #12
    3ed4:	f36f 71df 	bfc	r1, #31, #1
    3ed8:	2300      	movs	r3, #0
    3eda:	4846      	ldr	r0, [pc, #280]	; (3ff4 <esf_dump+0x234>)
    3edc:	f7fe f9b4 	bl	2248 <z_impl_z_log_msg_static_create>
    3ee0:	46ad      	mov	sp, r5
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    3ee2:	69e0      	ldr	r0, [r4, #28]
    3ee4:	466d      	mov	r5, sp
    3ee6:	b088      	sub	sp, #32
    3ee8:	466b      	mov	r3, sp
    3eea:	f113 0210 	adds.w	r2, r3, #16
    3eee:	d072      	beq.n	3fd6 <esf_dump+0x216>
    3ef0:	210c      	movs	r1, #12
    3ef2:	b11a      	cbz	r2, 3efc <esf_dump+0x13c>
    3ef4:	2904      	cmp	r1, #4
    3ef6:	dd01      	ble.n	3efc <esf_dump+0x13c>
    3ef8:	4e40      	ldr	r6, [pc, #256]	; (3ffc <esf_dump+0x23c>)
    3efa:	615e      	str	r6, [r3, #20]
    3efc:	b112      	cbz	r2, 3f04 <esf_dump+0x144>
    3efe:	2908      	cmp	r1, #8
    3f00:	dd00      	ble.n	3f04 <esf_dump+0x144>
    3f02:	6198      	str	r0, [r3, #24]
    3f04:	290b      	cmp	r1, #11
    3f06:	dd69      	ble.n	3fdc <esf_dump+0x21c>
    3f08:	f04f 0c0c 	mov.w	ip, #12
    3f0c:	b13a      	cbz	r2, 3f1e <esf_dump+0x15e>
    3f0e:	2103      	movs	r1, #3
    3f10:	7139      	strb	r1, [r7, #4]
    3f12:	2100      	movs	r1, #0
    3f14:	7179      	strb	r1, [r7, #5]
    3f16:	71b9      	strb	r1, [r7, #6]
    3f18:	71f9      	strb	r1, [r7, #7]
    3f1a:	6878      	ldr	r0, [r7, #4]
    3f1c:	6118      	str	r0, [r3, #16]
    3f1e:	2100      	movs	r1, #0
    3f20:	f36f 0100 	bfc	r1, #0, #1
    3f24:	f36f 0141 	bfc	r1, #1, #1
    3f28:	f36f 0182 	bfc	r1, #2, #1
    3f2c:	f36f 01c5 	bfc	r1, #3, #3
    3f30:	2301      	movs	r3, #1
    3f32:	f363 1188 	bfi	r1, r3, #6, #3
    3f36:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    3f3a:	f36c 2152 	bfi	r1, ip, #9, #10
    3f3e:	f36f 41de 	bfc	r1, #19, #12
    3f42:	f36f 71df 	bfc	r1, #31, #1
    3f46:	2300      	movs	r3, #0
    3f48:	482a      	ldr	r0, [pc, #168]	; (3ff4 <esf_dump+0x234>)
    3f4a:	f7fe f97d 	bl	2248 <z_impl_z_log_msg_static_create>
    3f4e:	46ad      	mov	sp, r5
	}

	LOG_ERR("EXC_RETURN: 0x%0x", esf->extra_info.exc_return);

#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    3f50:	69a0      	ldr	r0, [r4, #24]
    3f52:	b088      	sub	sp, #32
    3f54:	466b      	mov	r3, sp
    3f56:	f113 0210 	adds.w	r2, r3, #16
    3f5a:	d042      	beq.n	3fe2 <esf_dump+0x222>
    3f5c:	210c      	movs	r1, #12
    3f5e:	b11a      	cbz	r2, 3f68 <esf_dump+0x1a8>
    3f60:	2904      	cmp	r1, #4
    3f62:	dd01      	ble.n	3f68 <esf_dump+0x1a8>
    3f64:	4c26      	ldr	r4, [pc, #152]	; (4000 <CONFIG_FPROTECT_BLOCK_SIZE>)
    3f66:	615c      	str	r4, [r3, #20]
    3f68:	b112      	cbz	r2, 3f70 <esf_dump+0x1b0>
    3f6a:	2908      	cmp	r1, #8
    3f6c:	dd00      	ble.n	3f70 <esf_dump+0x1b0>
    3f6e:	6198      	str	r0, [r3, #24]
    3f70:	290b      	cmp	r1, #11
    3f72:	dd39      	ble.n	3fe8 <esf_dump+0x228>
    3f74:	240c      	movs	r4, #12
    3f76:	b13a      	cbz	r2, 3f88 <esf_dump+0x1c8>
    3f78:	2103      	movs	r1, #3
    3f7a:	7139      	strb	r1, [r7, #4]
    3f7c:	2100      	movs	r1, #0
    3f7e:	7179      	strb	r1, [r7, #5]
    3f80:	71b9      	strb	r1, [r7, #6]
    3f82:	71f9      	strb	r1, [r7, #7]
    3f84:	6878      	ldr	r0, [r7, #4]
    3f86:	6118      	str	r0, [r3, #16]
    3f88:	2100      	movs	r1, #0
    3f8a:	f36f 0100 	bfc	r1, #0, #1
    3f8e:	f36f 0141 	bfc	r1, #1, #1
    3f92:	f36f 0182 	bfc	r1, #2, #1
    3f96:	f36f 01c5 	bfc	r1, #3, #3
    3f9a:	2301      	movs	r3, #1
    3f9c:	f363 1188 	bfi	r1, r3, #6, #3
    3fa0:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    3fa4:	f364 2152 	bfi	r1, r4, #9, #10
    3fa8:	f36f 41de 	bfc	r1, #19, #12
    3fac:	f36f 71df 	bfc	r1, #31, #1
    3fb0:	2300      	movs	r3, #0
    3fb2:	4810      	ldr	r0, [pc, #64]	; (3ff4 <esf_dump+0x234>)
    3fb4:	f7fe f948 	bl	2248 <z_impl_z_log_msg_static_create>
		esf->basic.pc);
}
    3fb8:	370c      	adds	r7, #12
    3fba:	46bd      	mov	sp, r7
    3fbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    3fbe:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    3fc2:	e70d      	b.n	3de0 <esf_dump+0x20>
    3fc4:	f06f 051b 	mvn.w	r5, #27
    3fc8:	e722      	b.n	3e10 <esf_dump+0x50>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    3fca:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    3fce:	e74d      	b.n	3e6c <esf_dump+0xac>
    3fd0:	f06f 0c1b 	mvn.w	ip, #27
    3fd4:	e763      	b.n	3e9e <esf_dump+0xde>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    3fd6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    3fda:	e78a      	b.n	3ef2 <esf_dump+0x132>
    3fdc:	f06f 0c1b 	mvn.w	ip, #27
    3fe0:	e794      	b.n	3f0c <esf_dump+0x14c>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    3fe2:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    3fe6:	e7ba      	b.n	3f5e <esf_dump+0x19e>
    3fe8:	f06f 041b 	mvn.w	r4, #27
    3fec:	e7c3      	b.n	3f76 <esf_dump+0x1b6>
    3fee:	bf00      	nop
    3ff0:	0001d920 	.word	0x0001d920
    3ff4:	0001d084 	.word	0x0001d084
    3ff8:	0001d950 	.word	0x0001d950
    3ffc:	0001d980 	.word	0x0001d980
    4000:	0001d990 	.word	0x0001d990

00004004 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    4004:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    4006:	2800      	cmp	r0, #0
    4008:	db07      	blt.n	401a <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    400a:	f000 021f 	and.w	r2, r0, #31
    400e:	0940      	lsrs	r0, r0, #5
    4010:	2301      	movs	r3, #1
    4012:	4093      	lsls	r3, r2
    4014:	4a01      	ldr	r2, [pc, #4]	; (401c <arch_irq_enable+0x18>)
    4016:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
}
    401a:	4770      	bx	lr
    401c:	e000e100 	.word	0xe000e100

00004020 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    4020:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    4022:	2800      	cmp	r0, #0
    4024:	db0c      	blt.n	4040 <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4026:	f000 021f 	and.w	r2, r0, #31
    402a:	0940      	lsrs	r0, r0, #5
    402c:	2301      	movs	r3, #1
    402e:	4093      	lsls	r3, r2
    4030:	3020      	adds	r0, #32
    4032:	4a04      	ldr	r2, [pc, #16]	; (4044 <arch_irq_disable+0x24>)
    4034:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    4038:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    403c:	f3bf 8f6f 	isb	sy
}
    4040:	4770      	bx	lr
    4042:	bf00      	nop
    4044:	e000e100 	.word	0xe000e100

00004048 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    4048:	0942      	lsrs	r2, r0, #5
    404a:	4b05      	ldr	r3, [pc, #20]	; (4060 <arch_irq_is_enabled+0x18>)
    404c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    4050:	f000 001f 	and.w	r0, r0, #31
    4054:	2301      	movs	r3, #1
    4056:	fa03 f000 	lsl.w	r0, r3, r0
}
    405a:	4010      	ands	r0, r2
    405c:	4770      	bx	lr
    405e:	bf00      	nop
    4060:	e000e100 	.word	0xe000e100

00004064 <z_arm_irq_priority_set>:
			prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
		} else {
			/* Use caller supplied prio level as-is */
		}
	} else {
		prio += _IRQ_PRIO_OFFSET;
    4064:	3101      	adds	r1, #1
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    4066:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    4068:	2800      	cmp	r0, #0
    406a:	db08      	blt.n	407e <z_arm_irq_priority_set+0x1a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    406c:	0149      	lsls	r1, r1, #5
    406e:	b2c9      	uxtb	r1, r1
    4070:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
    4074:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
    4078:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
    407c:	4770      	bx	lr
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    407e:	f000 000f 	and.w	r0, r0, #15
    4082:	0149      	lsls	r1, r1, #5
    4084:	b2c9      	uxtb	r1, r1
    4086:	4b01      	ldr	r3, [pc, #4]	; (408c <z_arm_irq_priority_set+0x28>)
    4088:	5419      	strb	r1, [r3, r0]
}
    408a:	4770      	bx	lr
    408c:	e000ed14 	.word	0xe000ed14

00004090 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    4090:	bf30      	wfi
    b z_SysNmiOnReset
    4092:	f7ff bffd 	b.w	4090 <z_SysNmiOnReset>
    4096:	bf00      	nop

00004098 <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
    4098:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    409a:	4b0b      	ldr	r3, [pc, #44]	; (40c8 <z_arm_prep_c+0x30>)
    409c:	4a0b      	ldr	r2, [pc, #44]	; (40cc <z_arm_prep_c+0x34>)
    409e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    40a2:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    40a4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    40a8:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    40ac:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    40b0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    40b4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    40b8:	f00f fa60 	bl	1357c <z_bss_zero>
	z_data_copy();
    40bc:	f010 fbb2 	bl	14824 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    40c0:	f000 ff82 	bl	4fc8 <z_arm_interrupt_init>
	z_cstart();
    40c4:	f00f fab6 	bl	13634 <z_cstart>
    40c8:	e000ed00 	.word	0xe000ed00
    40cc:	00000000 	.word	0x00000000

000040d0 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    40d0:	4a0a      	ldr	r2, [pc, #40]	; (40fc <arch_swap+0x2c>)
    40d2:	6893      	ldr	r3, [r2, #8]
    40d4:	f8c3 00ac 	str.w	r0, [r3, #172]	; 0xac
	_current->arch.swap_return_value = _k_neg_eagain;
    40d8:	4909      	ldr	r1, [pc, #36]	; (4100 <arch_swap+0x30>)
    40da:	6809      	ldr	r1, [r1, #0]
    40dc:	f8c3 10b0 	str.w	r1, [r3, #176]	; 0xb0

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    40e0:	4908      	ldr	r1, [pc, #32]	; (4104 <arch_swap+0x34>)
    40e2:	684b      	ldr	r3, [r1, #4]
    40e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    40e8:	604b      	str	r3, [r1, #4]
    40ea:	2300      	movs	r3, #0
    40ec:	f383 8811 	msr	BASEPRI, r3
    40f0:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    40f4:	6893      	ldr	r3, [r2, #8]
}
    40f6:	f8d3 00b0 	ldr.w	r0, [r3, #176]	; 0xb0
    40fa:	4770      	bx	lr
    40fc:	200026d8 	.word	0x200026d8
    4100:	0001fec8 	.word	0x0001fec8
    4104:	e000ed00 	.word	0xe000ed00

00004108 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    4108:	4914      	ldr	r1, [pc, #80]	; (415c <z_arm_pendsv+0x54>)
    ldr r2, [r1, #_kernel_offset_to_current]
    410a:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    410c:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    4110:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    4112:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    4116:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    411a:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    411c:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    4120:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    4124:	4f0e      	ldr	r7, [pc, #56]	; (4160 <z_arm_pendsv+0x58>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    4126:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    412a:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    412c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    412e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    4130:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    movs r3, #0
    4134:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    4136:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    413a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    413e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    4142:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    4146:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
    414a:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
    414e:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
    4150:	f013 fa04 	bl	1755c <configure_builtin_stack_guard>
    pop {r2, lr}
    4154:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    4158:	4770      	bx	lr
    415a:	0000      	.short	0x0000
    ldr r1, =_kernel
    415c:	200026d8 	.word	0x200026d8
    ldr v4, =_SCS_ICSR
    4160:	e000ed04 	.word	0xe000ed04

00004164 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    4164:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    4168:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    416a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    416e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    4172:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    4174:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    4178:	2902      	cmp	r1, #2
    beq _oops
    417a:	d0ff      	beq.n	417c <_oops>

0000417c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    417c:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
    417e:	f013 f9db 	bl	17538 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
    4182:	bd01      	pop	{r0, pc}

00004184 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    4184:	b410      	push	{r4}
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    4186:	f1a2 0420 	sub.w	r4, r2, #32
		iframe->pc = (uint32_t)arch_user_mode_enter;
	} else {
		iframe->pc = (uint32_t)z_thread_entry;
	}
#else
	iframe->pc = (uint32_t)z_thread_entry;
    418a:	490e      	ldr	r1, [pc, #56]	; (41c4 <arch_new_thread+0x40>)
    418c:	f842 1c08 	str.w	r1, [r2, #-8]
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    4190:	f021 0101 	bic.w	r1, r1, #1
    4194:	f842 1c08 	str.w	r1, [r2, #-8]
#endif
	iframe->a1 = (uint32_t)entry;
    4198:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    419c:	9b01      	ldr	r3, [sp, #4]
    419e:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
    41a2:	9b02      	ldr	r3, [sp, #8]
    41a4:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    41a8:	9b03      	ldr	r3, [sp, #12]
    41aa:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    41ae:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    41b2:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe = (struct __basic_sf *)
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
    41b6:	6504      	str	r4, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    41b8:	2300      	movs	r3, #0
    41ba:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    41be:	bc10      	pop	{r4}
    41c0:	4770      	bx	lr
    41c2:	bf00      	nop
    41c4:	00015a41 	.word	0x00015a41

000041c8 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    41c8:	4b09      	ldr	r3, [pc, #36]	; (41f0 <arch_switch_to_main_thread+0x28>)
    41ca:	6098      	str	r0, [r3, #8]
#endif

#if defined(CONFIG_BUILTIN_STACK_GUARD)
	/* Set PSPLIM register for built-in stack guarding of main thread. */
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
	__set_PSPLIM(main_thread->stack_info.start);
    41cc:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
    41d0:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    41d4:	4610      	mov	r0, r2
    41d6:	f381 8809 	msr	PSP, r1
    41da:	2100      	movs	r1, #0
    41dc:	b663      	cpsie	if
    41de:	f381 8811 	msr	BASEPRI, r1
    41e2:	f3bf 8f6f 	isb	sy
    41e6:	2200      	movs	r2, #0
    41e8:	2300      	movs	r3, #0
    41ea:	f011 fc29 	bl	15a40 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    41ee:	bf00      	nop
    41f0:	200026d8 	.word	0x200026d8

000041f4 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    41f4:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    41f6:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    41f8:	4a0b      	ldr	r2, [pc, #44]	; (4228 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    41fa:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    41fc:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    41fe:	bf1e      	ittt	ne
	movne	r1, #0
    4200:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    4202:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
    4204:	f017 fefc 	blne	1c000 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    4208:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    420a:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    420e:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    4212:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    4216:	4905      	ldr	r1, [pc, #20]	; (422c <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    4218:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    421a:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    421c:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    421e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    4222:	4903      	ldr	r1, [pc, #12]	; (4230 <_isr_wrapper+0x3c>)
	bx r1
    4224:	4708      	bx	r1
    4226:	0000      	.short	0x0000
	ldr r2, =_kernel
    4228:	200026d8 	.word	0x200026d8
	ldr r1, =_sw_isr_table
    422c:	0001cd04 	.word	0x0001cd04
	ldr r1, =z_arm_int_exit
    4230:	00004235 	.word	0x00004235

00004234 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    4234:	4b04      	ldr	r3, [pc, #16]	; (4248 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    4236:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    4238:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    423a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    423c:	d003      	beq.n	4246 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    423e:	4903      	ldr	r1, [pc, #12]	; (424c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    4240:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    4244:	600a      	str	r2, [r1, #0]

00004246 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    4246:	4770      	bx	lr
	ldr r3, =_kernel
    4248:	200026d8 	.word	0x200026d8
	ldr r1, =_SCS_ICSR
    424c:	e000ed04 	.word	0xe000ed04

00004250 <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
    4250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4254:	b0a6      	sub	sp, #152	; 0x98
    4256:	af00      	add	r7, sp, #0
    4258:	4605      	mov	r5, r0
    425a:	460e      	mov	r6, r1
    425c:	4614      	mov	r4, r2
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
    425e:	4bad      	ldr	r3, [pc, #692]	; (4514 <mem_manage_fault+0x2c4>)
    4260:	61fb      	str	r3, [r7, #28]
    4262:	2302      	movs	r3, #2
    4264:	713b      	strb	r3, [r7, #4]
    4266:	2300      	movs	r3, #0
    4268:	717b      	strb	r3, [r7, #5]
    426a:	71bb      	strb	r3, [r7, #6]
    426c:	71fb      	strb	r3, [r7, #7]
    426e:	687a      	ldr	r2, [r7, #4]
    4270:	61ba      	str	r2, [r7, #24]
    4272:	4619      	mov	r1, r3
    4274:	f363 0100 	bfi	r1, r3, #0, #1
    4278:	f363 0141 	bfi	r1, r3, #1, #1
    427c:	f363 0182 	bfi	r1, r3, #2, #1
    4280:	f363 01c5 	bfi	r1, r3, #3, #3
    4284:	2201      	movs	r2, #1
    4286:	f362 1188 	bfi	r1, r2, #6, #3
    428a:	2208      	movs	r2, #8
    428c:	f362 2152 	bfi	r1, r2, #9, #10
    4290:	f363 41de 	bfi	r1, r3, #19, #12
    4294:	f363 71df 	bfi	r1, r3, #31, #1
    4298:	f107 0218 	add.w	r2, r7, #24
    429c:	489e      	ldr	r0, [pc, #632]	; (4518 <mem_manage_fault+0x2c8>)
    429e:	f7fd ffd3 	bl	2248 <z_impl_z_log_msg_static_create>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    42a2:	4b9e      	ldr	r3, [pc, #632]	; (451c <mem_manage_fault+0x2cc>)
    42a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42a6:	f013 0f10 	tst.w	r3, #16
    42aa:	d135      	bne.n	4318 <mem_manage_fault+0xc8>
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    42ac:	4b9b      	ldr	r3, [pc, #620]	; (451c <mem_manage_fault+0x2cc>)
    42ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42b0:	f013 0f08 	tst.w	r3, #8
    42b4:	d153      	bne.n	435e <mem_manage_fault+0x10e>
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    42b6:	4b99      	ldr	r3, [pc, #612]	; (451c <mem_manage_fault+0x2cc>)
    42b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42ba:	f013 0f02 	tst.w	r3, #2
    42be:	d171      	bne.n	43a4 <mem_manage_fault+0x154>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    42c0:	4b96      	ldr	r3, [pc, #600]	; (451c <mem_manage_fault+0x2cc>)
    42c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42c4:	f013 0f01 	tst.w	r3, #1
    42c8:	f040 80dc 	bne.w	4484 <mem_manage_fault+0x234>
		PR_FAULT_INFO("  Instruction Access Violation");
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    42cc:	4b93      	ldr	r3, [pc, #588]	; (451c <mem_manage_fault+0x2cc>)
    42ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42d0:	f013 0f20 	tst.w	r3, #32
    42d4:	f040 80f9 	bne.w	44ca <mem_manage_fault+0x27a>
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    42d8:	4b90      	ldr	r3, [pc, #576]	; (451c <mem_manage_fault+0x2cc>)
    42da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42dc:	f013 0f10 	tst.w	r3, #16
    42e0:	d101      	bne.n	42e6 <mem_manage_fault+0x96>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    42e2:	4b8e      	ldr	r3, [pc, #568]	; (451c <mem_manage_fault+0x2cc>)
    42e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	 * lazy stacking Memory Manage fault. At the time of writing, this
	 * can happen when printing.  If that's true, we should clear the
	 * pending flag in addition to the clearing the reason for the fault
	 */
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    42e6:	4b8d      	ldr	r3, [pc, #564]	; (451c <mem_manage_fault+0x2cc>)
    42e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    42ea:	f013 0f20 	tst.w	r3, #32
    42ee:	d004      	beq.n	42fa <mem_manage_fault+0xaa>
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
    42f0:	4a8a      	ldr	r2, [pc, #552]	; (451c <mem_manage_fault+0x2cc>)
    42f2:	6a53      	ldr	r3, [r2, #36]	; 0x24
    42f4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    42f8:	6253      	str	r3, [r2, #36]	; 0x24
	}
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    42fa:	4a88      	ldr	r2, [pc, #544]	; (451c <mem_manage_fault+0x2cc>)
    42fc:	6a93      	ldr	r3, [r2, #40]	; 0x28
    42fe:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    4302:	6293      	str	r3, [r2, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
    4304:	2101      	movs	r1, #1
    4306:	4628      	mov	r0, r5
    4308:	f013 f92d 	bl	17566 <memory_fault_recoverable>
    430c:	7020      	strb	r0, [r4, #0]

	return reason;
}
    430e:	2000      	movs	r0, #0
    4310:	3798      	adds	r7, #152	; 0x98
    4312:	46bd      	mov	sp, r7
    4314:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PR_FAULT_INFO("  Stacking error (context area might be"
    4318:	4b81      	ldr	r3, [pc, #516]	; (4520 <mem_manage_fault+0x2d0>)
    431a:	637b      	str	r3, [r7, #52]	; 0x34
    431c:	2302      	movs	r3, #2
    431e:	713b      	strb	r3, [r7, #4]
    4320:	2300      	movs	r3, #0
    4322:	717b      	strb	r3, [r7, #5]
    4324:	71bb      	strb	r3, [r7, #6]
    4326:	71fb      	strb	r3, [r7, #7]
    4328:	687a      	ldr	r2, [r7, #4]
    432a:	633a      	str	r2, [r7, #48]	; 0x30
    432c:	4619      	mov	r1, r3
    432e:	f363 0100 	bfi	r1, r3, #0, #1
    4332:	f363 0141 	bfi	r1, r3, #1, #1
    4336:	f363 0182 	bfi	r1, r3, #2, #1
    433a:	f363 01c5 	bfi	r1, r3, #3, #3
    433e:	2201      	movs	r2, #1
    4340:	f362 1188 	bfi	r1, r2, #6, #3
    4344:	2208      	movs	r2, #8
    4346:	f362 2152 	bfi	r1, r2, #9, #10
    434a:	f363 41de 	bfi	r1, r3, #19, #12
    434e:	f363 71df 	bfi	r1, r3, #31, #1
    4352:	f107 0230 	add.w	r2, r7, #48	; 0x30
    4356:	4870      	ldr	r0, [pc, #448]	; (4518 <mem_manage_fault+0x2c8>)
    4358:	f7fd ff76 	bl	2248 <z_impl_z_log_msg_static_create>
    435c:	e7a6      	b.n	42ac <mem_manage_fault+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    435e:	4b71      	ldr	r3, [pc, #452]	; (4524 <mem_manage_fault+0x2d4>)
    4360:	64fb      	str	r3, [r7, #76]	; 0x4c
    4362:	2302      	movs	r3, #2
    4364:	713b      	strb	r3, [r7, #4]
    4366:	2300      	movs	r3, #0
    4368:	717b      	strb	r3, [r7, #5]
    436a:	71bb      	strb	r3, [r7, #6]
    436c:	71fb      	strb	r3, [r7, #7]
    436e:	687a      	ldr	r2, [r7, #4]
    4370:	64ba      	str	r2, [r7, #72]	; 0x48
    4372:	4619      	mov	r1, r3
    4374:	f363 0100 	bfi	r1, r3, #0, #1
    4378:	f363 0141 	bfi	r1, r3, #1, #1
    437c:	f363 0182 	bfi	r1, r3, #2, #1
    4380:	f363 01c5 	bfi	r1, r3, #3, #3
    4384:	2201      	movs	r2, #1
    4386:	f362 1188 	bfi	r1, r2, #6, #3
    438a:	2208      	movs	r2, #8
    438c:	f362 2152 	bfi	r1, r2, #9, #10
    4390:	f363 41de 	bfi	r1, r3, #19, #12
    4394:	f363 71df 	bfi	r1, r3, #31, #1
    4398:	f107 0248 	add.w	r2, r7, #72	; 0x48
    439c:	485e      	ldr	r0, [pc, #376]	; (4518 <mem_manage_fault+0x2c8>)
    439e:	f7fd ff53 	bl	2248 <z_impl_z_log_msg_static_create>
    43a2:	e788      	b.n	42b6 <mem_manage_fault+0x66>
		PR_FAULT_INFO("  Data Access Violation");
    43a4:	4b60      	ldr	r3, [pc, #384]	; (4528 <mem_manage_fault+0x2d8>)
    43a6:	667b      	str	r3, [r7, #100]	; 0x64
    43a8:	2302      	movs	r3, #2
    43aa:	713b      	strb	r3, [r7, #4]
    43ac:	2300      	movs	r3, #0
    43ae:	717b      	strb	r3, [r7, #5]
    43b0:	71bb      	strb	r3, [r7, #6]
    43b2:	71fb      	strb	r3, [r7, #7]
    43b4:	687a      	ldr	r2, [r7, #4]
    43b6:	663a      	str	r2, [r7, #96]	; 0x60
    43b8:	4619      	mov	r1, r3
    43ba:	f363 0100 	bfi	r1, r3, #0, #1
    43be:	f363 0141 	bfi	r1, r3, #1, #1
    43c2:	f363 0182 	bfi	r1, r3, #2, #1
    43c6:	f363 01c5 	bfi	r1, r3, #3, #3
    43ca:	2201      	movs	r2, #1
    43cc:	f362 1188 	bfi	r1, r2, #6, #3
    43d0:	2208      	movs	r2, #8
    43d2:	f362 2152 	bfi	r1, r2, #9, #10
    43d6:	f363 41de 	bfi	r1, r3, #19, #12
    43da:	f363 71df 	bfi	r1, r3, #31, #1
    43de:	f107 0260 	add.w	r2, r7, #96	; 0x60
    43e2:	484d      	ldr	r0, [pc, #308]	; (4518 <mem_manage_fault+0x2c8>)
    43e4:	f7fd ff30 	bl	2248 <z_impl_z_log_msg_static_create>
		uint32_t temp = SCB->MMFAR;
    43e8:	4b4c      	ldr	r3, [pc, #304]	; (451c <mem_manage_fault+0x2cc>)
    43ea:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    43ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    43ee:	f013 0f80 	tst.w	r3, #128	; 0x80
    43f2:	f43f af65 	beq.w	42c0 <mem_manage_fault+0x70>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    43f6:	46e8      	mov	r8, sp
    43f8:	b088      	sub	sp, #32
    43fa:	466b      	mov	r3, sp
    43fc:	f113 0210 	adds.w	r2, r3, #16
    4400:	d03a      	beq.n	4478 <mem_manage_fault+0x228>
    4402:	210c      	movs	r1, #12
    4404:	b12a      	cbz	r2, 4412 <mem_manage_fault+0x1c2>
    4406:	2904      	cmp	r1, #4
    4408:	dd03      	ble.n	4412 <mem_manage_fault+0x1c2>
    440a:	f8df c120 	ldr.w	ip, [pc, #288]	; 452c <mem_manage_fault+0x2dc>
    440e:	f8c3 c014 	str.w	ip, [r3, #20]
    4412:	b112      	cbz	r2, 441a <mem_manage_fault+0x1ca>
    4414:	2908      	cmp	r1, #8
    4416:	dd00      	ble.n	441a <mem_manage_fault+0x1ca>
    4418:	6198      	str	r0, [r3, #24]
    441a:	290b      	cmp	r1, #11
    441c:	dd2f      	ble.n	447e <mem_manage_fault+0x22e>
    441e:	f04f 0c0c 	mov.w	ip, #12
    4422:	b13a      	cbz	r2, 4434 <mem_manage_fault+0x1e4>
    4424:	2103      	movs	r1, #3
    4426:	7139      	strb	r1, [r7, #4]
    4428:	2100      	movs	r1, #0
    442a:	7179      	strb	r1, [r7, #5]
    442c:	71b9      	strb	r1, [r7, #6]
    442e:	71f9      	strb	r1, [r7, #7]
    4430:	6878      	ldr	r0, [r7, #4]
    4432:	6118      	str	r0, [r3, #16]
    4434:	2100      	movs	r1, #0
    4436:	f36f 0100 	bfc	r1, #0, #1
    443a:	f36f 0141 	bfc	r1, #1, #1
    443e:	f36f 0182 	bfc	r1, #2, #1
    4442:	f36f 01c5 	bfc	r1, #3, #3
    4446:	2301      	movs	r3, #1
    4448:	f363 1188 	bfi	r1, r3, #6, #3
    444c:	f40c 737b 	and.w	r3, ip, #1004	; 0x3ec
    4450:	f363 2152 	bfi	r1, r3, #9, #10
    4454:	f36f 41de 	bfc	r1, #19, #12
    4458:	f36f 71df 	bfc	r1, #31, #1
    445c:	2300      	movs	r3, #0
    445e:	482e      	ldr	r0, [pc, #184]	; (4518 <mem_manage_fault+0x2c8>)
    4460:	f7fd fef2 	bl	2248 <z_impl_z_log_msg_static_create>
    4464:	46c5      	mov	sp, r8
			if (from_hard_fault != 0) {
    4466:	2e00      	cmp	r6, #0
    4468:	f43f af2a 	beq.w	42c0 <mem_manage_fault+0x70>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    446c:	4a2b      	ldr	r2, [pc, #172]	; (451c <mem_manage_fault+0x2cc>)
    446e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4470:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    4474:	6293      	str	r3, [r2, #40]	; 0x28
    4476:	e723      	b.n	42c0 <mem_manage_fault+0x70>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    4478:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    447c:	e7c2      	b.n	4404 <mem_manage_fault+0x1b4>
    447e:	f06f 0c1b 	mvn.w	ip, #27
    4482:	e7ce      	b.n	4422 <mem_manage_fault+0x1d2>
		PR_FAULT_INFO("  Instruction Access Violation");
    4484:	4b2a      	ldr	r3, [pc, #168]	; (4530 <mem_manage_fault+0x2e0>)
    4486:	67fb      	str	r3, [r7, #124]	; 0x7c
    4488:	2302      	movs	r3, #2
    448a:	713b      	strb	r3, [r7, #4]
    448c:	2300      	movs	r3, #0
    448e:	717b      	strb	r3, [r7, #5]
    4490:	71bb      	strb	r3, [r7, #6]
    4492:	71fb      	strb	r3, [r7, #7]
    4494:	687a      	ldr	r2, [r7, #4]
    4496:	67ba      	str	r2, [r7, #120]	; 0x78
    4498:	4619      	mov	r1, r3
    449a:	f363 0100 	bfi	r1, r3, #0, #1
    449e:	f363 0141 	bfi	r1, r3, #1, #1
    44a2:	f363 0182 	bfi	r1, r3, #2, #1
    44a6:	f363 01c5 	bfi	r1, r3, #3, #3
    44aa:	2201      	movs	r2, #1
    44ac:	f362 1188 	bfi	r1, r2, #6, #3
    44b0:	2208      	movs	r2, #8
    44b2:	f362 2152 	bfi	r1, r2, #9, #10
    44b6:	f363 41de 	bfi	r1, r3, #19, #12
    44ba:	f363 71df 	bfi	r1, r3, #31, #1
    44be:	f107 0278 	add.w	r2, r7, #120	; 0x78
    44c2:	4815      	ldr	r0, [pc, #84]	; (4518 <mem_manage_fault+0x2c8>)
    44c4:	f7fd fec0 	bl	2248 <z_impl_z_log_msg_static_create>
    44c8:	e700      	b.n	42cc <mem_manage_fault+0x7c>
		PR_FAULT_INFO(
    44ca:	4b1a      	ldr	r3, [pc, #104]	; (4534 <mem_manage_fault+0x2e4>)
    44cc:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    44d0:	2302      	movs	r3, #2
    44d2:	713b      	strb	r3, [r7, #4]
    44d4:	2300      	movs	r3, #0
    44d6:	717b      	strb	r3, [r7, #5]
    44d8:	71bb      	strb	r3, [r7, #6]
    44da:	71fb      	strb	r3, [r7, #7]
    44dc:	687a      	ldr	r2, [r7, #4]
    44de:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
    44e2:	4619      	mov	r1, r3
    44e4:	f363 0100 	bfi	r1, r3, #0, #1
    44e8:	f363 0141 	bfi	r1, r3, #1, #1
    44ec:	f363 0182 	bfi	r1, r3, #2, #1
    44f0:	f363 01c5 	bfi	r1, r3, #3, #3
    44f4:	2201      	movs	r2, #1
    44f6:	f362 1188 	bfi	r1, r2, #6, #3
    44fa:	2208      	movs	r2, #8
    44fc:	f362 2152 	bfi	r1, r2, #9, #10
    4500:	f363 41de 	bfi	r1, r3, #19, #12
    4504:	f363 71df 	bfi	r1, r3, #31, #1
    4508:	f107 0290 	add.w	r2, r7, #144	; 0x90
    450c:	4802      	ldr	r0, [pc, #8]	; (4518 <mem_manage_fault+0x2c8>)
    450e:	f7fd fe9b 	bl	2248 <z_impl_z_log_msg_static_create>
    4512:	e6e1      	b.n	42d8 <mem_manage_fault+0x88>
    4514:	0001d9c0 	.word	0x0001d9c0
    4518:	0001d084 	.word	0x0001d084
    451c:	e000ed00 	.word	0xe000ed00
    4520:	0001d9d8 	.word	0x0001d9d8
    4524:	0001da0c 	.word	0x0001da0c
    4528:	0001da20 	.word	0x0001da20
    452c:	0001da38 	.word	0x0001da38
    4530:	0001da50 	.word	0x0001da50
    4534:	0001da70 	.word	0x0001da70

00004538 <bus_fault>:
 *
 * @return error code to identify the fatal error reason.
 *
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
{
    4538:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    453c:	b0ac      	sub	sp, #176	; 0xb0
    453e:	af00      	add	r7, sp, #0
    4540:	4605      	mov	r5, r0
    4542:	460e      	mov	r6, r1
    4544:	4614      	mov	r4, r2
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
    4546:	4bba      	ldr	r3, [pc, #744]	; (4830 <bus_fault+0x2f8>)
    4548:	61fb      	str	r3, [r7, #28]
    454a:	2302      	movs	r3, #2
    454c:	713b      	strb	r3, [r7, #4]
    454e:	2300      	movs	r3, #0
    4550:	717b      	strb	r3, [r7, #5]
    4552:	71bb      	strb	r3, [r7, #6]
    4554:	71fb      	strb	r3, [r7, #7]
    4556:	687a      	ldr	r2, [r7, #4]
    4558:	61ba      	str	r2, [r7, #24]
    455a:	4619      	mov	r1, r3
    455c:	f363 0100 	bfi	r1, r3, #0, #1
    4560:	f363 0141 	bfi	r1, r3, #1, #1
    4564:	f363 0182 	bfi	r1, r3, #2, #1
    4568:	f363 01c5 	bfi	r1, r3, #3, #3
    456c:	2201      	movs	r2, #1
    456e:	f362 1188 	bfi	r1, r2, #6, #3
    4572:	2208      	movs	r2, #8
    4574:	f362 2152 	bfi	r1, r2, #9, #10
    4578:	f363 41de 	bfi	r1, r3, #19, #12
    457c:	f363 71df 	bfi	r1, r3, #31, #1
    4580:	f107 0218 	add.w	r2, r7, #24
    4584:	48ab      	ldr	r0, [pc, #684]	; (4834 <bus_fault+0x2fc>)
    4586:	f7fd fe5f 	bl	2248 <z_impl_z_log_msg_static_create>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    458a:	4bab      	ldr	r3, [pc, #684]	; (4838 <bus_fault+0x300>)
    458c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    458e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    4592:	d12a      	bne.n	45ea <bus_fault+0xb2>
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    4594:	4ba8      	ldr	r3, [pc, #672]	; (4838 <bus_fault+0x300>)
    4596:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4598:	f413 6f00 	tst.w	r3, #2048	; 0x800
    459c:	d148      	bne.n	4630 <bus_fault+0xf8>
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    459e:	4ba6      	ldr	r3, [pc, #664]	; (4838 <bus_fault+0x300>)
    45a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    45a2:	f413 7f00 	tst.w	r3, #512	; 0x200
    45a6:	d166      	bne.n	4676 <bus_fault+0x13e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    45a8:	4ba3      	ldr	r3, [pc, #652]	; (4838 <bus_fault+0x300>)
    45aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    45ac:	f413 6f80 	tst.w	r3, #1024	; 0x400
    45b0:	f040 80d1 	bne.w	4756 <bus_fault+0x21e>
		PR_FAULT_INFO("  Imprecise data bus error");
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    45b4:	4ba0      	ldr	r3, [pc, #640]	; (4838 <bus_fault+0x300>)
    45b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    45b8:	f413 7f80 	tst.w	r3, #256	; 0x100
    45bc:	f040 80ee 	bne.w	479c <bus_fault+0x264>
		PR_FAULT_INFO("  Instruction bus error");
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    45c0:	4b9d      	ldr	r3, [pc, #628]	; (4838 <bus_fault+0x300>)
    45c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    45c4:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    45c8:	f040 810d 	bne.w	47e6 <bus_fault+0x2ae>
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    45cc:	4a9a      	ldr	r2, [pc, #616]	; (4838 <bus_fault+0x300>)
    45ce:	6a93      	ldr	r3, [r2, #40]	; 0x28
    45d0:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    45d4:	6293      	str	r3, [r2, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
    45d6:	2101      	movs	r1, #1
    45d8:	4628      	mov	r0, r5
    45da:	f012 ffc4 	bl	17566 <memory_fault_recoverable>
    45de:	7020      	strb	r0, [r4, #0]

	return reason;
}
    45e0:	2000      	movs	r0, #0
    45e2:	37b0      	adds	r7, #176	; 0xb0
    45e4:	46bd      	mov	sp, r7
    45e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		PR_FAULT_INFO("  Stacking error");
    45ea:	4b94      	ldr	r3, [pc, #592]	; (483c <bus_fault+0x304>)
    45ec:	637b      	str	r3, [r7, #52]	; 0x34
    45ee:	2302      	movs	r3, #2
    45f0:	713b      	strb	r3, [r7, #4]
    45f2:	2300      	movs	r3, #0
    45f4:	717b      	strb	r3, [r7, #5]
    45f6:	71bb      	strb	r3, [r7, #6]
    45f8:	71fb      	strb	r3, [r7, #7]
    45fa:	687a      	ldr	r2, [r7, #4]
    45fc:	633a      	str	r2, [r7, #48]	; 0x30
    45fe:	4619      	mov	r1, r3
    4600:	f363 0100 	bfi	r1, r3, #0, #1
    4604:	f363 0141 	bfi	r1, r3, #1, #1
    4608:	f363 0182 	bfi	r1, r3, #2, #1
    460c:	f363 01c5 	bfi	r1, r3, #3, #3
    4610:	2201      	movs	r2, #1
    4612:	f362 1188 	bfi	r1, r2, #6, #3
    4616:	2208      	movs	r2, #8
    4618:	f362 2152 	bfi	r1, r2, #9, #10
    461c:	f363 41de 	bfi	r1, r3, #19, #12
    4620:	f363 71df 	bfi	r1, r3, #31, #1
    4624:	f107 0230 	add.w	r2, r7, #48	; 0x30
    4628:	4882      	ldr	r0, [pc, #520]	; (4834 <bus_fault+0x2fc>)
    462a:	f7fd fe0d 	bl	2248 <z_impl_z_log_msg_static_create>
    462e:	e7b1      	b.n	4594 <bus_fault+0x5c>
		PR_FAULT_INFO("  Unstacking error");
    4630:	4b83      	ldr	r3, [pc, #524]	; (4840 <bus_fault+0x308>)
    4632:	64fb      	str	r3, [r7, #76]	; 0x4c
    4634:	2302      	movs	r3, #2
    4636:	713b      	strb	r3, [r7, #4]
    4638:	2300      	movs	r3, #0
    463a:	717b      	strb	r3, [r7, #5]
    463c:	71bb      	strb	r3, [r7, #6]
    463e:	71fb      	strb	r3, [r7, #7]
    4640:	687a      	ldr	r2, [r7, #4]
    4642:	64ba      	str	r2, [r7, #72]	; 0x48
    4644:	4619      	mov	r1, r3
    4646:	f363 0100 	bfi	r1, r3, #0, #1
    464a:	f363 0141 	bfi	r1, r3, #1, #1
    464e:	f363 0182 	bfi	r1, r3, #2, #1
    4652:	f363 01c5 	bfi	r1, r3, #3, #3
    4656:	2201      	movs	r2, #1
    4658:	f362 1188 	bfi	r1, r2, #6, #3
    465c:	2208      	movs	r2, #8
    465e:	f362 2152 	bfi	r1, r2, #9, #10
    4662:	f363 41de 	bfi	r1, r3, #19, #12
    4666:	f363 71df 	bfi	r1, r3, #31, #1
    466a:	f107 0248 	add.w	r2, r7, #72	; 0x48
    466e:	4871      	ldr	r0, [pc, #452]	; (4834 <bus_fault+0x2fc>)
    4670:	f7fd fdea 	bl	2248 <z_impl_z_log_msg_static_create>
    4674:	e793      	b.n	459e <bus_fault+0x66>
		PR_FAULT_INFO("  Precise data bus error");
    4676:	4b73      	ldr	r3, [pc, #460]	; (4844 <bus_fault+0x30c>)
    4678:	667b      	str	r3, [r7, #100]	; 0x64
    467a:	2302      	movs	r3, #2
    467c:	713b      	strb	r3, [r7, #4]
    467e:	2300      	movs	r3, #0
    4680:	717b      	strb	r3, [r7, #5]
    4682:	71bb      	strb	r3, [r7, #6]
    4684:	71fb      	strb	r3, [r7, #7]
    4686:	687a      	ldr	r2, [r7, #4]
    4688:	663a      	str	r2, [r7, #96]	; 0x60
    468a:	4619      	mov	r1, r3
    468c:	f363 0100 	bfi	r1, r3, #0, #1
    4690:	f363 0141 	bfi	r1, r3, #1, #1
    4694:	f363 0182 	bfi	r1, r3, #2, #1
    4698:	f363 01c5 	bfi	r1, r3, #3, #3
    469c:	2201      	movs	r2, #1
    469e:	f362 1188 	bfi	r1, r2, #6, #3
    46a2:	2208      	movs	r2, #8
    46a4:	f362 2152 	bfi	r1, r2, #9, #10
    46a8:	f363 41de 	bfi	r1, r3, #19, #12
    46ac:	f363 71df 	bfi	r1, r3, #31, #1
    46b0:	f107 0260 	add.w	r2, r7, #96	; 0x60
    46b4:	485f      	ldr	r0, [pc, #380]	; (4834 <bus_fault+0x2fc>)
    46b6:	f7fd fdc7 	bl	2248 <z_impl_z_log_msg_static_create>
		STORE_xFAR(bfar, SCB->BFAR);
    46ba:	4b5f      	ldr	r3, [pc, #380]	; (4838 <bus_fault+0x300>)
    46bc:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    46be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    46c0:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    46c4:	f43f af70 	beq.w	45a8 <bus_fault+0x70>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    46c8:	46e8      	mov	r8, sp
    46ca:	b088      	sub	sp, #32
    46cc:	466b      	mov	r3, sp
    46ce:	f113 0210 	adds.w	r2, r3, #16
    46d2:	d03a      	beq.n	474a <bus_fault+0x212>
    46d4:	210c      	movs	r1, #12
    46d6:	b12a      	cbz	r2, 46e4 <bus_fault+0x1ac>
    46d8:	2904      	cmp	r1, #4
    46da:	dd03      	ble.n	46e4 <bus_fault+0x1ac>
    46dc:	f8df c168 	ldr.w	ip, [pc, #360]	; 4848 <bus_fault+0x310>
    46e0:	f8c3 c014 	str.w	ip, [r3, #20]
    46e4:	b112      	cbz	r2, 46ec <bus_fault+0x1b4>
    46e6:	2908      	cmp	r1, #8
    46e8:	dd00      	ble.n	46ec <bus_fault+0x1b4>
    46ea:	6198      	str	r0, [r3, #24]
    46ec:	290b      	cmp	r1, #11
    46ee:	dd2f      	ble.n	4750 <bus_fault+0x218>
    46f0:	f04f 0c0c 	mov.w	ip, #12
    46f4:	b13a      	cbz	r2, 4706 <bus_fault+0x1ce>
    46f6:	2103      	movs	r1, #3
    46f8:	7139      	strb	r1, [r7, #4]
    46fa:	2100      	movs	r1, #0
    46fc:	7179      	strb	r1, [r7, #5]
    46fe:	71b9      	strb	r1, [r7, #6]
    4700:	71f9      	strb	r1, [r7, #7]
    4702:	6878      	ldr	r0, [r7, #4]
    4704:	6118      	str	r0, [r3, #16]
    4706:	2100      	movs	r1, #0
    4708:	f36f 0100 	bfc	r1, #0, #1
    470c:	f36f 0141 	bfc	r1, #1, #1
    4710:	f36f 0182 	bfc	r1, #2, #1
    4714:	f36f 01c5 	bfc	r1, #3, #3
    4718:	2301      	movs	r3, #1
    471a:	f363 1188 	bfi	r1, r3, #6, #3
    471e:	f40c 737b 	and.w	r3, ip, #1004	; 0x3ec
    4722:	f363 2152 	bfi	r1, r3, #9, #10
    4726:	f36f 41de 	bfc	r1, #19, #12
    472a:	f36f 71df 	bfc	r1, #31, #1
    472e:	2300      	movs	r3, #0
    4730:	4840      	ldr	r0, [pc, #256]	; (4834 <bus_fault+0x2fc>)
    4732:	f7fd fd89 	bl	2248 <z_impl_z_log_msg_static_create>
    4736:	46c5      	mov	sp, r8
			if (from_hard_fault != 0) {
    4738:	2e00      	cmp	r6, #0
    473a:	f43f af35 	beq.w	45a8 <bus_fault+0x70>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    473e:	4a3e      	ldr	r2, [pc, #248]	; (4838 <bus_fault+0x300>)
    4740:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4742:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    4746:	6293      	str	r3, [r2, #40]	; 0x28
    4748:	e72e      	b.n	45a8 <bus_fault+0x70>
			PR_EXC("  BFAR Address: 0x%x", bfar);
    474a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    474e:	e7c2      	b.n	46d6 <bus_fault+0x19e>
    4750:	f06f 0c1b 	mvn.w	ip, #27
    4754:	e7ce      	b.n	46f4 <bus_fault+0x1bc>
		PR_FAULT_INFO("  Imprecise data bus error");
    4756:	4b3d      	ldr	r3, [pc, #244]	; (484c <bus_fault+0x314>)
    4758:	67fb      	str	r3, [r7, #124]	; 0x7c
    475a:	2302      	movs	r3, #2
    475c:	713b      	strb	r3, [r7, #4]
    475e:	2300      	movs	r3, #0
    4760:	717b      	strb	r3, [r7, #5]
    4762:	71bb      	strb	r3, [r7, #6]
    4764:	71fb      	strb	r3, [r7, #7]
    4766:	687a      	ldr	r2, [r7, #4]
    4768:	67ba      	str	r2, [r7, #120]	; 0x78
    476a:	4619      	mov	r1, r3
    476c:	f363 0100 	bfi	r1, r3, #0, #1
    4770:	f363 0141 	bfi	r1, r3, #1, #1
    4774:	f363 0182 	bfi	r1, r3, #2, #1
    4778:	f363 01c5 	bfi	r1, r3, #3, #3
    477c:	2201      	movs	r2, #1
    477e:	f362 1188 	bfi	r1, r2, #6, #3
    4782:	2208      	movs	r2, #8
    4784:	f362 2152 	bfi	r1, r2, #9, #10
    4788:	f363 41de 	bfi	r1, r3, #19, #12
    478c:	f363 71df 	bfi	r1, r3, #31, #1
    4790:	f107 0278 	add.w	r2, r7, #120	; 0x78
    4794:	4827      	ldr	r0, [pc, #156]	; (4834 <bus_fault+0x2fc>)
    4796:	f7fd fd57 	bl	2248 <z_impl_z_log_msg_static_create>
    479a:	e70b      	b.n	45b4 <bus_fault+0x7c>
		PR_FAULT_INFO("  Instruction bus error");
    479c:	4b2c      	ldr	r3, [pc, #176]	; (4850 <bus_fault+0x318>)
    479e:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    47a2:	2302      	movs	r3, #2
    47a4:	713b      	strb	r3, [r7, #4]
    47a6:	2300      	movs	r3, #0
    47a8:	717b      	strb	r3, [r7, #5]
    47aa:	71bb      	strb	r3, [r7, #6]
    47ac:	71fb      	strb	r3, [r7, #7]
    47ae:	687a      	ldr	r2, [r7, #4]
    47b0:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
    47b4:	4619      	mov	r1, r3
    47b6:	f363 0100 	bfi	r1, r3, #0, #1
    47ba:	f363 0141 	bfi	r1, r3, #1, #1
    47be:	f363 0182 	bfi	r1, r3, #2, #1
    47c2:	f363 01c5 	bfi	r1, r3, #3, #3
    47c6:	2201      	movs	r2, #1
    47c8:	f362 1188 	bfi	r1, r2, #6, #3
    47cc:	2208      	movs	r2, #8
    47ce:	f362 2152 	bfi	r1, r2, #9, #10
    47d2:	f363 41de 	bfi	r1, r3, #19, #12
    47d6:	f363 71df 	bfi	r1, r3, #31, #1
    47da:	f107 02a8 	add.w	r2, r7, #168	; 0xa8
    47de:	4815      	ldr	r0, [pc, #84]	; (4834 <bus_fault+0x2fc>)
    47e0:	f7fd fd32 	bl	2248 <z_impl_z_log_msg_static_create>
    47e4:	e6f2      	b.n	45cc <bus_fault+0x94>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    47e6:	4b1b      	ldr	r3, [pc, #108]	; (4854 <bus_fault+0x31c>)
    47e8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    47ec:	2302      	movs	r3, #2
    47ee:	713b      	strb	r3, [r7, #4]
    47f0:	2300      	movs	r3, #0
    47f2:	717b      	strb	r3, [r7, #5]
    47f4:	71bb      	strb	r3, [r7, #6]
    47f6:	71fb      	strb	r3, [r7, #7]
    47f8:	687a      	ldr	r2, [r7, #4]
    47fa:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
    47fe:	4619      	mov	r1, r3
    4800:	f363 0100 	bfi	r1, r3, #0, #1
    4804:	f363 0141 	bfi	r1, r3, #1, #1
    4808:	f363 0182 	bfi	r1, r3, #2, #1
    480c:	f363 01c5 	bfi	r1, r3, #3, #3
    4810:	2201      	movs	r2, #1
    4812:	f362 1188 	bfi	r1, r2, #6, #3
    4816:	2208      	movs	r2, #8
    4818:	f362 2152 	bfi	r1, r2, #9, #10
    481c:	f363 41de 	bfi	r1, r3, #19, #12
    4820:	f363 71df 	bfi	r1, r3, #31, #1
    4824:	f107 0290 	add.w	r2, r7, #144	; 0x90
    4828:	4802      	ldr	r0, [pc, #8]	; (4834 <bus_fault+0x2fc>)
    482a:	f7fd fd0d 	bl	2248 <z_impl_z_log_msg_static_create>
    482e:	e6cd      	b.n	45cc <bus_fault+0x94>
    4830:	0001daa0 	.word	0x0001daa0
    4834:	0001d084 	.word	0x0001d084
    4838:	e000ed00 	.word	0xe000ed00
    483c:	0001dab8 	.word	0x0001dab8
    4840:	0001da0c 	.word	0x0001da0c
    4844:	0001dacc 	.word	0x0001dacc
    4848:	0001dae8 	.word	0x0001dae8
    484c:	0001db00 	.word	0x0001db00
    4850:	0001db1c 	.word	0x0001db1c
    4854:	0001da70 	.word	0x0001da70

00004858 <usage_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
{
    4858:	b510      	push	{r4, lr}
    485a:	b0b2      	sub	sp, #200	; 0xc8
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    485c:	4baf      	ldr	r3, [pc, #700]	; (4b1c <usage_fault+0x2c4>)
    485e:	9307      	str	r3, [sp, #28]
    4860:	2302      	movs	r3, #2
    4862:	f88d 3004 	strb.w	r3, [sp, #4]
    4866:	2300      	movs	r3, #0
    4868:	f88d 3005 	strb.w	r3, [sp, #5]
    486c:	f88d 3006 	strb.w	r3, [sp, #6]
    4870:	f88d 3007 	strb.w	r3, [sp, #7]
    4874:	9a01      	ldr	r2, [sp, #4]
    4876:	9206      	str	r2, [sp, #24]
    4878:	4619      	mov	r1, r3
    487a:	f363 0100 	bfi	r1, r3, #0, #1
    487e:	f363 0141 	bfi	r1, r3, #1, #1
    4882:	f363 0182 	bfi	r1, r3, #2, #1
    4886:	f363 01c5 	bfi	r1, r3, #3, #3
    488a:	2201      	movs	r2, #1
    488c:	f362 1188 	bfi	r1, r2, #6, #3
    4890:	2208      	movs	r2, #8
    4892:	f362 2152 	bfi	r1, r2, #9, #10
    4896:	f363 41de 	bfi	r1, r3, #19, #12
    489a:	f363 71df 	bfi	r1, r3, #31, #1
    489e:	aa06      	add	r2, sp, #24
    48a0:	489f      	ldr	r0, [pc, #636]	; (4b20 <usage_fault+0x2c8>)
    48a2:	f7fd fcd1 	bl	2248 <z_impl_z_log_msg_static_create>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    48a6:	4b9f      	ldr	r3, [pc, #636]	; (4b24 <usage_fault+0x2cc>)
    48a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48aa:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    48ae:	d12b      	bne.n	4908 <usage_fault+0xb0>
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    48b0:	4b9c      	ldr	r3, [pc, #624]	; (4b24 <usage_fault+0x2cc>)
    48b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48b4:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
    48b8:	d14c      	bne.n	4954 <usage_fault+0xfc>
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    48ba:	4b9a      	ldr	r3, [pc, #616]	; (4b24 <usage_fault+0x2cc>)
    48bc:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    48be:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
    48c2:	d16d      	bne.n	49a0 <usage_fault+0x148>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    48c4:	4b97      	ldr	r3, [pc, #604]	; (4b24 <usage_fault+0x2cc>)
    48c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48c8:	f413 2f00 	tst.w	r3, #524288	; 0x80000
    48cc:	f040 808e 	bne.w	49ec <usage_fault+0x194>
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    48d0:	4b94      	ldr	r3, [pc, #592]	; (4b24 <usage_fault+0x2cc>)
    48d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48d4:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    48d8:	f040 80ae 	bne.w	4a38 <usage_fault+0x1e0>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    48dc:	4b91      	ldr	r3, [pc, #580]	; (4b24 <usage_fault+0x2cc>)
    48de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48e0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    48e4:	f040 80ce 	bne.w	4a84 <usage_fault+0x22c>
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    48e8:	4b8e      	ldr	r3, [pc, #568]	; (4b24 <usage_fault+0x2cc>)
    48ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    48ec:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    48f0:	f040 80ee 	bne.w	4ad0 <usage_fault+0x278>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    48f4:	4a8b      	ldr	r2, [pc, #556]	; (4b24 <usage_fault+0x2cc>)
    48f6:	6a93      	ldr	r3, [r2, #40]	; 0x28
    48f8:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    48fc:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    4900:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    4902:	4620      	mov	r0, r4
    4904:	b032      	add	sp, #200	; 0xc8
    4906:	bd10      	pop	{r4, pc}
		PR_FAULT_INFO("  Division by zero");
    4908:	4b87      	ldr	r3, [pc, #540]	; (4b28 <usage_fault+0x2d0>)
    490a:	930d      	str	r3, [sp, #52]	; 0x34
    490c:	2302      	movs	r3, #2
    490e:	f88d 3004 	strb.w	r3, [sp, #4]
    4912:	2300      	movs	r3, #0
    4914:	f88d 3005 	strb.w	r3, [sp, #5]
    4918:	f88d 3006 	strb.w	r3, [sp, #6]
    491c:	f88d 3007 	strb.w	r3, [sp, #7]
    4920:	9a01      	ldr	r2, [sp, #4]
    4922:	920c      	str	r2, [sp, #48]	; 0x30
    4924:	4619      	mov	r1, r3
    4926:	f363 0100 	bfi	r1, r3, #0, #1
    492a:	f363 0141 	bfi	r1, r3, #1, #1
    492e:	f363 0182 	bfi	r1, r3, #2, #1
    4932:	f363 01c5 	bfi	r1, r3, #3, #3
    4936:	2201      	movs	r2, #1
    4938:	f362 1188 	bfi	r1, r2, #6, #3
    493c:	2208      	movs	r2, #8
    493e:	f362 2152 	bfi	r1, r2, #9, #10
    4942:	f363 41de 	bfi	r1, r3, #19, #12
    4946:	f363 71df 	bfi	r1, r3, #31, #1
    494a:	aa0c      	add	r2, sp, #48	; 0x30
    494c:	4874      	ldr	r0, [pc, #464]	; (4b20 <usage_fault+0x2c8>)
    494e:	f7fd fc7b 	bl	2248 <z_impl_z_log_msg_static_create>
    4952:	e7ad      	b.n	48b0 <usage_fault+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
    4954:	4b75      	ldr	r3, [pc, #468]	; (4b2c <usage_fault+0x2d4>)
    4956:	9313      	str	r3, [sp, #76]	; 0x4c
    4958:	2302      	movs	r3, #2
    495a:	f88d 3004 	strb.w	r3, [sp, #4]
    495e:	2300      	movs	r3, #0
    4960:	f88d 3005 	strb.w	r3, [sp, #5]
    4964:	f88d 3006 	strb.w	r3, [sp, #6]
    4968:	f88d 3007 	strb.w	r3, [sp, #7]
    496c:	9a01      	ldr	r2, [sp, #4]
    496e:	9212      	str	r2, [sp, #72]	; 0x48
    4970:	4619      	mov	r1, r3
    4972:	f363 0100 	bfi	r1, r3, #0, #1
    4976:	f363 0141 	bfi	r1, r3, #1, #1
    497a:	f363 0182 	bfi	r1, r3, #2, #1
    497e:	f363 01c5 	bfi	r1, r3, #3, #3
    4982:	2201      	movs	r2, #1
    4984:	f362 1188 	bfi	r1, r2, #6, #3
    4988:	2208      	movs	r2, #8
    498a:	f362 2152 	bfi	r1, r2, #9, #10
    498e:	f363 41de 	bfi	r1, r3, #19, #12
    4992:	f363 71df 	bfi	r1, r3, #31, #1
    4996:	aa12      	add	r2, sp, #72	; 0x48
    4998:	4861      	ldr	r0, [pc, #388]	; (4b20 <usage_fault+0x2c8>)
    499a:	f7fd fc55 	bl	2248 <z_impl_z_log_msg_static_create>
    499e:	e78c      	b.n	48ba <usage_fault+0x62>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
    49a0:	4b63      	ldr	r3, [pc, #396]	; (4b30 <usage_fault+0x2d8>)
    49a2:	9319      	str	r3, [sp, #100]	; 0x64
    49a4:	2402      	movs	r4, #2
    49a6:	f88d 4004 	strb.w	r4, [sp, #4]
    49aa:	2300      	movs	r3, #0
    49ac:	f88d 3005 	strb.w	r3, [sp, #5]
    49b0:	f88d 3006 	strb.w	r3, [sp, #6]
    49b4:	f88d 3007 	strb.w	r3, [sp, #7]
    49b8:	9a01      	ldr	r2, [sp, #4]
    49ba:	9218      	str	r2, [sp, #96]	; 0x60
    49bc:	4619      	mov	r1, r3
    49be:	f363 0100 	bfi	r1, r3, #0, #1
    49c2:	f363 0141 	bfi	r1, r3, #1, #1
    49c6:	f363 0182 	bfi	r1, r3, #2, #1
    49ca:	f363 01c5 	bfi	r1, r3, #3, #3
    49ce:	2201      	movs	r2, #1
    49d0:	f362 1188 	bfi	r1, r2, #6, #3
    49d4:	2208      	movs	r2, #8
    49d6:	f362 2152 	bfi	r1, r2, #9, #10
    49da:	f363 41de 	bfi	r1, r3, #19, #12
    49de:	f363 71df 	bfi	r1, r3, #31, #1
    49e2:	aa18      	add	r2, sp, #96	; 0x60
    49e4:	484e      	ldr	r0, [pc, #312]	; (4b20 <usage_fault+0x2c8>)
    49e6:	f7fd fc2f 	bl	2248 <z_impl_z_log_msg_static_create>
		reason = K_ERR_STACK_CHK_FAIL;
    49ea:	e76b      	b.n	48c4 <usage_fault+0x6c>
		PR_FAULT_INFO("  No coprocessor instructions");
    49ec:	4b51      	ldr	r3, [pc, #324]	; (4b34 <usage_fault+0x2dc>)
    49ee:	931f      	str	r3, [sp, #124]	; 0x7c
    49f0:	2302      	movs	r3, #2
    49f2:	f88d 3004 	strb.w	r3, [sp, #4]
    49f6:	2300      	movs	r3, #0
    49f8:	f88d 3005 	strb.w	r3, [sp, #5]
    49fc:	f88d 3006 	strb.w	r3, [sp, #6]
    4a00:	f88d 3007 	strb.w	r3, [sp, #7]
    4a04:	9a01      	ldr	r2, [sp, #4]
    4a06:	921e      	str	r2, [sp, #120]	; 0x78
    4a08:	4619      	mov	r1, r3
    4a0a:	f363 0100 	bfi	r1, r3, #0, #1
    4a0e:	f363 0141 	bfi	r1, r3, #1, #1
    4a12:	f363 0182 	bfi	r1, r3, #2, #1
    4a16:	f363 01c5 	bfi	r1, r3, #3, #3
    4a1a:	2201      	movs	r2, #1
    4a1c:	f362 1188 	bfi	r1, r2, #6, #3
    4a20:	2208      	movs	r2, #8
    4a22:	f362 2152 	bfi	r1, r2, #9, #10
    4a26:	f363 41de 	bfi	r1, r3, #19, #12
    4a2a:	f363 71df 	bfi	r1, r3, #31, #1
    4a2e:	aa1e      	add	r2, sp, #120	; 0x78
    4a30:	483b      	ldr	r0, [pc, #236]	; (4b20 <usage_fault+0x2c8>)
    4a32:	f7fd fc09 	bl	2248 <z_impl_z_log_msg_static_create>
    4a36:	e74b      	b.n	48d0 <usage_fault+0x78>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    4a38:	4b3f      	ldr	r3, [pc, #252]	; (4b38 <usage_fault+0x2e0>)
    4a3a:	9325      	str	r3, [sp, #148]	; 0x94
    4a3c:	2302      	movs	r3, #2
    4a3e:	f88d 3004 	strb.w	r3, [sp, #4]
    4a42:	2300      	movs	r3, #0
    4a44:	f88d 3005 	strb.w	r3, [sp, #5]
    4a48:	f88d 3006 	strb.w	r3, [sp, #6]
    4a4c:	f88d 3007 	strb.w	r3, [sp, #7]
    4a50:	9a01      	ldr	r2, [sp, #4]
    4a52:	9224      	str	r2, [sp, #144]	; 0x90
    4a54:	4619      	mov	r1, r3
    4a56:	f363 0100 	bfi	r1, r3, #0, #1
    4a5a:	f363 0141 	bfi	r1, r3, #1, #1
    4a5e:	f363 0182 	bfi	r1, r3, #2, #1
    4a62:	f363 01c5 	bfi	r1, r3, #3, #3
    4a66:	2201      	movs	r2, #1
    4a68:	f362 1188 	bfi	r1, r2, #6, #3
    4a6c:	2208      	movs	r2, #8
    4a6e:	f362 2152 	bfi	r1, r2, #9, #10
    4a72:	f363 41de 	bfi	r1, r3, #19, #12
    4a76:	f363 71df 	bfi	r1, r3, #31, #1
    4a7a:	aa24      	add	r2, sp, #144	; 0x90
    4a7c:	4828      	ldr	r0, [pc, #160]	; (4b20 <usage_fault+0x2c8>)
    4a7e:	f7fd fbe3 	bl	2248 <z_impl_z_log_msg_static_create>
    4a82:	e72b      	b.n	48dc <usage_fault+0x84>
		PR_FAULT_INFO("  Illegal use of the EPSR");
    4a84:	4b2d      	ldr	r3, [pc, #180]	; (4b3c <usage_fault+0x2e4>)
    4a86:	932b      	str	r3, [sp, #172]	; 0xac
    4a88:	2302      	movs	r3, #2
    4a8a:	f88d 3004 	strb.w	r3, [sp, #4]
    4a8e:	2300      	movs	r3, #0
    4a90:	f88d 3005 	strb.w	r3, [sp, #5]
    4a94:	f88d 3006 	strb.w	r3, [sp, #6]
    4a98:	f88d 3007 	strb.w	r3, [sp, #7]
    4a9c:	9a01      	ldr	r2, [sp, #4]
    4a9e:	922a      	str	r2, [sp, #168]	; 0xa8
    4aa0:	4619      	mov	r1, r3
    4aa2:	f363 0100 	bfi	r1, r3, #0, #1
    4aa6:	f363 0141 	bfi	r1, r3, #1, #1
    4aaa:	f363 0182 	bfi	r1, r3, #2, #1
    4aae:	f363 01c5 	bfi	r1, r3, #3, #3
    4ab2:	2201      	movs	r2, #1
    4ab4:	f362 1188 	bfi	r1, r2, #6, #3
    4ab8:	2208      	movs	r2, #8
    4aba:	f362 2152 	bfi	r1, r2, #9, #10
    4abe:	f363 41de 	bfi	r1, r3, #19, #12
    4ac2:	f363 71df 	bfi	r1, r3, #31, #1
    4ac6:	aa2a      	add	r2, sp, #168	; 0xa8
    4ac8:	4815      	ldr	r0, [pc, #84]	; (4b20 <usage_fault+0x2c8>)
    4aca:	f7fd fbbd 	bl	2248 <z_impl_z_log_msg_static_create>
    4ace:	e70b      	b.n	48e8 <usage_fault+0x90>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    4ad0:	4b1b      	ldr	r3, [pc, #108]	; (4b40 <usage_fault+0x2e8>)
    4ad2:	9331      	str	r3, [sp, #196]	; 0xc4
    4ad4:	2302      	movs	r3, #2
    4ad6:	f88d 3004 	strb.w	r3, [sp, #4]
    4ada:	2300      	movs	r3, #0
    4adc:	f88d 3005 	strb.w	r3, [sp, #5]
    4ae0:	f88d 3006 	strb.w	r3, [sp, #6]
    4ae4:	f88d 3007 	strb.w	r3, [sp, #7]
    4ae8:	9a01      	ldr	r2, [sp, #4]
    4aea:	9230      	str	r2, [sp, #192]	; 0xc0
    4aec:	4619      	mov	r1, r3
    4aee:	f363 0100 	bfi	r1, r3, #0, #1
    4af2:	f363 0141 	bfi	r1, r3, #1, #1
    4af6:	f363 0182 	bfi	r1, r3, #2, #1
    4afa:	f363 01c5 	bfi	r1, r3, #3, #3
    4afe:	2201      	movs	r2, #1
    4b00:	f362 1188 	bfi	r1, r2, #6, #3
    4b04:	2208      	movs	r2, #8
    4b06:	f362 2152 	bfi	r1, r2, #9, #10
    4b0a:	f363 41de 	bfi	r1, r3, #19, #12
    4b0e:	f363 71df 	bfi	r1, r3, #31, #1
    4b12:	aa30      	add	r2, sp, #192	; 0xc0
    4b14:	4802      	ldr	r0, [pc, #8]	; (4b20 <usage_fault+0x2c8>)
    4b16:	f7fd fb97 	bl	2248 <z_impl_z_log_msg_static_create>
    4b1a:	e6eb      	b.n	48f4 <usage_fault+0x9c>
    4b1c:	0001db34 	.word	0x0001db34
    4b20:	0001d084 	.word	0x0001d084
    4b24:	e000ed00 	.word	0xe000ed00
    4b28:	0001db4c 	.word	0x0001db4c
    4b2c:	0001db60 	.word	0x0001db60
    4b30:	0001db7c 	.word	0x0001db7c
    4b34:	0001dba8 	.word	0x0001dba8
    4b38:	0001dbc8 	.word	0x0001dbc8
    4b3c:	0001dbf0 	.word	0x0001dbf0
    4b40:	0001dc0c 	.word	0x0001dc0c

00004b44 <hard_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t hard_fault(z_arch_esf_t *esf, bool *recoverable)
{
    4b44:	b5f0      	push	{r4, r5, r6, r7, lr}
    4b46:	b09b      	sub	sp, #108	; 0x6c
    4b48:	af00      	add	r7, sp, #0
    4b4a:	4606      	mov	r6, r0
    4b4c:	460d      	mov	r5, r1
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** HARD FAULT *****");
    4b4e:	4b84      	ldr	r3, [pc, #528]	; (4d60 <hard_fault+0x21c>)
    4b50:	61fb      	str	r3, [r7, #28]
    4b52:	2302      	movs	r3, #2
    4b54:	713b      	strb	r3, [r7, #4]
    4b56:	2400      	movs	r4, #0
    4b58:	717c      	strb	r4, [r7, #5]
    4b5a:	71bc      	strb	r4, [r7, #6]
    4b5c:	71fc      	strb	r4, [r7, #7]
    4b5e:	687b      	ldr	r3, [r7, #4]
    4b60:	61bb      	str	r3, [r7, #24]
    4b62:	4621      	mov	r1, r4
    4b64:	f364 0100 	bfi	r1, r4, #0, #1
    4b68:	f364 0141 	bfi	r1, r4, #1, #1
    4b6c:	f364 0182 	bfi	r1, r4, #2, #1
    4b70:	f364 01c5 	bfi	r1, r4, #3, #3
    4b74:	2301      	movs	r3, #1
    4b76:	f363 1188 	bfi	r1, r3, #6, #3
    4b7a:	2308      	movs	r3, #8
    4b7c:	f363 2152 	bfi	r1, r3, #9, #10
    4b80:	f364 41de 	bfi	r1, r4, #19, #12
    4b84:	f364 71df 	bfi	r1, r4, #31, #1
    4b88:	4623      	mov	r3, r4
    4b8a:	f107 0218 	add.w	r2, r7, #24
    4b8e:	4875      	ldr	r0, [pc, #468]	; (4d64 <hard_fault+0x220>)
    4b90:	f7fd fb5a 	bl	2248 <z_impl_z_log_msg_static_create>
		reason = esf->basic.r0;
	}

	*recoverable = memory_fault_recoverable(esf, true);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	*recoverable = false;
    4b94:	702c      	strb	r4, [r5, #0]

	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    4b96:	4b74      	ldr	r3, [pc, #464]	; (4d68 <hard_fault+0x224>)
    4b98:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    4b9a:	f014 0402 	ands.w	r4, r4, #2
    4b9e:	d10c      	bne.n	4bba <hard_fault+0x76>
		PR_EXC("  Bus fault on vector table read");
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    4ba0:	4b71      	ldr	r3, [pc, #452]	; (4d68 <hard_fault+0x224>)
    4ba2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4ba4:	2b00      	cmp	r3, #0
    4ba6:	db2c      	blt.n	4c02 <hard_fault+0xbe>
		PR_EXC("  Debug event");
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    4ba8:	4b6f      	ldr	r3, [pc, #444]	; (4d68 <hard_fault+0x224>)
    4baa:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    4bac:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
    4bb0:	d14a      	bne.n	4c48 <hard_fault+0x104>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return reason;
}
    4bb2:	4620      	mov	r0, r4
    4bb4:	376c      	adds	r7, #108	; 0x6c
    4bb6:	46bd      	mov	sp, r7
    4bb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		PR_EXC("  Bus fault on vector table read");
    4bba:	4b6c      	ldr	r3, [pc, #432]	; (4d6c <hard_fault+0x228>)
    4bbc:	667b      	str	r3, [r7, #100]	; 0x64
    4bbe:	2302      	movs	r3, #2
    4bc0:	713b      	strb	r3, [r7, #4]
    4bc2:	2400      	movs	r4, #0
    4bc4:	717c      	strb	r4, [r7, #5]
    4bc6:	71bc      	strb	r4, [r7, #6]
    4bc8:	71fc      	strb	r4, [r7, #7]
    4bca:	687b      	ldr	r3, [r7, #4]
    4bcc:	663b      	str	r3, [r7, #96]	; 0x60
    4bce:	4621      	mov	r1, r4
    4bd0:	f364 0100 	bfi	r1, r4, #0, #1
    4bd4:	f364 0141 	bfi	r1, r4, #1, #1
    4bd8:	f364 0182 	bfi	r1, r4, #2, #1
    4bdc:	f364 01c5 	bfi	r1, r4, #3, #3
    4be0:	2301      	movs	r3, #1
    4be2:	f363 1188 	bfi	r1, r3, #6, #3
    4be6:	2308      	movs	r3, #8
    4be8:	f363 2152 	bfi	r1, r3, #9, #10
    4bec:	f364 41de 	bfi	r1, r4, #19, #12
    4bf0:	f364 71df 	bfi	r1, r4, #31, #1
    4bf4:	4623      	mov	r3, r4
    4bf6:	f107 0260 	add.w	r2, r7, #96	; 0x60
    4bfa:	485a      	ldr	r0, [pc, #360]	; (4d64 <hard_fault+0x220>)
    4bfc:	f7fd fb24 	bl	2248 <z_impl_z_log_msg_static_create>
    4c00:	e7d7      	b.n	4bb2 <hard_fault+0x6e>
		PR_EXC("  Debug event");
    4c02:	4b5b      	ldr	r3, [pc, #364]	; (4d70 <hard_fault+0x22c>)
    4c04:	64fb      	str	r3, [r7, #76]	; 0x4c
    4c06:	2302      	movs	r3, #2
    4c08:	713b      	strb	r3, [r7, #4]
    4c0a:	2300      	movs	r3, #0
    4c0c:	717b      	strb	r3, [r7, #5]
    4c0e:	71bb      	strb	r3, [r7, #6]
    4c10:	71fb      	strb	r3, [r7, #7]
    4c12:	687a      	ldr	r2, [r7, #4]
    4c14:	64ba      	str	r2, [r7, #72]	; 0x48
    4c16:	4619      	mov	r1, r3
    4c18:	f363 0100 	bfi	r1, r3, #0, #1
    4c1c:	f363 0141 	bfi	r1, r3, #1, #1
    4c20:	f363 0182 	bfi	r1, r3, #2, #1
    4c24:	f363 01c5 	bfi	r1, r3, #3, #3
    4c28:	2201      	movs	r2, #1
    4c2a:	f362 1188 	bfi	r1, r2, #6, #3
    4c2e:	2208      	movs	r2, #8
    4c30:	f362 2152 	bfi	r1, r2, #9, #10
    4c34:	f363 41de 	bfi	r1, r3, #19, #12
    4c38:	f363 71df 	bfi	r1, r3, #31, #1
    4c3c:	f107 0248 	add.w	r2, r7, #72	; 0x48
    4c40:	4848      	ldr	r0, [pc, #288]	; (4d64 <hard_fault+0x220>)
    4c42:	f7fd fb01 	bl	2248 <z_impl_z_log_msg_static_create>
    4c46:	e7b4      	b.n	4bb2 <hard_fault+0x6e>
		PR_EXC("  Fault escalation (see below)");
    4c48:	4b4a      	ldr	r3, [pc, #296]	; (4d74 <hard_fault+0x230>)
    4c4a:	637b      	str	r3, [r7, #52]	; 0x34
    4c4c:	2302      	movs	r3, #2
    4c4e:	713b      	strb	r3, [r7, #4]
    4c50:	2300      	movs	r3, #0
    4c52:	717b      	strb	r3, [r7, #5]
    4c54:	71bb      	strb	r3, [r7, #6]
    4c56:	71fb      	strb	r3, [r7, #7]
    4c58:	687a      	ldr	r2, [r7, #4]
    4c5a:	633a      	str	r2, [r7, #48]	; 0x30
    4c5c:	4619      	mov	r1, r3
    4c5e:	f363 0100 	bfi	r1, r3, #0, #1
    4c62:	f363 0141 	bfi	r1, r3, #1, #1
    4c66:	f363 0182 	bfi	r1, r3, #2, #1
    4c6a:	f363 01c5 	bfi	r1, r3, #3, #3
    4c6e:	2201      	movs	r2, #1
    4c70:	f362 1188 	bfi	r1, r2, #6, #3
    4c74:	2208      	movs	r2, #8
    4c76:	f362 2152 	bfi	r1, r2, #9, #10
    4c7a:	f363 41de 	bfi	r1, r3, #19, #12
    4c7e:	f363 71df 	bfi	r1, r3, #31, #1
    4c82:	f107 0230 	add.w	r2, r7, #48	; 0x30
    4c86:	4837      	ldr	r0, [pc, #220]	; (4d64 <hard_fault+0x220>)
    4c88:	f7fd fade 	bl	2248 <z_impl_z_log_msg_static_create>
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
    4c8c:	69b3      	ldr	r3, [r6, #24]
	uint16_t fault_insn = *(ret_addr - 1);
    4c8e:	f833 2c02 	ldrh.w	r2, [r3, #-2]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    4c92:	f64d 7302 	movw	r3, #57090	; 0xdf02
    4c96:	429a      	cmp	r2, r3
    4c98:	d015      	beq.n	4cc6 <hard_fault+0x182>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
    4c9a:	4b33      	ldr	r3, [pc, #204]	; (4d68 <hard_fault+0x224>)
    4c9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4c9e:	f013 0fff 	tst.w	r3, #255	; 0xff
    4ca2:	d14e      	bne.n	4d42 <hard_fault+0x1fe>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
    4ca4:	4b30      	ldr	r3, [pc, #192]	; (4d68 <hard_fault+0x224>)
    4ca6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4ca8:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
    4cac:	d150      	bne.n	4d50 <hard_fault+0x20c>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
    4cae:	4b2e      	ldr	r3, [pc, #184]	; (4d68 <hard_fault+0x224>)
    4cb0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    4cb2:	0c24      	lsrs	r4, r4, #16
    4cb4:	0424      	lsls	r4, r4, #16
    4cb6:	2c00      	cmp	r4, #0
    4cb8:	f43f af7b 	beq.w	4bb2 <hard_fault+0x6e>
			reason = usage_fault(esf);
    4cbc:	4630      	mov	r0, r6
    4cbe:	f7ff fdcb 	bl	4858 <usage_fault>
    4cc2:	4604      	mov	r4, r0
	return reason;
    4cc4:	e775      	b.n	4bb2 <hard_fault+0x6e>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    4cc6:	6830      	ldr	r0, [r6, #0]
    4cc8:	466d      	mov	r5, sp
    4cca:	b088      	sub	sp, #32
    4ccc:	466b      	mov	r3, sp
    4cce:	f113 0210 	adds.w	r2, r3, #16
    4cd2:	d030      	beq.n	4d36 <hard_fault+0x1f2>
    4cd4:	210c      	movs	r1, #12
    4cd6:	b11a      	cbz	r2, 4ce0 <hard_fault+0x19c>
    4cd8:	2904      	cmp	r1, #4
    4cda:	dd01      	ble.n	4ce0 <hard_fault+0x19c>
    4cdc:	4c26      	ldr	r4, [pc, #152]	; (4d78 <hard_fault+0x234>)
    4cde:	615c      	str	r4, [r3, #20]
    4ce0:	b112      	cbz	r2, 4ce8 <hard_fault+0x1a4>
    4ce2:	2908      	cmp	r1, #8
    4ce4:	dd00      	ble.n	4ce8 <hard_fault+0x1a4>
    4ce6:	6198      	str	r0, [r3, #24]
    4ce8:	290b      	cmp	r1, #11
    4cea:	dd27      	ble.n	4d3c <hard_fault+0x1f8>
    4cec:	240c      	movs	r4, #12
    4cee:	b13a      	cbz	r2, 4d00 <hard_fault+0x1bc>
    4cf0:	2103      	movs	r1, #3
    4cf2:	7139      	strb	r1, [r7, #4]
    4cf4:	2100      	movs	r1, #0
    4cf6:	7179      	strb	r1, [r7, #5]
    4cf8:	71b9      	strb	r1, [r7, #6]
    4cfa:	71f9      	strb	r1, [r7, #7]
    4cfc:	6878      	ldr	r0, [r7, #4]
    4cfe:	6118      	str	r0, [r3, #16]
    4d00:	2100      	movs	r1, #0
    4d02:	f36f 0100 	bfc	r1, #0, #1
    4d06:	f36f 0141 	bfc	r1, #1, #1
    4d0a:	f36f 0182 	bfc	r1, #2, #1
    4d0e:	f36f 01c5 	bfc	r1, #3, #3
    4d12:	2301      	movs	r3, #1
    4d14:	f363 1188 	bfi	r1, r3, #6, #3
    4d18:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    4d1c:	f364 2152 	bfi	r1, r4, #9, #10
    4d20:	f36f 41de 	bfc	r1, #19, #12
    4d24:	f36f 71df 	bfc	r1, #31, #1
    4d28:	2300      	movs	r3, #0
    4d2a:	480e      	ldr	r0, [pc, #56]	; (4d64 <hard_fault+0x220>)
    4d2c:	f7fd fa8c 	bl	2248 <z_impl_z_log_msg_static_create>
    4d30:	46ad      	mov	sp, r5
			reason = esf->basic.r0;
    4d32:	6834      	ldr	r4, [r6, #0]
    4d34:	e73d      	b.n	4bb2 <hard_fault+0x6e>
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    4d36:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    4d3a:	e7cc      	b.n	4cd6 <hard_fault+0x192>
    4d3c:	f06f 041b 	mvn.w	r4, #27
    4d40:	e7d5      	b.n	4cee <hard_fault+0x1aa>
			reason = mem_manage_fault(esf, 1, recoverable);
    4d42:	462a      	mov	r2, r5
    4d44:	2101      	movs	r1, #1
    4d46:	4630      	mov	r0, r6
    4d48:	f7ff fa82 	bl	4250 <mem_manage_fault>
    4d4c:	4604      	mov	r4, r0
    4d4e:	e730      	b.n	4bb2 <hard_fault+0x6e>
			reason = bus_fault(esf, 1, recoverable);
    4d50:	462a      	mov	r2, r5
    4d52:	2101      	movs	r1, #1
    4d54:	4630      	mov	r0, r6
    4d56:	f7ff fbef 	bl	4538 <bus_fault>
    4d5a:	4604      	mov	r4, r0
    4d5c:	e729      	b.n	4bb2 <hard_fault+0x6e>
    4d5e:	bf00      	nop
    4d60:	0001dc38 	.word	0x0001dc38
    4d64:	0001d084 	.word	0x0001d084
    4d68:	e000ed00 	.word	0xe000ed00
    4d6c:	0001dc50 	.word	0x0001dc50
    4d70:	0001dc74 	.word	0x0001dc74
    4d74:	0001dc84 	.word	0x0001dc84
    4d78:	0001dca4 	.word	0x0001dca4

00004d7c <debug_monitor>:
{
    4d7c:	b500      	push	{lr}
    4d7e:	b089      	sub	sp, #36	; 0x24
	*recoverable = false;
    4d80:	2300      	movs	r3, #0
    4d82:	700b      	strb	r3, [r1, #0]
	PR_FAULT_INFO(
    4d84:	4a13      	ldr	r2, [pc, #76]	; (4dd4 <debug_monitor+0x58>)
    4d86:	9207      	str	r2, [sp, #28]
    4d88:	2202      	movs	r2, #2
    4d8a:	f88d 2004 	strb.w	r2, [sp, #4]
    4d8e:	f88d 3005 	strb.w	r3, [sp, #5]
    4d92:	f88d 3006 	strb.w	r3, [sp, #6]
    4d96:	f88d 3007 	strb.w	r3, [sp, #7]
    4d9a:	9a01      	ldr	r2, [sp, #4]
    4d9c:	9206      	str	r2, [sp, #24]
    4d9e:	4619      	mov	r1, r3
    4da0:	f363 0100 	bfi	r1, r3, #0, #1
    4da4:	f363 0141 	bfi	r1, r3, #1, #1
    4da8:	f363 0182 	bfi	r1, r3, #2, #1
    4dac:	f363 01c5 	bfi	r1, r3, #3, #3
    4db0:	2201      	movs	r2, #1
    4db2:	f362 1188 	bfi	r1, r2, #6, #3
    4db6:	2208      	movs	r2, #8
    4db8:	f362 2152 	bfi	r1, r2, #9, #10
    4dbc:	f363 41de 	bfi	r1, r3, #19, #12
    4dc0:	f363 71df 	bfi	r1, r3, #31, #1
    4dc4:	aa06      	add	r2, sp, #24
    4dc6:	4804      	ldr	r0, [pc, #16]	; (4dd8 <debug_monitor+0x5c>)
    4dc8:	f7fd fa3e 	bl	2248 <z_impl_z_log_msg_static_create>
}
    4dcc:	b009      	add	sp, #36	; 0x24
    4dce:	f85d fb04 	ldr.w	pc, [sp], #4
    4dd2:	bf00      	nop
    4dd4:	0001dcc0 	.word	0x0001dcc0
    4dd8:	0001d084 	.word	0x0001d084

00004ddc <reserved_exception>:
 *
 * See z_arm_fault_dump() for example.
 *
 */
static void reserved_exception(const z_arch_esf_t *esf, int fault)
{
    4ddc:	b590      	push	{r4, r7, lr}
    4dde:	b083      	sub	sp, #12
    4de0:	af00      	add	r7, sp, #0
	ARG_UNUSED(esf);

	PR_FAULT_INFO("***** %s %d) *****",
    4de2:	290f      	cmp	r1, #15
    4de4:	dc4b      	bgt.n	4e7e <reserved_exception+0xa2>
    4de6:	4c2f      	ldr	r4, [pc, #188]	; (4ea4 <reserved_exception+0xc8>)
    4de8:	3910      	subs	r1, #16
    4dea:	2302      	movs	r3, #2
    4dec:	713b      	strb	r3, [r7, #4]
    4dee:	b08a      	sub	sp, #40	; 0x28
    4df0:	466b      	mov	r3, sp
    4df2:	f113 0210 	adds.w	r2, r3, #16
    4df6:	d044      	beq.n	4e82 <reserved_exception+0xa6>
    4df8:	f04f 0c11 	mov.w	ip, #17
    4dfc:	b122      	cbz	r2, 4e08 <reserved_exception+0x2c>
    4dfe:	f1bc 0f04 	cmp.w	ip, #4
    4e02:	dd01      	ble.n	4e08 <reserved_exception+0x2c>
    4e04:	4828      	ldr	r0, [pc, #160]	; (4ea8 <reserved_exception+0xcc>)
    4e06:	6158      	str	r0, [r3, #20]
    4e08:	2002      	movs	r0, #2
    4e0a:	7038      	strb	r0, [r7, #0]
    4e0c:	b11a      	cbz	r2, 4e16 <reserved_exception+0x3a>
    4e0e:	f1bc 0f08 	cmp.w	ip, #8
    4e12:	dd00      	ble.n	4e16 <reserved_exception+0x3a>
    4e14:	619c      	str	r4, [r3, #24]
    4e16:	b11a      	cbz	r2, 4e20 <reserved_exception+0x44>
    4e18:	f1bc 0f0c 	cmp.w	ip, #12
    4e1c:	dd00      	ble.n	4e20 <reserved_exception+0x44>
    4e1e:	61d9      	str	r1, [r3, #28]
    4e20:	b11a      	cbz	r2, 4e2a <reserved_exception+0x4e>
    4e22:	f103 0120 	add.w	r1, r3, #32
    4e26:	2000      	movs	r0, #0
    4e28:	b370      	cbz	r0, 4e88 <reserved_exception+0xac>
    4e2a:	f1bc 0f10 	cmp.w	ip, #16
    4e2e:	dd35      	ble.n	4e9c <reserved_exception+0xc0>
    4e30:	f04f 0c11 	mov.w	ip, #17
    4e34:	b142      	cbz	r2, 4e48 <reserved_exception+0x6c>
    4e36:	2104      	movs	r1, #4
    4e38:	7139      	strb	r1, [r7, #4]
    4e3a:	2100      	movs	r1, #0
    4e3c:	7179      	strb	r1, [r7, #5]
    4e3e:	71b9      	strb	r1, [r7, #6]
    4e40:	2101      	movs	r1, #1
    4e42:	71f9      	strb	r1, [r7, #7]
    4e44:	6878      	ldr	r0, [r7, #4]
    4e46:	6118      	str	r0, [r3, #16]
    4e48:	2100      	movs	r1, #0
    4e4a:	f36f 0100 	bfc	r1, #0, #1
    4e4e:	f36f 0141 	bfc	r1, #1, #1
    4e52:	f36f 0182 	bfc	r1, #2, #1
    4e56:	f36f 01c5 	bfc	r1, #3, #3
    4e5a:	2301      	movs	r3, #1
    4e5c:	f363 1188 	bfi	r1, r3, #6, #3
    4e60:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    4e64:	f36c 2152 	bfi	r1, ip, #9, #10
    4e68:	f36f 41de 	bfc	r1, #19, #12
    4e6c:	f36f 71df 	bfc	r1, #31, #1
    4e70:	2300      	movs	r3, #0
    4e72:	480e      	ldr	r0, [pc, #56]	; (4eac <reserved_exception+0xd0>)
    4e74:	f7fd f9e8 	bl	2248 <z_impl_z_log_msg_static_create>
	       fault < 16 ? "Reserved Exception (" : "Spurious interrupt (IRQ ",
	       fault - 16);
}
    4e78:	370c      	adds	r7, #12
    4e7a:	46bd      	mov	sp, r7
    4e7c:	bd90      	pop	{r4, r7, pc}
	PR_FAULT_INFO("***** %s %d) *****",
    4e7e:	4c0c      	ldr	r4, [pc, #48]	; (4eb0 <reserved_exception+0xd4>)
    4e80:	e7b2      	b.n	4de8 <reserved_exception+0xc>
    4e82:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    4e86:	e7b9      	b.n	4dfc <reserved_exception+0x20>
    4e88:	f107 0408 	add.w	r4, r7, #8
    4e8c:	eb04 0e00 	add.w	lr, r4, r0
    4e90:	f81e ec08 	ldrb.w	lr, [lr, #-8]
    4e94:	f801 eb01 	strb.w	lr, [r1], #1
    4e98:	3001      	adds	r0, #1
    4e9a:	e7c5      	b.n	4e28 <reserved_exception+0x4c>
    4e9c:	f06f 0c1b 	mvn.w	ip, #27
    4ea0:	e7c8      	b.n	4e34 <reserved_exception+0x58>
    4ea2:	bf00      	nop
    4ea4:	0001dd00 	.word	0x0001dd00
    4ea8:	0001dd18 	.word	0x0001dd18
    4eac:	0001d084 	.word	0x0001d084
    4eb0:	0001dce4 	.word	0x0001dce4

00004eb4 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    4eb4:	b570      	push	{r4, r5, r6, lr}
    4eb6:	b090      	sub	sp, #64	; 0x40
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    4eb8:	4b35      	ldr	r3, [pc, #212]	; (4f90 <z_arm_fault+0xdc>)
    4eba:	685d      	ldr	r5, [r3, #4]
    4ebc:	f3c5 0508 	ubfx	r5, r5, #0, #9
    4ec0:	2300      	movs	r3, #0
    4ec2:	f383 8811 	msr	BASEPRI, r3
    4ec6:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    4eca:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    4ece:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    4ed2:	d13f      	bne.n	4f54 <z_arm_fault+0xa0>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    4ed4:	f002 030c 	and.w	r3, r2, #12
    4ed8:	2b08      	cmp	r3, #8
    4eda:	d010      	beq.n	4efe <z_arm_fault+0x4a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    4edc:	f012 0f08 	tst.w	r2, #8
    4ee0:	d035      	beq.n	4f4e <z_arm_fault+0x9a>
			ptr_esf =  (z_arch_esf_t *)psp;
    4ee2:	460c      	mov	r4, r1
	*nested_exc = false;
    4ee4:	2600      	movs	r6, #0

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
    4ee6:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    4eea:	4629      	mov	r1, r5
    4eec:	4620      	mov	r0, r4
    4eee:	f012 fb3c 	bl	1756a <fault_handle>
    4ef2:	4605      	mov	r5, r0
	if (recoverable) {
    4ef4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    4ef8:	b37b      	cbz	r3, 4f5a <z_arm_fault+0xa6>
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
	}

	z_arm_fatal_error(reason, &esf_copy);
}
    4efa:	b010      	add	sp, #64	; 0x40
    4efc:	bd70      	pop	{r4, r5, r6, pc}
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    4efe:	4b25      	ldr	r3, [pc, #148]	; (4f94 <z_arm_fault+0xe0>)
    4f00:	930f      	str	r3, [sp, #60]	; 0x3c
    4f02:	2302      	movs	r3, #2
    4f04:	f88d 3000 	strb.w	r3, [sp]
    4f08:	2400      	movs	r4, #0
    4f0a:	f88d 4001 	strb.w	r4, [sp, #1]
    4f0e:	f88d 4002 	strb.w	r4, [sp, #2]
    4f12:	f88d 4003 	strb.w	r4, [sp, #3]
    4f16:	9b00      	ldr	r3, [sp, #0]
    4f18:	930e      	str	r3, [sp, #56]	; 0x38
    4f1a:	4621      	mov	r1, r4
    4f1c:	f364 0100 	bfi	r1, r4, #0, #1
    4f20:	f364 0141 	bfi	r1, r4, #1, #1
    4f24:	f364 0182 	bfi	r1, r4, #2, #1
    4f28:	f364 01c5 	bfi	r1, r4, #3, #3
    4f2c:	2301      	movs	r3, #1
    4f2e:	f363 1188 	bfi	r1, r3, #6, #3
    4f32:	2308      	movs	r3, #8
    4f34:	f363 2152 	bfi	r1, r3, #9, #10
    4f38:	f364 41de 	bfi	r1, r4, #19, #12
    4f3c:	f364 71df 	bfi	r1, r4, #31, #1
    4f40:	4623      	mov	r3, r4
    4f42:	aa0e      	add	r2, sp, #56	; 0x38
    4f44:	4814      	ldr	r0, [pc, #80]	; (4f98 <z_arm_fault+0xe4>)
    4f46:	f7fd f97f 	bl	2248 <z_impl_z_log_msg_static_create>
	*nested_exc = false;
    4f4a:	4626      	mov	r6, r4
		return NULL;
    4f4c:	e7cb      	b.n	4ee6 <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    4f4e:	4604      	mov	r4, r0
			*nested_exc = true;
    4f50:	2601      	movs	r6, #1
    4f52:	e7c8      	b.n	4ee6 <z_arm_fault+0x32>
	*nested_exc = false;
    4f54:	2600      	movs	r6, #0
		return NULL;
    4f56:	4634      	mov	r4, r6
    4f58:	e7c5      	b.n	4ee6 <z_arm_fault+0x32>
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    4f5a:	2220      	movs	r2, #32
    4f5c:	4621      	mov	r1, r4
    4f5e:	a801      	add	r0, sp, #4
    4f60:	f012 fbe6 	bl	17730 <memcpy>
	if (nested_exc) {
    4f64:	b14e      	cbz	r6, 4f7a <z_arm_fault+0xc6>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    4f66:	9b08      	ldr	r3, [sp, #32]
    4f68:	f3c3 0208 	ubfx	r2, r3, #0, #9
    4f6c:	b95a      	cbnz	r2, 4f86 <z_arm_fault+0xd2>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    4f6e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    4f72:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    4f76:	9308      	str	r3, [sp, #32]
    4f78:	e005      	b.n	4f86 <z_arm_fault+0xd2>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    4f7a:	9b08      	ldr	r3, [sp, #32]
    4f7c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    4f80:	f023 0301 	bic.w	r3, r3, #1
    4f84:	9308      	str	r3, [sp, #32]
	z_arm_fatal_error(reason, &esf_copy);
    4f86:	a901      	add	r1, sp, #4
    4f88:	4628      	mov	r0, r5
    4f8a:	f012 fac9 	bl	17520 <z_arm_fatal_error>
    4f8e:	e7b4      	b.n	4efa <z_arm_fault+0x46>
    4f90:	e000ed00 	.word	0xe000ed00
    4f94:	0001dd2c 	.word	0x0001dd2c
    4f98:	0001d084 	.word	0x0001d084

00004f9c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    4f9c:	4b04      	ldr	r3, [pc, #16]	; (4fb0 <z_arm_fault_init+0x14>)
    4f9e:	695a      	ldr	r2, [r3, #20]
    4fa0:	f042 0210 	orr.w	r2, r2, #16
    4fa4:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
    4fa6:	695a      	ldr	r2, [r3, #20]
    4fa8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    4fac:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
    4fae:	4770      	bx	lr
    4fb0:	e000ed00 	.word	0xe000ed00

00004fb4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    4fb4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    4fb8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    4fbc:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    4fbe:	4672      	mov	r2, lr
	bl z_arm_fault
    4fc0:	f7ff ff78 	bl	4eb4 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    4fc4:	bd01      	pop	{r0, pc}
    4fc6:	bf00      	nop

00004fc8 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    4fc8:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    4fca:	e007      	b.n	4fdc <z_arm_interrupt_init+0x14>
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4fcc:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    4fd0:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    4fd4:	2120      	movs	r1, #32
    4fd6:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    4fda:	3201      	adds	r2, #1
    4fdc:	2a44      	cmp	r2, #68	; 0x44
    4fde:	dc09      	bgt.n	4ff4 <z_arm_interrupt_init+0x2c>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
    4fe0:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
    4fe2:	2b00      	cmp	r3, #0
    4fe4:	daf2      	bge.n	4fcc <z_arm_interrupt_init+0x4>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4fe6:	f002 010f 	and.w	r1, r2, #15
    4fea:	4b03      	ldr	r3, [pc, #12]	; (4ff8 <z_arm_interrupt_init+0x30>)
    4fec:	440b      	add	r3, r1
    4fee:	2120      	movs	r1, #32
    4ff0:	7619      	strb	r1, [r3, #24]
    4ff2:	e7f2      	b.n	4fda <z_arm_interrupt_init+0x12>
	}
}
    4ff4:	4770      	bx	lr
    4ff6:	bf00      	nop
    4ff8:	e000ecfc 	.word	0xe000ecfc

00004ffc <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_DEBUG_THREAD_INFO)
    /* Clear z_sys_post_kernel flag for RTOS aware debuggers */
    movs.n r0, #0
    4ffc:	2000      	movs	r0, #0
    ldr r1, =z_sys_post_kernel
    4ffe:	4915      	ldr	r1, [pc, #84]	; (5054 <__start+0x58>)
    strb r0, [r1]
    5000:	7008      	strb	r0, [r1, #0]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    5002:	2000      	movs	r0, #0
    msr CONTROL, r0
    5004:	f380 8814 	msr	CONTROL, r0
    isb
    5008:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
    500c:	2000      	movs	r0, #0
    msr MSPLIM, r0
    500e:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
    5012:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    5016:	f7fc fe4b 	bl	1cb0 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
    501a:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
    501c:	490e      	ldr	r1, [pc, #56]	; (5058 <__start+0x5c>)
    str r0, [r1]
    501e:	6008      	str	r0, [r1, #0]
    dsb
    5020:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    5024:	480d      	ldr	r0, [pc, #52]	; (505c <__start+0x60>)
    msr msp, r0
    5026:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    502a:	f000 f841 	bl	50b0 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    502e:	2020      	movs	r0, #32
    msr BASEPRI, r0
    5030:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    5034:	480a      	ldr	r0, [pc, #40]	; (5060 <__start+0x64>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    5036:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    503a:	1840      	adds	r0, r0, r1
    msr PSP, r0
    503c:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    5040:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    5044:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    5046:	4308      	orrs	r0, r1
    msr CONTROL, r0
    5048:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    504c:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    5050:	f7ff f822 	bl	4098 <z_arm_prep_c>
    ldr r1, =z_sys_post_kernel
    5054:	20002900 	.word	0x20002900
    ldr r1, =_SCS_MPU_CTRL
    5058:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    505c:	200042b8 	.word	0x200042b8
    ldr r0, =z_interrupt_stacks
    5060:	200043f8 	.word	0x200043f8

00005064 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
    5064:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5068:	4905      	ldr	r1, [pc, #20]	; (5080 <sys_arch_reboot+0x1c>)
    506a:	68ca      	ldr	r2, [r1, #12]
    506c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    5070:	4b04      	ldr	r3, [pc, #16]	; (5084 <sys_arch_reboot+0x20>)
    5072:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5074:	60cb      	str	r3, [r1, #12]
    5076:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    507a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    507c:	e7fd      	b.n	507a <sys_arch_reboot+0x16>
    507e:	bf00      	nop
    5080:	e000ed00 	.word	0xe000ed00
    5084:	05fa0004 	.word	0x05fa0004

00005088 <z_arm_clear_arm_mpu_config>:
void z_arm_clear_arm_mpu_config(void)
{
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
    5088:	4b08      	ldr	r3, [pc, #32]	; (50ac <z_arm_clear_arm_mpu_config+0x24>)
    508a:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
	int num_regions =
    508e:	f3c0 2007 	ubfx	r0, r0, #8, #8

	for (i = 0; i < num_regions; i++) {
    5092:	2300      	movs	r3, #0
    5094:	e006      	b.n	50a4 <z_arm_clear_arm_mpu_config+0x1c>
* \param mpu Pointer to MPU to be used.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
    5096:	4a05      	ldr	r2, [pc, #20]	; (50ac <z_arm_clear_arm_mpu_config+0x24>)
    5098:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
  mpu->RLAR = 0U;
    509c:	2100      	movs	r1, #0
    509e:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
    50a2:	3301      	adds	r3, #1
    50a4:	4283      	cmp	r3, r0
    50a6:	dbf6      	blt.n	5096 <z_arm_clear_arm_mpu_config+0xe>
		ARM_MPU_ClrRegion(i);
	}
}
    50a8:	4770      	bx	lr
    50aa:	bf00      	nop
    50ac:	e000ed00 	.word	0xe000ed00

000050b0 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
    50b0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    50b2:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
    50b4:	2400      	movs	r4, #0
    50b6:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
    50ba:	f7ff ffe5 	bl	5088 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    50be:	4623      	mov	r3, r4
    50c0:	e008      	b.n	50d4 <z_arm_init_arch_hw_at_boot+0x24>
		NVIC->ICER[i] = 0xFFFFFFFF;
    50c2:	f103 0120 	add.w	r1, r3, #32
    50c6:	4a0e      	ldr	r2, [pc, #56]	; (5100 <z_arm_init_arch_hw_at_boot+0x50>)
    50c8:	f04f 30ff 	mov.w	r0, #4294967295
    50cc:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    50d0:	3301      	adds	r3, #1
    50d2:	b2db      	uxtb	r3, r3
    50d4:	2b0f      	cmp	r3, #15
    50d6:	d9f4      	bls.n	50c2 <z_arm_init_arch_hw_at_boot+0x12>
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    50d8:	2300      	movs	r3, #0
    50da:	e008      	b.n	50ee <z_arm_init_arch_hw_at_boot+0x3e>
		NVIC->ICPR[i] = 0xFFFFFFFF;
    50dc:	f103 0160 	add.w	r1, r3, #96	; 0x60
    50e0:	4a07      	ldr	r2, [pc, #28]	; (5100 <z_arm_init_arch_hw_at_boot+0x50>)
    50e2:	f04f 30ff 	mov.w	r0, #4294967295
    50e6:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    50ea:	3301      	adds	r3, #1
    50ec:	b2db      	uxtb	r3, r3
    50ee:	2b0f      	cmp	r3, #15
    50f0:	d9f4      	bls.n	50dc <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
    50f2:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    50f4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    50f8:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    50fc:	bd10      	pop	{r4, pc}
    50fe:	bf00      	nop
    5100:	e000e100 	.word	0xe000e100

00005104 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    5104:	b508      	push	{r3, lr}
	if (_current == thread) {
    5106:	4b0a      	ldr	r3, [pc, #40]	; (5130 <z_impl_k_thread_abort+0x2c>)
    5108:	689b      	ldr	r3, [r3, #8]
    510a:	4283      	cmp	r3, r0
    510c:	d002      	beq.n	5114 <z_impl_k_thread_abort+0x10>
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
		}
	}

	z_thread_abort(thread);
    510e:	f00f fb3d 	bl	1478c <z_thread_abort>
}
    5112:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    5114:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    5118:	2b00      	cmp	r3, #0
    511a:	d0f8      	beq.n	510e <z_impl_k_thread_abort+0xa>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    511c:	4b05      	ldr	r3, [pc, #20]	; (5134 <z_impl_k_thread_abort+0x30>)
    511e:	685a      	ldr	r2, [r3, #4]
    5120:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    5124:	605a      	str	r2, [r3, #4]
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
    5126:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    5128:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    512c:	625a      	str	r2, [r3, #36]	; 0x24
    512e:	e7ee      	b.n	510e <z_impl_k_thread_abort+0xa>
    5130:	200026d8 	.word	0x200026d8
    5134:	e000ed00 	.word	0xe000ed00

00005138 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    5138:	b510      	push	{r4, lr}
    513a:	b084      	sub	sp, #16
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    513c:	4c0a      	ldr	r4, [pc, #40]	; (5168 <z_arm_configure_static_mpu_regions+0x30>)
    513e:	4623      	mov	r3, r4
    5140:	4a0a      	ldr	r2, [pc, #40]	; (516c <z_arm_configure_static_mpu_regions+0x34>)
    5142:	2101      	movs	r1, #1
    5144:	480a      	ldr	r0, [pc, #40]	; (5170 <z_arm_configure_static_mpu_regions+0x38>)
    5146:	f012 fa84 	bl	17652 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    514a:	2300      	movs	r3, #0
    514c:	9301      	str	r3, [sp, #4]
    514e:	9302      	str	r3, [sp, #8]
    5150:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    5152:	4b08      	ldr	r3, [pc, #32]	; (5174 <z_arm_configure_static_mpu_regions+0x3c>)
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    5154:	9301      	str	r3, [sp, #4]
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    5156:	1ae4      	subs	r4, r4, r3
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    5158:	9402      	str	r4, [sp, #8]
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    515a:	2101      	movs	r1, #1
    515c:	a801      	add	r0, sp, #4
    515e:	f012 fa7c 	bl	1765a <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    5162:	b004      	add	sp, #16
    5164:	bd10      	pop	{r4, pc}
    5166:	bf00      	nop
    5168:	20070000 	.word	0x20070000
    516c:	20000000 	.word	0x20000000
    5170:	0001dd5c 	.word	0x0001dd5c
    5174:	200007b8 	.word	0x200007b8

00005178 <mpu_init>:
static struct dynamic_region_info dyn_reg_info[MPU_DYNAMIC_REGION_AREAS_NUM];
#if defined(CONFIG_CPU_CORTEX_M23) || defined(CONFIG_CPU_CORTEX_M33) || \
	defined(CONFIG_CPU_CORTEX_M55)
static inline void mpu_set_mair0(uint32_t mair0)
{
	MPU->MAIR0 = mair0;
    5178:	4b02      	ldr	r3, [pc, #8]	; (5184 <mpu_init+0xc>)
    517a:	4a03      	ldr	r2, [pc, #12]	; (5188 <mpu_init+0x10>)
    517c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
{
	/* Configure the cache-ability attributes for all the
	 * different types of memory regions.
	 */
	mpu_set_mair0(MPU_MAIR_ATTRS);
}
    5180:	4770      	bx	lr
    5182:	bf00      	nop
    5184:	e000ed00 	.word	0xe000ed00
    5188:	0044ffaa 	.word	0x0044ffaa

0000518c <mpu_set_region>:
	MPU->RNR = rnr;
    518c:	4b03      	ldr	r3, [pc, #12]	; (519c <mpu_set_region+0x10>)
    518e:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
	MPU->RBAR = rbar;
    5192:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
	MPU->RLAR = rlar;
    5196:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
static void mpu_set_region(uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
	mpu_set_rnr(rnr);
	mpu_set_rbar(rbar);
	mpu_set_rlar(rlar);
}
    519a:	4770      	bx	lr
    519c:	e000ed00 	.word	0xe000ed00

000051a0 <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
    51a0:	b5b0      	push	{r4, r5, r7, lr}
    51a2:	b082      	sub	sp, #8
    51a4:	af00      	add	r7, sp, #0
    51a6:	4604      	mov	r4, r0
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    51a8:	2807      	cmp	r0, #7
    51aa:	d805      	bhi.n	51b8 <region_allocate_and_init+0x18>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    51ac:	f012 fa0c 	bl	175c8 <region_init>

	return index;
    51b0:	4620      	mov	r0, r4
}
    51b2:	3708      	adds	r7, #8
    51b4:	46bd      	mov	sp, r7
    51b6:	bdb0      	pop	{r4, r5, r7, pc}
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    51b8:	466d      	mov	r5, sp
    51ba:	b088      	sub	sp, #32
    51bc:	466b      	mov	r3, sp
    51be:	f113 0210 	adds.w	r2, r3, #16
    51c2:	d031      	beq.n	5228 <region_allocate_and_init+0x88>
    51c4:	210c      	movs	r1, #12
    51c6:	b11a      	cbz	r2, 51d0 <region_allocate_and_init+0x30>
    51c8:	2904      	cmp	r1, #4
    51ca:	dd01      	ble.n	51d0 <region_allocate_and_init+0x30>
    51cc:	4819      	ldr	r0, [pc, #100]	; (5234 <region_allocate_and_init+0x94>)
    51ce:	6158      	str	r0, [r3, #20]
    51d0:	b112      	cbz	r2, 51d8 <region_allocate_and_init+0x38>
    51d2:	2908      	cmp	r1, #8
    51d4:	dd00      	ble.n	51d8 <region_allocate_and_init+0x38>
    51d6:	619c      	str	r4, [r3, #24]
    51d8:	290b      	cmp	r1, #11
    51da:	dd28      	ble.n	522e <region_allocate_and_init+0x8e>
    51dc:	240c      	movs	r4, #12
    51de:	b13a      	cbz	r2, 51f0 <region_allocate_and_init+0x50>
    51e0:	2103      	movs	r1, #3
    51e2:	7139      	strb	r1, [r7, #4]
    51e4:	2100      	movs	r1, #0
    51e6:	7179      	strb	r1, [r7, #5]
    51e8:	71b9      	strb	r1, [r7, #6]
    51ea:	71f9      	strb	r1, [r7, #7]
    51ec:	6878      	ldr	r0, [r7, #4]
    51ee:	6118      	str	r0, [r3, #16]
    51f0:	2100      	movs	r1, #0
    51f2:	f36f 0100 	bfc	r1, #0, #1
    51f6:	f36f 0141 	bfc	r1, #1, #1
    51fa:	f36f 0182 	bfc	r1, #2, #1
    51fe:	f36f 01c5 	bfc	r1, #3, #3
    5202:	2301      	movs	r3, #1
    5204:	f363 1188 	bfi	r1, r3, #6, #3
    5208:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    520c:	f364 2152 	bfi	r1, r4, #9, #10
    5210:	f36f 41de 	bfc	r1, #19, #12
    5214:	f36f 71df 	bfc	r1, #31, #1
    5218:	2300      	movs	r3, #0
    521a:	4807      	ldr	r0, [pc, #28]	; (5238 <region_allocate_and_init+0x98>)
    521c:	f7fd f814 	bl	2248 <z_impl_z_log_msg_static_create>
    5220:	46ad      	mov	sp, r5
		return -EINVAL;
    5222:	f06f 0015 	mvn.w	r0, #21
    5226:	e7c4      	b.n	51b2 <region_allocate_and_init+0x12>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    5228:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    522c:	e7cb      	b.n	51c6 <region_allocate_and_init+0x26>
    522e:	f06f 041b 	mvn.w	r4, #27
    5232:	e7d4      	b.n	51de <region_allocate_and_init+0x3e>
    5234:	0001dd68 	.word	0x0001dd68
    5238:	0001d074 	.word	0x0001d074

0000523c <mpu_configure_regions_and_partition>:
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    523c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5240:	b089      	sub	sp, #36	; 0x24
    5242:	af00      	add	r7, sp, #0
    5244:	4682      	mov	sl, r0
    5246:	60b9      	str	r1, [r7, #8]
    5248:	607b      	str	r3, [r7, #4]
	int i;
	int reg_index = start_reg_index;
    524a:	4614      	mov	r4, r2

	for (i = 0; i < regions_num; i++) {
    524c:	f04f 0800 	mov.w	r8, #0
    5250:	e0b8      	b.n	53c4 <mpu_configure_regions_and_partition+0x188>
		}
		/* Non-empty region. */

		if (do_sanity_check &&
			(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
    5252:	466d      	mov	r5, sp
    5254:	b088      	sub	sp, #32
    5256:	466b      	mov	r3, sp
    5258:	f113 0210 	adds.w	r2, r3, #16
    525c:	d032      	beq.n	52c4 <mpu_configure_regions_and_partition+0x88>
    525e:	210c      	movs	r1, #12
    5260:	b11a      	cbz	r2, 526a <mpu_configure_regions_and_partition+0x2e>
    5262:	2904      	cmp	r1, #4
    5264:	dd01      	ble.n	526a <mpu_configure_regions_and_partition+0x2e>
    5266:	489d      	ldr	r0, [pc, #628]	; (54dc <mpu_configure_regions_and_partition+0x2a0>)
    5268:	6158      	str	r0, [r3, #20]
    526a:	b11a      	cbz	r2, 5274 <mpu_configure_regions_and_partition+0x38>
    526c:	2908      	cmp	r1, #8
    526e:	dd01      	ble.n	5274 <mpu_configure_regions_and_partition+0x38>
    5270:	f8c3 8018 	str.w	r8, [r3, #24]
    5274:	290b      	cmp	r1, #11
    5276:	dd28      	ble.n	52ca <mpu_configure_regions_and_partition+0x8e>
    5278:	240c      	movs	r4, #12
    527a:	b13a      	cbz	r2, 528c <mpu_configure_regions_and_partition+0x50>
    527c:	2103      	movs	r1, #3
    527e:	7439      	strb	r1, [r7, #16]
    5280:	2100      	movs	r1, #0
    5282:	7479      	strb	r1, [r7, #17]
    5284:	74b9      	strb	r1, [r7, #18]
    5286:	74f9      	strb	r1, [r7, #19]
    5288:	6938      	ldr	r0, [r7, #16]
    528a:	6118      	str	r0, [r3, #16]
    528c:	2100      	movs	r1, #0
    528e:	f36f 0100 	bfc	r1, #0, #1
    5292:	f36f 0141 	bfc	r1, #1, #1
    5296:	f36f 0182 	bfc	r1, #2, #1
    529a:	f36f 01c5 	bfc	r1, #3, #3
    529e:	2301      	movs	r3, #1
    52a0:	f363 1188 	bfi	r1, r3, #6, #3
    52a4:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    52a8:	f364 2152 	bfi	r1, r4, #9, #10
    52ac:	f36f 41de 	bfc	r1, #19, #12
    52b0:	f36f 71df 	bfc	r1, #31, #1
    52b4:	2300      	movs	r3, #0
    52b6:	488a      	ldr	r0, [pc, #552]	; (54e0 <mpu_configure_regions_and_partition+0x2a4>)
    52b8:	f7fc ffc6 	bl	2248 <z_impl_z_log_msg_static_create>
    52bc:	46ad      	mov	sp, r5
			return -EINVAL;
    52be:	f06f 0415 	mvn.w	r4, #21
    52c2:	e03f      	b.n	5344 <mpu_configure_regions_and_partition+0x108>
			LOG_ERR("Partition %u: sanity check failed.", i);
    52c4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    52c8:	e7ca      	b.n	5260 <mpu_configure_regions_and_partition+0x24>
    52ca:	f06f 041b 	mvn.w	r4, #27
    52ce:	e7d4      	b.n	527a <mpu_configure_regions_and_partition+0x3e>
	return -EINVAL;
    52d0:	f06f 0615 	mvn.w	r6, #21
    52d4:	e09c      	b.n	5410 <mpu_configure_regions_and_partition+0x1d4>
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
    52d6:	466d      	mov	r5, sp
    52d8:	b088      	sub	sp, #32
    52da:	466b      	mov	r3, sp
    52dc:	f113 0210 	adds.w	r2, r3, #16
    52e0:	d035      	beq.n	534e <mpu_configure_regions_and_partition+0x112>
    52e2:	210c      	movs	r1, #12
    52e4:	b11a      	cbz	r2, 52ee <mpu_configure_regions_and_partition+0xb2>
    52e6:	2904      	cmp	r1, #4
    52e8:	dd01      	ble.n	52ee <mpu_configure_regions_and_partition+0xb2>
    52ea:	487e      	ldr	r0, [pc, #504]	; (54e4 <mpu_configure_regions_and_partition+0x2a8>)
    52ec:	6158      	str	r0, [r3, #20]
    52ee:	b112      	cbz	r2, 52f6 <mpu_configure_regions_and_partition+0xba>
    52f0:	2908      	cmp	r1, #8
    52f2:	dd00      	ble.n	52f6 <mpu_configure_regions_and_partition+0xba>
    52f4:	619e      	str	r6, [r3, #24]
    52f6:	290b      	cmp	r1, #11
    52f8:	dd2c      	ble.n	5354 <mpu_configure_regions_and_partition+0x118>
    52fa:	240c      	movs	r4, #12
    52fc:	b13a      	cbz	r2, 530e <mpu_configure_regions_and_partition+0xd2>
    52fe:	2103      	movs	r1, #3
    5300:	7439      	strb	r1, [r7, #16]
    5302:	2100      	movs	r1, #0
    5304:	7479      	strb	r1, [r7, #17]
    5306:	74b9      	strb	r1, [r7, #18]
    5308:	74f9      	strb	r1, [r7, #19]
    530a:	6938      	ldr	r0, [r7, #16]
    530c:	6118      	str	r0, [r3, #16]
    530e:	2100      	movs	r1, #0
    5310:	f36f 0100 	bfc	r1, #0, #1
    5314:	f36f 0141 	bfc	r1, #1, #1
    5318:	f36f 0182 	bfc	r1, #2, #1
    531c:	f36f 01c5 	bfc	r1, #3, #3
    5320:	2301      	movs	r3, #1
    5322:	f363 1188 	bfi	r1, r3, #6, #3
    5326:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    532a:	f363 2152 	bfi	r1, r3, #9, #10
    532e:	f36f 41de 	bfc	r1, #19, #12
    5332:	f36f 71df 	bfc	r1, #31, #1
    5336:	2300      	movs	r3, #0
    5338:	4869      	ldr	r0, [pc, #420]	; (54e0 <mpu_configure_regions_and_partition+0x2a4>)
    533a:	f7fc ff85 	bl	2248 <z_impl_z_log_msg_static_create>
    533e:	46ad      	mov	sp, r5
				u_reg_index);
			return -EINVAL;
    5340:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    5344:	4620      	mov	r0, r4
    5346:	3724      	adds	r7, #36	; 0x24
    5348:	46bd      	mov	sp, r7
    534a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			LOG_ERR("Invalid underlying region index %u",
    534e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    5352:	e7c7      	b.n	52e4 <mpu_configure_regions_and_partition+0xa8>
    5354:	f06f 041b 	mvn.w	r4, #27
    5358:	e7d0      	b.n	52fc <mpu_configure_regions_and_partition+0xc0>
		if ((regions[i].start == u_reg_base) &&
    535a:	4581      	cmp	r9, r0
    535c:	d175      	bne.n	544a <mpu_configure_regions_and_partition+0x20e>
			mpu_configure_region(u_reg_index, &regions[i]);
    535e:	4629      	mov	r1, r5
    5360:	b2f0      	uxtb	r0, r6
    5362:	f012 f957 	bl	17614 <mpu_configure_region>
    5366:	e02b      	b.n	53c0 <mpu_configure_regions_and_partition+0x184>
	MPU->RNR = rnr;
    5368:	4a5f      	ldr	r2, [pc, #380]	; (54e8 <mpu_configure_regions_and_partition+0x2ac>)
    536a:	f8c2 c098 	str.w	ip, [r2, #152]	; 0x98
	return MPU->RBAR;
    536e:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
    5372:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
    5376:	f021 011f 	bic.w	r1, r1, #31
    537a:	4319      	orrs	r1, r3
	MPU->RBAR = rbar;
    537c:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
    5380:	4629      	mov	r1, r5
    5382:	b2e0      	uxtb	r0, r4
    5384:	f012 f946 	bl	17614 <mpu_configure_region>
    5388:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    538a:	f110 0f16 	cmn.w	r0, #22
    538e:	d0d9      	beq.n	5344 <mpu_configure_regions_and_partition+0x108>
			reg_index++;
    5390:	3401      	adds	r4, #1
    5392:	e015      	b.n	53c0 <mpu_configure_regions_and_partition+0x184>
				regions[i].start - 1);
    5394:	3b01      	subs	r3, #1
	MPU->RNR = rnr;
    5396:	4954      	ldr	r1, [pc, #336]	; (54e8 <mpu_configure_regions_and_partition+0x2ac>)
    5398:	f8c1 c098 	str.w	ip, [r1, #152]	; 0x98
	return MPU->RLAR;
    539c:	f8d1 20a0 	ldr.w	r2, [r1, #160]	; 0xa0
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
    53a0:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
    53a4:	f023 031f 	bic.w	r3, r3, #31
    53a8:	4313      	orrs	r3, r2
	MPU->RLAR = rlar;
    53aa:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
    53ae:	4629      	mov	r1, r5
    53b0:	b2e0      	uxtb	r0, r4
    53b2:	f012 f92f 	bl	17614 <mpu_configure_region>
    53b6:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    53b8:	f110 0f16 	cmn.w	r0, #22
    53bc:	d0c2      	beq.n	5344 <mpu_configure_regions_and_partition+0x108>
			reg_index++;
    53be:	3401      	adds	r4, #1
	for (i = 0; i < regions_num; i++) {
    53c0:	f108 0801 	add.w	r8, r8, #1
    53c4:	68bb      	ldr	r3, [r7, #8]
    53c6:	4598      	cmp	r8, r3
    53c8:	dabc      	bge.n	5344 <mpu_configure_regions_and_partition+0x108>
		if (regions[i].size == 0U) {
    53ca:	eb08 0548 	add.w	r5, r8, r8, lsl #1
    53ce:	ea4f 0b85 	mov.w	fp, r5, lsl #2
    53d2:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
    53d6:	f8d5 9004 	ldr.w	r9, [r5, #4]
    53da:	f1b9 0f00 	cmp.w	r9, #0
    53de:	d0ef      	beq.n	53c0 <mpu_configure_regions_and_partition+0x184>
		if (do_sanity_check &&
    53e0:	687b      	ldr	r3, [r7, #4]
    53e2:	b12b      	cbz	r3, 53f0 <mpu_configure_regions_and_partition+0x1b4>
			(!mpu_partition_is_valid(&regions[i]))) {
    53e4:	4628      	mov	r0, r5
    53e6:	f012 f903 	bl	175f0 <mpu_partition_is_valid>
		if (do_sanity_check &&
    53ea:	2800      	cmp	r0, #0
    53ec:	f43f af31 	beq.w	5252 <mpu_configure_regions_and_partition+0x16>
			get_region_index(regions[i].start, regions[i].size);
    53f0:	f85a 300b 	ldr.w	r3, [sl, fp]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    53f4:	60fb      	str	r3, [r7, #12]
    53f6:	4618      	mov	r0, r3
    53f8:	f012 f8dc 	bl	175b4 <arm_cmse_mpu_region_get>
    53fc:	4606      	mov	r6, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    53fe:	68fb      	ldr	r3, [r7, #12]
    5400:	eb09 0003 	add.w	r0, r9, r3
    5404:	3801      	subs	r0, #1
    5406:	f012 f8d5 	bl	175b4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    540a:	4286      	cmp	r6, r0
    540c:	f47f af60 	bne.w	52d0 <mpu_configure_regions_and_partition+0x94>
		if ((u_reg_index == -EINVAL) ||
    5410:	f116 0f16 	cmn.w	r6, #22
    5414:	f43f af5f 	beq.w	52d6 <mpu_configure_regions_and_partition+0x9a>
    5418:	42b4      	cmp	r4, r6
    541a:	f77f af5c 	ble.w	52d6 <mpu_configure_regions_and_partition+0x9a>
		uint32_t u_reg_base = mpu_region_get_base(u_reg_index);
    541e:	46b4      	mov	ip, r6
	MPU->RNR = rnr;
    5420:	4b31      	ldr	r3, [pc, #196]	; (54e8 <mpu_configure_regions_and_partition+0x2ac>)
    5422:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
	return MPU->RBAR;
    5426:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
    542a:	f022 021f 	bic.w	r2, r2, #31
	MPU->RNR = rnr;
    542e:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
	return MPU->RLAR;
    5432:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    5436:	f043 091f 	orr.w	r9, r3, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
    543a:	f85a 300b 	ldr.w	r3, [sl, fp]
    543e:	6869      	ldr	r1, [r5, #4]
    5440:	4419      	add	r1, r3
    5442:	1e48      	subs	r0, r1, #1
    5444:	60f8      	str	r0, [r7, #12]
		if ((regions[i].start == u_reg_base) &&
    5446:	4293      	cmp	r3, r2
    5448:	d087      	beq.n	535a <mpu_configure_regions_and_partition+0x11e>
		} else if (regions[i].start == u_reg_base) {
    544a:	4293      	cmp	r3, r2
    544c:	d08c      	beq.n	5368 <mpu_configure_regions_and_partition+0x12c>
		} else if (reg_last == u_reg_last) {
    544e:	68fa      	ldr	r2, [r7, #12]
    5450:	4591      	cmp	r9, r2
    5452:	d09f      	beq.n	5394 <mpu_configure_regions_and_partition+0x158>
				regions[i].start - 1);
    5454:	3b01      	subs	r3, #1
	MPU->RNR = rnr;
    5456:	4924      	ldr	r1, [pc, #144]	; (54e8 <mpu_configure_regions_and_partition+0x2ac>)
    5458:	4666      	mov	r6, ip
    545a:	f8c1 c098 	str.w	ip, [r1, #152]	; 0x98
	return MPU->RLAR;
    545e:	f8d1 20a0 	ldr.w	r2, [r1, #160]	; 0xa0
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
    5462:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
    5466:	f023 031f 	bic.w	r3, r3, #31
    546a:	4313      	orrs	r3, r2
	MPU->RLAR = rlar;
    546c:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
				mpu_configure_region(reg_index, &regions[i]);
    5470:	4629      	mov	r1, r5
    5472:	b2e0      	uxtb	r0, r4
    5474:	f012 f8ce 	bl	17614 <mpu_configure_region>
    5478:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    547a:	f110 0f16 	cmn.w	r0, #22
    547e:	f43f af61 	beq.w	5344 <mpu_configure_regions_and_partition+0x108>
			reg_index++;
    5482:	3001      	adds	r0, #1
	MPU->RNR = rnr;
    5484:	4b18      	ldr	r3, [pc, #96]	; (54e8 <mpu_configure_regions_and_partition+0x2ac>)
    5486:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
	return MPU->RBAR;
    548a:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
    548e:	7e3a      	ldrb	r2, [r7, #24]
    5490:	f361 0204 	bfi	r2, r1, #0, #5
    5494:	763a      	strb	r2, [r7, #24]
	return MPU->RLAR;
    5496:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
    549a:	f3c3 0342 	ubfx	r3, r3, #1, #3
    549e:	b2d2      	uxtb	r2, r2
    54a0:	f363 1247 	bfi	r2, r3, #5, #3
    54a4:	763a      	strb	r2, [r7, #24]
			fill_region.base = regions[i].start +
    54a6:	f85a 300b 	ldr.w	r3, [sl, fp]
				regions[i].size;
    54aa:	686a      	ldr	r2, [r5, #4]
			fill_region.base = regions[i].start +
    54ac:	4413      	add	r3, r2
    54ae:	613b      	str	r3, [r7, #16]
			REGION_LIMIT_ADDR((regions[i].start +
    54b0:	f023 031f 	bic.w	r3, r3, #31
    54b4:	68fa      	ldr	r2, [r7, #12]
    54b6:	eba9 0902 	sub.w	r9, r9, r2
    54ba:	444b      	add	r3, r9
    54bc:	3b01      	subs	r3, #1
    54be:	f023 031f 	bic.w	r3, r3, #31
			fill_region.attr.r_limit =
    54c2:	61fb      	str	r3, [r7, #28]
				region_allocate_and_init(reg_index,
    54c4:	f107 0110 	add.w	r1, r7, #16
    54c8:	b2c0      	uxtb	r0, r0
    54ca:	f7ff fe69 	bl	51a0 <region_allocate_and_init>
    54ce:	4604      	mov	r4, r0
			if (reg_index == -EINVAL) {
    54d0:	f110 0f16 	cmn.w	r0, #22
    54d4:	f43f af36 	beq.w	5344 <mpu_configure_regions_and_partition+0x108>
			reg_index++;
    54d8:	3401      	adds	r4, #1
    54da:	e771      	b.n	53c0 <mpu_configure_regions_and_partition+0x184>
    54dc:	0001dd90 	.word	0x0001dd90
    54e0:	0001d074 	.word	0x0001d074
    54e4:	0001ddb4 	.word	0x0001ddb4
    54e8:	e000ed00 	.word	0xe000ed00

000054ec <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
    54ec:	b510      	push	{r4, lr}
	int mpu_reg_index = static_regions_num;
    54ee:	4c03      	ldr	r4, [pc, #12]	; (54fc <mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    54f0:	2301      	movs	r3, #1
    54f2:	7822      	ldrb	r2, [r4, #0]
    54f4:	f7ff fea2 	bl	523c <mpu_configure_regions_and_partition>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    54f8:	7020      	strb	r0, [r4, #0]

	return mpu_reg_index;
}
    54fa:	bd10      	pop	{r4, pc}
    54fc:	200028fc 	.word	0x200028fc

00005500 <mpu_mark_areas_for_dynamic_regions>:
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
		const struct z_arm_mpu_partition dyn_region_areas[],
		const uint8_t dyn_region_areas_num)
{
    5500:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5504:	4607      	mov	r7, r0
    5506:	4688      	mov	r8, r1
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    5508:	2400      	movs	r4, #0
    550a:	e003      	b.n	5514 <mpu_mark_areas_for_dynamic_regions+0x14>
	return -EINVAL;
    550c:	f06f 0515 	mvn.w	r5, #21
    5510:	e017      	b.n	5542 <mpu_mark_areas_for_dynamic_regions+0x42>
	for (int i = 0; i < dyn_region_areas_num; i++) {
    5512:	3401      	adds	r4, #1
    5514:	45a0      	cmp	r8, r4
    5516:	dd43      	ble.n	55a0 <mpu_mark_areas_for_dynamic_regions+0xa0>
		if (dyn_region_areas[i].size == 0U) {
    5518:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    551c:	009a      	lsls	r2, r3, #2
    551e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    5522:	685e      	ldr	r6, [r3, #4]
    5524:	2e00      	cmp	r6, #0
    5526:	d0f4      	beq.n	5512 <mpu_mark_areas_for_dynamic_regions+0x12>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    5528:	f857 9002 	ldr.w	r9, [r7, r2]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    552c:	4648      	mov	r0, r9
    552e:	f012 f841 	bl	175b4 <arm_cmse_mpu_region_get>
    5532:	4605      	mov	r5, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    5534:	eb06 0009 	add.w	r0, r6, r9
    5538:	3801      	subs	r0, #1
    553a:	f012 f83b 	bl	175b4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    553e:	4285      	cmp	r5, r0
    5540:	d1e4      	bne.n	550c <mpu_mark_areas_for_dynamic_regions+0xc>
		dyn_reg_info[i].index =
    5542:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    5546:	4a1a      	ldr	r2, [pc, #104]	; (55b0 <mpu_mark_areas_for_dynamic_regions+0xb0>)
    5548:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    554c:	f115 0f16 	cmn.w	r5, #22
    5550:	d027      	beq.n	55a2 <mpu_mark_areas_for_dynamic_regions+0xa2>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    5552:	4b18      	ldr	r3, [pc, #96]	; (55b4 <mpu_mark_areas_for_dynamic_regions+0xb4>)
    5554:	781b      	ldrb	r3, [r3, #0]
    5556:	42ab      	cmp	r3, r5
    5558:	dd26      	ble.n	55a8 <mpu_mark_areas_for_dynamic_regions+0xa8>

			return -EINVAL;
		}

		/* Store default configuration */
		mpu_region_get_conf(dyn_reg_info[i].index,
    555a:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    555e:	4b14      	ldr	r3, [pc, #80]	; (55b0 <mpu_mark_areas_for_dynamic_regions+0xb0>)
    5560:	eb03 0282 	add.w	r2, r3, r2, lsl #2
	MPU->RNR = rnr;
    5564:	4b14      	ldr	r3, [pc, #80]	; (55b8 <mpu_mark_areas_for_dynamic_regions+0xb8>)
    5566:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
    556a:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
	return MPU->RBAR;
    556e:	f8d3 509c 	ldr.w	r5, [r3, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
    5572:	7b10      	ldrb	r0, [r2, #12]
    5574:	f365 0004 	bfi	r0, r5, #0, #5
    5578:	7310      	strb	r0, [r2, #12]
	return MPU->RLAR;
    557a:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
    557e:	f3c0 0042 	ubfx	r0, r0, #1, #3
    5582:	7b15      	ldrb	r5, [r2, #12]
    5584:	f360 1547 	bfi	r5, r0, #5, #3
    5588:	7315      	strb	r5, [r2, #12]
	return MPU->RBAR;
    558a:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
    558e:	f020 001f 	bic.w	r0, r0, #31
    5592:	6050      	str	r0, [r2, #4]
	return MPU->RLAR;
    5594:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
    5598:	f023 031f 	bic.w	r3, r3, #31
    559c:	6113      	str	r3, [r2, #16]
}
    559e:	e7b8      	b.n	5512 <mpu_mark_areas_for_dynamic_regions+0x12>
			&dyn_reg_info[i].region_conf);
	}

	return 0;
    55a0:	2500      	movs	r5, #0
}
    55a2:	4628      	mov	r0, r5
    55a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return -EINVAL;
    55a8:	f06f 0515 	mvn.w	r5, #21
    55ac:	e7f9      	b.n	55a2 <mpu_mark_areas_for_dynamic_regions+0xa2>
    55ae:	bf00      	nop
    55b0:	20002194 	.word	0x20002194
    55b4:	200028fc 	.word	0x200028fc
    55b8:	e000ed00 	.word	0xe000ed00

000055bc <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    55bc:	4b04      	ldr	r3, [pc, #16]	; (55d0 <arm_core_mpu_enable+0x14>)
    55be:	2205      	movs	r2, #5
    55c0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    55c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    55c8:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    55cc:	4770      	bx	lr
    55ce:	bf00      	nop
    55d0:	e000ed00 	.word	0xe000ed00

000055d4 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    55d4:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    55d8:	4b02      	ldr	r3, [pc, #8]	; (55e4 <arm_core_mpu_disable+0x10>)
    55da:	2200      	movs	r2, #0
    55dc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    55e0:	4770      	bx	lr
    55e2:	bf00      	nop
    55e4:	e000ed00 	.word	0xe000ed00

000055e8 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
    55e8:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    55ea:	4b0e      	ldr	r3, [pc, #56]	; (5624 <z_arm_mpu_init+0x3c>)
    55ec:	681d      	ldr	r5, [r3, #0]
    55ee:	2d08      	cmp	r5, #8
    55f0:	d815      	bhi.n	561e <z_arm_mpu_init+0x36>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    55f2:	f7ff ffef 	bl	55d4 <arm_core_mpu_disable>
	}
#endif
#endif /* CONFIG_NOCACHE_MEMORY */

	/* Architecture-specific configuration */
	mpu_init();
    55f6:	f7ff fdbf 	bl	5178 <mpu_init>

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    55fa:	2400      	movs	r4, #0
    55fc:	e007      	b.n	560e <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    55fe:	4b09      	ldr	r3, [pc, #36]	; (5624 <z_arm_mpu_init+0x3c>)
    5600:	6859      	ldr	r1, [r3, #4]
    5602:	eb01 1104 	add.w	r1, r1, r4, lsl #4
    5606:	4620      	mov	r0, r4
    5608:	f011 ffde 	bl	175c8 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    560c:	3401      	adds	r4, #1
    560e:	42a5      	cmp	r5, r4
    5610:	d8f5      	bhi.n	55fe <z_arm_mpu_init+0x16>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    5612:	4b05      	ldr	r3, [pc, #20]	; (5628 <z_arm_mpu_init+0x40>)
    5614:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    5616:	f7ff ffd1 	bl	55bc <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    561a:	2000      	movs	r0, #0
}
    561c:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    561e:	f04f 30ff 	mov.w	r0, #4294967295
    5622:	e7fb      	b.n	561c <z_arm_mpu_init+0x34>
    5624:	0001dde8 	.word	0x0001dde8
    5628:	200028fc 	.word	0x200028fc

0000562c <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
    562c:	4b01      	ldr	r3, [pc, #4]	; (5634 <__stdout_hook_install+0x8>)
    562e:	6018      	str	r0, [r3, #0]
}
    5630:	4770      	bx	lr
    5632:	bf00      	nop
    5634:	20000214 	.word	0x20000214

00005638 <enable_cpunet>:
{
#if !defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)
	/* Retain nRF5340 Network MCU in Secure domain (bus
	 * accesses by Network MCU will have Secure attribute set).
	 */
	NRF_SPU->EXTDOMAIN[0].PERM = 1 << 4;
    5638:	4b04      	ldr	r3, [pc, #16]	; (564c <enable_cpunet+0x14>)
    563a:	2210      	movs	r2, #16
    563c:	f8c3 2440 	str.w	r2, [r3, #1088]	; 0x440
	 * this case do the remainder of actions to properly configure and
	 * boot the Network MCU.
	 */

	/* Release the Network MCU, 'Release force off signal' */
	NRF_RESET->NETWORK.FORCEOFF = RESET_NETWORK_FORCEOFF_FORCEOFF_Release;
    5640:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    5644:	2200      	movs	r2, #0
    5646:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614

	LOG_DBG("Network MCU released.");
#endif /* !CONFIG_TRUSTED_EXECUTION_SECURE */
}
    564a:	4770      	bx	lr
    564c:	50003000 	.word	0x50003000

00005650 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const uint8_t *b = buf;
	size_t i;

	len = MIN(len, (sizeof(str) - 1) / 2);
    5650:	2940      	cmp	r1, #64	; 0x40
    5652:	bf28      	it	cs
    5654:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
    5656:	2300      	movs	r3, #0
    5658:	428b      	cmp	r3, r1
    565a:	d21c      	bcs.n	5696 <bt_hex_real+0x46>
{
    565c:	b430      	push	{r4, r5}
		str[i * 2]     = hex[b[i] >> 4];
    565e:	f810 c003 	ldrb.w	ip, [r0, r3]
    5662:	ea4f 1c1c 	mov.w	ip, ip, lsr #4
    5666:	005a      	lsls	r2, r3, #1
    5668:	4d0d      	ldr	r5, [pc, #52]	; (56a0 <bt_hex_real+0x50>)
    566a:	f815 c00c 	ldrb.w	ip, [r5, ip]
    566e:	4c0d      	ldr	r4, [pc, #52]	; (56a4 <bt_hex_real+0x54>)
    5670:	f804 c013 	strb.w	ip, [r4, r3, lsl #1]
		str[i * 2 + 1] = hex[b[i] & 0xf];
    5674:	f810 c003 	ldrb.w	ip, [r0, r3]
    5678:	f00c 0c0f 	and.w	ip, ip, #15
    567c:	3201      	adds	r2, #1
    567e:	f815 500c 	ldrb.w	r5, [r5, ip]
    5682:	54a5      	strb	r5, [r4, r2]
	for (i = 0; i < len; i++) {
    5684:	3301      	adds	r3, #1
    5686:	428b      	cmp	r3, r1
    5688:	d3e9      	bcc.n	565e <bt_hex_real+0xe>
	}

	str[i * 2] = '\0';
    568a:	4806      	ldr	r0, [pc, #24]	; (56a4 <bt_hex_real+0x54>)
    568c:	2200      	movs	r2, #0
    568e:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]

	return str;
}
    5692:	bc30      	pop	{r4, r5}
    5694:	4770      	bx	lr
	str[i * 2] = '\0';
    5696:	4803      	ldr	r0, [pc, #12]	; (56a4 <bt_hex_real+0x54>)
    5698:	2200      	movs	r2, #0
    569a:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]
}
    569e:	4770      	bx	lr
    56a0:	0001de70 	.word	0x0001de70
    56a4:	200021c8 	.word	0x200021c8

000056a8 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
    56a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    56aa:	b08b      	sub	sp, #44	; 0x2c
    56ac:	4604      	mov	r4, r0
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
	char type[10];

	switch (addr->type) {
    56ae:	7803      	ldrb	r3, [r0, #0]
    56b0:	2b03      	cmp	r3, #3
    56b2:	d82c      	bhi.n	570e <bt_addr_le_str_real+0x66>
    56b4:	e8df f003 	tbb	[pc, r3]
    56b8:	26211c02 	.word	0x26211c02
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    56bc:	4917      	ldr	r1, [pc, #92]	; (571c <bt_addr_le_str_real+0x74>)
    56be:	a807      	add	r0, sp, #28
    56c0:	f011 ffcf 	bl	17662 <strcpy>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
    56c4:	7963      	ldrb	r3, [r4, #5]
    56c6:	7922      	ldrb	r2, [r4, #4]
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
    56c8:	78e1      	ldrb	r1, [r4, #3]
    56ca:	78a0      	ldrb	r0, [r4, #2]
    56cc:	7866      	ldrb	r6, [r4, #1]
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    56ce:	4d14      	ldr	r5, [pc, #80]	; (5720 <bt_addr_le_str_real+0x78>)
    56d0:	af07      	add	r7, sp, #28
    56d2:	9705      	str	r7, [sp, #20]
    56d4:	9604      	str	r6, [sp, #16]
    56d6:	9003      	str	r0, [sp, #12]
    56d8:	9102      	str	r1, [sp, #8]
    56da:	9201      	str	r2, [sp, #4]
    56dc:	9300      	str	r3, [sp, #0]
    56de:	79a3      	ldrb	r3, [r4, #6]
    56e0:	4a10      	ldr	r2, [pc, #64]	; (5724 <bt_addr_le_str_real+0x7c>)
    56e2:	211e      	movs	r1, #30
    56e4:	4628      	mov	r0, r5
    56e6:	f010 f818 	bl	1571a <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
    56ea:	4628      	mov	r0, r5
    56ec:	b00b      	add	sp, #44	; 0x2c
    56ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strcpy(type, "random");
    56f0:	490d      	ldr	r1, [pc, #52]	; (5728 <bt_addr_le_str_real+0x80>)
    56f2:	a807      	add	r0, sp, #28
    56f4:	f011 ffb5 	bl	17662 <strcpy>
		break;
    56f8:	e7e4      	b.n	56c4 <bt_addr_le_str_real+0x1c>
		strcpy(type, "public-id");
    56fa:	490c      	ldr	r1, [pc, #48]	; (572c <bt_addr_le_str_real+0x84>)
    56fc:	a807      	add	r0, sp, #28
    56fe:	f011 ffb0 	bl	17662 <strcpy>
		break;
    5702:	e7df      	b.n	56c4 <bt_addr_le_str_real+0x1c>
		strcpy(type, "random-id");
    5704:	490a      	ldr	r1, [pc, #40]	; (5730 <bt_addr_le_str_real+0x88>)
    5706:	a807      	add	r0, sp, #28
    5708:	f011 ffab 	bl	17662 <strcpy>
		break;
    570c:	e7da      	b.n	56c4 <bt_addr_le_str_real+0x1c>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    570e:	4a09      	ldr	r2, [pc, #36]	; (5734 <bt_addr_le_str_real+0x8c>)
    5710:	210a      	movs	r1, #10
    5712:	a807      	add	r0, sp, #28
    5714:	f010 f801 	bl	1571a <snprintk>
		break;
    5718:	e7d4      	b.n	56c4 <bt_addr_le_str_real+0x1c>
    571a:	bf00      	nop
    571c:	0001de24 	.word	0x0001de24
    5720:	200021a8 	.word	0x200021a8
    5724:	0001de4c 	.word	0x0001de4c
    5728:	0001de2c 	.word	0x0001de2c
    572c:	0001de34 	.word	0x0001de34
    5730:	0001de40 	.word	0x0001de40
    5734:	0001ef6c 	.word	0x0001ef6c

00005738 <long_wq_init>:
{
	return k_work_submit_to_queue(&bt_long_wq, work);
}

static int long_wq_init(const struct device *d)
{
    5738:	b570      	push	{r4, r5, r6, lr}
    573a:	b084      	sub	sp, #16
	ARG_UNUSED(d);

	const struct k_work_queue_config cfg = {.name = "BT_LW_WQ"};
    573c:	ae02      	add	r6, sp, #8
    573e:	2400      	movs	r4, #0
    5740:	9402      	str	r4, [sp, #8]
    5742:	9403      	str	r4, [sp, #12]
    5744:	4b08      	ldr	r3, [pc, #32]	; (5768 <long_wq_init+0x30>)
    5746:	9302      	str	r3, [sp, #8]

	k_work_queue_init(&bt_long_wq);
    5748:	4d08      	ldr	r5, [pc, #32]	; (576c <long_wq_init+0x34>)
    574a:	4628      	mov	r0, r5
    574c:	f016 fe10 	bl	1c370 <k_work_queue_init>

	k_work_queue_start(&bt_long_wq, bt_lw_stack_area,
    5750:	9600      	str	r6, [sp, #0]
    5752:	230a      	movs	r3, #10
    5754:	f44f 62a3 	mov.w	r2, #1304	; 0x518
    5758:	4905      	ldr	r1, [pc, #20]	; (5770 <long_wq_init+0x38>)
    575a:	4628      	mov	r0, r5
    575c:	f00e fbe8 	bl	13f30 <k_work_queue_start>
			   K_THREAD_STACK_SIZEOF(bt_lw_stack_area),
			   CONFIG_BT_LONG_WQ_PRIO, &cfg);

	return 0;
}
    5760:	4620      	mov	r0, r4
    5762:	b004      	add	sp, #16
    5764:	bd70      	pop	{r4, r5, r6, pc}
    5766:	bf00      	nop
    5768:	0001de84 	.word	0x0001de84
    576c:	20001438 	.word	0x20001438
    5770:	20003008 	.word	0x20003008

00005774 <bt_long_wq_schedule>:
{
    5774:	b508      	push	{r3, lr}
    5776:	4601      	mov	r1, r0
	return k_work_schedule_for_queue(&bt_long_wq, dwork, timeout);
    5778:	4801      	ldr	r0, [pc, #4]	; (5780 <bt_long_wq_schedule+0xc>)
    577a:	f016 fe1b 	bl	1c3b4 <k_work_schedule_for_queue>
}
    577e:	bd08      	pop	{r3, pc}
    5780:	20001438 	.word	0x20001438

00005784 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
    5784:	b510      	push	{r4, lr}
    5786:	4686      	mov	lr, r0
    5788:	468c      	mov	ip, r1
	switch (src->type) {
    578a:	7803      	ldrb	r3, [r0, #0]
    578c:	2b01      	cmp	r3, #1
    578e:	d018      	beq.n	57c2 <uuid_to_uuid128+0x3e>
    5790:	2b02      	cmp	r3, #2
    5792:	d032      	beq.n	57fa <uuid_to_uuid128+0x76>
    5794:	b103      	cbz	r3, 5798 <uuid_to_uuid128+0x14>
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
    5796:	bd10      	pop	{r4, pc}
		*dst = uuid128_base;
    5798:	4c1b      	ldr	r4, [pc, #108]	; (5808 <uuid_to_uuid128+0x84>)
    579a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    579c:	f8cc 0000 	str.w	r0, [ip]
    57a0:	f8cc 1004 	str.w	r1, [ip, #4]
    57a4:	f8cc 2008 	str.w	r2, [ip, #8]
    57a8:	f8cc 300c 	str.w	r3, [ip, #12]
    57ac:	7823      	ldrb	r3, [r4, #0]
    57ae:	f88c 3010 	strb.w	r3, [ip, #16]
		sys_put_le16(BT_UUID_16(src)->val,
    57b2:	f8be 3002 	ldrh.w	r3, [lr, #2]
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
    57b6:	f88c 300d 	strb.w	r3, [ip, #13]
	dst[1] = val >> 8;
    57ba:	0a1b      	lsrs	r3, r3, #8
    57bc:	f88c 300e 	strb.w	r3, [ip, #14]
}
    57c0:	e7e9      	b.n	5796 <uuid_to_uuid128+0x12>
		*dst = uuid128_base;
    57c2:	4c11      	ldr	r4, [pc, #68]	; (5808 <uuid_to_uuid128+0x84>)
    57c4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    57c6:	f8cc 0000 	str.w	r0, [ip]
    57ca:	f8cc 1004 	str.w	r1, [ip, #4]
    57ce:	f8cc 2008 	str.w	r2, [ip, #8]
    57d2:	f8cc 300c 	str.w	r3, [ip, #12]
    57d6:	7823      	ldrb	r3, [r4, #0]
    57d8:	f88c 3010 	strb.w	r3, [ip, #16]
		sys_put_le32(BT_UUID_32(src)->val,
    57dc:	f8de 3004 	ldr.w	r3, [lr, #4]
	dst[0] = val;
    57e0:	f88c 300d 	strb.w	r3, [ip, #13]
	dst[1] = val >> 8;
    57e4:	f3c3 2207 	ubfx	r2, r3, #8, #8
    57e8:	f88c 200e 	strb.w	r2, [ip, #14]
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le32(uint32_t val, uint8_t dst[4])
{
	sys_put_le16(val, dst);
	sys_put_le16(val >> 16, &dst[2]);
    57ec:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
    57ee:	f88c 200f 	strb.w	r2, [ip, #15]
	dst[1] = val >> 8;
    57f2:	0e1b      	lsrs	r3, r3, #24
    57f4:	f88c 3010 	strb.w	r3, [ip, #16]
}
    57f8:	e7cd      	b.n	5796 <uuid_to_uuid128+0x12>
		memcpy(dst, src, sizeof(*dst));
    57fa:	2211      	movs	r2, #17
    57fc:	4601      	mov	r1, r0
    57fe:	4660      	mov	r0, ip
    5800:	f011 ff96 	bl	17730 <memcpy>
		return;
    5804:	e7c7      	b.n	5796 <uuid_to_uuid128+0x12>
    5806:	bf00      	nop
    5808:	0001de90 	.word	0x0001de90

0000580c <bt_buf_get_rx>:
			  BT_BUF_RX_SIZE, 8,
			  NULL);
#endif /* CONFIG_BT_HCI_ACL_FLOW_CONTROL */

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
    580c:	b538      	push	{r3, r4, r5, lr}
    580e:	4605      	mov	r5, r0
	     type == BT_BUF_ISO_IN) {
		return bt_iso_get_rx(timeout);
	}

#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	if (type == BT_BUF_EVT) {
    5810:	2801      	cmp	r0, #1
    5812:	d00c      	beq.n	582e <bt_buf_get_rx+0x22>
 * @copydetails net_buf_alloc_fixed
 */
static inline struct net_buf * __must_check net_buf_alloc(struct net_buf_pool *pool,
							  k_timeout_t timeout)
{
	return net_buf_alloc_fixed(pool, timeout);
    5814:	4808      	ldr	r0, [pc, #32]	; (5838 <bt_buf_get_rx+0x2c>)
    5816:	f014 fc15 	bl	1a044 <net_buf_alloc_fixed>
    581a:	4604      	mov	r4, r0
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
#endif

	if (buf) {
    581c:	b12c      	cbz	r4, 582a <bt_buf_get_rx+0x1e>
 * @param buf Buffer to initialize.
 * @param reserve How much headroom to reserve.
 */
static inline void net_buf_reserve(struct net_buf *buf, size_t reserve)
{
	net_buf_simple_reserve(&buf->b, reserve);
    581e:	2101      	movs	r1, #1
    5820:	f104 0008 	add.w	r0, r4, #8
    5824:	f014 fc36 	bl	1a094 <net_buf_simple_reserve>
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    5828:	7525      	strb	r5, [r4, #20]
		net_buf_reserve(buf, BT_BUF_RESERVE);
		bt_buf_set_type(buf, type);
	}

	return buf;
}
    582a:	4620      	mov	r0, r4
    582c:	bd38      	pop	{r3, r4, r5, pc}
	return net_buf_alloc_fixed(pool, timeout);
    582e:	4803      	ldr	r0, [pc, #12]	; (583c <bt_buf_get_rx+0x30>)
    5830:	f014 fc08 	bl	1a044 <net_buf_alloc_fixed>
    5834:	4604      	mov	r4, r0
    5836:	e7f1      	b.n	581c <bt_buf_get_rx+0x10>
    5838:	20000684 	.word	0x20000684
    583c:	20000708 	.word	0x20000708

00005840 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(k_timeout_t timeout)
{
    5840:	b510      	push	{r4, lr}
    5842:	4602      	mov	r2, r0
	struct net_buf *buf;

	if (bt_dev.sent_cmd) {
    5844:	4b0a      	ldr	r3, [pc, #40]	; (5870 <bt_buf_get_cmd_complete+0x30>)
    5846:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
    584a:	b158      	cbz	r0, 5864 <bt_buf_get_cmd_complete+0x24>
		buf = net_buf_ref(bt_dev.sent_cmd);
    584c:	f014 fcb3 	bl	1a1b6 <net_buf_ref>
    5850:	4604      	mov	r4, r0
    5852:	2101      	movs	r1, #1
    5854:	7501      	strb	r1, [r0, #20]

		bt_buf_set_type(buf, BT_BUF_EVT);
		buf->len = 0U;
    5856:	2300      	movs	r3, #0
    5858:	8183      	strh	r3, [r0, #12]
	net_buf_simple_reserve(&buf->b, reserve);
    585a:	3008      	adds	r0, #8
    585c:	f014 fc1a 	bl	1a094 <net_buf_simple_reserve>

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}
    5860:	4620      	mov	r0, r4
    5862:	bd10      	pop	{r4, pc}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
    5864:	460b      	mov	r3, r1
    5866:	2001      	movs	r0, #1
    5868:	f7ff ffd0 	bl	580c <bt_buf_get_rx>
    586c:	4604      	mov	r4, r0
    586e:	e7f7      	b.n	5860 <bt_buf_get_cmd_complete+0x20>
    5870:	20000000 	.word	0x20000000

00005874 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(uint8_t evt, bool discardable,
			       k_timeout_t timeout)
{
    5874:	b510      	push	{r4, lr}
	switch (evt) {
    5876:	280f      	cmp	r0, #15
    5878:	d90d      	bls.n	5896 <bt_buf_get_evt+0x22>
    587a:	2813      	cmp	r0, #19
    587c:	d10d      	bne.n	589a <bt_buf_get_evt+0x26>
	return net_buf_alloc_fixed(pool, timeout);
    587e:	4814      	ldr	r0, [pc, #80]	; (58d0 <bt_buf_get_evt+0x5c>)
    5880:	f014 fbe0 	bl	1a044 <net_buf_alloc_fixed>
	case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
		{
			struct net_buf *buf;

			buf = net_buf_alloc(&num_complete_pool, timeout);
			if (buf) {
    5884:	4604      	mov	r4, r0
    5886:	b198      	cbz	r0, 58b0 <bt_buf_get_evt+0x3c>
	net_buf_simple_reserve(&buf->b, reserve);
    5888:	2101      	movs	r1, #1
    588a:	3008      	adds	r0, #8
    588c:	f014 fc02 	bl	1a094 <net_buf_simple_reserve>
    5890:	2301      	movs	r3, #1
    5892:	7523      	strb	r3, [r4, #20]
}
    5894:	e00c      	b.n	58b0 <bt_buf_get_evt+0x3c>
	switch (evt) {
    5896:	280e      	cmp	r0, #14
    5898:	d205      	bcs.n	58a6 <bt_buf_get_evt+0x32>
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return bt_buf_get_cmd_complete(timeout);
	default:
#if defined(CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT)
		if (discardable) {
    589a:	b959      	cbnz	r1, 58b4 <bt_buf_get_evt+0x40>

			return buf;
		}
#endif /* CONFIG_BT_BUF_EVT_DISCARDABLE_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
    589c:	2001      	movs	r0, #1
    589e:	f7ff ffb5 	bl	580c <bt_buf_get_rx>
    58a2:	4604      	mov	r4, r0
    58a4:	e004      	b.n	58b0 <bt_buf_get_evt+0x3c>
		return bt_buf_get_cmd_complete(timeout);
    58a6:	4610      	mov	r0, r2
    58a8:	4619      	mov	r1, r3
    58aa:	f7ff ffc9 	bl	5840 <bt_buf_get_cmd_complete>
    58ae:	4604      	mov	r4, r0
	}
}
    58b0:	4620      	mov	r0, r4
    58b2:	bd10      	pop	{r4, pc}
	return net_buf_alloc_fixed(pool, timeout);
    58b4:	4807      	ldr	r0, [pc, #28]	; (58d4 <bt_buf_get_evt+0x60>)
    58b6:	f014 fbc5 	bl	1a044 <net_buf_alloc_fixed>
			if (buf) {
    58ba:	4604      	mov	r4, r0
    58bc:	2800      	cmp	r0, #0
    58be:	d0f7      	beq.n	58b0 <bt_buf_get_evt+0x3c>
	net_buf_simple_reserve(&buf->b, reserve);
    58c0:	2101      	movs	r1, #1
    58c2:	3008      	adds	r0, #8
    58c4:	f014 fbe6 	bl	1a094 <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    58c8:	2301      	movs	r3, #1
    58ca:	7523      	strb	r3, [r4, #20]
			return buf;
    58cc:	e7f0      	b.n	58b0 <bt_buf_get_evt+0x3c>
    58ce:	bf00      	nop
    58d0:	2000078c 	.word	0x2000078c
    58d4:	200006dc 	.word	0x200006dc

000058d8 <conn_handle_disconnected>:
}

static uint16_t disconnected_handles[CONFIG_BT_MAX_CONN];
static void conn_handle_disconnected(uint16_t handle)
{
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
    58d8:	2300      	movs	r3, #0
    58da:	b103      	cbz	r3, 58de <conn_handle_disconnected+0x6>
			 * handle 0 can be used as a valid non-zero handle.
			 */
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
		}
	}
}
    58dc:	4770      	bx	lr
		if (!disconnected_handles[i]) {
    58de:	4a05      	ldr	r2, [pc, #20]	; (58f4 <conn_handle_disconnected+0x1c>)
    58e0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    58e4:	b922      	cbnz	r2, 58f0 <conn_handle_disconnected+0x18>
			disconnected_handles[i] = ~BT_ACL_HANDLE_MASK | handle;
    58e6:	f440 4270 	orr.w	r2, r0, #61440	; 0xf000
    58ea:	4902      	ldr	r1, [pc, #8]	; (58f4 <conn_handle_disconnected+0x1c>)
    58ec:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
    58f0:	3301      	adds	r3, #1
    58f2:	e7f2      	b.n	58da <conn_handle_disconnected+0x2>
    58f4:	200022c4 	.word	0x200022c4

000058f8 <conn_handle_is_disconnected>:

static bool conn_handle_is_disconnected(uint16_t handle)
{
	handle |= ~BT_ACL_HANDLE_MASK;
    58f8:	f440 4070 	orr.w	r0, r0, #61440	; 0xf000

	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
    58fc:	2300      	movs	r3, #0
    58fe:	b10b      	cbz	r3, 5904 <conn_handle_is_disconnected+0xc>
			disconnected_handles[i] = 0;
			return true;
		}
	}

	return false;
    5900:	2000      	movs	r0, #0
}
    5902:	4770      	bx	lr
		if (disconnected_handles[i] == handle) {
    5904:	4a06      	ldr	r2, [pc, #24]	; (5920 <conn_handle_is_disconnected+0x28>)
    5906:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    590a:	4282      	cmp	r2, r0
    590c:	d001      	beq.n	5912 <conn_handle_is_disconnected+0x1a>
	for (int i = 0; i < ARRAY_SIZE(disconnected_handles); i++) {
    590e:	3301      	adds	r3, #1
    5910:	e7f5      	b.n	58fe <conn_handle_is_disconnected+0x6>
			disconnected_handles[i] = 0;
    5912:	4a03      	ldr	r2, [pc, #12]	; (5920 <conn_handle_is_disconnected+0x28>)
    5914:	2100      	movs	r1, #0
    5916:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
			return true;
    591a:	2001      	movs	r0, #1
    591c:	4770      	bx	lr
    591e:	bf00      	nop
    5920:	200022c4 	.word	0x200022c4

00005924 <read_local_ver_complete>:
}


static void read_local_ver_complete(struct net_buf *buf)
{
	struct bt_hci_rp_read_local_version_info *rp = (void *)buf->data;
    5924:	6882      	ldr	r2, [r0, #8]

	BT_DBG("status 0x%02x", rp->status);

	bt_dev.hci_version = rp->hci_version;
    5926:	7851      	ldrb	r1, [r2, #1]
    5928:	4b08      	ldr	r3, [pc, #32]	; (594c <read_local_ver_complete+0x28>)
    592a:	f883 1068 	strb.w	r1, [r3, #104]	; 0x68
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
    592e:	8851      	ldrh	r1, [r2, #2]
    5930:	f8a3 106a 	strh.w	r1, [r3, #106]	; 0x6a
	bt_dev.lmp_version = rp->lmp_version;
    5934:	7911      	ldrb	r1, [r2, #4]
    5936:	f883 1069 	strb.w	r1, [r3, #105]	; 0x69
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
    593a:	f8b2 1007 	ldrh.w	r1, [r2, #7]
    593e:	f8a3 106c 	strh.w	r1, [r3, #108]	; 0x6c
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
    5942:	f8b2 2005 	ldrh.w	r2, [r2, #5]
    5946:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
}
    594a:	4770      	bx	lr
    594c:	20000000 	.word	0x20000000

00005950 <le_read_supp_states_complete>:
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
}

static void le_read_supp_states_complete(struct net_buf *buf)
{
	struct bt_hci_rp_le_read_supp_states *rp = (void *)buf->data;
    5950:	6883      	ldr	r3, [r0, #8]
 *
 *  @return 16-bit integer in host endianness.
 */
static inline uint16_t sys_get_le16(const uint8_t src[2])
{
	return ((uint16_t)src[1] << 8) | src[0];
    5952:	7a19      	ldrb	r1, [r3, #8]
    5954:	79da      	ldrb	r2, [r3, #7]
    5956:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    595a:	7998      	ldrb	r0, [r3, #6]
    595c:	795a      	ldrb	r2, [r3, #5]
    595e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 *
 *  @return 32-bit integer in host endianness.
 */
static inline uint32_t sys_get_le32(const uint8_t src[4])
{
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    5962:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
	return ((uint16_t)src[1] << 8) | src[0];
    5966:	7918      	ldrb	r0, [r3, #4]
    5968:	78d9      	ldrb	r1, [r3, #3]
    596a:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
    596e:	7898      	ldrb	r0, [r3, #2]
    5970:	785b      	ldrb	r3, [r3, #1]
    5972:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
    5976:	ea43 4301 	orr.w	r3, r3, r1, lsl #16

	BT_DBG("status 0x%02x", rp->status);

	bt_dev.le.states = sys_get_le64(rp->le_states);
    597a:	4903      	ldr	r1, [pc, #12]	; (5988 <le_read_supp_states_complete+0x38>)
    597c:	f8c1 30d8 	str.w	r3, [r1, #216]	; 0xd8
    5980:	f8c1 20dc 	str.w	r2, [r1, #220]	; 0xdc
}
    5984:	4770      	bx	lr
    5986:	bf00      	nop
    5988:	20000000 	.word	0x20000000

0000598c <ver_str>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
}

#if defined(CONFIG_BT_DEBUG)
static const char *ver_str(uint8_t ver)
{
    598c:	b510      	push	{r4, lr}
    598e:	b08e      	sub	sp, #56	; 0x38
    5990:	4686      	mov	lr, r0
	const char * const str[] = {
    5992:	f10d 0c04 	add.w	ip, sp, #4
    5996:	4c0c      	ldr	r4, [pc, #48]	; (59c8 <ver_str+0x3c>)
    5998:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    599a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    599e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    59a0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    59a4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    59a6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    59aa:	6823      	ldr	r3, [r4, #0]
    59ac:	f8cc 3000 	str.w	r3, [ip]
		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
		"5.0", "5.1", "5.2", "5.3"
	};

	if (ver < ARRAY_SIZE(str)) {
    59b0:	f1be 0f0c 	cmp.w	lr, #12
    59b4:	d902      	bls.n	59bc <ver_str+0x30>
		return str[ver];
	}

	return "unknown";
    59b6:	4805      	ldr	r0, [pc, #20]	; (59cc <ver_str+0x40>)
}
    59b8:	b00e      	add	sp, #56	; 0x38
    59ba:	bd10      	pop	{r4, pc}
		return str[ver];
    59bc:	ab0e      	add	r3, sp, #56	; 0x38
    59be:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
    59c2:	f85e 0c34 	ldr.w	r0, [lr, #-52]
    59c6:	e7f7      	b.n	59b8 <ver_str+0x2c>
    59c8:	0001d184 	.word	0x0001d184
    59cc:	0001dff0 	.word	0x0001dff0

000059d0 <vs_hw_platform>:
{
	static const char * const plat_str[] = {
		"reserved", "Intel Corporation", "Nordic Semiconductor",
		"NXP Semiconductors" };

	if (platform < ARRAY_SIZE(plat_str)) {
    59d0:	2803      	cmp	r0, #3
    59d2:	d901      	bls.n	59d8 <vs_hw_platform+0x8>
		return plat_str[platform];
	}

	return "unknown";
    59d4:	4802      	ldr	r0, [pc, #8]	; (59e0 <vs_hw_platform+0x10>)
}
    59d6:	4770      	bx	lr
		return plat_str[platform];
    59d8:	4b02      	ldr	r3, [pc, #8]	; (59e4 <vs_hw_platform+0x14>)
    59da:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    59de:	4770      	bx	lr
    59e0:	0001dff0 	.word	0x0001dff0
    59e4:	0001e784 	.word	0x0001e784

000059e8 <vs_hw_variant>:
{
	static const char * const nordic_str[] = {
		"reserved", "nRF51x", "nRF52x", "nRF53x"
	};

	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
    59e8:	2802      	cmp	r0, #2
    59ea:	d107      	bne.n	59fc <vs_hw_variant+0x14>
		return "unknown";
	}

	if (variant < ARRAY_SIZE(nordic_str)) {
    59ec:	2903      	cmp	r1, #3
    59ee:	d901      	bls.n	59f4 <vs_hw_variant+0xc>
		return nordic_str[variant];
	}

	return "unknown";
    59f0:	4803      	ldr	r0, [pc, #12]	; (5a00 <vs_hw_variant+0x18>)
}
    59f2:	4770      	bx	lr
		return nordic_str[variant];
    59f4:	4b03      	ldr	r3, [pc, #12]	; (5a04 <vs_hw_variant+0x1c>)
    59f6:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
    59fa:	4770      	bx	lr
		return "unknown";
    59fc:	4800      	ldr	r0, [pc, #0]	; (5a00 <vs_hw_variant+0x18>)
    59fe:	4770      	bx	lr
    5a00:	0001dff0 	.word	0x0001dff0
    5a04:	0001e754 	.word	0x0001e754

00005a08 <vs_fw_variant>:
		"Vendor specific controller",
		"Firmware loader",
		"Rescue image",
	};

	if (variant < ARRAY_SIZE(var_str)) {
    5a08:	2803      	cmp	r0, #3
    5a0a:	d901      	bls.n	5a10 <vs_fw_variant+0x8>
		return var_str[variant];
	}

	return "unknown";
    5a0c:	4802      	ldr	r0, [pc, #8]	; (5a18 <vs_fw_variant+0x10>)
}
    5a0e:	4770      	bx	lr
		return var_str[variant];
    5a10:	4b02      	ldr	r3, [pc, #8]	; (5a1c <vs_fw_variant+0x14>)
    5a12:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    5a16:	4770      	bx	lr
    5a18:	0001dff0 	.word	0x0001dff0
    5a1c:	0001e7bc 	.word	0x0001e7bc

00005a20 <hci_reset_complete>:
	uint8_t status = buf->data[0];
    5a20:	6883      	ldr	r3, [r0, #8]
    5a22:	781b      	ldrb	r3, [r3, #0]
	if (status) {
    5a24:	b953      	cbnz	r3, 5a3c <hci_reset_complete+0x1c>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    5a26:	4b06      	ldr	r3, [pc, #24]	; (5a40 <hci_reset_complete+0x20>)
    5a28:	e8d3 2faf 	lda	r2, [r3]
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
    5a2c:	f002 0209 	and.w	r2, r2, #9
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    5a30:	e8d3 1fef 	ldaex	r1, [r3]
    5a34:	e8c3 2fe0 	stlex	r0, r2, [r3]
    5a38:	2800      	cmp	r0, #0
    5a3a:	d1f9      	bne.n	5a30 <hci_reset_complete+0x10>
}
    5a3c:	4770      	bx	lr
    5a3e:	bf00      	nop
    5a40:	200000cc 	.word	0x200000cc

00005a44 <read_local_features_complete>:
{
    5a44:	b508      	push	{r3, lr}
	struct bt_hci_rp_read_local_features *rp = (void *)buf->data;
    5a46:	6881      	ldr	r1, [r0, #8]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
    5a48:	2208      	movs	r2, #8
    5a4a:	3101      	adds	r1, #1
    5a4c:	4801      	ldr	r0, [pc, #4]	; (5a54 <read_local_features_complete+0x10>)
    5a4e:	f011 fe6f 	bl	17730 <memcpy>
}
    5a52:	bd08      	pop	{r3, pc}
    5a54:	20000070 	.word	0x20000070

00005a58 <read_supported_commands_complete>:
{
    5a58:	b508      	push	{r3, lr}
	struct bt_hci_rp_read_supported_commands *rp = (void *)buf->data;
    5a5a:	6881      	ldr	r1, [r0, #8]
	memcpy(bt_dev.supported_commands, rp->commands,
    5a5c:	2240      	movs	r2, #64	; 0x40
    5a5e:	3101      	adds	r1, #1
    5a60:	4801      	ldr	r0, [pc, #4]	; (5a68 <read_supported_commands_complete+0x10>)
    5a62:	f011 fe65 	bl	17730 <memcpy>
}
    5a66:	bd08      	pop	{r3, pc}
    5a68:	20000078 	.word	0x20000078

00005a6c <read_le_features_complete>:
{
    5a6c:	b508      	push	{r3, lr}
	struct bt_hci_rp_le_read_local_features *rp = (void *)buf->data;
    5a6e:	6881      	ldr	r1, [r0, #8]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
    5a70:	2208      	movs	r2, #8
    5a72:	3101      	adds	r1, #1
    5a74:	4801      	ldr	r0, [pc, #4]	; (5a7c <read_le_features_complete+0x10>)
    5a76:	f011 fe5b 	bl	17730 <memcpy>
}
    5a7a:	bd08      	pop	{r3, pc}
    5a7c:	200000d0 	.word	0x200000d0

00005a80 <le_read_buffer_size_complete>:
{
    5a80:	b508      	push	{r3, lr}
	struct bt_hci_rp_le_read_buffer_size *rp = (void *)buf->data;
    5a82:	6882      	ldr	r2, [r0, #8]
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->le_max_len);
    5a84:	f8b2 3001 	ldrh.w	r3, [r2, #1]
    5a88:	b299      	uxth	r1, r3
    5a8a:	4806      	ldr	r0, [pc, #24]	; (5aa4 <le_read_buffer_size_complete+0x24>)
    5a8c:	f8a0 30fc 	strh.w	r3, [r0, #252]	; 0xfc
	if (!bt_dev.le.acl_mtu) {
    5a90:	b901      	cbnz	r1, 5a94 <le_read_buffer_size_complete+0x14>
}
    5a92:	bd08      	pop	{r3, pc}
	k_sem_init(&bt_dev.le.acl_pkts, rp->le_max_num, rp->le_max_num);
    5a94:	78d1      	ldrb	r1, [r2, #3]
	return z_impl_k_sem_init(sem, initial_count, limit);
    5a96:	460a      	mov	r2, r1
    5a98:	f500 7080 	add.w	r0, r0, #256	; 0x100
    5a9c:	f016 fbba 	bl	1c214 <z_impl_k_sem_init>
    5aa0:	e7f7      	b.n	5a92 <le_read_buffer_size_complete+0x12>
    5aa2:	bf00      	nop
    5aa4:	20000000 	.word	0x20000000

00005aa8 <read_buffer_size_complete>:
{
    5aa8:	b508      	push	{r3, lr}
	struct bt_hci_rp_read_buffer_size *rp = (void *)buf->data;
    5aaa:	6882      	ldr	r2, [r0, #8]
	if (bt_dev.le.acl_mtu) {
    5aac:	4b08      	ldr	r3, [pc, #32]	; (5ad0 <read_buffer_size_complete+0x28>)
    5aae:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
    5ab2:	b103      	cbz	r3, 5ab6 <read_buffer_size_complete+0xe>
}
    5ab4:	bd08      	pop	{r3, pc}
	bt_dev.le.acl_mtu = sys_le16_to_cpu(rp->acl_max_len);
    5ab6:	f8b2 3001 	ldrh.w	r3, [r2, #1]
    5aba:	4805      	ldr	r0, [pc, #20]	; (5ad0 <read_buffer_size_complete+0x28>)
    5abc:	f8a0 30fc 	strh.w	r3, [r0, #252]	; 0xfc
	pkts = sys_le16_to_cpu(rp->acl_max_num);
    5ac0:	8891      	ldrh	r1, [r2, #4]
    5ac2:	460a      	mov	r2, r1
    5ac4:	f500 7080 	add.w	r0, r0, #256	; 0x100
    5ac8:	f016 fba4 	bl	1c214 <z_impl_k_sem_init>
    5acc:	e7f2      	b.n	5ab4 <read_buffer_size_complete+0xc>
    5ace:	bf00      	nop
    5ad0:	20000000 	.word	0x20000000

00005ad4 <hci_data_buf_overflow>:
{
    5ad4:	b590      	push	{r4, r7, lr}
    5ad6:	b083      	sub	sp, #12
    5ad8:	af00      	add	r7, sp, #0
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
    5ada:	6883      	ldr	r3, [r0, #8]
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    5adc:	7818      	ldrb	r0, [r3, #0]
    5ade:	b088      	sub	sp, #32
    5ae0:	466b      	mov	r3, sp
    5ae2:	f113 0210 	adds.w	r2, r3, #16
    5ae6:	d031      	beq.n	5b4c <hci_data_buf_overflow+0x78>
    5ae8:	210c      	movs	r1, #12
    5aea:	b11a      	cbz	r2, 5af4 <hci_data_buf_overflow+0x20>
    5aec:	2904      	cmp	r1, #4
    5aee:	dd01      	ble.n	5af4 <hci_data_buf_overflow+0x20>
    5af0:	4c19      	ldr	r4, [pc, #100]	; (5b58 <hci_data_buf_overflow+0x84>)
    5af2:	615c      	str	r4, [r3, #20]
    5af4:	b112      	cbz	r2, 5afc <hci_data_buf_overflow+0x28>
    5af6:	2908      	cmp	r1, #8
    5af8:	dd00      	ble.n	5afc <hci_data_buf_overflow+0x28>
    5afa:	6198      	str	r0, [r3, #24]
    5afc:	290b      	cmp	r1, #11
    5afe:	dd28      	ble.n	5b52 <hci_data_buf_overflow+0x7e>
    5b00:	f04f 0c0c 	mov.w	ip, #12
    5b04:	b13a      	cbz	r2, 5b16 <hci_data_buf_overflow+0x42>
    5b06:	2103      	movs	r1, #3
    5b08:	7139      	strb	r1, [r7, #4]
    5b0a:	2100      	movs	r1, #0
    5b0c:	7179      	strb	r1, [r7, #5]
    5b0e:	71b9      	strb	r1, [r7, #6]
    5b10:	71f9      	strb	r1, [r7, #7]
    5b12:	6878      	ldr	r0, [r7, #4]
    5b14:	6118      	str	r0, [r3, #16]
    5b16:	2100      	movs	r1, #0
    5b18:	f36f 0100 	bfc	r1, #0, #1
    5b1c:	f36f 0141 	bfc	r1, #1, #1
    5b20:	f36f 0182 	bfc	r1, #2, #1
    5b24:	f36f 01c5 	bfc	r1, #3, #3
    5b28:	2302      	movs	r3, #2
    5b2a:	f363 1188 	bfi	r1, r3, #6, #3
    5b2e:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    5b32:	f36c 2152 	bfi	r1, ip, #9, #10
    5b36:	f36f 41de 	bfc	r1, #19, #12
    5b3a:	f36f 71df 	bfc	r1, #31, #1
    5b3e:	2300      	movs	r3, #0
    5b40:	4806      	ldr	r0, [pc, #24]	; (5b5c <hci_data_buf_overflow+0x88>)
    5b42:	f7fc fb81 	bl	2248 <z_impl_z_log_msg_static_create>
}
    5b46:	370c      	adds	r7, #12
    5b48:	46bd      	mov	sp, r7
    5b4a:	bd90      	pop	{r4, r7, pc}
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
    5b4c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    5b50:	e7cb      	b.n	5aea <hci_data_buf_overflow+0x16>
    5b52:	f06f 0c1b 	mvn.w	ip, #27
    5b56:	e7d5      	b.n	5b04 <hci_data_buf_overflow+0x30>
    5b58:	0001dff8 	.word	0x0001dff8
    5b5c:	0001cffc 	.word	0x0001cffc

00005b60 <handle_event_common>:
{
    5b60:	b5f0      	push	{r4, r5, r6, r7, lr}
    5b62:	b083      	sub	sp, #12
    5b64:	af00      	add	r7, sp, #0
    5b66:	4604      	mov	r4, r0
    5b68:	4608      	mov	r0, r1
	for (i = 0; i < num_handlers; i++) {
    5b6a:	f04f 0c00 	mov.w	ip, #0
    5b6e:	4563      	cmp	r3, ip
    5b70:	d954      	bls.n	5c1c <handle_event_common+0xbc>
		const struct event_handler *handler = &handlers[i];
    5b72:	eb02 01cc 	add.w	r1, r2, ip, lsl #3
		if (handler->event != event) {
    5b76:	f812 e03c 	ldrb.w	lr, [r2, ip, lsl #3]
    5b7a:	45a6      	cmp	lr, r4
    5b7c:	d109      	bne.n	5b92 <handle_event_common+0x32>
		if (buf->len < handler->min_len) {
    5b7e:	8983      	ldrh	r3, [r0, #12]
    5b80:	784a      	ldrb	r2, [r1, #1]
    5b82:	4293      	cmp	r3, r2
    5b84:	d308      	bcc.n	5b98 <handle_event_common+0x38>
		handler->handler(buf);
    5b86:	684b      	ldr	r3, [r1, #4]
    5b88:	4798      	blx	r3
		return 0;
    5b8a:	2000      	movs	r0, #0
}
    5b8c:	370c      	adds	r7, #12
    5b8e:	46bd      	mov	sp, r7
    5b90:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (i = 0; i < num_handlers; i++) {
    5b92:	f10c 0c01 	add.w	ip, ip, #1
    5b96:	e7ea      	b.n	5b6e <handle_event_common+0xe>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    5b98:	466d      	mov	r5, sp
    5b9a:	b088      	sub	sp, #32
    5b9c:	4669      	mov	r1, sp
    5b9e:	f111 0210 	adds.w	r2, r1, #16
    5ba2:	d035      	beq.n	5c10 <handle_event_common+0xb0>
    5ba4:	2010      	movs	r0, #16
    5ba6:	b11a      	cbz	r2, 5bb0 <handle_event_common+0x50>
    5ba8:	2804      	cmp	r0, #4
    5baa:	dd01      	ble.n	5bb0 <handle_event_common+0x50>
    5bac:	4e1d      	ldr	r6, [pc, #116]	; (5c24 <handle_event_common+0xc4>)
    5bae:	614e      	str	r6, [r1, #20]
    5bb0:	b112      	cbz	r2, 5bb8 <handle_event_common+0x58>
    5bb2:	2808      	cmp	r0, #8
    5bb4:	dd00      	ble.n	5bb8 <handle_event_common+0x58>
    5bb6:	618b      	str	r3, [r1, #24]
    5bb8:	b112      	cbz	r2, 5bc0 <handle_event_common+0x60>
    5bba:	280c      	cmp	r0, #12
    5bbc:	dd00      	ble.n	5bc0 <handle_event_common+0x60>
    5bbe:	61cc      	str	r4, [r1, #28]
    5bc0:	280f      	cmp	r0, #15
    5bc2:	dd28      	ble.n	5c16 <handle_event_common+0xb6>
    5bc4:	2310      	movs	r3, #16
    5bc6:	b13a      	cbz	r2, 5bd8 <handle_event_common+0x78>
    5bc8:	2004      	movs	r0, #4
    5bca:	7138      	strb	r0, [r7, #4]
    5bcc:	2000      	movs	r0, #0
    5bce:	7178      	strb	r0, [r7, #5]
    5bd0:	71b8      	strb	r0, [r7, #6]
    5bd2:	71f8      	strb	r0, [r7, #7]
    5bd4:	6878      	ldr	r0, [r7, #4]
    5bd6:	6108      	str	r0, [r1, #16]
    5bd8:	2100      	movs	r1, #0
    5bda:	f36f 0100 	bfc	r1, #0, #1
    5bde:	f36f 0141 	bfc	r1, #1, #1
    5be2:	f36f 0182 	bfc	r1, #2, #1
    5be6:	f36f 01c5 	bfc	r1, #3, #3
    5bea:	2001      	movs	r0, #1
    5bec:	f360 1188 	bfi	r1, r0, #6, #3
    5bf0:	f403 737d 	and.w	r3, r3, #1012	; 0x3f4
    5bf4:	f363 2152 	bfi	r1, r3, #9, #10
    5bf8:	f36f 41de 	bfc	r1, #19, #12
    5bfc:	f36f 71df 	bfc	r1, #31, #1
    5c00:	2300      	movs	r3, #0
    5c02:	4809      	ldr	r0, [pc, #36]	; (5c28 <handle_event_common+0xc8>)
    5c04:	f7fc fb20 	bl	2248 <z_impl_z_log_msg_static_create>
    5c08:	46ad      	mov	sp, r5
			return -EINVAL;
    5c0a:	f06f 0015 	mvn.w	r0, #21
    5c0e:	e7bd      	b.n	5b8c <handle_event_common+0x2c>
			BT_ERR("Too small (%u bytes) event 0x%02x",
    5c10:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    5c14:	e7c7      	b.n	5ba6 <handle_event_common+0x46>
    5c16:	f06f 031b 	mvn.w	r3, #27
    5c1a:	e7d4      	b.n	5bc6 <handle_event_common+0x66>
	return -EOPNOTSUPP;
    5c1c:	f06f 005e 	mvn.w	r0, #94	; 0x5e
    5c20:	e7b4      	b.n	5b8c <handle_event_common+0x2c>
    5c22:	bf00      	nop
    5c24:	0001e020 	.word	0x0001e020
    5c28:	0001cffc 	.word	0x0001cffc

00005c2c <bt_dev_show_info>:
{
    5c2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5c30:	b082      	sub	sp, #8
    5c32:	af00      	add	r7, sp, #0
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    5c34:	4b69      	ldr	r3, [pc, #420]	; (5ddc <bt_dev_show_info+0x1b0>)
    5c36:	79db      	ldrb	r3, [r3, #7]
    5c38:	2b01      	cmp	r3, #1
    5c3a:	d92a      	bls.n	5c92 <bt_dev_show_info+0x66>
    5c3c:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 5de0 <bt_dev_show_info+0x1b4>
    5c40:	4866      	ldr	r0, [pc, #408]	; (5ddc <bt_dev_show_info+0x1b0>)
    5c42:	f7ff fd31 	bl	56a8 <bt_addr_le_str_real>
    5c46:	2302      	movs	r3, #2
    5c48:	713b      	strb	r3, [r7, #4]
    5c4a:	2303      	movs	r3, #3
    5c4c:	717b      	strb	r3, [r7, #5]
    5c4e:	466d      	mov	r5, sp
    5c50:	b08a      	sub	sp, #40	; 0x28
    5c52:	466e      	mov	r6, sp
    5c54:	f116 0210 	adds.w	r2, r6, #16
    5c58:	d01e      	beq.n	5c98 <bt_dev_show_info+0x6c>
    5c5a:	f04f 0c12 	mov.w	ip, #18
    5c5e:	b122      	cbz	r2, 5c6a <bt_dev_show_info+0x3e>
    5c60:	f1bc 0f04 	cmp.w	ip, #4
    5c64:	dd01      	ble.n	5c6a <bt_dev_show_info+0x3e>
    5c66:	4b5f      	ldr	r3, [pc, #380]	; (5de4 <bt_dev_show_info+0x1b8>)
    5c68:	6173      	str	r3, [r6, #20]
    5c6a:	2302      	movs	r3, #2
    5c6c:	703b      	strb	r3, [r7, #0]
    5c6e:	b122      	cbz	r2, 5c7a <bt_dev_show_info+0x4e>
    5c70:	f1bc 0f08 	cmp.w	ip, #8
    5c74:	dd01      	ble.n	5c7a <bt_dev_show_info+0x4e>
    5c76:	f8c6 8018 	str.w	r8, [r6, #24]
    5c7a:	2303      	movs	r3, #3
    5c7c:	707b      	strb	r3, [r7, #1]
    5c7e:	b11a      	cbz	r2, 5c88 <bt_dev_show_info+0x5c>
    5c80:	f1bc 0f0c 	cmp.w	ip, #12
    5c84:	dd00      	ble.n	5c88 <bt_dev_show_info+0x5c>
    5c86:	61f0      	str	r0, [r6, #28]
    5c88:	b19a      	cbz	r2, 5cb2 <bt_dev_show_info+0x86>
    5c8a:	f106 0320 	add.w	r3, r6, #32
    5c8e:	2100      	movs	r1, #0
    5c90:	e00d      	b.n	5cae <bt_dev_show_info+0x82>
    5c92:	f8df 8154 	ldr.w	r8, [pc, #340]	; 5de8 <bt_dev_show_info+0x1bc>
    5c96:	e7d3      	b.n	5c40 <bt_dev_show_info+0x14>
    5c98:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    5c9c:	e7df      	b.n	5c5e <bt_dev_show_info+0x32>
    5c9e:	f107 0008 	add.w	r0, r7, #8
    5ca2:	4408      	add	r0, r1
    5ca4:	f810 0c08 	ldrb.w	r0, [r0, #-8]
    5ca8:	f803 0b01 	strb.w	r0, [r3], #1
    5cac:	3101      	adds	r1, #1
    5cae:	2901      	cmp	r1, #1
    5cb0:	d9f5      	bls.n	5c9e <bt_dev_show_info+0x72>
    5cb2:	f1bc 0f11 	cmp.w	ip, #17
    5cb6:	dd25      	ble.n	5d04 <bt_dev_show_info+0xd8>
    5cb8:	2312      	movs	r3, #18
    5cba:	b142      	cbz	r2, 5cce <bt_dev_show_info+0xa2>
    5cbc:	2104      	movs	r1, #4
    5cbe:	7139      	strb	r1, [r7, #4]
    5cc0:	2100      	movs	r1, #0
    5cc2:	7179      	strb	r1, [r7, #5]
    5cc4:	71b9      	strb	r1, [r7, #6]
    5cc6:	2102      	movs	r1, #2
    5cc8:	71f9      	strb	r1, [r7, #7]
    5cca:	6878      	ldr	r0, [r7, #4]
    5ccc:	6130      	str	r0, [r6, #16]
    5cce:	2100      	movs	r1, #0
    5cd0:	f36f 0100 	bfc	r1, #0, #1
    5cd4:	f36f 0141 	bfc	r1, #1, #1
    5cd8:	f36f 0182 	bfc	r1, #2, #1
    5cdc:	f36f 01c5 	bfc	r1, #3, #3
    5ce0:	2003      	movs	r0, #3
    5ce2:	f360 1188 	bfi	r1, r0, #6, #3
    5ce6:	f3c3 0309 	ubfx	r3, r3, #0, #10
    5cea:	f363 2152 	bfi	r1, r3, #9, #10
    5cee:	f36f 41de 	bfc	r1, #19, #12
    5cf2:	f36f 71df 	bfc	r1, #31, #1
    5cf6:	2300      	movs	r3, #0
    5cf8:	483c      	ldr	r0, [pc, #240]	; (5dec <bt_dev_show_info+0x1c0>)
    5cfa:	f7fc faa5 	bl	2248 <z_impl_z_log_msg_static_create>
    5cfe:	46ad      	mov	sp, r5
	for (i = 1; i < bt_dev.id_count; i++) {
    5d00:	2501      	movs	r5, #1
    5d02:	e03a      	b.n	5d7a <bt_dev_show_info+0x14e>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
    5d04:	f06f 031b 	mvn.w	r3, #27
    5d08:	e7d7      	b.n	5cba <bt_dev_show_info+0x8e>
		BT_INFO("Identity[%d]: %s",
    5d0a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    5d0e:	e047      	b.n	5da0 <bt_dev_show_info+0x174>
    5d10:	b112      	cbz	r2, 5d18 <bt_dev_show_info+0xec>
    5d12:	2908      	cmp	r1, #8
    5d14:	dd00      	ble.n	5d18 <bt_dev_show_info+0xec>
    5d16:	619d      	str	r5, [r3, #24]
    5d18:	f04f 0c03 	mov.w	ip, #3
    5d1c:	f887 c000 	strb.w	ip, [r7]
    5d20:	b112      	cbz	r2, 5d28 <bt_dev_show_info+0xfc>
    5d22:	290c      	cmp	r1, #12
    5d24:	dd00      	ble.n	5d28 <bt_dev_show_info+0xfc>
    5d26:	61d8      	str	r0, [r3, #28]
    5d28:	2a00      	cmp	r2, #0
    5d2a:	d142      	bne.n	5db2 <bt_dev_show_info+0x186>
    5d2c:	2910      	cmp	r1, #16
    5d2e:	dd51      	ble.n	5dd4 <bt_dev_show_info+0x1a8>
    5d30:	2111      	movs	r1, #17
    5d32:	b142      	cbz	r2, 5d46 <bt_dev_show_info+0x11a>
    5d34:	2004      	movs	r0, #4
    5d36:	7138      	strb	r0, [r7, #4]
    5d38:	2000      	movs	r0, #0
    5d3a:	7178      	strb	r0, [r7, #5]
    5d3c:	71b8      	strb	r0, [r7, #6]
    5d3e:	2001      	movs	r0, #1
    5d40:	71f8      	strb	r0, [r7, #7]
    5d42:	6878      	ldr	r0, [r7, #4]
    5d44:	6118      	str	r0, [r3, #16]
    5d46:	f36f 0400 	bfc	r4, #0, #1
    5d4a:	f36f 0441 	bfc	r4, #1, #1
    5d4e:	f36f 0482 	bfc	r4, #2, #1
    5d52:	f36f 04c5 	bfc	r4, #3, #3
    5d56:	2303      	movs	r3, #3
    5d58:	f363 1488 	bfi	r4, r3, #6, #3
    5d5c:	f3c1 0109 	ubfx	r1, r1, #0, #10
    5d60:	f361 2452 	bfi	r4, r1, #9, #10
    5d64:	f36f 44de 	bfc	r4, #19, #12
    5d68:	f36f 74df 	bfc	r4, #31, #1
    5d6c:	2300      	movs	r3, #0
    5d6e:	4621      	mov	r1, r4
    5d70:	481e      	ldr	r0, [pc, #120]	; (5dec <bt_dev_show_info+0x1c0>)
    5d72:	f7fc fa69 	bl	2248 <z_impl_z_log_msg_static_create>
    5d76:	46b5      	mov	sp, r6
	for (i = 1; i < bt_dev.id_count; i++) {
    5d78:	3501      	adds	r5, #1
    5d7a:	4b18      	ldr	r3, [pc, #96]	; (5ddc <bt_dev_show_info+0x1b0>)
    5d7c:	79db      	ldrb	r3, [r3, #7]
    5d7e:	42ab      	cmp	r3, r5
    5d80:	dd38      	ble.n	5df4 <bt_dev_show_info+0x1c8>
		BT_INFO("Identity[%d]: %s",
    5d82:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
    5d86:	4815      	ldr	r0, [pc, #84]	; (5ddc <bt_dev_show_info+0x1b0>)
    5d88:	4418      	add	r0, r3
    5d8a:	f7ff fc8d 	bl	56a8 <bt_addr_le_str_real>
    5d8e:	2303      	movs	r3, #3
    5d90:	713b      	strb	r3, [r7, #4]
    5d92:	466e      	mov	r6, sp
    5d94:	b08a      	sub	sp, #40	; 0x28
    5d96:	466b      	mov	r3, sp
    5d98:	f113 0210 	adds.w	r2, r3, #16
    5d9c:	d0b5      	beq.n	5d0a <bt_dev_show_info+0xde>
    5d9e:	2111      	movs	r1, #17
    5da0:	2a00      	cmp	r2, #0
    5da2:	d0b5      	beq.n	5d10 <bt_dev_show_info+0xe4>
    5da4:	2904      	cmp	r1, #4
    5da6:	ddb3      	ble.n	5d10 <bt_dev_show_info+0xe4>
    5da8:	f8df c044 	ldr.w	ip, [pc, #68]	; 5df0 <bt_dev_show_info+0x1c4>
    5dac:	f8c3 c014 	str.w	ip, [r3, #20]
    5db0:	e7ae      	b.n	5d10 <bt_dev_show_info+0xe4>
    5db2:	f103 0020 	add.w	r0, r3, #32
    5db6:	f04f 0c00 	mov.w	ip, #0
    5dba:	f1bc 0f00 	cmp.w	ip, #0
    5dbe:	d1b5      	bne.n	5d2c <bt_dev_show_info+0x100>
    5dc0:	f107 0e08 	add.w	lr, r7, #8
    5dc4:	44e6      	add	lr, ip
    5dc6:	f81e ec08 	ldrb.w	lr, [lr, #-8]
    5dca:	f800 eb01 	strb.w	lr, [r0], #1
    5dce:	f10c 0c01 	add.w	ip, ip, #1
    5dd2:	e7f2      	b.n	5dba <bt_dev_show_info+0x18e>
    5dd4:	f06f 011b 	mvn.w	r1, #27
    5dd8:	e7ab      	b.n	5d32 <bt_dev_show_info+0x106>
    5dda:	bf00      	nop
    5ddc:	20000000 	.word	0x20000000
    5de0:	0001e044 	.word	0x0001e044
    5de4:	0001e048 	.word	0x0001e048
    5de8:	0001d410 	.word	0x0001d410
    5dec:	0001cffc 	.word	0x0001cffc
    5df0:	0001e058 	.word	0x0001e058
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    5df4:	4c64      	ldr	r4, [pc, #400]	; (5f88 <bt_dev_show_info+0x35c>)
    5df6:	f894 5068 	ldrb.w	r5, [r4, #104]	; 0x68
    5dfa:	4628      	mov	r0, r5
    5dfc:	f7ff fdc6 	bl	598c <ver_str>
    5e00:	f8b4 e06a 	ldrh.w	lr, [r4, #106]	; 0x6a
    5e04:	f8b4 c06e 	ldrh.w	ip, [r4, #110]	; 0x6e
    5e08:	2302      	movs	r3, #2
    5e0a:	713b      	strb	r3, [r7, #4]
    5e0c:	466c      	mov	r4, sp
    5e0e:	b08c      	sub	sp, #48	; 0x30
    5e10:	466b      	mov	r3, sp
    5e12:	f113 0210 	adds.w	r2, r3, #16
    5e16:	f000 8098 	beq.w	5f4a <bt_dev_show_info+0x31e>
    5e1a:	2119      	movs	r1, #25
    5e1c:	b11a      	cbz	r2, 5e26 <bt_dev_show_info+0x1fa>
    5e1e:	2904      	cmp	r1, #4
    5e20:	dd01      	ble.n	5e26 <bt_dev_show_info+0x1fa>
    5e22:	4e5a      	ldr	r6, [pc, #360]	; (5f8c <bt_dev_show_info+0x360>)
    5e24:	615e      	str	r6, [r3, #20]
    5e26:	2602      	movs	r6, #2
    5e28:	703e      	strb	r6, [r7, #0]
    5e2a:	b112      	cbz	r2, 5e32 <bt_dev_show_info+0x206>
    5e2c:	2908      	cmp	r1, #8
    5e2e:	dd00      	ble.n	5e32 <bt_dev_show_info+0x206>
    5e30:	6198      	str	r0, [r3, #24]
    5e32:	b112      	cbz	r2, 5e3a <bt_dev_show_info+0x20e>
    5e34:	290c      	cmp	r1, #12
    5e36:	dd00      	ble.n	5e3a <bt_dev_show_info+0x20e>
    5e38:	61dd      	str	r5, [r3, #28]
    5e3a:	b11a      	cbz	r2, 5e44 <bt_dev_show_info+0x218>
    5e3c:	2910      	cmp	r1, #16
    5e3e:	dd01      	ble.n	5e44 <bt_dev_show_info+0x218>
    5e40:	f8c3 e020 	str.w	lr, [r3, #32]
    5e44:	b11a      	cbz	r2, 5e4e <bt_dev_show_info+0x222>
    5e46:	2914      	cmp	r1, #20
    5e48:	dd01      	ble.n	5e4e <bt_dev_show_info+0x222>
    5e4a:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
    5e4e:	b122      	cbz	r2, 5e5a <bt_dev_show_info+0x22e>
    5e50:	f103 0028 	add.w	r0, r3, #40	; 0x28
    5e54:	2500      	movs	r5, #0
    5e56:	2d00      	cmp	r5, #0
    5e58:	d07a      	beq.n	5f50 <bt_dev_show_info+0x324>
    5e5a:	2918      	cmp	r1, #24
    5e5c:	f340 8081 	ble.w	5f62 <bt_dev_show_info+0x336>
    5e60:	2519      	movs	r5, #25
    5e62:	b142      	cbz	r2, 5e76 <bt_dev_show_info+0x24a>
    5e64:	2106      	movs	r1, #6
    5e66:	7139      	strb	r1, [r7, #4]
    5e68:	2100      	movs	r1, #0
    5e6a:	7179      	strb	r1, [r7, #5]
    5e6c:	71b9      	strb	r1, [r7, #6]
    5e6e:	2101      	movs	r1, #1
    5e70:	71f9      	strb	r1, [r7, #7]
    5e72:	6878      	ldr	r0, [r7, #4]
    5e74:	6118      	str	r0, [r3, #16]
    5e76:	2100      	movs	r1, #0
    5e78:	f36f 0100 	bfc	r1, #0, #1
    5e7c:	f36f 0141 	bfc	r1, #1, #1
    5e80:	f36f 0182 	bfc	r1, #2, #1
    5e84:	f36f 01c5 	bfc	r1, #3, #3
    5e88:	2303      	movs	r3, #3
    5e8a:	f363 1188 	bfi	r1, r3, #6, #3
    5e8e:	f3c5 0509 	ubfx	r5, r5, #0, #10
    5e92:	f365 2152 	bfi	r1, r5, #9, #10
    5e96:	f36f 41de 	bfc	r1, #19, #12
    5e9a:	f36f 71df 	bfc	r1, #31, #1
    5e9e:	2300      	movs	r3, #0
    5ea0:	483b      	ldr	r0, [pc, #236]	; (5f90 <bt_dev_show_info+0x364>)
    5ea2:	f7fc f9d1 	bl	2248 <z_impl_z_log_msg_static_create>
    5ea6:	46a5      	mov	sp, r4
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    5ea8:	4c37      	ldr	r4, [pc, #220]	; (5f88 <bt_dev_show_info+0x35c>)
    5eaa:	f894 5069 	ldrb.w	r5, [r4, #105]	; 0x69
    5eae:	4628      	mov	r0, r5
    5eb0:	f7ff fd6c 	bl	598c <ver_str>
    5eb4:	f8b4 606c 	ldrh.w	r6, [r4, #108]	; 0x6c
    5eb8:	2302      	movs	r3, #2
    5eba:	713b      	strb	r3, [r7, #4]
    5ebc:	b08a      	sub	sp, #40	; 0x28
    5ebe:	466b      	mov	r3, sp
    5ec0:	f113 0210 	adds.w	r2, r3, #16
    5ec4:	d050      	beq.n	5f68 <bt_dev_show_info+0x33c>
    5ec6:	2415      	movs	r4, #21
    5ec8:	b11a      	cbz	r2, 5ed2 <bt_dev_show_info+0x2a6>
    5eca:	2c04      	cmp	r4, #4
    5ecc:	dd01      	ble.n	5ed2 <bt_dev_show_info+0x2a6>
    5ece:	4931      	ldr	r1, [pc, #196]	; (5f94 <bt_dev_show_info+0x368>)
    5ed0:	6159      	str	r1, [r3, #20]
    5ed2:	2102      	movs	r1, #2
    5ed4:	7039      	strb	r1, [r7, #0]
    5ed6:	b112      	cbz	r2, 5ede <bt_dev_show_info+0x2b2>
    5ed8:	2c08      	cmp	r4, #8
    5eda:	dd00      	ble.n	5ede <bt_dev_show_info+0x2b2>
    5edc:	6198      	str	r0, [r3, #24]
    5ede:	b112      	cbz	r2, 5ee6 <bt_dev_show_info+0x2ba>
    5ee0:	2c0c      	cmp	r4, #12
    5ee2:	dd00      	ble.n	5ee6 <bt_dev_show_info+0x2ba>
    5ee4:	61dd      	str	r5, [r3, #28]
    5ee6:	b112      	cbz	r2, 5eee <bt_dev_show_info+0x2c2>
    5ee8:	2c10      	cmp	r4, #16
    5eea:	dd00      	ble.n	5eee <bt_dev_show_info+0x2c2>
    5eec:	621e      	str	r6, [r3, #32]
    5eee:	b11a      	cbz	r2, 5ef8 <bt_dev_show_info+0x2cc>
    5ef0:	f103 0124 	add.w	r1, r3, #36	; 0x24
    5ef4:	2000      	movs	r0, #0
    5ef6:	b3d0      	cbz	r0, 5f6e <bt_dev_show_info+0x342>
    5ef8:	2c14      	cmp	r4, #20
    5efa:	dd41      	ble.n	5f80 <bt_dev_show_info+0x354>
    5efc:	2415      	movs	r4, #21
    5efe:	b142      	cbz	r2, 5f12 <bt_dev_show_info+0x2e6>
    5f00:	2105      	movs	r1, #5
    5f02:	7139      	strb	r1, [r7, #4]
    5f04:	2100      	movs	r1, #0
    5f06:	7179      	strb	r1, [r7, #5]
    5f08:	71b9      	strb	r1, [r7, #6]
    5f0a:	2101      	movs	r1, #1
    5f0c:	71f9      	strb	r1, [r7, #7]
    5f0e:	6878      	ldr	r0, [r7, #4]
    5f10:	6118      	str	r0, [r3, #16]
    5f12:	2100      	movs	r1, #0
    5f14:	f36f 0100 	bfc	r1, #0, #1
    5f18:	f36f 0141 	bfc	r1, #1, #1
    5f1c:	f36f 0182 	bfc	r1, #2, #1
    5f20:	f36f 01c5 	bfc	r1, #3, #3
    5f24:	2303      	movs	r3, #3
    5f26:	f363 1188 	bfi	r1, r3, #6, #3
    5f2a:	f3c4 0409 	ubfx	r4, r4, #0, #10
    5f2e:	f364 2152 	bfi	r1, r4, #9, #10
    5f32:	f36f 41de 	bfc	r1, #19, #12
    5f36:	f36f 71df 	bfc	r1, #31, #1
    5f3a:	2300      	movs	r3, #0
    5f3c:	4814      	ldr	r0, [pc, #80]	; (5f90 <bt_dev_show_info+0x364>)
    5f3e:	f7fc f983 	bl	2248 <z_impl_z_log_msg_static_create>
}
    5f42:	3708      	adds	r7, #8
    5f44:	46bd      	mov	sp, r7
    5f46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
    5f4a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    5f4e:	e765      	b.n	5e1c <bt_dev_show_info+0x1f0>
    5f50:	f107 0608 	add.w	r6, r7, #8
    5f54:	442e      	add	r6, r5
    5f56:	f816 6c08 	ldrb.w	r6, [r6, #-8]
    5f5a:	f800 6b01 	strb.w	r6, [r0], #1
    5f5e:	3501      	adds	r5, #1
    5f60:	e779      	b.n	5e56 <bt_dev_show_info+0x22a>
    5f62:	f06f 051b 	mvn.w	r5, #27
    5f66:	e77c      	b.n	5e62 <bt_dev_show_info+0x236>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
    5f68:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
    5f6c:	e7ac      	b.n	5ec8 <bt_dev_show_info+0x29c>
    5f6e:	f107 0508 	add.w	r5, r7, #8
    5f72:	4405      	add	r5, r0
    5f74:	f815 5c08 	ldrb.w	r5, [r5, #-8]
    5f78:	f801 5b01 	strb.w	r5, [r1], #1
    5f7c:	3001      	adds	r0, #1
    5f7e:	e7ba      	b.n	5ef6 <bt_dev_show_info+0x2ca>
    5f80:	f06f 041b 	mvn.w	r4, #27
    5f84:	e7bb      	b.n	5efe <bt_dev_show_info+0x2d2>
    5f86:	bf00      	nop
    5f88:	20000000 	.word	0x20000000
    5f8c:	0001e06c 	.word	0x0001e06c
    5f90:	0001cffc 	.word	0x0001cffc
    5f94:	0001e0ac 	.word	0x0001e0ac

00005f98 <find_pending_connect>:
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && role == BT_HCI_ROLE_PERIPHERAL) {
    5f98:	2801      	cmp	r0, #1
    5f9a:	d001      	beq.n	5fa0 <find_pending_connect+0x8>
	return NULL;
    5f9c:	2000      	movs	r0, #0
}
    5f9e:	4770      	bx	lr
{
    5fa0:	b500      	push	{lr}
    5fa2:	b083      	sub	sp, #12
		conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id, peer_addr,
    5fa4:	2205      	movs	r2, #5
    5fa6:	4b0d      	ldr	r3, [pc, #52]	; (5fdc <find_pending_connect+0x44>)
    5fa8:	f893 0067 	ldrb.w	r0, [r3, #103]	; 0x67
    5fac:	f004 fb24 	bl	a5f8 <bt_conn_lookup_state_le>
		if (!conn) {
    5fb0:	b110      	cbz	r0, 5fb8 <find_pending_connect+0x20>
}
    5fb2:	b003      	add	sp, #12
    5fb4:	f85d fb04 	ldr.w	pc, [sp], #4
						       BT_ADDR_LE_NONE,
    5fb8:	4b09      	ldr	r3, [pc, #36]	; (5fe0 <find_pending_connect+0x48>)
    5fba:	e893 0003 	ldmia.w	r3, {r0, r1}
    5fbe:	9000      	str	r0, [sp, #0]
    5fc0:	f8ad 1004 	strh.w	r1, [sp, #4]
    5fc4:	0c09      	lsrs	r1, r1, #16
    5fc6:	f88d 1006 	strb.w	r1, [sp, #6]
			conn = bt_conn_lookup_state_le(bt_dev.adv_conn_id,
    5fca:	2204      	movs	r2, #4
    5fcc:	4669      	mov	r1, sp
    5fce:	4b03      	ldr	r3, [pc, #12]	; (5fdc <find_pending_connect+0x44>)
    5fd0:	f893 0067 	ldrb.w	r0, [r3, #103]	; 0x67
    5fd4:	f004 fb10 	bl	a5f8 <bt_conn_lookup_state_le>
		return conn;
    5fd8:	e7eb      	b.n	5fb2 <find_pending_connect+0x1a>
    5fda:	bf00      	nop
    5fdc:	20000000 	.word	0x20000000
    5fe0:	0001d1b8 	.word	0x0001d1b8

00005fe4 <le_conn_complete_adv_timeout>:
{
    5fe4:	b510      	push	{r4, lr}
    5fe6:	b088      	sub	sp, #32
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    5fe8:	f003 f8f2 	bl	91d0 <bt_le_adv_lookup_legacy>
		atomic_clear_bit(adv->flags, BT_ADV_ENABLED);
    5fec:	3010      	adds	r0, #16
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    5fee:	e8d0 3fef 	ldaex	r3, [r0]
    5ff2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    5ff6:	e8c0 3fe2 	stlex	r2, r3, [r0]
    5ffa:	2a00      	cmp	r2, #0
    5ffc:	d1f7      	bne.n	5fee <le_conn_complete_adv_timeout+0xa>
		conn = find_pending_connect(BT_HCI_ROLE_PERIPHERAL, NULL);
    5ffe:	2100      	movs	r1, #0
    6000:	2001      	movs	r0, #1
    6002:	f7ff ffc9 	bl	5f98 <find_pending_connect>
		if (!conn) {
    6006:	4604      	mov	r4, r0
    6008:	b148      	cbz	r0, 601e <le_conn_complete_adv_timeout+0x3a>
		conn->err = BT_HCI_ERR_ADV_TIMEOUT;
    600a:	233c      	movs	r3, #60	; 0x3c
    600c:	7243      	strb	r3, [r0, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    600e:	2100      	movs	r1, #0
    6010:	f003 ffce 	bl	9fb0 <bt_conn_set_state>
		bt_conn_unref(conn);
    6014:	4620      	mov	r0, r4
    6016:	f012 f861 	bl	180dc <bt_conn_unref>
}
    601a:	b008      	add	sp, #32
    601c:	bd10      	pop	{r4, pc}
			BT_ERR("No pending peripheral connection");
    601e:	4b13      	ldr	r3, [pc, #76]	; (606c <le_conn_complete_adv_timeout+0x88>)
    6020:	9307      	str	r3, [sp, #28]
    6022:	2302      	movs	r3, #2
    6024:	f88d 3004 	strb.w	r3, [sp, #4]
    6028:	2300      	movs	r3, #0
    602a:	f88d 3005 	strb.w	r3, [sp, #5]
    602e:	f88d 3006 	strb.w	r3, [sp, #6]
    6032:	f88d 3007 	strb.w	r3, [sp, #7]
    6036:	9a01      	ldr	r2, [sp, #4]
    6038:	9206      	str	r2, [sp, #24]
    603a:	4619      	mov	r1, r3
    603c:	f363 0100 	bfi	r1, r3, #0, #1
    6040:	f363 0141 	bfi	r1, r3, #1, #1
    6044:	f363 0182 	bfi	r1, r3, #2, #1
    6048:	f363 01c5 	bfi	r1, r3, #3, #3
    604c:	2201      	movs	r2, #1
    604e:	f362 1188 	bfi	r1, r2, #6, #3
    6052:	2208      	movs	r2, #8
    6054:	f362 2152 	bfi	r1, r2, #9, #10
    6058:	f363 41de 	bfi	r1, r3, #19, #12
    605c:	f363 71df 	bfi	r1, r3, #31, #1
    6060:	aa06      	add	r2, sp, #24
    6062:	4803      	ldr	r0, [pc, #12]	; (6070 <le_conn_complete_adv_timeout+0x8c>)
    6064:	f7fc f8f0 	bl	2248 <z_impl_z_log_msg_static_create>
			return;
    6068:	e7d7      	b.n	601a <le_conn_complete_adv_timeout+0x36>
    606a:	bf00      	nop
    606c:	0001e0d4 	.word	0x0001e0d4
    6070:	0001cffc 	.word	0x0001cffc

00006074 <hci_disconn_complete>:
{
    6074:	b5f0      	push	{r4, r5, r6, r7, lr}
    6076:	b083      	sub	sp, #12
    6078:	af00      	add	r7, sp, #0
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
    607a:	6884      	ldr	r4, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    607c:	f8b4 6001 	ldrh.w	r6, [r4, #1]
	if (evt->status) {
    6080:	7823      	ldrb	r3, [r4, #0]
    6082:	b113      	cbz	r3, 608a <hci_disconn_complete+0x16>
}
    6084:	370c      	adds	r7, #12
    6086:	46bd      	mov	sp, r7
    6088:	bdf0      	pop	{r4, r5, r6, r7, pc}
	conn = bt_conn_lookup_handle(handle);
    608a:	4630      	mov	r0, r6
    608c:	f003 ff86 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    6090:	4605      	mov	r5, r0
    6092:	b158      	cbz	r0, 60ac <hci_disconn_complete+0x38>
	conn->err = evt->reason;
    6094:	78e3      	ldrb	r3, [r4, #3]
    6096:	7243      	strb	r3, [r0, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    6098:	2100      	movs	r1, #0
    609a:	f003 ff89 	bl	9fb0 <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
    609e:	78ab      	ldrb	r3, [r5, #2]
    60a0:	2b01      	cmp	r3, #1
    60a2:	d03f      	beq.n	6124 <hci_disconn_complete+0xb0>
		bt_conn_unref(conn);
    60a4:	4628      	mov	r0, r5
    60a6:	f012 f819 	bl	180dc <bt_conn_unref>
		return;
    60aa:	e7eb      	b.n	6084 <hci_disconn_complete+0x10>
		BT_ERR("Unable to look up conn with handle %u", handle);
    60ac:	466d      	mov	r5, sp
    60ae:	b088      	sub	sp, #32
    60b0:	466b      	mov	r3, sp
    60b2:	f113 0210 	adds.w	r2, r3, #16
    60b6:	d02f      	beq.n	6118 <hci_disconn_complete+0xa4>
    60b8:	210c      	movs	r1, #12
    60ba:	b11a      	cbz	r2, 60c4 <hci_disconn_complete+0x50>
    60bc:	2904      	cmp	r1, #4
    60be:	dd01      	ble.n	60c4 <hci_disconn_complete+0x50>
    60c0:	481a      	ldr	r0, [pc, #104]	; (612c <hci_disconn_complete+0xb8>)
    60c2:	6158      	str	r0, [r3, #20]
    60c4:	b112      	cbz	r2, 60cc <hci_disconn_complete+0x58>
    60c6:	2908      	cmp	r1, #8
    60c8:	dd00      	ble.n	60cc <hci_disconn_complete+0x58>
    60ca:	619e      	str	r6, [r3, #24]
    60cc:	290b      	cmp	r1, #11
    60ce:	dd26      	ble.n	611e <hci_disconn_complete+0xaa>
    60d0:	240c      	movs	r4, #12
    60d2:	b13a      	cbz	r2, 60e4 <hci_disconn_complete+0x70>
    60d4:	2103      	movs	r1, #3
    60d6:	7139      	strb	r1, [r7, #4]
    60d8:	2100      	movs	r1, #0
    60da:	7179      	strb	r1, [r7, #5]
    60dc:	71b9      	strb	r1, [r7, #6]
    60de:	71f9      	strb	r1, [r7, #7]
    60e0:	6878      	ldr	r0, [r7, #4]
    60e2:	6118      	str	r0, [r3, #16]
    60e4:	2100      	movs	r1, #0
    60e6:	f36f 0100 	bfc	r1, #0, #1
    60ea:	f36f 0141 	bfc	r1, #1, #1
    60ee:	f36f 0182 	bfc	r1, #2, #1
    60f2:	f36f 01c5 	bfc	r1, #3, #3
    60f6:	2301      	movs	r3, #1
    60f8:	f363 1188 	bfi	r1, r3, #6, #3
    60fc:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    6100:	f363 2152 	bfi	r1, r3, #9, #10
    6104:	f36f 41de 	bfc	r1, #19, #12
    6108:	f36f 71df 	bfc	r1, #31, #1
    610c:	2300      	movs	r3, #0
    610e:	4808      	ldr	r0, [pc, #32]	; (6130 <hci_disconn_complete+0xbc>)
    6110:	f7fc f89a 	bl	2248 <z_impl_z_log_msg_static_create>
    6114:	46ad      	mov	sp, r5
		return;
    6116:	e7b5      	b.n	6084 <hci_disconn_complete+0x10>
		BT_ERR("Unable to look up conn with handle %u", handle);
    6118:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    611c:	e7cd      	b.n	60ba <hci_disconn_complete+0x46>
    611e:	f06f 041b 	mvn.w	r4, #27
    6122:	e7d6      	b.n	60d2 <hci_disconn_complete+0x5e>
	bt_conn_unref(conn);
    6124:	4628      	mov	r0, r5
    6126:	f011 ffd9 	bl	180dc <bt_conn_unref>
    612a:	e7ab      	b.n	6084 <hci_disconn_complete+0x10>
    612c:	0001e0f8 	.word	0x0001e0f8
    6130:	0001cffc 	.word	0x0001cffc

00006134 <le_phy_update_complete>:
{
    6134:	b5b0      	push	{r4, r5, r7, lr}
    6136:	b082      	sub	sp, #8
    6138:	af00      	add	r7, sp, #0
	struct bt_hci_evt_le_phy_update_complete *evt = (void *)buf->data;
    613a:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    613c:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
    6140:	4620      	mov	r0, r4
    6142:	f003 ff2b 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    6146:	b120      	cbz	r0, 6152 <le_phy_update_complete+0x1e>
	bt_conn_unref(conn);
    6148:	f011 ffc8 	bl	180dc <bt_conn_unref>
}
    614c:	3708      	adds	r7, #8
    614e:	46bd      	mov	sp, r7
    6150:	bdb0      	pop	{r4, r5, r7, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    6152:	466d      	mov	r5, sp
    6154:	b088      	sub	sp, #32
    6156:	466b      	mov	r3, sp
    6158:	f113 0210 	adds.w	r2, r3, #16
    615c:	d02f      	beq.n	61be <le_phy_update_complete+0x8a>
    615e:	210c      	movs	r1, #12
    6160:	b11a      	cbz	r2, 616a <le_phy_update_complete+0x36>
    6162:	2904      	cmp	r1, #4
    6164:	dd01      	ble.n	616a <le_phy_update_complete+0x36>
    6166:	4819      	ldr	r0, [pc, #100]	; (61cc <le_phy_update_complete+0x98>)
    6168:	6158      	str	r0, [r3, #20]
    616a:	b112      	cbz	r2, 6172 <le_phy_update_complete+0x3e>
    616c:	2908      	cmp	r1, #8
    616e:	dd00      	ble.n	6172 <le_phy_update_complete+0x3e>
    6170:	619c      	str	r4, [r3, #24]
    6172:	290b      	cmp	r1, #11
    6174:	dd26      	ble.n	61c4 <le_phy_update_complete+0x90>
    6176:	240c      	movs	r4, #12
    6178:	b13a      	cbz	r2, 618a <le_phy_update_complete+0x56>
    617a:	2103      	movs	r1, #3
    617c:	7139      	strb	r1, [r7, #4]
    617e:	2100      	movs	r1, #0
    6180:	7179      	strb	r1, [r7, #5]
    6182:	71b9      	strb	r1, [r7, #6]
    6184:	71f9      	strb	r1, [r7, #7]
    6186:	6878      	ldr	r0, [r7, #4]
    6188:	6118      	str	r0, [r3, #16]
    618a:	2100      	movs	r1, #0
    618c:	f36f 0100 	bfc	r1, #0, #1
    6190:	f36f 0141 	bfc	r1, #1, #1
    6194:	f36f 0182 	bfc	r1, #2, #1
    6198:	f36f 01c5 	bfc	r1, #3, #3
    619c:	2301      	movs	r3, #1
    619e:	f363 1188 	bfi	r1, r3, #6, #3
    61a2:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    61a6:	f363 2152 	bfi	r1, r3, #9, #10
    61aa:	f36f 41de 	bfc	r1, #19, #12
    61ae:	f36f 71df 	bfc	r1, #31, #1
    61b2:	2300      	movs	r3, #0
    61b4:	4806      	ldr	r0, [pc, #24]	; (61d0 <le_phy_update_complete+0x9c>)
    61b6:	f7fc f847 	bl	2248 <z_impl_z_log_msg_static_create>
    61ba:	46ad      	mov	sp, r5
		return;
    61bc:	e7c6      	b.n	614c <le_phy_update_complete+0x18>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    61be:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    61c2:	e7cd      	b.n	6160 <le_phy_update_complete+0x2c>
    61c4:	f06f 041b 	mvn.w	r4, #27
    61c8:	e7d6      	b.n	6178 <le_phy_update_complete+0x44>
    61ca:	bf00      	nop
    61cc:	0001e120 	.word	0x0001e120
    61d0:	0001cffc 	.word	0x0001cffc

000061d4 <le_data_len_change>:
{
    61d4:	b5b0      	push	{r4, r5, r7, lr}
    61d6:	b082      	sub	sp, #8
    61d8:	af00      	add	r7, sp, #0
	struct bt_hci_evt_le_data_len_change *evt = (void *)buf->data;
    61da:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    61dc:	881c      	ldrh	r4, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
    61de:	4620      	mov	r0, r4
    61e0:	f003 fedc 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    61e4:	b120      	cbz	r0, 61f0 <le_data_len_change+0x1c>
	bt_conn_unref(conn);
    61e6:	f011 ff79 	bl	180dc <bt_conn_unref>
}
    61ea:	3708      	adds	r7, #8
    61ec:	46bd      	mov	sp, r7
    61ee:	bdb0      	pop	{r4, r5, r7, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    61f0:	466d      	mov	r5, sp
    61f2:	b088      	sub	sp, #32
    61f4:	466b      	mov	r3, sp
    61f6:	f113 0210 	adds.w	r2, r3, #16
    61fa:	d02f      	beq.n	625c <le_data_len_change+0x88>
    61fc:	210c      	movs	r1, #12
    61fe:	b11a      	cbz	r2, 6208 <le_data_len_change+0x34>
    6200:	2904      	cmp	r1, #4
    6202:	dd01      	ble.n	6208 <le_data_len_change+0x34>
    6204:	4818      	ldr	r0, [pc, #96]	; (6268 <le_data_len_change+0x94>)
    6206:	6158      	str	r0, [r3, #20]
    6208:	b112      	cbz	r2, 6210 <le_data_len_change+0x3c>
    620a:	2908      	cmp	r1, #8
    620c:	dd00      	ble.n	6210 <le_data_len_change+0x3c>
    620e:	619c      	str	r4, [r3, #24]
    6210:	290b      	cmp	r1, #11
    6212:	dd26      	ble.n	6262 <le_data_len_change+0x8e>
    6214:	240c      	movs	r4, #12
    6216:	b13a      	cbz	r2, 6228 <le_data_len_change+0x54>
    6218:	2103      	movs	r1, #3
    621a:	7139      	strb	r1, [r7, #4]
    621c:	2100      	movs	r1, #0
    621e:	7179      	strb	r1, [r7, #5]
    6220:	71b9      	strb	r1, [r7, #6]
    6222:	71f9      	strb	r1, [r7, #7]
    6224:	6878      	ldr	r0, [r7, #4]
    6226:	6118      	str	r0, [r3, #16]
    6228:	2100      	movs	r1, #0
    622a:	f36f 0100 	bfc	r1, #0, #1
    622e:	f36f 0141 	bfc	r1, #1, #1
    6232:	f36f 0182 	bfc	r1, #2, #1
    6236:	f36f 01c5 	bfc	r1, #3, #3
    623a:	2301      	movs	r3, #1
    623c:	f363 1188 	bfi	r1, r3, #6, #3
    6240:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    6244:	f363 2152 	bfi	r1, r3, #9, #10
    6248:	f36f 41de 	bfc	r1, #19, #12
    624c:	f36f 71df 	bfc	r1, #31, #1
    6250:	2300      	movs	r3, #0
    6252:	4806      	ldr	r0, [pc, #24]	; (626c <le_data_len_change+0x98>)
    6254:	f7fb fff8 	bl	2248 <z_impl_z_log_msg_static_create>
    6258:	46ad      	mov	sp, r5
		return;
    625a:	e7c6      	b.n	61ea <le_data_len_change+0x16>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    625c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6260:	e7cd      	b.n	61fe <le_data_len_change+0x2a>
    6262:	f06f 041b 	mvn.w	r4, #27
    6266:	e7d6      	b.n	6216 <le_data_len_change+0x42>
    6268:	0001e120 	.word	0x0001e120
    626c:	0001cffc 	.word	0x0001cffc

00006270 <hci_num_completed_packets>:
{
    6270:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6274:	b089      	sub	sp, #36	; 0x24
    6276:	af00      	add	r7, sp, #0
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
    6278:	f8d0 a008 	ldr.w	sl, [r0, #8]
	for (i = 0; i < evt->num_handles; i++) {
    627c:	2600      	movs	r6, #0
    627e:	e079      	b.n	6374 <hci_num_completed_packets+0x104>
			BT_ERR("No connection for handle %u", handle);
    6280:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6284:	e08e      	b.n	63a4 <hci_num_completed_packets+0x134>
    6286:	f06f 011b 	mvn.w	r1, #27
    628a:	e098      	b.n	63be <hci_num_completed_packets+0x14e>
				conn->pending_no_cb--;
    628c:	3b01      	subs	r3, #1
    628e:	61e3      	str	r3, [r4, #28]
    6290:	f382 8811 	msr	BASEPRI, r2
    6294:	f3bf 8f6f 	isb	sy
				k_sem_give(bt_conn_get_pkts(conn));
    6298:	4620      	mov	r0, r4
    629a:	f003 fb4f 	bl	993c <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
    629e:	f00d fc77 	bl	13b90 <z_impl_k_sem_give>
				continue;
    62a2:	e025      	b.n	62f0 <hci_num_completed_packets+0x80>
    62a4:	f382 8811 	msr	BASEPRI, r2
    62a8:	f3bf 8f6f 	isb	sy
			if (!node) {
    62ac:	2b00      	cmp	r3, #0
    62ae:	d03b      	beq.n	6328 <hci_num_completed_packets+0xb8>
	__asm__ volatile(
    62b0:	f04f 0220 	mov.w	r2, #32
    62b4:	f3ef 8111 	mrs	r1, BASEPRI
    62b8:	f382 8812 	msr	BASEPRI_MAX, r2
    62bc:	f3bf 8f6f 	isb	sy
			conn->pending_no_cb = tx->pending_no_cb;
    62c0:	68da      	ldr	r2, [r3, #12]
    62c2:	61e2      	str	r2, [r4, #28]
			tx->pending_no_cb = 0U;
    62c4:	2200      	movs	r2, #0
    62c6:	60da      	str	r2, [r3, #12]
	parent->next = child;
    62c8:	601a      	str	r2, [r3, #0]
	return list->tail;
    62ca:	6a62      	ldr	r2, [r4, #36]	; 0x24
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    62cc:	2a00      	cmp	r2, #0
    62ce:	f000 8099 	beq.w	6404 <hci_num_completed_packets+0x194>
	parent->next = child;
    62d2:	6013      	str	r3, [r2, #0]
	list->tail = node;
    62d4:	6263      	str	r3, [r4, #36]	; 0x24
	__asm__ volatile(
    62d6:	f381 8811 	msr	BASEPRI, r1
    62da:	f3bf 8f6f 	isb	sy
			k_work_submit(&conn->tx_complete_work);
    62de:	f104 0028 	add.w	r0, r4, #40	; 0x28
    62e2:	f00d fe1d 	bl	13f20 <k_work_submit>
			k_sem_give(bt_conn_get_pkts(conn));
    62e6:	4620      	mov	r0, r4
    62e8:	f003 fb28 	bl	993c <bt_conn_get_pkts>
    62ec:	f00d fc50 	bl	13b90 <z_impl_k_sem_give>
			BT_ERR("No connection for handle %u", handle);
    62f0:	46ab      	mov	fp, r5
		while (count--) {
    62f2:	f10b 35ff 	add.w	r5, fp, #4294967295
    62f6:	b2ad      	uxth	r5, r5
    62f8:	f1bb 0f00 	cmp.w	fp, #0
    62fc:	d036      	beq.n	636c <hci_num_completed_packets+0xfc>
	__asm__ volatile(
    62fe:	f04f 0320 	mov.w	r3, #32
    6302:	f3ef 8211 	mrs	r2, BASEPRI
    6306:	f383 8812 	msr	BASEPRI_MAX, r3
    630a:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
    630e:	69e3      	ldr	r3, [r4, #28]
    6310:	2b00      	cmp	r3, #0
    6312:	d1bb      	bne.n	628c <hci_num_completed_packets+0x1c>
	return list->head;
    6314:	6963      	ldr	r3, [r4, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    6316:	2b00      	cmp	r3, #0
    6318:	d0c4      	beq.n	62a4 <hci_num_completed_packets+0x34>
	return node->next;
    631a:	6819      	ldr	r1, [r3, #0]
	list->head = node;
    631c:	6161      	str	r1, [r4, #20]
	return list->tail;
    631e:	69a0      	ldr	r0, [r4, #24]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    6320:	4298      	cmp	r0, r3
    6322:	d1bf      	bne.n	62a4 <hci_num_completed_packets+0x34>
	list->tail = node;
    6324:	61a1      	str	r1, [r4, #24]
}
    6326:	e7bd      	b.n	62a4 <hci_num_completed_packets+0x34>
				BT_ERR("packets count mismatch");
    6328:	4b3a      	ldr	r3, [pc, #232]	; (6414 <hci_num_completed_packets+0x1a4>)
    632a:	61fb      	str	r3, [r7, #28]
    632c:	2302      	movs	r3, #2
    632e:	713b      	strb	r3, [r7, #4]
    6330:	2300      	movs	r3, #0
    6332:	717b      	strb	r3, [r7, #5]
    6334:	71bb      	strb	r3, [r7, #6]
    6336:	71fb      	strb	r3, [r7, #7]
    6338:	687a      	ldr	r2, [r7, #4]
    633a:	61ba      	str	r2, [r7, #24]
    633c:	f363 0900 	bfi	r9, r3, #0, #1
    6340:	f363 0941 	bfi	r9, r3, #1, #1
    6344:	f363 0982 	bfi	r9, r3, #2, #1
    6348:	f363 09c5 	bfi	r9, r3, #3, #3
    634c:	2201      	movs	r2, #1
    634e:	f362 1988 	bfi	r9, r2, #6, #3
    6352:	2208      	movs	r2, #8
    6354:	f362 2952 	bfi	r9, r2, #9, #10
    6358:	f363 49de 	bfi	r9, r3, #19, #12
    635c:	f363 79df 	bfi	r9, r3, #31, #1
    6360:	f107 0218 	add.w	r2, r7, #24
    6364:	4649      	mov	r1, r9
    6366:	482c      	ldr	r0, [pc, #176]	; (6418 <hci_num_completed_packets+0x1a8>)
    6368:	f7fb ff6e 	bl	2248 <z_impl_z_log_msg_static_create>
		bt_conn_unref(conn);
    636c:	4620      	mov	r0, r4
    636e:	f011 feb5 	bl	180dc <bt_conn_unref>
	for (i = 0; i < evt->num_handles; i++) {
    6372:	3601      	adds	r6, #1
    6374:	f89a 3000 	ldrb.w	r3, [sl]
    6378:	429e      	cmp	r6, r3
    637a:	da46      	bge.n	640a <hci_num_completed_packets+0x19a>
		handle = sys_le16_to_cpu(evt->h[i].handle);
    637c:	eb0a 0386 	add.w	r3, sl, r6, lsl #2
    6380:	f8b3 5001 	ldrh.w	r5, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
    6384:	f8b3 b003 	ldrh.w	fp, [r3, #3]
		conn = bt_conn_lookup_handle(handle);
    6388:	4628      	mov	r0, r5
    638a:	f003 fe07 	bl	9f9c <bt_conn_lookup_handle>
		if (!conn) {
    638e:	4604      	mov	r4, r0
    6390:	2800      	cmp	r0, #0
    6392:	d1ae      	bne.n	62f2 <hci_num_completed_packets+0x82>
			BT_ERR("No connection for handle %u", handle);
    6394:	466c      	mov	r4, sp
    6396:	b088      	sub	sp, #32
    6398:	466b      	mov	r3, sp
    639a:	f113 0210 	adds.w	r2, r3, #16
    639e:	f43f af6f 	beq.w	6280 <hci_num_completed_packets+0x10>
    63a2:	210c      	movs	r1, #12
    63a4:	b11a      	cbz	r2, 63ae <hci_num_completed_packets+0x13e>
    63a6:	2904      	cmp	r1, #4
    63a8:	dd01      	ble.n	63ae <hci_num_completed_packets+0x13e>
    63aa:	481c      	ldr	r0, [pc, #112]	; (641c <hci_num_completed_packets+0x1ac>)
    63ac:	6158      	str	r0, [r3, #20]
    63ae:	b112      	cbz	r2, 63b6 <hci_num_completed_packets+0x146>
    63b0:	2908      	cmp	r1, #8
    63b2:	dd00      	ble.n	63b6 <hci_num_completed_packets+0x146>
    63b4:	619d      	str	r5, [r3, #24]
    63b6:	290b      	cmp	r1, #11
    63b8:	f77f af65 	ble.w	6286 <hci_num_completed_packets+0x16>
    63bc:	210c      	movs	r1, #12
    63be:	b13a      	cbz	r2, 63d0 <hci_num_completed_packets+0x160>
    63c0:	2003      	movs	r0, #3
    63c2:	7138      	strb	r0, [r7, #4]
    63c4:	2000      	movs	r0, #0
    63c6:	7178      	strb	r0, [r7, #5]
    63c8:	71b8      	strb	r0, [r7, #6]
    63ca:	71f8      	strb	r0, [r7, #7]
    63cc:	6878      	ldr	r0, [r7, #4]
    63ce:	6118      	str	r0, [r3, #16]
    63d0:	f36f 0800 	bfc	r8, #0, #1
    63d4:	f36f 0841 	bfc	r8, #1, #1
    63d8:	f36f 0882 	bfc	r8, #2, #1
    63dc:	f36f 08c5 	bfc	r8, #3, #3
    63e0:	2301      	movs	r3, #1
    63e2:	f363 1888 	bfi	r8, r3, #6, #3
    63e6:	f401 737b 	and.w	r3, r1, #1004	; 0x3ec
    63ea:	f363 2852 	bfi	r8, r3, #9, #10
    63ee:	f36f 48de 	bfc	r8, #19, #12
    63f2:	f36f 78df 	bfc	r8, #31, #1
    63f6:	2300      	movs	r3, #0
    63f8:	4641      	mov	r1, r8
    63fa:	4807      	ldr	r0, [pc, #28]	; (6418 <hci_num_completed_packets+0x1a8>)
    63fc:	f7fb ff24 	bl	2248 <z_impl_z_log_msg_static_create>
    6400:	46a5      	mov	sp, r4
			continue;
    6402:	e7b6      	b.n	6372 <hci_num_completed_packets+0x102>
	list->tail = node;
    6404:	6263      	str	r3, [r4, #36]	; 0x24
	list->head = node;
    6406:	6223      	str	r3, [r4, #32]
}
    6408:	e765      	b.n	62d6 <hci_num_completed_packets+0x66>
}
    640a:	3724      	adds	r7, #36	; 0x24
    640c:	46bd      	mov	sp, r7
    640e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6412:	bf00      	nop
    6414:	0001e160 	.word	0x0001e160
    6418:	0001cffc 	.word	0x0001cffc
    641c:	0001e144 	.word	0x0001e144

00006420 <hci_cmd_done>:
{
    6420:	b5f0      	push	{r4, r5, r6, r7, lr}
    6422:	b083      	sub	sp, #12
    6424:	af00      	add	r7, sp, #0
    6426:	4605      	mov	r5, r0
    6428:	460e      	mov	r6, r1
    642a:	4614      	mov	r4, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
    642c:	7990      	ldrb	r0, [r2, #6]
    642e:	f007 fc1f 	bl	dc70 <net_buf_pool_get>
    6432:	4b83      	ldr	r3, [pc, #524]	; (6640 <hci_cmd_done+0x220>)
    6434:	4283      	cmp	r3, r0
    6436:	d050      	beq.n	64da <hci_cmd_done+0xba>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    6438:	79a6      	ldrb	r6, [r4, #6]
    643a:	4630      	mov	r0, r6
    643c:	f007 fc18 	bl	dc70 <net_buf_pool_get>
    6440:	466c      	mov	r4, sp
    6442:	b08a      	sub	sp, #40	; 0x28
    6444:	4669      	mov	r1, sp
    6446:	f111 0210 	adds.w	r2, r1, #16
    644a:	d040      	beq.n	64ce <hci_cmd_done+0xae>
    644c:	2318      	movs	r3, #24
    644e:	b12a      	cbz	r2, 645c <hci_cmd_done+0x3c>
    6450:	2b04      	cmp	r3, #4
    6452:	dd03      	ble.n	645c <hci_cmd_done+0x3c>
    6454:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 6644 <hci_cmd_done+0x224>
    6458:	f8c1 c014 	str.w	ip, [r1, #20]
    645c:	b112      	cbz	r2, 6464 <hci_cmd_done+0x44>
    645e:	2b08      	cmp	r3, #8
    6460:	dd00      	ble.n	6464 <hci_cmd_done+0x44>
    6462:	618d      	str	r5, [r1, #24]
    6464:	b112      	cbz	r2, 646c <hci_cmd_done+0x4c>
    6466:	2b0c      	cmp	r3, #12
    6468:	dd00      	ble.n	646c <hci_cmd_done+0x4c>
    646a:	61ce      	str	r6, [r1, #28]
    646c:	b112      	cbz	r2, 6474 <hci_cmd_done+0x54>
    646e:	2b10      	cmp	r3, #16
    6470:	dd00      	ble.n	6474 <hci_cmd_done+0x54>
    6472:	6208      	str	r0, [r1, #32]
    6474:	b11a      	cbz	r2, 647e <hci_cmd_done+0x5e>
    6476:	2b14      	cmp	r3, #20
    6478:	dd01      	ble.n	647e <hci_cmd_done+0x5e>
    647a:	4871      	ldr	r0, [pc, #452]	; (6640 <hci_cmd_done+0x220>)
    647c:	6248      	str	r0, [r1, #36]	; 0x24
    647e:	2b17      	cmp	r3, #23
    6480:	dd28      	ble.n	64d4 <hci_cmd_done+0xb4>
    6482:	2318      	movs	r3, #24
    6484:	b13a      	cbz	r2, 6496 <hci_cmd_done+0x76>
    6486:	2006      	movs	r0, #6
    6488:	7138      	strb	r0, [r7, #4]
    648a:	2000      	movs	r0, #0
    648c:	7178      	strb	r0, [r7, #5]
    648e:	71b8      	strb	r0, [r7, #6]
    6490:	71f8      	strb	r0, [r7, #7]
    6492:	6878      	ldr	r0, [r7, #4]
    6494:	6108      	str	r0, [r1, #16]
    6496:	2100      	movs	r1, #0
    6498:	f36f 0100 	bfc	r1, #0, #1
    649c:	f36f 0141 	bfc	r1, #1, #1
    64a0:	f36f 0182 	bfc	r1, #2, #1
    64a4:	f36f 01c5 	bfc	r1, #3, #3
    64a8:	2002      	movs	r0, #2
    64aa:	f360 1188 	bfi	r1, r0, #6, #3
    64ae:	f403 737f 	and.w	r3, r3, #1020	; 0x3fc
    64b2:	f363 2152 	bfi	r1, r3, #9, #10
    64b6:	f36f 41de 	bfc	r1, #19, #12
    64ba:	f36f 71df 	bfc	r1, #31, #1
    64be:	2300      	movs	r3, #0
    64c0:	4861      	ldr	r0, [pc, #388]	; (6648 <hci_cmd_done+0x228>)
    64c2:	f7fb fec1 	bl	2248 <z_impl_z_log_msg_static_create>
    64c6:	46a5      	mov	sp, r4
}
    64c8:	370c      	adds	r7, #12
    64ca:	46bd      	mov	sp, r7
    64cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
    64ce:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    64d2:	e7bc      	b.n	644e <hci_cmd_done+0x2e>
    64d4:	f06f 031b 	mvn.w	r3, #27
    64d8:	e7d4      	b.n	6484 <hci_cmd_done+0x64>
	if (cmd(buf)->opcode != opcode) {
    64da:	4620      	mov	r0, r4
    64dc:	f013 fd06 	bl	19eec <net_buf_id>
    64e0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    64e4:	4b59      	ldr	r3, [pc, #356]	; (664c <hci_cmd_done+0x22c>)
    64e6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    64ea:	8843      	ldrh	r3, [r0, #2]
    64ec:	429d      	cmp	r5, r3
    64ee:	d133      	bne.n	6558 <hci_cmd_done+0x138>
	if (bt_dev.sent_cmd) {
    64f0:	4b57      	ldr	r3, [pc, #348]	; (6650 <hci_cmd_done+0x230>)
    64f2:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
    64f6:	b128      	cbz	r0, 6504 <hci_cmd_done+0xe4>
		net_buf_unref(bt_dev.sent_cmd);
    64f8:	f013 fe37 	bl	1a16a <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    64fc:	4b54      	ldr	r3, [pc, #336]	; (6650 <hci_cmd_done+0x230>)
    64fe:	2200      	movs	r2, #0
    6500:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
	if (cmd(buf)->state && !status) {
    6504:	4620      	mov	r0, r4
    6506:	f013 fcf1 	bl	19eec <net_buf_id>
    650a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    650e:	4b4f      	ldr	r3, [pc, #316]	; (664c <hci_cmd_done+0x22c>)
    6510:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    6514:	6843      	ldr	r3, [r0, #4]
    6516:	b10b      	cbz	r3, 651c <hci_cmd_done+0xfc>
    6518:	2e00      	cmp	r6, #0
    651a:	d066      	beq.n	65ea <hci_cmd_done+0x1ca>
	if (cmd(buf)->sync) {
    651c:	4620      	mov	r0, r4
    651e:	f013 fce5 	bl	19eec <net_buf_id>
    6522:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6526:	4b49      	ldr	r3, [pc, #292]	; (664c <hci_cmd_done+0x22c>)
    6528:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    652c:	6883      	ldr	r3, [r0, #8]
    652e:	2b00      	cmp	r3, #0
    6530:	d0ca      	beq.n	64c8 <hci_cmd_done+0xa8>
		cmd(buf)->status = status;
    6532:	4620      	mov	r0, r4
    6534:	f013 fcda 	bl	19eec <net_buf_id>
    6538:	4d44      	ldr	r5, [pc, #272]	; (664c <hci_cmd_done+0x22c>)
    653a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    653e:	f805 6020 	strb.w	r6, [r5, r0, lsl #2]
		k_sem_give(cmd(buf)->sync);
    6542:	4620      	mov	r0, r4
    6544:	f013 fcd2 	bl	19eec <net_buf_id>
    6548:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    654c:	eb05 0580 	add.w	r5, r5, r0, lsl #2
    6550:	68a8      	ldr	r0, [r5, #8]
    6552:	f00d fb1d 	bl	13b90 <z_impl_k_sem_give>
}
    6556:	e7b7      	b.n	64c8 <hci_cmd_done+0xa8>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    6558:	4620      	mov	r0, r4
    655a:	f013 fcc7 	bl	19eec <net_buf_id>
    655e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6562:	4b3a      	ldr	r3, [pc, #232]	; (664c <hci_cmd_done+0x22c>)
    6564:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    6568:	8840      	ldrh	r0, [r0, #2]
    656a:	466c      	mov	r4, sp
    656c:	b088      	sub	sp, #32
    656e:	466b      	mov	r3, sp
    6570:	f113 0210 	adds.w	r2, r3, #16
    6574:	d033      	beq.n	65de <hci_cmd_done+0x1be>
    6576:	2110      	movs	r1, #16
    6578:	b11a      	cbz	r2, 6582 <hci_cmd_done+0x162>
    657a:	2904      	cmp	r1, #4
    657c:	dd01      	ble.n	6582 <hci_cmd_done+0x162>
    657e:	4e35      	ldr	r6, [pc, #212]	; (6654 <hci_cmd_done+0x234>)
    6580:	615e      	str	r6, [r3, #20]
    6582:	b112      	cbz	r2, 658a <hci_cmd_done+0x16a>
    6584:	2908      	cmp	r1, #8
    6586:	dd00      	ble.n	658a <hci_cmd_done+0x16a>
    6588:	619d      	str	r5, [r3, #24]
    658a:	b112      	cbz	r2, 6592 <hci_cmd_done+0x172>
    658c:	290c      	cmp	r1, #12
    658e:	dd00      	ble.n	6592 <hci_cmd_done+0x172>
    6590:	61d8      	str	r0, [r3, #28]
    6592:	290f      	cmp	r1, #15
    6594:	dd26      	ble.n	65e4 <hci_cmd_done+0x1c4>
    6596:	2510      	movs	r5, #16
    6598:	b13a      	cbz	r2, 65aa <hci_cmd_done+0x18a>
    659a:	2104      	movs	r1, #4
    659c:	7139      	strb	r1, [r7, #4]
    659e:	2100      	movs	r1, #0
    65a0:	7179      	strb	r1, [r7, #5]
    65a2:	71b9      	strb	r1, [r7, #6]
    65a4:	71f9      	strb	r1, [r7, #7]
    65a6:	6878      	ldr	r0, [r7, #4]
    65a8:	6118      	str	r0, [r3, #16]
    65aa:	2100      	movs	r1, #0
    65ac:	f36f 0100 	bfc	r1, #0, #1
    65b0:	f36f 0141 	bfc	r1, #1, #1
    65b4:	f36f 0182 	bfc	r1, #2, #1
    65b8:	f36f 01c5 	bfc	r1, #3, #3
    65bc:	2302      	movs	r3, #2
    65be:	f363 1188 	bfi	r1, r3, #6, #3
    65c2:	f405 737d 	and.w	r3, r5, #1012	; 0x3f4
    65c6:	f363 2152 	bfi	r1, r3, #9, #10
    65ca:	f36f 41de 	bfc	r1, #19, #12
    65ce:	f36f 71df 	bfc	r1, #31, #1
    65d2:	2300      	movs	r3, #0
    65d4:	481c      	ldr	r0, [pc, #112]	; (6648 <hci_cmd_done+0x228>)
    65d6:	f7fb fe37 	bl	2248 <z_impl_z_log_msg_static_create>
    65da:	46a5      	mov	sp, r4
		return;
    65dc:	e774      	b.n	64c8 <hci_cmd_done+0xa8>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
    65de:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    65e2:	e7c9      	b.n	6578 <hci_cmd_done+0x158>
    65e4:	f06f 051b 	mvn.w	r5, #27
    65e8:	e7d6      	b.n	6598 <hci_cmd_done+0x178>
		struct bt_hci_cmd_state_set *update = cmd(buf)->state;
    65ea:	4620      	mov	r0, r4
    65ec:	f013 fc7e 	bl	19eec <net_buf_id>
    65f0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    65f4:	4b15      	ldr	r3, [pc, #84]	; (664c <hci_cmd_done+0x22c>)
    65f6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    65fa:	6842      	ldr	r2, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
    65fc:	6813      	ldr	r3, [r2, #0]
    65fe:	6851      	ldr	r1, [r2, #4]
    6600:	7a10      	ldrb	r0, [r2, #8]
 * @param bit Bit number (starting from 0).
 * @param val true for 1, false for 0.
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    6602:	f001 051f 	and.w	r5, r1, #31
    6606:	2201      	movs	r2, #1
    6608:	40aa      	lsls	r2, r5

	if (val) {
    660a:	b158      	cbz	r0, 6624 <hci_cmd_done+0x204>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    660c:	0949      	lsrs	r1, r1, #5
    660e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    6612:	e8d3 1fef 	ldaex	r1, [r3]
    6616:	4311      	orrs	r1, r2
    6618:	e8c3 1fe0 	stlex	r0, r1, [r3]
    661c:	2800      	cmp	r0, #0
    661e:	f43f af7d 	beq.w	651c <hci_cmd_done+0xfc>
    6622:	e7f6      	b.n	6612 <hci_cmd_done+0x1f2>
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    6624:	0949      	lsrs	r1, r1, #5
    6626:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    662a:	43d2      	mvns	r2, r2
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    662c:	e8d3 1fef 	ldaex	r1, [r3]
    6630:	4011      	ands	r1, r2
    6632:	e8c3 1fe0 	stlex	r0, r1, [r3]
    6636:	2800      	cmp	r0, #0
    6638:	f43f af70 	beq.w	651c <hci_cmd_done+0xfc>
    663c:	e7f6      	b.n	662c <hci_cmd_done+0x20c>
    663e:	bf00      	nop
    6640:	20000760 	.word	0x20000760
    6644:	0001e178 	.word	0x0001e178
    6648:	0001cffc 	.word	0x0001cffc
    664c:	2000224c 	.word	0x2000224c
    6650:	20000000 	.word	0x20000000
    6654:	0001e1b0 	.word	0x0001e1b0

00006658 <le_remote_feat_complete>:
{
    6658:	b5f0      	push	{r4, r5, r6, r7, lr}
    665a:	b083      	sub	sp, #12
    665c:	af00      	add	r7, sp, #0
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
    665e:	6884      	ldr	r4, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    6660:	f8b4 6001 	ldrh.w	r6, [r4, #1]
	conn = bt_conn_lookup_handle(handle);
    6664:	4630      	mov	r0, r6
    6666:	f003 fc99 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    666a:	b190      	cbz	r0, 6692 <le_remote_feat_complete+0x3a>
    666c:	4605      	mov	r5, r0
	if (!evt->status) {
    666e:	7823      	ldrb	r3, [r4, #0]
    6670:	2b00      	cmp	r3, #0
    6672:	d04a      	beq.n	670a <le_remote_feat_complete+0xb2>
	atomic_set_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH);
    6674:	1d2b      	adds	r3, r5, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    6676:	e8d3 2fef 	ldaex	r2, [r3]
    667a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    667e:	e8c3 2fe1 	stlex	r1, r2, [r3]
    6682:	2900      	cmp	r1, #0
    6684:	d1f7      	bne.n	6676 <le_remote_feat_complete+0x1e>
	bt_conn_unref(conn);
    6686:	4628      	mov	r0, r5
    6688:	f011 fd28 	bl	180dc <bt_conn_unref>
}
    668c:	370c      	adds	r7, #12
    668e:	46bd      	mov	sp, r7
    6690:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    6692:	466d      	mov	r5, sp
    6694:	b088      	sub	sp, #32
    6696:	466b      	mov	r3, sp
    6698:	f113 0210 	adds.w	r2, r3, #16
    669c:	d02f      	beq.n	66fe <le_remote_feat_complete+0xa6>
    669e:	210c      	movs	r1, #12
    66a0:	b11a      	cbz	r2, 66aa <le_remote_feat_complete+0x52>
    66a2:	2904      	cmp	r1, #4
    66a4:	dd01      	ble.n	66aa <le_remote_feat_complete+0x52>
    66a6:	481c      	ldr	r0, [pc, #112]	; (6718 <le_remote_feat_complete+0xc0>)
    66a8:	6158      	str	r0, [r3, #20]
    66aa:	b112      	cbz	r2, 66b2 <le_remote_feat_complete+0x5a>
    66ac:	2908      	cmp	r1, #8
    66ae:	dd00      	ble.n	66b2 <le_remote_feat_complete+0x5a>
    66b0:	619e      	str	r6, [r3, #24]
    66b2:	290b      	cmp	r1, #11
    66b4:	dd26      	ble.n	6704 <le_remote_feat_complete+0xac>
    66b6:	240c      	movs	r4, #12
    66b8:	b13a      	cbz	r2, 66ca <le_remote_feat_complete+0x72>
    66ba:	2103      	movs	r1, #3
    66bc:	7139      	strb	r1, [r7, #4]
    66be:	2100      	movs	r1, #0
    66c0:	7179      	strb	r1, [r7, #5]
    66c2:	71b9      	strb	r1, [r7, #6]
    66c4:	71f9      	strb	r1, [r7, #7]
    66c6:	6878      	ldr	r0, [r7, #4]
    66c8:	6118      	str	r0, [r3, #16]
    66ca:	2100      	movs	r1, #0
    66cc:	f36f 0100 	bfc	r1, #0, #1
    66d0:	f36f 0141 	bfc	r1, #1, #1
    66d4:	f36f 0182 	bfc	r1, #2, #1
    66d8:	f36f 01c5 	bfc	r1, #3, #3
    66dc:	2301      	movs	r3, #1
    66de:	f363 1188 	bfi	r1, r3, #6, #3
    66e2:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    66e6:	f364 2152 	bfi	r1, r4, #9, #10
    66ea:	f36f 41de 	bfc	r1, #19, #12
    66ee:	f36f 71df 	bfc	r1, #31, #1
    66f2:	2300      	movs	r3, #0
    66f4:	4809      	ldr	r0, [pc, #36]	; (671c <le_remote_feat_complete+0xc4>)
    66f6:	f7fb fda7 	bl	2248 <z_impl_z_log_msg_static_create>
    66fa:	46ad      	mov	sp, r5
		return;
    66fc:	e7c6      	b.n	668c <le_remote_feat_complete+0x34>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    66fe:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6702:	e7cd      	b.n	66a0 <le_remote_feat_complete+0x48>
    6704:	f06f 041b 	mvn.w	r4, #27
    6708:	e7d6      	b.n	66b8 <le_remote_feat_complete+0x60>
		memcpy(conn->le.features, evt->features,
    670a:	2208      	movs	r2, #8
    670c:	1ce1      	adds	r1, r4, #3
    670e:	30ac      	adds	r0, #172	; 0xac
    6710:	f011 f80e 	bl	17730 <memcpy>
    6714:	e7ae      	b.n	6674 <le_remote_feat_complete+0x1c>
    6716:	bf00      	nop
    6718:	0001e120 	.word	0x0001e120
    671c:	0001cffc 	.word	0x0001cffc

00006720 <hci_cmd_status>:
{
    6720:	b538      	push	{r3, r4, r5, lr}
    6722:	4604      	mov	r4, r0
 *
 * @return Pointer to the old beginning of the buffer data.
 */
static inline void *net_buf_pull_mem(struct net_buf *buf, size_t len)
{
	return net_buf_simple_pull_mem(&buf->b, len);
    6724:	2104      	movs	r1, #4
    6726:	3008      	adds	r0, #8
    6728:	f013 fda1 	bl	1a26e <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    672c:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
    672e:	4622      	mov	r2, r4
    6730:	7801      	ldrb	r1, [r0, #0]
    6732:	8840      	ldrh	r0, [r0, #2]
    6734:	f7ff fe74 	bl	6420 <hci_cmd_done>
	if (ncmd) {
    6738:	b905      	cbnz	r5, 673c <hci_cmd_status+0x1c>
}
    673a:	bd38      	pop	{r3, r4, r5, pc}
	z_impl_k_sem_give(sem);
    673c:	4801      	ldr	r0, [pc, #4]	; (6744 <hci_cmd_status+0x24>)
    673e:	f00d fa27 	bl	13b90 <z_impl_k_sem_give>
    6742:	e7fa      	b.n	673a <hci_cmd_status+0x1a>
    6744:	20000118 	.word	0x20000118

00006748 <hci_cmd_complete>:
{
    6748:	b538      	push	{r3, r4, r5, lr}
    674a:	4604      	mov	r4, r0
    674c:	2103      	movs	r1, #3
    674e:	3008      	adds	r0, #8
    6750:	f013 fd8d 	bl	1a26e <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
    6754:	7805      	ldrb	r5, [r0, #0]
	status = buf->data[0];
    6756:	68a3      	ldr	r3, [r4, #8]
	hci_cmd_done(opcode, status, buf);
    6758:	4622      	mov	r2, r4
    675a:	7819      	ldrb	r1, [r3, #0]
    675c:	f8b0 0001 	ldrh.w	r0, [r0, #1]
    6760:	f7ff fe5e 	bl	6420 <hci_cmd_done>
	if (ncmd) {
    6764:	b905      	cbnz	r5, 6768 <hci_cmd_complete+0x20>
}
    6766:	bd38      	pop	{r3, r4, r5, pc}
    6768:	4801      	ldr	r0, [pc, #4]	; (6770 <hci_cmd_complete+0x28>)
    676a:	f00d fa11 	bl	13b90 <z_impl_k_sem_give>
    676e:	e7fa      	b.n	6766 <hci_cmd_complete+0x1e>
    6770:	20000118 	.word	0x20000118

00006774 <hci_hardware_error>:
{
    6774:	b590      	push	{r4, r7, lr}
    6776:	b083      	sub	sp, #12
    6778:	af00      	add	r7, sp, #0
    677a:	2101      	movs	r1, #1
    677c:	3008      	adds	r0, #8
    677e:	f013 fd76 	bl	1a26e <net_buf_simple_pull_mem>
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
    6782:	7800      	ldrb	r0, [r0, #0]
    6784:	b088      	sub	sp, #32
    6786:	466b      	mov	r3, sp
    6788:	f113 0210 	adds.w	r2, r3, #16
    678c:	d031      	beq.n	67f2 <hci_hardware_error+0x7e>
    678e:	210c      	movs	r1, #12
    6790:	b11a      	cbz	r2, 679a <hci_hardware_error+0x26>
    6792:	2904      	cmp	r1, #4
    6794:	dd01      	ble.n	679a <hci_hardware_error+0x26>
    6796:	4c1a      	ldr	r4, [pc, #104]	; (6800 <hci_hardware_error+0x8c>)
    6798:	615c      	str	r4, [r3, #20]
    679a:	b112      	cbz	r2, 67a2 <hci_hardware_error+0x2e>
    679c:	2908      	cmp	r1, #8
    679e:	dd00      	ble.n	67a2 <hci_hardware_error+0x2e>
    67a0:	6198      	str	r0, [r3, #24]
    67a2:	290b      	cmp	r1, #11
    67a4:	dd28      	ble.n	67f8 <hci_hardware_error+0x84>
    67a6:	f04f 0c0c 	mov.w	ip, #12
    67aa:	b13a      	cbz	r2, 67bc <hci_hardware_error+0x48>
    67ac:	2103      	movs	r1, #3
    67ae:	7139      	strb	r1, [r7, #4]
    67b0:	2100      	movs	r1, #0
    67b2:	7179      	strb	r1, [r7, #5]
    67b4:	71b9      	strb	r1, [r7, #6]
    67b6:	71f9      	strb	r1, [r7, #7]
    67b8:	6878      	ldr	r0, [r7, #4]
    67ba:	6118      	str	r0, [r3, #16]
    67bc:	2100      	movs	r1, #0
    67be:	f36f 0100 	bfc	r1, #0, #1
    67c2:	f36f 0141 	bfc	r1, #1, #1
    67c6:	f36f 0182 	bfc	r1, #2, #1
    67ca:	f36f 01c5 	bfc	r1, #3, #3
    67ce:	2301      	movs	r3, #1
    67d0:	f363 1188 	bfi	r1, r3, #6, #3
    67d4:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    67d8:	f36c 2152 	bfi	r1, ip, #9, #10
    67dc:	f36f 41de 	bfc	r1, #19, #12
    67e0:	f36f 71df 	bfc	r1, #31, #1
    67e4:	2300      	movs	r3, #0
    67e6:	4807      	ldr	r0, [pc, #28]	; (6804 <hci_hardware_error+0x90>)
    67e8:	f7fb fd2e 	bl	2248 <z_impl_z_log_msg_static_create>
}
    67ec:	370c      	adds	r7, #12
    67ee:	46bd      	mov	sp, r7
    67f0:	bd90      	pop	{r4, r7, pc}
	BT_ERR("Hardware error, hardware code: %d", evt->hardware_code);
    67f2:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    67f6:	e7cb      	b.n	6790 <hci_hardware_error+0x1c>
    67f8:	f06f 0c1b 	mvn.w	ip, #27
    67fc:	e7d5      	b.n	67aa <hci_hardware_error+0x36>
    67fe:	bf00      	nop
    6800:	0001e1e4 	.word	0x0001e1e4
    6804:	0001cffc 	.word	0x0001cffc

00006808 <handle_event>:
{
    6808:	b5f0      	push	{r4, r5, r6, r7, lr}
    680a:	b083      	sub	sp, #12
    680c:	af00      	add	r7, sp, #0
    680e:	4605      	mov	r5, r0
    6810:	460c      	mov	r4, r1
	err = handle_event_common(event, buf, handlers, num_handlers);
    6812:	f7ff f9a5 	bl	5b60 <handle_event_common>
	if (err == -EOPNOTSUPP) {
    6816:	f110 0f5f 	cmn.w	r0, #95	; 0x5f
    681a:	d002      	beq.n	6822 <handle_event+0x1a>
}
    681c:	370c      	adds	r7, #12
    681e:	46bd      	mov	sp, r7
    6820:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_WARN("Unhandled event 0x%02x len %u: %s", event, buf->len,
    6822:	89a6      	ldrh	r6, [r4, #12]
    6824:	4631      	mov	r1, r6
    6826:	68a0      	ldr	r0, [r4, #8]
    6828:	f7fe ff12 	bl	5650 <bt_hex_real>
    682c:	2304      	movs	r3, #4
    682e:	713b      	strb	r3, [r7, #4]
    6830:	466c      	mov	r4, sp
    6832:	b08a      	sub	sp, #40	; 0x28
    6834:	466b      	mov	r3, sp
    6836:	f113 0210 	adds.w	r2, r3, #16
    683a:	d045      	beq.n	68c8 <handle_event+0xc0>
    683c:	f04f 0c15 	mov.w	ip, #21
    6840:	b122      	cbz	r2, 684c <handle_event+0x44>
    6842:	f1bc 0f04 	cmp.w	ip, #4
    6846:	dd01      	ble.n	684c <handle_event+0x44>
    6848:	4927      	ldr	r1, [pc, #156]	; (68e8 <handle_event+0xe0>)
    684a:	6159      	str	r1, [r3, #20]
    684c:	b11a      	cbz	r2, 6856 <handle_event+0x4e>
    684e:	f1bc 0f08 	cmp.w	ip, #8
    6852:	dd00      	ble.n	6856 <handle_event+0x4e>
    6854:	619d      	str	r5, [r3, #24]
    6856:	b11a      	cbz	r2, 6860 <handle_event+0x58>
    6858:	f1bc 0f0c 	cmp.w	ip, #12
    685c:	dd00      	ble.n	6860 <handle_event+0x58>
    685e:	61de      	str	r6, [r3, #28]
    6860:	2104      	movs	r1, #4
    6862:	7039      	strb	r1, [r7, #0]
    6864:	b11a      	cbz	r2, 686e <handle_event+0x66>
    6866:	f1bc 0f10 	cmp.w	ip, #16
    686a:	dd00      	ble.n	686e <handle_event+0x66>
    686c:	6218      	str	r0, [r3, #32]
    686e:	b11a      	cbz	r2, 6878 <handle_event+0x70>
    6870:	f103 0124 	add.w	r1, r3, #36	; 0x24
    6874:	2000      	movs	r0, #0
    6876:	b350      	cbz	r0, 68ce <handle_event+0xc6>
    6878:	f1bc 0f14 	cmp.w	ip, #20
    687c:	dd30      	ble.n	68e0 <handle_event+0xd8>
    687e:	2515      	movs	r5, #21
    6880:	b142      	cbz	r2, 6894 <handle_event+0x8c>
    6882:	2105      	movs	r1, #5
    6884:	7139      	strb	r1, [r7, #4]
    6886:	2100      	movs	r1, #0
    6888:	7179      	strb	r1, [r7, #5]
    688a:	71b9      	strb	r1, [r7, #6]
    688c:	2101      	movs	r1, #1
    688e:	71f9      	strb	r1, [r7, #7]
    6890:	6878      	ldr	r0, [r7, #4]
    6892:	6118      	str	r0, [r3, #16]
    6894:	2100      	movs	r1, #0
    6896:	f36f 0100 	bfc	r1, #0, #1
    689a:	f36f 0141 	bfc	r1, #1, #1
    689e:	f36f 0182 	bfc	r1, #2, #1
    68a2:	f36f 01c5 	bfc	r1, #3, #3
    68a6:	2302      	movs	r3, #2
    68a8:	f363 1188 	bfi	r1, r3, #6, #3
    68ac:	f3c5 0509 	ubfx	r5, r5, #0, #10
    68b0:	f365 2152 	bfi	r1, r5, #9, #10
    68b4:	f36f 41de 	bfc	r1, #19, #12
    68b8:	f36f 71df 	bfc	r1, #31, #1
    68bc:	2300      	movs	r3, #0
    68be:	480b      	ldr	r0, [pc, #44]	; (68ec <handle_event+0xe4>)
    68c0:	f7fb fcc2 	bl	2248 <z_impl_z_log_msg_static_create>
    68c4:	46a5      	mov	sp, r4
}
    68c6:	e7a9      	b.n	681c <handle_event+0x14>
		BT_WARN("Unhandled event 0x%02x len %u: %s", event, buf->len,
    68c8:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    68cc:	e7b8      	b.n	6840 <handle_event+0x38>
    68ce:	f107 0508 	add.w	r5, r7, #8
    68d2:	4405      	add	r5, r0
    68d4:	f815 5c08 	ldrb.w	r5, [r5, #-8]
    68d8:	f801 5b01 	strb.w	r5, [r1], #1
    68dc:	3001      	adds	r0, #1
    68de:	e7ca      	b.n	6876 <handle_event+0x6e>
    68e0:	f06f 051b 	mvn.w	r5, #27
    68e4:	e7cc      	b.n	6880 <handle_event+0x78>
    68e6:	bf00      	nop
    68e8:	0001e208 	.word	0x0001e208
    68ec:	0001cffc 	.word	0x0001cffc

000068f0 <hci_le_meta_event>:
{
    68f0:	b510      	push	{r4, lr}
    68f2:	4604      	mov	r4, r0
    68f4:	2101      	movs	r1, #1
    68f6:	3008      	adds	r0, #8
    68f8:	f013 fcb9 	bl	1a26e <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
    68fc:	2307      	movs	r3, #7
    68fe:	4a03      	ldr	r2, [pc, #12]	; (690c <hci_le_meta_event+0x1c>)
    6900:	4621      	mov	r1, r4
    6902:	7800      	ldrb	r0, [r0, #0]
    6904:	f7ff ff80 	bl	6808 <handle_event>
}
    6908:	bd10      	pop	{r4, pc}
    690a:	bf00      	nop
    690c:	0001e70c 	.word	0x0001e70c

00006910 <rx_queue_put>:
	}
}

#if !defined(CONFIG_BT_RECV_BLOCKING)
static void rx_queue_put(struct net_buf *buf)
{
    6910:	b5b0      	push	{r4, r5, r7, lr}
    6912:	b082      	sub	sp, #8
    6914:	af00      	add	r7, sp, #0
    6916:	4601      	mov	r1, r0
	net_buf_slist_put(&bt_dev.rx_queue, buf);
    6918:	4824      	ldr	r0, [pc, #144]	; (69ac <rx_queue_put+0x9c>)
    691a:	f013 fbbf 	bl	1a09c <net_buf_slist_put>

#if defined(CONFIG_BT_RECV_WORKQ_SYS)
	const int err = k_work_submit(&rx_work);
#elif defined(CONFIG_BT_RECV_WORKQ_BT)
	const int err = k_work_submit_to_queue(&bt_workq, &rx_work);
    691e:	4924      	ldr	r1, [pc, #144]	; (69b0 <rx_queue_put+0xa0>)
    6920:	4824      	ldr	r0, [pc, #144]	; (69b4 <rx_queue_put+0xa4>)
    6922:	f015 fd13 	bl	1c34c <k_work_submit_to_queue>
#endif /* CONFIG_BT_RECV_WORKQ_SYS */
	if (err < 0) {
    6926:	2800      	cmp	r0, #0
    6928:	db02      	blt.n	6930 <rx_queue_put+0x20>
		BT_ERR("Could not submit rx_work: %d", err);
	}
}
    692a:	3708      	adds	r7, #8
    692c:	46bd      	mov	sp, r7
    692e:	bdb0      	pop	{r4, r5, r7, pc}
		BT_ERR("Could not submit rx_work: %d", err);
    6930:	466c      	mov	r4, sp
    6932:	b088      	sub	sp, #32
    6934:	466b      	mov	r3, sp
    6936:	f113 0210 	adds.w	r2, r3, #16
    693a:	d030      	beq.n	699e <rx_queue_put+0x8e>
    693c:	210c      	movs	r1, #12
    693e:	b11a      	cbz	r2, 6948 <rx_queue_put+0x38>
    6940:	2904      	cmp	r1, #4
    6942:	dd01      	ble.n	6948 <rx_queue_put+0x38>
    6944:	4d1c      	ldr	r5, [pc, #112]	; (69b8 <rx_queue_put+0xa8>)
    6946:	615d      	str	r5, [r3, #20]
    6948:	b112      	cbz	r2, 6950 <rx_queue_put+0x40>
    694a:	2908      	cmp	r1, #8
    694c:	dd00      	ble.n	6950 <rx_queue_put+0x40>
    694e:	6198      	str	r0, [r3, #24]
    6950:	290b      	cmp	r1, #11
    6952:	dd27      	ble.n	69a4 <rx_queue_put+0x94>
    6954:	f04f 0c0c 	mov.w	ip, #12
    6958:	b13a      	cbz	r2, 696a <rx_queue_put+0x5a>
    695a:	2103      	movs	r1, #3
    695c:	7139      	strb	r1, [r7, #4]
    695e:	2100      	movs	r1, #0
    6960:	7179      	strb	r1, [r7, #5]
    6962:	71b9      	strb	r1, [r7, #6]
    6964:	71f9      	strb	r1, [r7, #7]
    6966:	6878      	ldr	r0, [r7, #4]
    6968:	6118      	str	r0, [r3, #16]
    696a:	2100      	movs	r1, #0
    696c:	f36f 0100 	bfc	r1, #0, #1
    6970:	f36f 0141 	bfc	r1, #1, #1
    6974:	f36f 0182 	bfc	r1, #2, #1
    6978:	f36f 01c5 	bfc	r1, #3, #3
    697c:	2301      	movs	r3, #1
    697e:	f363 1188 	bfi	r1, r3, #6, #3
    6982:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    6986:	f36c 2152 	bfi	r1, ip, #9, #10
    698a:	f36f 41de 	bfc	r1, #19, #12
    698e:	f36f 71df 	bfc	r1, #31, #1
    6992:	2300      	movs	r3, #0
    6994:	4809      	ldr	r0, [pc, #36]	; (69bc <rx_queue_put+0xac>)
    6996:	f7fb fc57 	bl	2248 <z_impl_z_log_msg_static_create>
    699a:	46a5      	mov	sp, r4
}
    699c:	e7c5      	b.n	692a <rx_queue_put+0x1a>
		BT_ERR("Could not submit rx_work: %d", err);
    699e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    69a2:	e7cc      	b.n	693e <rx_queue_put+0x2e>
    69a4:	f06f 0c1b 	mvn.w	ip, #27
    69a8:	e7d6      	b.n	6958 <rx_queue_put+0x48>
    69aa:	bf00      	nop
    69ac:	20000134 	.word	0x20000134
    69b0:	20000254 	.word	0x20000254
    69b4:	20001510 	.word	0x20001510
    69b8:	0001e22c 	.word	0x0001e22c
    69bc:	0001cffc 	.word	0x0001cffc

000069c0 <hci_acl>:
{
    69c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    69c2:	b083      	sub	sp, #12
    69c4:	af00      	add	r7, sp, #0
    69c6:	4604      	mov	r4, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
    69c8:	8983      	ldrh	r3, [r0, #12]
    69ca:	2b03      	cmp	r3, #3
    69cc:	d951      	bls.n	6a72 <hci_acl+0xb2>
    69ce:	2104      	movs	r1, #4
    69d0:	f104 0008 	add.w	r0, r4, #8
    69d4:	f013 fc4b 	bl	1a26e <net_buf_simple_pull_mem>
	len = sys_le16_to_cpu(hdr->len);
    69d8:	8846      	ldrh	r6, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
    69da:	8800      	ldrh	r0, [r0, #0]
	flags = bt_acl_flags(handle);
    69dc:	0b05      	lsrs	r5, r0, #12
	acl(buf)->handle = bt_acl_handle(handle);
    69de:	f3c0 000b 	ubfx	r0, r0, #0, #12
    69e2:	82e0      	strh	r0, [r4, #22]
	acl(buf)->index = BT_CONN_INDEX_INVALID;
    69e4:	23ff      	movs	r3, #255	; 0xff
    69e6:	7563      	strb	r3, [r4, #21]
	if (buf->len != len) {
    69e8:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
    69ec:	45b4      	cmp	ip, r6
    69ee:	d054      	beq.n	6a9a <hci_acl+0xda>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    69f0:	466d      	mov	r5, sp
    69f2:	b088      	sub	sp, #32
    69f4:	466b      	mov	r3, sp
    69f6:	f113 0210 	adds.w	r2, r3, #16
    69fa:	d048      	beq.n	6a8e <hci_acl+0xce>
    69fc:	2110      	movs	r1, #16
    69fe:	b11a      	cbz	r2, 6a08 <hci_acl+0x48>
    6a00:	2904      	cmp	r1, #4
    6a02:	dd01      	ble.n	6a08 <hci_acl+0x48>
    6a04:	484d      	ldr	r0, [pc, #308]	; (6b3c <hci_acl+0x17c>)
    6a06:	6158      	str	r0, [r3, #20]
    6a08:	b11a      	cbz	r2, 6a12 <hci_acl+0x52>
    6a0a:	2908      	cmp	r1, #8
    6a0c:	dd01      	ble.n	6a12 <hci_acl+0x52>
    6a0e:	f8c3 c018 	str.w	ip, [r3, #24]
    6a12:	b112      	cbz	r2, 6a1a <hci_acl+0x5a>
    6a14:	290c      	cmp	r1, #12
    6a16:	dd00      	ble.n	6a1a <hci_acl+0x5a>
    6a18:	61de      	str	r6, [r3, #28]
    6a1a:	290f      	cmp	r1, #15
    6a1c:	dd3a      	ble.n	6a94 <hci_acl+0xd4>
    6a1e:	f04f 0c10 	mov.w	ip, #16
    6a22:	b13a      	cbz	r2, 6a34 <hci_acl+0x74>
    6a24:	2104      	movs	r1, #4
    6a26:	7139      	strb	r1, [r7, #4]
    6a28:	2100      	movs	r1, #0
    6a2a:	7179      	strb	r1, [r7, #5]
    6a2c:	71b9      	strb	r1, [r7, #6]
    6a2e:	71f9      	strb	r1, [r7, #7]
    6a30:	6878      	ldr	r0, [r7, #4]
    6a32:	6118      	str	r0, [r3, #16]
    6a34:	2100      	movs	r1, #0
    6a36:	f36f 0100 	bfc	r1, #0, #1
    6a3a:	f36f 0141 	bfc	r1, #1, #1
    6a3e:	f36f 0182 	bfc	r1, #2, #1
    6a42:	f36f 01c5 	bfc	r1, #3, #3
    6a46:	2301      	movs	r3, #1
    6a48:	f363 1188 	bfi	r1, r3, #6, #3
    6a4c:	f40c 7c7d 	and.w	ip, ip, #1012	; 0x3f4
    6a50:	f36c 2152 	bfi	r1, ip, #9, #10
    6a54:	f36f 41de 	bfc	r1, #19, #12
    6a58:	f36f 71df 	bfc	r1, #31, #1
    6a5c:	2300      	movs	r3, #0
    6a5e:	4838      	ldr	r0, [pc, #224]	; (6b40 <hci_acl+0x180>)
    6a60:	f7fb fbf2 	bl	2248 <z_impl_z_log_msg_static_create>
    6a64:	46ad      	mov	sp, r5
		net_buf_unref(buf);
    6a66:	4620      	mov	r0, r4
    6a68:	f013 fb7f 	bl	1a16a <net_buf_unref>
}
    6a6c:	370c      	adds	r7, #12
    6a6e:	46bd      	mov	sp, r7
    6a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6a72:	f240 13eb 	movw	r3, #491	; 0x1eb
    6a76:	4a33      	ldr	r2, [pc, #204]	; (6b44 <hci_acl+0x184>)
    6a78:	4933      	ldr	r1, [pc, #204]	; (6b48 <hci_acl+0x188>)
    6a7a:	4834      	ldr	r0, [pc, #208]	; (6b4c <hci_acl+0x18c>)
    6a7c:	f00f fc15 	bl	162aa <assert_print>
    6a80:	4040      	eors	r0, r0
    6a82:	f380 8811 	msr	BASEPRI, r0
    6a86:	f04f 0003 	mov.w	r0, #3
    6a8a:	df02      	svc	2
    6a8c:	e79f      	b.n	69ce <hci_acl+0xe>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
    6a8e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6a92:	e7b4      	b.n	69fe <hci_acl+0x3e>
    6a94:	f06f 0c1b 	mvn.w	ip, #27
    6a98:	e7c3      	b.n	6a22 <hci_acl+0x62>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
    6a9a:	f003 fa7f 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    6a9e:	4606      	mov	r6, r0
    6aa0:	b158      	cbz	r0, 6aba <hci_acl+0xfa>
	acl(buf)->index = bt_conn_index(conn);
    6aa2:	f003 fc1b 	bl	a2dc <bt_conn_index>
    6aa6:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
    6aa8:	462a      	mov	r2, r5
    6aaa:	4621      	mov	r1, r4
    6aac:	4630      	mov	r0, r6
    6aae:	f011 faec 	bl	1808a <bt_conn_recv>
	bt_conn_unref(conn);
    6ab2:	4630      	mov	r0, r6
    6ab4:	f011 fb12 	bl	180dc <bt_conn_unref>
    6ab8:	e7d8      	b.n	6a6c <hci_acl+0xac>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    6aba:	8ae0      	ldrh	r0, [r4, #22]
    6abc:	466e      	mov	r6, sp
    6abe:	b088      	sub	sp, #32
    6ac0:	466b      	mov	r3, sp
    6ac2:	f113 0210 	adds.w	r2, r3, #16
    6ac6:	d032      	beq.n	6b2e <hci_acl+0x16e>
    6ac8:	210c      	movs	r1, #12
    6aca:	b11a      	cbz	r2, 6ad4 <hci_acl+0x114>
    6acc:	2904      	cmp	r1, #4
    6ace:	dd01      	ble.n	6ad4 <hci_acl+0x114>
    6ad0:	4d1f      	ldr	r5, [pc, #124]	; (6b50 <hci_acl+0x190>)
    6ad2:	615d      	str	r5, [r3, #20]
    6ad4:	b112      	cbz	r2, 6adc <hci_acl+0x11c>
    6ad6:	2908      	cmp	r1, #8
    6ad8:	dd00      	ble.n	6adc <hci_acl+0x11c>
    6ada:	6198      	str	r0, [r3, #24]
    6adc:	290b      	cmp	r1, #11
    6ade:	dd29      	ble.n	6b34 <hci_acl+0x174>
    6ae0:	250c      	movs	r5, #12
    6ae2:	b13a      	cbz	r2, 6af4 <hci_acl+0x134>
    6ae4:	2103      	movs	r1, #3
    6ae6:	7139      	strb	r1, [r7, #4]
    6ae8:	2100      	movs	r1, #0
    6aea:	7179      	strb	r1, [r7, #5]
    6aec:	71b9      	strb	r1, [r7, #6]
    6aee:	71f9      	strb	r1, [r7, #7]
    6af0:	6878      	ldr	r0, [r7, #4]
    6af2:	6118      	str	r0, [r3, #16]
    6af4:	2100      	movs	r1, #0
    6af6:	f36f 0100 	bfc	r1, #0, #1
    6afa:	f36f 0141 	bfc	r1, #1, #1
    6afe:	f36f 0182 	bfc	r1, #2, #1
    6b02:	f36f 01c5 	bfc	r1, #3, #3
    6b06:	2301      	movs	r3, #1
    6b08:	f363 1188 	bfi	r1, r3, #6, #3
    6b0c:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    6b10:	f365 2152 	bfi	r1, r5, #9, #10
    6b14:	f36f 41de 	bfc	r1, #19, #12
    6b18:	f36f 71df 	bfc	r1, #31, #1
    6b1c:	2300      	movs	r3, #0
    6b1e:	4808      	ldr	r0, [pc, #32]	; (6b40 <hci_acl+0x180>)
    6b20:	f7fb fb92 	bl	2248 <z_impl_z_log_msg_static_create>
    6b24:	46b5      	mov	sp, r6
		net_buf_unref(buf);
    6b26:	4620      	mov	r0, r4
    6b28:	f013 fb1f 	bl	1a16a <net_buf_unref>
		return;
    6b2c:	e79e      	b.n	6a6c <hci_acl+0xac>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
    6b2e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6b32:	e7ca      	b.n	6aca <hci_acl+0x10a>
    6b34:	f06f 051b 	mvn.w	r5, #27
    6b38:	e7d3      	b.n	6ae2 <hci_acl+0x122>
    6b3a:	bf00      	nop
    6b3c:	0001e2bc 	.word	0x0001e2bc
    6b40:	0001cffc 	.word	0x0001cffc
    6b44:	0001e24c 	.word	0x0001e24c
    6b48:	0001e280 	.word	0x0001e280
    6b4c:	0001e29c 	.word	0x0001e29c
    6b50:	0001e2e0 	.word	0x0001e2e0

00006b54 <le_conn_update_complete>:
{
    6b54:	b5f0      	push	{r4, r5, r6, r7, lr}
    6b56:	b083      	sub	sp, #12
    6b58:	af00      	add	r7, sp, #0
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
    6b5a:	6884      	ldr	r4, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    6b5c:	f8b4 6001 	ldrh.w	r6, [r4, #1]
	conn = bt_conn_lookup_handle(handle);
    6b60:	4630      	mov	r0, r6
    6b62:	f003 fa1b 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    6b66:	b158      	cbz	r0, 6b80 <le_conn_update_complete+0x2c>
    6b68:	4605      	mov	r5, r0
	if (!evt->status) {
    6b6a:	7823      	ldrb	r3, [r4, #0]
    6b6c:	2b00      	cmp	r3, #0
    6b6e:	d043      	beq.n	6bf8 <le_conn_update_complete+0xa4>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    6b70:	2b1a      	cmp	r3, #26
    6b72:	d050      	beq.n	6c16 <le_conn_update_complete+0xc2>
	bt_conn_unref(conn);
    6b74:	4628      	mov	r0, r5
    6b76:	f011 fab1 	bl	180dc <bt_conn_unref>
}
    6b7a:	370c      	adds	r7, #12
    6b7c:	46bd      	mov	sp, r7
    6b7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    6b80:	466d      	mov	r5, sp
    6b82:	b088      	sub	sp, #32
    6b84:	466b      	mov	r3, sp
    6b86:	f113 0210 	adds.w	r2, r3, #16
    6b8a:	d02f      	beq.n	6bec <le_conn_update_complete+0x98>
    6b8c:	210c      	movs	r1, #12
    6b8e:	b11a      	cbz	r2, 6b98 <le_conn_update_complete+0x44>
    6b90:	2904      	cmp	r1, #4
    6b92:	dd01      	ble.n	6b98 <le_conn_update_complete+0x44>
    6b94:	4830      	ldr	r0, [pc, #192]	; (6c58 <le_conn_update_complete+0x104>)
    6b96:	6158      	str	r0, [r3, #20]
    6b98:	b112      	cbz	r2, 6ba0 <le_conn_update_complete+0x4c>
    6b9a:	2908      	cmp	r1, #8
    6b9c:	dd00      	ble.n	6ba0 <le_conn_update_complete+0x4c>
    6b9e:	619e      	str	r6, [r3, #24]
    6ba0:	290b      	cmp	r1, #11
    6ba2:	dd26      	ble.n	6bf2 <le_conn_update_complete+0x9e>
    6ba4:	240c      	movs	r4, #12
    6ba6:	b13a      	cbz	r2, 6bb8 <le_conn_update_complete+0x64>
    6ba8:	2103      	movs	r1, #3
    6baa:	7039      	strb	r1, [r7, #0]
    6bac:	2100      	movs	r1, #0
    6bae:	7079      	strb	r1, [r7, #1]
    6bb0:	70b9      	strb	r1, [r7, #2]
    6bb2:	70f9      	strb	r1, [r7, #3]
    6bb4:	6838      	ldr	r0, [r7, #0]
    6bb6:	6118      	str	r0, [r3, #16]
    6bb8:	2100      	movs	r1, #0
    6bba:	f36f 0100 	bfc	r1, #0, #1
    6bbe:	f36f 0141 	bfc	r1, #1, #1
    6bc2:	f36f 0182 	bfc	r1, #2, #1
    6bc6:	f36f 01c5 	bfc	r1, #3, #3
    6bca:	2301      	movs	r3, #1
    6bcc:	f363 1188 	bfi	r1, r3, #6, #3
    6bd0:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    6bd4:	f364 2152 	bfi	r1, r4, #9, #10
    6bd8:	f36f 41de 	bfc	r1, #19, #12
    6bdc:	f36f 71df 	bfc	r1, #31, #1
    6be0:	2300      	movs	r3, #0
    6be2:	481e      	ldr	r0, [pc, #120]	; (6c5c <le_conn_update_complete+0x108>)
    6be4:	f7fb fb30 	bl	2248 <z_impl_z_log_msg_static_create>
    6be8:	46ad      	mov	sp, r5
		return;
    6bea:	e7c6      	b.n	6b7a <le_conn_update_complete+0x26>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    6bec:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6bf0:	e7cd      	b.n	6b8e <le_conn_update_complete+0x3a>
    6bf2:	f06f 041b 	mvn.w	r4, #27
    6bf6:	e7d6      	b.n	6ba6 <le_conn_update_complete+0x52>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
    6bf8:	f8b4 3003 	ldrh.w	r3, [r4, #3]
    6bfc:	f8a0 309e 	strh.w	r3, [r0, #158]	; 0x9e
		conn->le.latency = sys_le16_to_cpu(evt->latency);
    6c00:	f8b4 3005 	ldrh.w	r3, [r4, #5]
    6c04:	f8a0 30a4 	strh.w	r3, [r0, #164]	; 0xa4
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    6c08:	f8b4 3007 	ldrh.w	r3, [r4, #7]
    6c0c:	f8a0 30a6 	strh.w	r3, [r0, #166]	; 0xa6
		notify_le_param_updated(conn);
    6c10:	f003 fbae 	bl	a370 <notify_le_param_updated>
    6c14:	e7ae      	b.n	6b74 <le_conn_update_complete+0x20>
		   conn->role == BT_HCI_ROLE_PERIPHERAL &&
    6c16:	78c3      	ldrb	r3, [r0, #3]
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
    6c18:	2b01      	cmp	r3, #1
    6c1a:	d1ab      	bne.n	6b74 <le_conn_update_complete+0x20>
		   !atomic_test_and_set_bit(conn->flags,
    6c1c:	1d03      	adds	r3, r0, #4
    6c1e:	e8d3 2fef 	ldaex	r2, [r3]
    6c22:	f442 7100 	orr.w	r1, r2, #512	; 0x200
    6c26:	e8c3 1fe0 	stlex	r0, r1, [r3]
    6c2a:	2800      	cmp	r0, #0
    6c2c:	d1f7      	bne.n	6c1e <le_conn_update_complete+0xca>
		   conn->role == BT_HCI_ROLE_PERIPHERAL &&
    6c2e:	f412 7f00 	tst.w	r2, #512	; 0x200
    6c32:	d19f      	bne.n	6b74 <le_conn_update_complete+0x20>
		param.interval_min = conn->le.interval_min;
    6c34:	f8b5 30a0 	ldrh.w	r3, [r5, #160]	; 0xa0
    6c38:	803b      	strh	r3, [r7, #0]
		param.interval_max = conn->le.interval_max;
    6c3a:	f8b5 30a2 	ldrh.w	r3, [r5, #162]	; 0xa2
    6c3e:	807b      	strh	r3, [r7, #2]
		param.latency = conn->le.pending_latency;
    6c40:	f8b5 30a8 	ldrh.w	r3, [r5, #168]	; 0xa8
    6c44:	80bb      	strh	r3, [r7, #4]
		param.timeout = conn->le.pending_timeout;
    6c46:	f8b5 30aa 	ldrh.w	r3, [r5, #170]	; 0xaa
    6c4a:	80fb      	strh	r3, [r7, #6]
		bt_l2cap_update_conn_param(conn, &param);
    6c4c:	4639      	mov	r1, r7
    6c4e:	4628      	mov	r0, r5
    6c50:	f011 fb9b 	bl	1838a <bt_l2cap_update_conn_param>
    6c54:	e78e      	b.n	6b74 <le_conn_update_complete+0x20>
    6c56:	bf00      	nop
    6c58:	0001e120 	.word	0x0001e120
    6c5c:	0001cffc 	.word	0x0001cffc

00006c60 <hci_event>:
{
    6c60:	b538      	push	{r3, r4, r5, lr}
    6c62:	4604      	mov	r4, r0
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6c64:	8983      	ldrh	r3, [r0, #12]
    6c66:	2b01      	cmp	r3, #1
    6c68:	d916      	bls.n	6c98 <hci_event+0x38>
    6c6a:	2102      	movs	r1, #2
    6c6c:	f104 0008 	add.w	r0, r4, #8
    6c70:	f013 fafd 	bl	1a26e <net_buf_simple_pull_mem>
    6c74:	4605      	mov	r5, r0
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    6c76:	7803      	ldrb	r3, [r0, #0]
 *
 * @return HCI event flags for the specified event.
 */
static inline uint8_t bt_hci_evt_get_flags(uint8_t evt)
{
	switch (evt) {
    6c78:	3b05      	subs	r3, #5
    6c7a:	2b15      	cmp	r3, #21
    6c7c:	d81c      	bhi.n	6cb8 <hci_event+0x58>
    6c7e:	e8df f003 	tbb	[pc, r3]
    6c82:	1b19      	.short	0x1b19
    6c84:	1b1b1b1b 	.word	0x1b1b1b1b
    6c88:	291b1b1b 	.word	0x291b1b1b
    6c8c:	1b1b1b29 	.word	0x1b1b1b29
    6c90:	1b1b1b29 	.word	0x1b1b1b29
    6c94:	291b1b1b 	.word	0x291b1b1b
	BT_ASSERT(buf->len >= sizeof(*hdr));
    6c98:	f640 1359 	movw	r3, #2393	; 0x959
    6c9c:	4a15      	ldr	r2, [pc, #84]	; (6cf4 <hci_event+0x94>)
    6c9e:	4916      	ldr	r1, [pc, #88]	; (6cf8 <hci_event+0x98>)
    6ca0:	4816      	ldr	r0, [pc, #88]	; (6cfc <hci_event+0x9c>)
    6ca2:	f00f fb02 	bl	162aa <assert_print>
    6ca6:	4040      	eors	r0, r0
    6ca8:	f380 8811 	msr	BASEPRI, r0
    6cac:	f04f 0003 	mov.w	r0, #3
    6cb0:	df02      	svc	2
    6cb2:	e7da      	b.n	6c6a <hci_event+0xa>
    6cb4:	2303      	movs	r3, #3
    6cb6:	e000      	b.n	6cba <hci_event+0x5a>
#endif /* CONFIG_BT_CONN ||  CONFIG_BT_ISO */
	case BT_HCI_EVT_CMD_COMPLETE:
	case BT_HCI_EVT_CMD_STATUS:
		return BT_HCI_EVT_FLAG_RECV_PRIO;
	default:
		return BT_HCI_EVT_FLAG_RECV;
    6cb8:	2302      	movs	r3, #2
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    6cba:	f013 0f02 	tst.w	r3, #2
    6cbe:	d00b      	beq.n	6cd8 <hci_event+0x78>
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
    6cc0:	2304      	movs	r3, #4
    6cc2:	4a0f      	ldr	r2, [pc, #60]	; (6d00 <hci_event+0xa0>)
    6cc4:	4621      	mov	r1, r4
    6cc6:	7828      	ldrb	r0, [r5, #0]
    6cc8:	f7ff fd9e 	bl	6808 <handle_event>
	net_buf_unref(buf);
    6ccc:	4620      	mov	r0, r4
    6cce:	f013 fa4c 	bl	1a16a <net_buf_unref>
}
    6cd2:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_EVT_FLAG_RECV_PRIO;
    6cd4:	2301      	movs	r3, #1
    6cd6:	e7f0      	b.n	6cba <hci_event+0x5a>
	BT_ASSERT(bt_hci_evt_get_flags(hdr->evt) & BT_HCI_EVT_FLAG_RECV);
    6cd8:	f640 135d 	movw	r3, #2397	; 0x95d
    6cdc:	4a05      	ldr	r2, [pc, #20]	; (6cf4 <hci_event+0x94>)
    6cde:	4909      	ldr	r1, [pc, #36]	; (6d04 <hci_event+0xa4>)
    6ce0:	4806      	ldr	r0, [pc, #24]	; (6cfc <hci_event+0x9c>)
    6ce2:	f00f fae2 	bl	162aa <assert_print>
    6ce6:	4040      	eors	r0, r0
    6ce8:	f380 8811 	msr	BASEPRI, r0
    6cec:	f04f 0003 	mov.w	r0, #3
    6cf0:	df02      	svc	2
    6cf2:	e7e5      	b.n	6cc0 <hci_event+0x60>
    6cf4:	0001e24c 	.word	0x0001e24c
    6cf8:	0001e280 	.word	0x0001e280
    6cfc:	0001e29c 	.word	0x0001e29c
    6d00:	0001e764 	.word	0x0001e764
    6d04:	0001e304 	.word	0x0001e304

00006d08 <rx_work_handler>:
	}
}

#if !defined(CONFIG_BT_RECV_BLOCKING)
static void rx_work_handler(struct k_work *work)
{
    6d08:	b5f0      	push	{r4, r5, r6, r7, lr}
    6d0a:	b083      	sub	sp, #12
    6d0c:	af00      	add	r7, sp, #0
	int err;

	struct net_buf *buf;

	BT_DBG("Getting net_buf from queue");
	buf = net_buf_slist_get(&bt_dev.rx_queue);
    6d0e:	484c      	ldr	r0, [pc, #304]	; (6e40 <rx_work_handler+0x138>)
    6d10:	f013 f9e6 	bl	1a0e0 <net_buf_slist_get>
	if (!buf) {
    6d14:	2800      	cmp	r0, #0
    6d16:	d04d      	beq.n	6db4 <rx_work_handler+0xac>
    6d18:	4604      	mov	r4, r0
 *
 *  @return The BT_* type to of the buffer
 */
static inline enum bt_buf_type bt_buf_get_type(struct net_buf *buf)
{
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    6d1a:	7d03      	ldrb	r3, [r0, #20]
	}

	BT_DBG("buf %p type %u len %u", buf, bt_buf_get_type(buf),
	       buf->len);

	switch (bt_buf_get_type(buf)) {
    6d1c:	2b01      	cmp	r3, #1
    6d1e:	d004      	beq.n	6d2a <rx_work_handler+0x22>
    6d20:	2b03      	cmp	r3, #3
    6d22:	d105      	bne.n	6d30 <rx_work_handler+0x28>
#if defined(CONFIG_BT_CONN)
	case BT_BUF_ACL_IN:
		hci_acl(buf);
    6d24:	f7ff fe4c 	bl	69c0 <hci_acl>
		break;
    6d28:	e03a      	b.n	6da0 <rx_work_handler+0x98>
	case BT_BUF_ISO_IN:
		hci_iso(buf);
		break;
#endif /* CONFIG_BT_ISO */
	case BT_BUF_EVT:
		hci_event(buf);
    6d2a:	f7ff ff99 	bl	6c60 <hci_event>
		break;
    6d2e:	e037      	b.n	6da0 <rx_work_handler+0x98>
	default:
		BT_ERR("Unknown buf type %u", bt_buf_get_type(buf));
    6d30:	466d      	mov	r5, sp
    6d32:	b088      	sub	sp, #32
    6d34:	4669      	mov	r1, sp
    6d36:	f111 0210 	adds.w	r2, r1, #16
    6d3a:	d03e      	beq.n	6dba <rx_work_handler+0xb2>
    6d3c:	200c      	movs	r0, #12
    6d3e:	b11a      	cbz	r2, 6d48 <rx_work_handler+0x40>
    6d40:	2804      	cmp	r0, #4
    6d42:	dd01      	ble.n	6d48 <rx_work_handler+0x40>
    6d44:	4e3f      	ldr	r6, [pc, #252]	; (6e44 <rx_work_handler+0x13c>)
    6d46:	614e      	str	r6, [r1, #20]
    6d48:	b112      	cbz	r2, 6d50 <rx_work_handler+0x48>
    6d4a:	2808      	cmp	r0, #8
    6d4c:	dd00      	ble.n	6d50 <rx_work_handler+0x48>
    6d4e:	618b      	str	r3, [r1, #24]
    6d50:	280b      	cmp	r0, #11
    6d52:	dd35      	ble.n	6dc0 <rx_work_handler+0xb8>
    6d54:	230c      	movs	r3, #12
    6d56:	b13a      	cbz	r2, 6d68 <rx_work_handler+0x60>
    6d58:	2003      	movs	r0, #3
    6d5a:	7138      	strb	r0, [r7, #4]
    6d5c:	2000      	movs	r0, #0
    6d5e:	7178      	strb	r0, [r7, #5]
    6d60:	71b8      	strb	r0, [r7, #6]
    6d62:	71f8      	strb	r0, [r7, #7]
    6d64:	6878      	ldr	r0, [r7, #4]
    6d66:	6108      	str	r0, [r1, #16]
    6d68:	2100      	movs	r1, #0
    6d6a:	f36f 0100 	bfc	r1, #0, #1
    6d6e:	f36f 0141 	bfc	r1, #1, #1
    6d72:	f36f 0182 	bfc	r1, #2, #1
    6d76:	f36f 01c5 	bfc	r1, #3, #3
    6d7a:	2001      	movs	r0, #1
    6d7c:	f360 1188 	bfi	r1, r0, #6, #3
    6d80:	f403 737b 	and.w	r3, r3, #1004	; 0x3ec
    6d84:	f363 2152 	bfi	r1, r3, #9, #10
    6d88:	f36f 41de 	bfc	r1, #19, #12
    6d8c:	f36f 71df 	bfc	r1, #31, #1
    6d90:	2300      	movs	r3, #0
    6d92:	482d      	ldr	r0, [pc, #180]	; (6e48 <rx_work_handler+0x140>)
    6d94:	f7fb fa58 	bl	2248 <z_impl_z_log_msg_static_create>
    6d98:	46ad      	mov	sp, r5
		net_buf_unref(buf);
    6d9a:	4620      	mov	r0, r4
    6d9c:	f013 f9e5 	bl	1a16a <net_buf_unref>
	return list->head;
    6da0:	4b2a      	ldr	r3, [pc, #168]	; (6e4c <rx_work_handler+0x144>)
    6da2:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
	/* Schedule the work handler to be executed again if there are
	 * additional items in the queue. This allows for other users of the
	 * work queue to get a chance at running, which wouldn't be possible if
	 * we used a while() loop with a k_yield() statement.
	 */
	if (!sys_slist_is_empty(&bt_dev.rx_queue)) {
    6da6:	b12b      	cbz	r3, 6db4 <rx_work_handler+0xac>

#if defined(CONFIG_BT_RECV_WORKQ_SYS)
		err = k_work_submit(&rx_work);
#elif defined(CONFIG_BT_RECV_WORKQ_BT)
		err = k_work_submit_to_queue(&bt_workq, &rx_work);
    6da8:	4929      	ldr	r1, [pc, #164]	; (6e50 <rx_work_handler+0x148>)
    6daa:	482a      	ldr	r0, [pc, #168]	; (6e54 <rx_work_handler+0x14c>)
    6dac:	f015 face 	bl	1c34c <k_work_submit_to_queue>
#endif
		if (err < 0) {
    6db0:	2800      	cmp	r0, #0
    6db2:	db08      	blt.n	6dc6 <rx_work_handler+0xbe>
			BT_ERR("Could not submit rx_work: %d", err);
		}
	}
}
    6db4:	370c      	adds	r7, #12
    6db6:	46bd      	mov	sp, r7
    6db8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("Unknown buf type %u", bt_buf_get_type(buf));
    6dba:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    6dbe:	e7be      	b.n	6d3e <rx_work_handler+0x36>
    6dc0:	f06f 031b 	mvn.w	r3, #27
    6dc4:	e7c7      	b.n	6d56 <rx_work_handler+0x4e>
			BT_ERR("Could not submit rx_work: %d", err);
    6dc6:	466d      	mov	r5, sp
    6dc8:	b088      	sub	sp, #32
    6dca:	466b      	mov	r3, sp
    6dcc:	f113 0210 	adds.w	r2, r3, #16
    6dd0:	d02f      	beq.n	6e32 <rx_work_handler+0x12a>
    6dd2:	210c      	movs	r1, #12
    6dd4:	b11a      	cbz	r2, 6dde <rx_work_handler+0xd6>
    6dd6:	2904      	cmp	r1, #4
    6dd8:	dd01      	ble.n	6dde <rx_work_handler+0xd6>
    6dda:	4c1f      	ldr	r4, [pc, #124]	; (6e58 <rx_work_handler+0x150>)
    6ddc:	615c      	str	r4, [r3, #20]
    6dde:	b112      	cbz	r2, 6de6 <rx_work_handler+0xde>
    6de0:	2908      	cmp	r1, #8
    6de2:	dd00      	ble.n	6de6 <rx_work_handler+0xde>
    6de4:	6198      	str	r0, [r3, #24]
    6de6:	290b      	cmp	r1, #11
    6de8:	dd26      	ble.n	6e38 <rx_work_handler+0x130>
    6dea:	240c      	movs	r4, #12
    6dec:	b13a      	cbz	r2, 6dfe <rx_work_handler+0xf6>
    6dee:	2103      	movs	r1, #3
    6df0:	7139      	strb	r1, [r7, #4]
    6df2:	2100      	movs	r1, #0
    6df4:	7179      	strb	r1, [r7, #5]
    6df6:	71b9      	strb	r1, [r7, #6]
    6df8:	71f9      	strb	r1, [r7, #7]
    6dfa:	6878      	ldr	r0, [r7, #4]
    6dfc:	6118      	str	r0, [r3, #16]
    6dfe:	2100      	movs	r1, #0
    6e00:	f36f 0100 	bfc	r1, #0, #1
    6e04:	f36f 0141 	bfc	r1, #1, #1
    6e08:	f36f 0182 	bfc	r1, #2, #1
    6e0c:	f36f 01c5 	bfc	r1, #3, #3
    6e10:	2301      	movs	r3, #1
    6e12:	f363 1188 	bfi	r1, r3, #6, #3
    6e16:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    6e1a:	f363 2152 	bfi	r1, r3, #9, #10
    6e1e:	f36f 41de 	bfc	r1, #19, #12
    6e22:	f36f 71df 	bfc	r1, #31, #1
    6e26:	2300      	movs	r3, #0
    6e28:	4807      	ldr	r0, [pc, #28]	; (6e48 <rx_work_handler+0x140>)
    6e2a:	f7fb fa0d 	bl	2248 <z_impl_z_log_msg_static_create>
    6e2e:	46ad      	mov	sp, r5
    6e30:	e7c0      	b.n	6db4 <rx_work_handler+0xac>
    6e32:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    6e36:	e7cd      	b.n	6dd4 <rx_work_handler+0xcc>
    6e38:	f06f 041b 	mvn.w	r4, #27
    6e3c:	e7d6      	b.n	6dec <rx_work_handler+0xe4>
    6e3e:	bf00      	nop
    6e40:	20000134 	.word	0x20000134
    6e44:	0001e334 	.word	0x0001e334
    6e48:	0001cffc 	.word	0x0001cffc
    6e4c:	20000000 	.word	0x20000000
    6e50:	20000254 	.word	0x20000254
    6e54:	20001510 	.word	0x20001510
    6e58:	0001e22c 	.word	0x0001e22c

00006e5c <bt_hci_cmd_state_set_init>:
{
    6e5c:	b510      	push	{r4, lr}
    6e5e:	460c      	mov	r4, r1
	state->target = target;
    6e60:	600a      	str	r2, [r1, #0]
	state->bit = bit;
    6e62:	604b      	str	r3, [r1, #4]
	state->val = val;
    6e64:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6e68:	720b      	strb	r3, [r1, #8]
	cmd(buf)->state = state;
    6e6a:	f013 f83f 	bl	19eec <net_buf_id>
    6e6e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6e72:	4b02      	ldr	r3, [pc, #8]	; (6e7c <bt_hci_cmd_state_set_init+0x20>)
    6e74:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    6e78:	6044      	str	r4, [r0, #4]
}
    6e7a:	bd10      	pop	{r4, pc}
    6e7c:	2000224c 	.word	0x2000224c

00006e80 <bt_hci_cmd_create>:
{
    6e80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6e84:	4606      	mov	r6, r0
    6e86:	460f      	mov	r7, r1
	return net_buf_alloc_fixed(pool, timeout);
    6e88:	f04f 32ff 	mov.w	r2, #4294967295
    6e8c:	f04f 33ff 	mov.w	r3, #4294967295
    6e90:	4818      	ldr	r0, [pc, #96]	; (6ef4 <bt_hci_cmd_create+0x74>)
    6e92:	f013 f8d7 	bl	1a044 <net_buf_alloc_fixed>
    6e96:	4604      	mov	r4, r0
	net_buf_simple_reserve(&buf->b, reserve);
    6e98:	f100 0908 	add.w	r9, r0, #8
    6e9c:	2101      	movs	r1, #1
    6e9e:	4648      	mov	r0, r9
    6ea0:	f013 f8f8 	bl	1a094 <net_buf_simple_reserve>
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
    6ea4:	f04f 0800 	mov.w	r8, #0
    6ea8:	f884 8014 	strb.w	r8, [r4, #20]
	cmd(buf)->opcode = opcode;
    6eac:	4620      	mov	r0, r4
    6eae:	f013 f81d 	bl	19eec <net_buf_id>
    6eb2:	4d11      	ldr	r5, [pc, #68]	; (6ef8 <bt_hci_cmd_create+0x78>)
    6eb4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6eb8:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    6ebc:	8046      	strh	r6, [r0, #2]
	cmd(buf)->sync = NULL;
    6ebe:	4620      	mov	r0, r4
    6ec0:	f013 f814 	bl	19eec <net_buf_id>
    6ec4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6ec8:	eb05 0380 	add.w	r3, r5, r0, lsl #2
    6ecc:	f8c3 8008 	str.w	r8, [r3, #8]
	cmd(buf)->state = NULL;
    6ed0:	4620      	mov	r0, r4
    6ed2:	f013 f80b 	bl	19eec <net_buf_id>
    6ed6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6eda:	eb05 0580 	add.w	r5, r5, r0, lsl #2
    6ede:	f8c5 8004 	str.w	r8, [r5, #4]
	return net_buf_simple_add(&buf->b, len);
    6ee2:	2103      	movs	r1, #3
    6ee4:	4648      	mov	r0, r9
    6ee6:	f013 f98a 	bl	1a1fe <net_buf_simple_add>
	hdr->opcode = sys_cpu_to_le16(opcode);
    6eea:	8006      	strh	r6, [r0, #0]
	hdr->param_len = param_len;
    6eec:	7087      	strb	r7, [r0, #2]
}
    6eee:	4620      	mov	r0, r4
    6ef0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6ef4:	20000760 	.word	0x20000760
    6ef8:	2000224c 	.word	0x2000224c

00006efc <bt_hci_cmd_send_sync>:
{
    6efc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6f00:	b088      	sub	sp, #32
    6f02:	af00      	add	r7, sp, #0
    6f04:	4606      	mov	r6, r0
    6f06:	4615      	mov	r5, r2
	if (!buf) {
    6f08:	460c      	mov	r4, r1
    6f0a:	2900      	cmp	r1, #0
    6f0c:	d06e      	beq.n	6fec <bt_hci_cmd_send_sync+0xf0>
	return z_impl_k_sem_init(sem, initial_count, limit);
    6f0e:	f107 0808 	add.w	r8, r7, #8
    6f12:	2201      	movs	r2, #1
    6f14:	2100      	movs	r1, #0
    6f16:	4640      	mov	r0, r8
    6f18:	f015 f97c 	bl	1c214 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
    6f1c:	4620      	mov	r0, r4
    6f1e:	f012 ffe5 	bl	19eec <net_buf_id>
    6f22:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6f26:	4b49      	ldr	r3, [pc, #292]	; (704c <bt_hci_cmd_send_sync+0x150>)
    6f28:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    6f2c:	f8c0 8008 	str.w	r8, [r0, #8]
	net_buf_put(&bt_dev.cmd_tx_queue, net_buf_ref(buf));
    6f30:	4620      	mov	r0, r4
    6f32:	f013 f940 	bl	1a1b6 <net_buf_ref>
    6f36:	4601      	mov	r1, r0
    6f38:	4845      	ldr	r0, [pc, #276]	; (7050 <bt_hci_cmd_send_sync+0x154>)
    6f3a:	f013 f908 	bl	1a14e <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
    6f3e:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    6f42:	2300      	movs	r3, #0
    6f44:	4640      	mov	r0, r8
    6f46:	f00c fe4b 	bl	13be0 <z_impl_k_sem_take>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    6f4a:	4680      	mov	r8, r0
    6f4c:	2800      	cmp	r0, #0
    6f4e:	d155      	bne.n	6ffc <bt_hci_cmd_send_sync+0x100>
	status = cmd(buf)->status;
    6f50:	4620      	mov	r0, r4
    6f52:	f012 ffcb 	bl	19eec <net_buf_id>
    6f56:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    6f5a:	4b3c      	ldr	r3, [pc, #240]	; (704c <bt_hci_cmd_send_sync+0x150>)
    6f5c:	f813 8020 	ldrb.w	r8, [r3, r0, lsl #2]
	if (status) {
    6f60:	f1b8 0f00 	cmp.w	r8, #0
    6f64:	d065      	beq.n	7032 <bt_hci_cmd_send_sync+0x136>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    6f66:	466d      	mov	r5, sp
    6f68:	b088      	sub	sp, #32
    6f6a:	466b      	mov	r3, sp
    6f6c:	f113 0210 	adds.w	r2, r3, #16
    6f70:	d056      	beq.n	7020 <bt_hci_cmd_send_sync+0x124>
    6f72:	2110      	movs	r1, #16
    6f74:	b11a      	cbz	r2, 6f7e <bt_hci_cmd_send_sync+0x82>
    6f76:	2904      	cmp	r1, #4
    6f78:	dd01      	ble.n	6f7e <bt_hci_cmd_send_sync+0x82>
    6f7a:	4836      	ldr	r0, [pc, #216]	; (7054 <bt_hci_cmd_send_sync+0x158>)
    6f7c:	6158      	str	r0, [r3, #20]
    6f7e:	b112      	cbz	r2, 6f86 <bt_hci_cmd_send_sync+0x8a>
    6f80:	2908      	cmp	r1, #8
    6f82:	dd00      	ble.n	6f86 <bt_hci_cmd_send_sync+0x8a>
    6f84:	619e      	str	r6, [r3, #24]
    6f86:	b11a      	cbz	r2, 6f90 <bt_hci_cmd_send_sync+0x94>
    6f88:	290c      	cmp	r1, #12
    6f8a:	dd01      	ble.n	6f90 <bt_hci_cmd_send_sync+0x94>
    6f8c:	f8c3 801c 	str.w	r8, [r3, #28]
    6f90:	290f      	cmp	r1, #15
    6f92:	dd48      	ble.n	7026 <bt_hci_cmd_send_sync+0x12a>
    6f94:	2610      	movs	r6, #16
    6f96:	b13a      	cbz	r2, 6fa8 <bt_hci_cmd_send_sync+0xac>
    6f98:	2104      	movs	r1, #4
    6f9a:	7139      	strb	r1, [r7, #4]
    6f9c:	2100      	movs	r1, #0
    6f9e:	7179      	strb	r1, [r7, #5]
    6fa0:	71b9      	strb	r1, [r7, #6]
    6fa2:	71f9      	strb	r1, [r7, #7]
    6fa4:	6878      	ldr	r0, [r7, #4]
    6fa6:	6118      	str	r0, [r3, #16]
    6fa8:	2100      	movs	r1, #0
    6faa:	f36f 0100 	bfc	r1, #0, #1
    6fae:	f36f 0141 	bfc	r1, #1, #1
    6fb2:	f36f 0182 	bfc	r1, #2, #1
    6fb6:	f36f 01c5 	bfc	r1, #3, #3
    6fba:	2302      	movs	r3, #2
    6fbc:	f363 1188 	bfi	r1, r3, #6, #3
    6fc0:	f406 737d 	and.w	r3, r6, #1012	; 0x3f4
    6fc4:	f363 2152 	bfi	r1, r3, #9, #10
    6fc8:	f36f 41de 	bfc	r1, #19, #12
    6fcc:	f36f 71df 	bfc	r1, #31, #1
    6fd0:	2300      	movs	r3, #0
    6fd2:	4821      	ldr	r0, [pc, #132]	; (7058 <bt_hci_cmd_send_sync+0x15c>)
    6fd4:	f7fb f938 	bl	2248 <z_impl_z_log_msg_static_create>
    6fd8:	46ad      	mov	sp, r5
		net_buf_unref(buf);
    6fda:	4620      	mov	r0, r4
    6fdc:	f013 f8c5 	bl	1a16a <net_buf_unref>
		switch (status) {
    6fe0:	f1b8 0f09 	cmp.w	r8, #9
    6fe4:	d022      	beq.n	702c <bt_hci_cmd_send_sync+0x130>
			return -EIO;
    6fe6:	f06f 0004 	mvn.w	r0, #4
    6fea:	e025      	b.n	7038 <bt_hci_cmd_send_sync+0x13c>
		buf = bt_hci_cmd_create(opcode, 0);
    6fec:	f7ff ff48 	bl	6e80 <bt_hci_cmd_create>
		if (!buf) {
    6ff0:	4604      	mov	r4, r0
    6ff2:	2800      	cmp	r0, #0
    6ff4:	d18b      	bne.n	6f0e <bt_hci_cmd_send_sync+0x12>
			return -ENOBUFS;
    6ff6:	f06f 0068 	mvn.w	r0, #104	; 0x68
    6ffa:	e01d      	b.n	7038 <bt_hci_cmd_send_sync+0x13c>
	BT_ASSERT_MSG(err == 0, "k_sem_take failed with err %d", err);
    6ffc:	f240 1347 	movw	r3, #327	; 0x147
    7000:	4a16      	ldr	r2, [pc, #88]	; (705c <bt_hci_cmd_send_sync+0x160>)
    7002:	4917      	ldr	r1, [pc, #92]	; (7060 <bt_hci_cmd_send_sync+0x164>)
    7004:	4817      	ldr	r0, [pc, #92]	; (7064 <bt_hci_cmd_send_sync+0x168>)
    7006:	f00f f950 	bl	162aa <assert_print>
    700a:	4641      	mov	r1, r8
    700c:	4816      	ldr	r0, [pc, #88]	; (7068 <bt_hci_cmd_send_sync+0x16c>)
    700e:	f00f f94c 	bl	162aa <assert_print>
    7012:	4040      	eors	r0, r0
    7014:	f380 8811 	msr	BASEPRI, r0
    7018:	f04f 0003 	mov.w	r0, #3
    701c:	df02      	svc	2
    701e:	e797      	b.n	6f50 <bt_hci_cmd_send_sync+0x54>
		BT_WARN("opcode 0x%04x status 0x%02x", opcode, status);
    7020:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7024:	e7a6      	b.n	6f74 <bt_hci_cmd_send_sync+0x78>
    7026:	f06f 061b 	mvn.w	r6, #27
    702a:	e7b4      	b.n	6f96 <bt_hci_cmd_send_sync+0x9a>
			return -ECONNREFUSED;
    702c:	f06f 006e 	mvn.w	r0, #110	; 0x6e
    7030:	e002      	b.n	7038 <bt_hci_cmd_send_sync+0x13c>
	if (rsp) {
    7032:	b12d      	cbz	r5, 7040 <bt_hci_cmd_send_sync+0x144>
		*rsp = buf;
    7034:	602c      	str	r4, [r5, #0]
	return 0;
    7036:	2000      	movs	r0, #0
}
    7038:	3720      	adds	r7, #32
    703a:	46bd      	mov	sp, r7
    703c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
    7040:	4620      	mov	r0, r4
    7042:	f013 f892 	bl	1a16a <net_buf_unref>
	return 0;
    7046:	2000      	movs	r0, #0
    7048:	e7f6      	b.n	7038 <bt_hci_cmd_send_sync+0x13c>
    704a:	bf00      	nop
    704c:	2000224c 	.word	0x2000224c
    7050:	2000013c 	.word	0x2000013c
    7054:	0001e374 	.word	0x0001e374
    7058:	0001cffc 	.word	0x0001cffc
    705c:	0001e24c 	.word	0x0001e24c
    7060:	0001e348 	.word	0x0001e348
    7064:	0001e29c 	.word	0x0001e29c
    7068:	0001e354 	.word	0x0001e354

0000706c <set_flow_control>:
{
    706c:	b530      	push	{r4, r5, lr}
    706e:	b089      	sub	sp, #36	; 0x24
	if (!BT_CMD_TEST(bt_dev.supported_commands, 10, 5)) {
    7070:	4b31      	ldr	r3, [pc, #196]	; (7138 <set_flow_control+0xcc>)
    7072:	f893 3082 	ldrb.w	r3, [r3, #130]	; 0x82
    7076:	f013 0f20 	tst.w	r3, #32
    707a:	d02f      	beq.n	70dc <set_flow_control+0x70>
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_BUFFER_SIZE,
    707c:	2107      	movs	r1, #7
    707e:	f640 4033 	movw	r0, #3123	; 0xc33
    7082:	f7ff fefd 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    7086:	4605      	mov	r5, r0
    7088:	2800      	cmp	r0, #0
    708a:	d04f      	beq.n	712c <set_flow_control+0xc0>
    708c:	2107      	movs	r1, #7
    708e:	3008      	adds	r0, #8
    7090:	f013 f8b5 	bl	1a1fe <net_buf_simple_add>
    7094:	4604      	mov	r4, r0
	(void)memset(hbs, 0, sizeof(*hbs));
    7096:	2207      	movs	r2, #7
    7098:	2100      	movs	r1, #0
    709a:	f010 fb78 	bl	1778e <memset>
	hbs->acl_mtu = sys_cpu_to_le16(CONFIG_BT_BUF_ACL_RX_SIZE);
    709e:	2200      	movs	r2, #0
    70a0:	231b      	movs	r3, #27
    70a2:	7023      	strb	r3, [r4, #0]
    70a4:	7062      	strb	r2, [r4, #1]
	hbs->acl_pkts = sys_cpu_to_le16(CONFIG_BT_BUF_ACL_RX_COUNT);
    70a6:	2306      	movs	r3, #6
    70a8:	70e3      	strb	r3, [r4, #3]
    70aa:	7122      	strb	r2, [r4, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_HOST_BUFFER_SIZE, buf, NULL);
    70ac:	4629      	mov	r1, r5
    70ae:	f640 4033 	movw	r0, #3123	; 0xc33
    70b2:	f7ff ff23 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    70b6:	bbb8      	cbnz	r0, 7128 <set_flow_control+0xbc>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, 1);
    70b8:	2101      	movs	r1, #1
    70ba:	f640 4031 	movw	r0, #3121	; 0xc31
    70be:	f7ff fedf 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    70c2:	4604      	mov	r4, r0
    70c4:	b3a8      	cbz	r0, 7132 <set_flow_control+0xc6>
	return net_buf_simple_add_u8(&buf->b, val);
    70c6:	2101      	movs	r1, #1
    70c8:	3008      	adds	r0, #8
    70ca:	f013 f8a9 	bl	1a220 <net_buf_simple_add_u8>
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_CTL_TO_HOST_FLOW, buf, NULL);
    70ce:	2200      	movs	r2, #0
    70d0:	4621      	mov	r1, r4
    70d2:	f640 4031 	movw	r0, #3121	; 0xc31
    70d6:	f7ff ff11 	bl	6efc <bt_hci_cmd_send_sync>
    70da:	e025      	b.n	7128 <set_flow_control+0xbc>
		BT_WARN("Controller to host flow control not supported");
    70dc:	4b17      	ldr	r3, [pc, #92]	; (713c <set_flow_control+0xd0>)
    70de:	9307      	str	r3, [sp, #28]
    70e0:	2302      	movs	r3, #2
    70e2:	f88d 3004 	strb.w	r3, [sp, #4]
    70e6:	2400      	movs	r4, #0
    70e8:	f88d 4005 	strb.w	r4, [sp, #5]
    70ec:	f88d 4006 	strb.w	r4, [sp, #6]
    70f0:	f88d 4007 	strb.w	r4, [sp, #7]
    70f4:	9a01      	ldr	r2, [sp, #4]
    70f6:	9206      	str	r2, [sp, #24]
    70f8:	4621      	mov	r1, r4
    70fa:	f364 0100 	bfi	r1, r4, #0, #1
    70fe:	f364 0141 	bfi	r1, r4, #1, #1
    7102:	f364 0182 	bfi	r1, r4, #2, #1
    7106:	f364 01c5 	bfi	r1, r4, #3, #3
    710a:	f363 1188 	bfi	r1, r3, #6, #3
    710e:	2308      	movs	r3, #8
    7110:	f363 2152 	bfi	r1, r3, #9, #10
    7114:	f364 41de 	bfi	r1, r4, #19, #12
    7118:	f364 71df 	bfi	r1, r4, #31, #1
    711c:	4623      	mov	r3, r4
    711e:	aa06      	add	r2, sp, #24
    7120:	4807      	ldr	r0, [pc, #28]	; (7140 <set_flow_control+0xd4>)
    7122:	f7fb f891 	bl	2248 <z_impl_z_log_msg_static_create>
		return 0;
    7126:	4620      	mov	r0, r4
}
    7128:	b009      	add	sp, #36	; 0x24
    712a:	bd30      	pop	{r4, r5, pc}
		return -ENOBUFS;
    712c:	f06f 0068 	mvn.w	r0, #104	; 0x68
    7130:	e7fa      	b.n	7128 <set_flow_control+0xbc>
		return -ENOBUFS;
    7132:	f06f 0068 	mvn.w	r0, #104	; 0x68
    7136:	e7f7      	b.n	7128 <set_flow_control+0xbc>
    7138:	20000000 	.word	0x20000000
    713c:	0001e390 	.word	0x0001e390
    7140:	0001cffc 	.word	0x0001cffc

00007144 <common_init>:
{
    7144:	b500      	push	{lr}
    7146:	b083      	sub	sp, #12
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
    7148:	4b26      	ldr	r3, [pc, #152]	; (71e4 <common_init+0xa0>)
    714a:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
    714e:	689b      	ldr	r3, [r3, #8]
    7150:	f013 0f01 	tst.w	r3, #1
    7154:	d10d      	bne.n	7172 <common_init+0x2e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
    7156:	aa01      	add	r2, sp, #4
    7158:	2100      	movs	r1, #0
    715a:	f640 4003 	movw	r0, #3075	; 0xc03
    715e:	f7ff fecd 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    7162:	4603      	mov	r3, r0
    7164:	b968      	cbnz	r0, 7182 <common_init+0x3e>
		hci_reset_complete(rsp);
    7166:	9801      	ldr	r0, [sp, #4]
    7168:	f7fe fc5a 	bl	5a20 <hci_reset_complete>
		net_buf_unref(rsp);
    716c:	9801      	ldr	r0, [sp, #4]
    716e:	f012 fffc 	bl	1a16a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
    7172:	aa01      	add	r2, sp, #4
    7174:	2100      	movs	r1, #0
    7176:	f241 0003 	movw	r0, #4099	; 0x1003
    717a:	f7ff febf 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    717e:	4603      	mov	r3, r0
    7180:	b118      	cbz	r0, 718a <common_init+0x46>
}
    7182:	4618      	mov	r0, r3
    7184:	b003      	add	sp, #12
    7186:	f85d fb04 	ldr.w	pc, [sp], #4
	read_local_features_complete(rsp);
    718a:	9801      	ldr	r0, [sp, #4]
    718c:	f7fe fc5a 	bl	5a44 <read_local_features_complete>
	net_buf_unref(rsp);
    7190:	9801      	ldr	r0, [sp, #4]
    7192:	f012 ffea 	bl	1a16a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
    7196:	aa01      	add	r2, sp, #4
    7198:	2100      	movs	r1, #0
    719a:	f241 0001 	movw	r0, #4097	; 0x1001
    719e:	f7ff fead 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    71a2:	4603      	mov	r3, r0
    71a4:	2800      	cmp	r0, #0
    71a6:	d1ec      	bne.n	7182 <common_init+0x3e>
	read_local_ver_complete(rsp);
    71a8:	9801      	ldr	r0, [sp, #4]
    71aa:	f7fe fbbb 	bl	5924 <read_local_ver_complete>
	net_buf_unref(rsp);
    71ae:	9801      	ldr	r0, [sp, #4]
    71b0:	f012 ffdb 	bl	1a16a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
    71b4:	aa01      	add	r2, sp, #4
    71b6:	2100      	movs	r1, #0
    71b8:	f241 0002 	movw	r0, #4098	; 0x1002
    71bc:	f7ff fe9e 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    71c0:	4603      	mov	r3, r0
    71c2:	2800      	cmp	r0, #0
    71c4:	d1dd      	bne.n	7182 <common_init+0x3e>
	read_supported_commands_complete(rsp);
    71c6:	9801      	ldr	r0, [sp, #4]
    71c8:	f7fe fc46 	bl	5a58 <read_supported_commands_complete>
	net_buf_unref(rsp);
    71cc:	9801      	ldr	r0, [sp, #4]
    71ce:	f012 ffcc 	bl	1a16a <net_buf_unref>
		err = prng_init();
    71d2:	f002 fae9 	bl	97a8 <prng_init>
		if (err) {
    71d6:	4603      	mov	r3, r0
    71d8:	2800      	cmp	r0, #0
    71da:	d1d2      	bne.n	7182 <common_init+0x3e>
	err = set_flow_control();
    71dc:	f7ff ff46 	bl	706c <set_flow_control>
    71e0:	4603      	mov	r3, r0
	if (err) {
    71e2:	e7ce      	b.n	7182 <common_init+0x3e>
    71e4:	20000000 	.word	0x20000000

000071e8 <hci_le_read_max_data_len>:
{
    71e8:	b570      	push	{r4, r5, r6, lr}
    71ea:	b088      	sub	sp, #32
    71ec:	4605      	mov	r5, r0
    71ee:	460c      	mov	r4, r1
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
    71f0:	aa01      	add	r2, sp, #4
    71f2:	2100      	movs	r1, #0
    71f4:	f242 002f 	movw	r0, #8239	; 0x202f
    71f8:	f7ff fe80 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    71fc:	4606      	mov	r6, r0
    71fe:	b960      	cbnz	r0, 721a <hci_le_read_max_data_len+0x32>
	rp = (void *)rsp->data;
    7200:	9801      	ldr	r0, [sp, #4]
    7202:	6883      	ldr	r3, [r0, #8]
	*tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
    7204:	f8b3 2001 	ldrh.w	r2, [r3, #1]
    7208:	802a      	strh	r2, [r5, #0]
	*tx_time = sys_le16_to_cpu(rp->max_tx_time);
    720a:	f8b3 3003 	ldrh.w	r3, [r3, #3]
    720e:	8023      	strh	r3, [r4, #0]
	net_buf_unref(rsp);
    7210:	f012 ffab 	bl	1a16a <net_buf_unref>
}
    7214:	4630      	mov	r0, r6
    7216:	b008      	add	sp, #32
    7218:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("Failed to read DLE max data len");
    721a:	4b13      	ldr	r3, [pc, #76]	; (7268 <hci_le_read_max_data_len+0x80>)
    721c:	9307      	str	r3, [sp, #28]
    721e:	2302      	movs	r3, #2
    7220:	f88d 3000 	strb.w	r3, [sp]
    7224:	2300      	movs	r3, #0
    7226:	f88d 3001 	strb.w	r3, [sp, #1]
    722a:	f88d 3002 	strb.w	r3, [sp, #2]
    722e:	f88d 3003 	strb.w	r3, [sp, #3]
    7232:	9a00      	ldr	r2, [sp, #0]
    7234:	9206      	str	r2, [sp, #24]
    7236:	4619      	mov	r1, r3
    7238:	f363 0100 	bfi	r1, r3, #0, #1
    723c:	f363 0141 	bfi	r1, r3, #1, #1
    7240:	f363 0182 	bfi	r1, r3, #2, #1
    7244:	f363 01c5 	bfi	r1, r3, #3, #3
    7248:	2201      	movs	r2, #1
    724a:	f362 1188 	bfi	r1, r2, #6, #3
    724e:	2208      	movs	r2, #8
    7250:	f362 2152 	bfi	r1, r2, #9, #10
    7254:	f363 41de 	bfi	r1, r3, #19, #12
    7258:	f363 71df 	bfi	r1, r3, #31, #1
    725c:	aa06      	add	r2, sp, #24
    725e:	4803      	ldr	r0, [pc, #12]	; (726c <hci_le_read_max_data_len+0x84>)
    7260:	f7fa fff2 	bl	2248 <z_impl_z_log_msg_static_create>
		return err;
    7264:	e7d6      	b.n	7214 <hci_le_read_max_data_len+0x2c>
    7266:	bf00      	nop
    7268:	0001e3c0 	.word	0x0001e3c0
    726c:	0001cffc 	.word	0x0001cffc

00007270 <le_set_event_mask>:
{
    7270:	b510      	push	{r4, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
    7272:	2108      	movs	r1, #8
    7274:	f242 0001 	movw	r0, #8193	; 0x2001
    7278:	f7ff fe02 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    727c:	b390      	cbz	r0, 72e4 <le_set_event_mask+0x74>
    727e:	4604      	mov	r4, r0
	return net_buf_simple_add(&buf->b, len);
    7280:	2108      	movs	r1, #8
    7282:	4408      	add	r0, r1
    7284:	f012 ffbb 	bl	1a1fe <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
    7288:	4b18      	ldr	r3, [pc, #96]	; (72ec <le_set_event_mask+0x7c>)
    728a:	f893 10d0 	ldrb.w	r1, [r3, #208]	; 0xd0
    728e:	f011 0f02 	tst.w	r1, #2
    7292:	d124      	bne.n	72de <le_set_event_mask+0x6e>
		mask |= BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE;
    7294:	230f      	movs	r3, #15
    7296:	2200      	movs	r2, #0
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
    7298:	f011 0f20 	tst.w	r1, #32
    729c:	d001      	beq.n	72a2 <le_set_event_mask+0x32>
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
    729e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
		    (BT_FEAT_LE_PHY_2M(bt_dev.le.features) ||
    72a2:	4912      	ldr	r1, [pc, #72]	; (72ec <le_set_event_mask+0x7c>)
    72a4:	f891 10d1 	ldrb.w	r1, [r1, #209]	; 0xd1
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
    72a8:	f011 0f09 	tst.w	r1, #9
    72ac:	d001      	beq.n	72b2 <le_set_event_mask+0x42>
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
    72ae:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
	dst[0] = val;
    72b2:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
    72b4:	f3c3 2107 	ubfx	r1, r3, #8, #8
    72b8:	7041      	strb	r1, [r0, #1]
	sys_put_le16(val >> 16, &dst[2]);
    72ba:	0c19      	lsrs	r1, r3, #16
	dst[0] = val;
    72bc:	7081      	strb	r1, [r0, #2]
	dst[1] = val >> 8;
    72be:	0e1b      	lsrs	r3, r3, #24
    72c0:	70c3      	strb	r3, [r0, #3]
	dst[0] = val;
    72c2:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
    72c4:	0e13      	lsrs	r3, r2, #24
    72c6:	7143      	strb	r3, [r0, #5]
	sys_put_le16(val >> 16, &dst[2]);
    72c8:	0c13      	lsrs	r3, r2, #16
	dst[0] = val;
    72ca:	7183      	strb	r3, [r0, #6]
	dst[1] = val >> 8;
    72cc:	0e12      	lsrs	r2, r2, #24
    72ce:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
    72d0:	2200      	movs	r2, #0
    72d2:	4621      	mov	r1, r4
    72d4:	f242 0001 	movw	r0, #8193	; 0x2001
    72d8:	f7ff fe10 	bl	6efc <bt_hci_cmd_send_sync>
}
    72dc:	bd10      	pop	{r4, pc}
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
    72de:	232f      	movs	r3, #47	; 0x2f
    72e0:	2200      	movs	r2, #0
    72e2:	e7d9      	b.n	7298 <le_set_event_mask+0x28>
		return -ENOBUFS;
    72e4:	f06f 0068 	mvn.w	r0, #104	; 0x68
    72e8:	e7f8      	b.n	72dc <le_set_event_mask+0x6c>
    72ea:	bf00      	nop
    72ec:	20000000 	.word	0x20000000

000072f0 <le_init>:
{
    72f0:	b510      	push	{r4, lr}
    72f2:	b08a      	sub	sp, #40	; 0x28
	if (!BT_FEAT_LE(bt_dev.features)) {
    72f4:	4b5a      	ldr	r3, [pc, #360]	; (7460 <le_init+0x170>)
    72f6:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
    72fa:	f013 0f40 	tst.w	r3, #64	; 0x40
    72fe:	d00a      	beq.n	7316 <le_init+0x26>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
    7300:	aa03      	add	r2, sp, #12
    7302:	2100      	movs	r1, #0
    7304:	f242 0003 	movw	r0, #8195	; 0x2003
    7308:	f7ff fdf8 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    730c:	4603      	mov	r3, r0
    730e:	b350      	cbz	r0, 7366 <le_init+0x76>
}
    7310:	4618      	mov	r0, r3
    7312:	b00a      	add	sp, #40	; 0x28
    7314:	bd10      	pop	{r4, pc}
		BT_ERR("Non-LE capable controller detected!");
    7316:	4b53      	ldr	r3, [pc, #332]	; (7464 <le_init+0x174>)
    7318:	9309      	str	r3, [sp, #36]	; 0x24
    731a:	2302      	movs	r3, #2
    731c:	f88d 3008 	strb.w	r3, [sp, #8]
    7320:	2300      	movs	r3, #0
    7322:	f88d 3009 	strb.w	r3, [sp, #9]
    7326:	f88d 300a 	strb.w	r3, [sp, #10]
    732a:	f88d 300b 	strb.w	r3, [sp, #11]
    732e:	9a02      	ldr	r2, [sp, #8]
    7330:	9208      	str	r2, [sp, #32]
    7332:	4619      	mov	r1, r3
    7334:	f363 0100 	bfi	r1, r3, #0, #1
    7338:	f363 0141 	bfi	r1, r3, #1, #1
    733c:	f363 0182 	bfi	r1, r3, #2, #1
    7340:	f363 01c5 	bfi	r1, r3, #3, #3
    7344:	2201      	movs	r2, #1
    7346:	f362 1188 	bfi	r1, r2, #6, #3
    734a:	2208      	movs	r2, #8
    734c:	f362 2152 	bfi	r1, r2, #9, #10
    7350:	f363 41de 	bfi	r1, r3, #19, #12
    7354:	f363 71df 	bfi	r1, r3, #31, #1
    7358:	aa08      	add	r2, sp, #32
    735a:	4843      	ldr	r0, [pc, #268]	; (7468 <le_init+0x178>)
    735c:	f7fa ff74 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ENODEV;
    7360:	f06f 0312 	mvn.w	r3, #18
    7364:	e7d4      	b.n	7310 <le_init+0x20>
	read_le_features_complete(rsp);
    7366:	9803      	ldr	r0, [sp, #12]
    7368:	f7fe fb80 	bl	5a6c <read_le_features_complete>
	net_buf_unref(rsp);
    736c:	9803      	ldr	r0, [sp, #12]
    736e:	f012 fefc 	bl	1a16a <net_buf_unref>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
    7372:	aa03      	add	r2, sp, #12
    7374:	2100      	movs	r1, #0
    7376:	f242 0002 	movw	r0, #8194	; 0x2002
    737a:	f7ff fdbf 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    737e:	4603      	mov	r3, r0
    7380:	2800      	cmp	r0, #0
    7382:	d1c5      	bne.n	7310 <le_init+0x20>
		le_read_buffer_size_complete(rsp);
    7384:	9803      	ldr	r0, [sp, #12]
    7386:	f7fe fb7b 	bl	5a80 <le_read_buffer_size_complete>
		net_buf_unref(rsp);
    738a:	9803      	ldr	r0, [sp, #12]
    738c:	f012 feed 	bl	1a16a <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    7390:	4b33      	ldr	r3, [pc, #204]	; (7460 <le_init+0x170>)
    7392:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
    7396:	f013 0f20 	tst.w	r3, #32
    739a:	d032      	beq.n	7402 <le_init+0x112>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
    739c:	4b30      	ldr	r3, [pc, #192]	; (7460 <le_init+0x170>)
    739e:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
    73a2:	f013 0f08 	tst.w	r3, #8
    73a6:	d144      	bne.n	7432 <le_init+0x142>
	    BT_FEAT_LE_DLE(bt_dev.le.features)) {
    73a8:	4b2d      	ldr	r3, [pc, #180]	; (7460 <le_init+0x170>)
    73aa:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
	if (IS_ENABLED(CONFIG_BT_CONN) &&
    73ae:	f013 0f20 	tst.w	r3, #32
    73b2:	d022      	beq.n	73fa <le_init+0x10a>
		err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    73b4:	a902      	add	r1, sp, #8
    73b6:	f10d 0006 	add.w	r0, sp, #6
    73ba:	f7ff ff15 	bl	71e8 <hci_le_read_max_data_len>
		if (err) {
    73be:	4603      	mov	r3, r0
    73c0:	2800      	cmp	r0, #0
    73c2:	d1a5      	bne.n	7310 <le_init+0x20>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    73c4:	2104      	movs	r1, #4
    73c6:	f242 0024 	movw	r0, #8228	; 0x2024
    73ca:	f7ff fd59 	bl	6e80 <bt_hci_cmd_create>
		if (!buf) {
    73ce:	4604      	mov	r4, r0
    73d0:	2800      	cmp	r0, #0
    73d2:	d03f      	beq.n	7454 <le_init+0x164>
    73d4:	2104      	movs	r1, #4
    73d6:	3008      	adds	r0, #8
    73d8:	f012 ff11 	bl	1a1fe <net_buf_simple_add>
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
    73dc:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    73e0:	8003      	strh	r3, [r0, #0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
    73e2:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    73e6:	8043      	strh	r3, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
    73e8:	2200      	movs	r2, #0
    73ea:	4621      	mov	r1, r4
    73ec:	f242 0024 	movw	r0, #8228	; 0x2024
    73f0:	f7ff fd84 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    73f4:	4603      	mov	r3, r0
    73f6:	2800      	cmp	r0, #0
    73f8:	d18a      	bne.n	7310 <le_init+0x20>
	return  le_set_event_mask();
    73fa:	f7ff ff39 	bl	7270 <le_set_event_mask>
    73fe:	4603      	mov	r3, r0
    7400:	e786      	b.n	7310 <le_init+0x20>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
    7402:	2102      	movs	r1, #2
    7404:	f640 406d 	movw	r0, #3181	; 0xc6d
    7408:	f7ff fd3a 	bl	6e80 <bt_hci_cmd_create>
		if (!buf) {
    740c:	4604      	mov	r4, r0
    740e:	b320      	cbz	r0, 745a <le_init+0x16a>
    7410:	2102      	movs	r1, #2
    7412:	3008      	adds	r0, #8
    7414:	f012 fef3 	bl	1a1fe <net_buf_simple_add>
		cp_le->le = 0x01;
    7418:	2301      	movs	r3, #1
    741a:	7003      	strb	r3, [r0, #0]
		cp_le->simul = 0x00;
    741c:	2200      	movs	r2, #0
    741e:	7042      	strb	r2, [r0, #1]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
    7420:	4621      	mov	r1, r4
    7422:	f640 406d 	movw	r0, #3181	; 0xc6d
    7426:	f7ff fd69 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    742a:	4603      	mov	r3, r0
    742c:	2800      	cmp	r0, #0
    742e:	d0b5      	beq.n	739c <le_init+0xac>
    7430:	e76e      	b.n	7310 <le_init+0x20>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
    7432:	aa03      	add	r2, sp, #12
    7434:	2100      	movs	r1, #0
    7436:	f242 001c 	movw	r0, #8220	; 0x201c
    743a:	f7ff fd5f 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    743e:	4603      	mov	r3, r0
    7440:	2800      	cmp	r0, #0
    7442:	f47f af65 	bne.w	7310 <le_init+0x20>
		le_read_supp_states_complete(rsp);
    7446:	9803      	ldr	r0, [sp, #12]
    7448:	f7fe fa82 	bl	5950 <le_read_supp_states_complete>
		net_buf_unref(rsp);
    744c:	9803      	ldr	r0, [sp, #12]
    744e:	f012 fe8c 	bl	1a16a <net_buf_unref>
    7452:	e7a9      	b.n	73a8 <le_init+0xb8>
			return -ENOBUFS;
    7454:	f06f 0368 	mvn.w	r3, #104	; 0x68
    7458:	e75a      	b.n	7310 <le_init+0x20>
			return -ENOBUFS;
    745a:	f06f 0368 	mvn.w	r3, #104	; 0x68
    745e:	e757      	b.n	7310 <le_init+0x20>
    7460:	20000000 	.word	0x20000000
    7464:	0001e3e0 	.word	0x0001e3e0
    7468:	0001cffc 	.word	0x0001cffc

0000746c <bt_br_init>:
{
    746c:	b510      	push	{r4, lr}
    746e:	b082      	sub	sp, #8
	if (bt_dev.le.acl_mtu) {
    7470:	4b0b      	ldr	r3, [pc, #44]	; (74a0 <bt_br_init+0x34>)
    7472:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
    7476:	b11b      	cbz	r3, 7480 <bt_br_init+0x14>
		return 0;
    7478:	2400      	movs	r4, #0
}
    747a:	4620      	mov	r0, r4
    747c:	b002      	add	sp, #8
    747e:	bd10      	pop	{r4, pc}
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
    7480:	aa01      	add	r2, sp, #4
    7482:	2100      	movs	r1, #0
    7484:	f241 0005 	movw	r0, #4101	; 0x1005
    7488:	f7ff fd38 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    748c:	4604      	mov	r4, r0
    748e:	2800      	cmp	r0, #0
    7490:	d1f3      	bne.n	747a <bt_br_init+0xe>
	read_buffer_size_complete(rsp);
    7492:	9801      	ldr	r0, [sp, #4]
    7494:	f7fe fb08 	bl	5aa8 <read_buffer_size_complete>
	net_buf_unref(rsp);
    7498:	9801      	ldr	r0, [sp, #4]
    749a:	f012 fe66 	bl	1a16a <net_buf_unref>
	return 0;
    749e:	e7ec      	b.n	747a <bt_br_init+0xe>
    74a0:	20000000 	.word	0x20000000

000074a4 <hci_vs_init>:
{
    74a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74a8:	b096      	sub	sp, #88	; 0x58
    74aa:	af00      	add	r7, sp, #0
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
    74ac:	f107 020c 	add.w	r2, r7, #12
    74b0:	2100      	movs	r1, #0
    74b2:	f64f 4001 	movw	r0, #64513	; 0xfc01
    74b6:	f7ff fd21 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    74ba:	2800      	cmp	r0, #0
    74bc:	f040 812a 	bne.w	7714 <hci_vs_init+0x270>
	rp.info = (void *)rsp->data;
    74c0:	68fb      	ldr	r3, [r7, #12]
    74c2:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
    74c4:	f8b4 6001 	ldrh.w	r6, [r4, #1]
    74c8:	4630      	mov	r0, r6
    74ca:	f7fe fa81 	bl	59d0 <vs_hw_platform>
    74ce:	2302      	movs	r3, #2
    74d0:	723b      	strb	r3, [r7, #8]
    74d2:	466d      	mov	r5, sp
    74d4:	b08a      	sub	sp, #40	; 0x28
    74d6:	466b      	mov	r3, sp
    74d8:	f113 0210 	adds.w	r2, r3, #16
    74dc:	f000 813c 	beq.w	7758 <hci_vs_init+0x2b4>
    74e0:	f04f 0c11 	mov.w	ip, #17
    74e4:	b122      	cbz	r2, 74f0 <hci_vs_init+0x4c>
    74e6:	f1bc 0f04 	cmp.w	ip, #4
    74ea:	dd01      	ble.n	74f0 <hci_vs_init+0x4c>
    74ec:	49b1      	ldr	r1, [pc, #708]	; (77b4 <hci_vs_init+0x310>)
    74ee:	6159      	str	r1, [r3, #20]
    74f0:	2102      	movs	r1, #2
    74f2:	7139      	strb	r1, [r7, #4]
    74f4:	b11a      	cbz	r2, 74fe <hci_vs_init+0x5a>
    74f6:	f1bc 0f08 	cmp.w	ip, #8
    74fa:	dd00      	ble.n	74fe <hci_vs_init+0x5a>
    74fc:	6198      	str	r0, [r3, #24]
    74fe:	b11a      	cbz	r2, 7508 <hci_vs_init+0x64>
    7500:	f1bc 0f0c 	cmp.w	ip, #12
    7504:	dd00      	ble.n	7508 <hci_vs_init+0x64>
    7506:	61de      	str	r6, [r3, #28]
    7508:	b12a      	cbz	r2, 7516 <hci_vs_init+0x72>
    750a:	f103 0120 	add.w	r1, r3, #32
    750e:	2000      	movs	r0, #0
    7510:	2800      	cmp	r0, #0
    7512:	f000 8124 	beq.w	775e <hci_vs_init+0x2ba>
    7516:	f1bc 0f10 	cmp.w	ip, #16
    751a:	f340 8129 	ble.w	7770 <hci_vs_init+0x2cc>
    751e:	f04f 0c11 	mov.w	ip, #17
    7522:	b142      	cbz	r2, 7536 <hci_vs_init+0x92>
    7524:	2104      	movs	r1, #4
    7526:	7239      	strb	r1, [r7, #8]
    7528:	2100      	movs	r1, #0
    752a:	7279      	strb	r1, [r7, #9]
    752c:	72b9      	strb	r1, [r7, #10]
    752e:	2101      	movs	r1, #1
    7530:	72f9      	strb	r1, [r7, #11]
    7532:	68b8      	ldr	r0, [r7, #8]
    7534:	6118      	str	r0, [r3, #16]
    7536:	2100      	movs	r1, #0
    7538:	f36f 0100 	bfc	r1, #0, #1
    753c:	f36f 0141 	bfc	r1, #1, #1
    7540:	f36f 0182 	bfc	r1, #2, #1
    7544:	f36f 01c5 	bfc	r1, #3, #3
    7548:	2303      	movs	r3, #3
    754a:	f363 1188 	bfi	r1, r3, #6, #3
    754e:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    7552:	f36c 2152 	bfi	r1, ip, #9, #10
    7556:	f36f 41de 	bfc	r1, #19, #12
    755a:	f36f 71df 	bfc	r1, #31, #1
    755e:	2300      	movs	r3, #0
    7560:	4895      	ldr	r0, [pc, #596]	; (77b8 <hci_vs_init+0x314>)
    7562:	f7fa fe71 	bl	2248 <z_impl_z_log_msg_static_create>
    7566:	46ad      	mov	sp, r5
	BT_INFO("HW Variant: %s (0x%04x)",
    7568:	f8b4 6003 	ldrh.w	r6, [r4, #3]
    756c:	4631      	mov	r1, r6
    756e:	f8b4 0001 	ldrh.w	r0, [r4, #1]
    7572:	f7fe fa39 	bl	59e8 <vs_hw_variant>
    7576:	2302      	movs	r3, #2
    7578:	723b      	strb	r3, [r7, #8]
    757a:	466d      	mov	r5, sp
    757c:	b08a      	sub	sp, #40	; 0x28
    757e:	466b      	mov	r3, sp
    7580:	f113 0210 	adds.w	r2, r3, #16
    7584:	f000 80f7 	beq.w	7776 <hci_vs_init+0x2d2>
    7588:	f04f 0c11 	mov.w	ip, #17
    758c:	b122      	cbz	r2, 7598 <hci_vs_init+0xf4>
    758e:	f1bc 0f04 	cmp.w	ip, #4
    7592:	dd01      	ble.n	7598 <hci_vs_init+0xf4>
    7594:	4989      	ldr	r1, [pc, #548]	; (77bc <hci_vs_init+0x318>)
    7596:	6159      	str	r1, [r3, #20]
    7598:	2102      	movs	r1, #2
    759a:	7139      	strb	r1, [r7, #4]
    759c:	b11a      	cbz	r2, 75a6 <hci_vs_init+0x102>
    759e:	f1bc 0f08 	cmp.w	ip, #8
    75a2:	dd00      	ble.n	75a6 <hci_vs_init+0x102>
    75a4:	6198      	str	r0, [r3, #24]
    75a6:	b11a      	cbz	r2, 75b0 <hci_vs_init+0x10c>
    75a8:	f1bc 0f0c 	cmp.w	ip, #12
    75ac:	dd00      	ble.n	75b0 <hci_vs_init+0x10c>
    75ae:	61de      	str	r6, [r3, #28]
    75b0:	b12a      	cbz	r2, 75be <hci_vs_init+0x11a>
    75b2:	f103 0120 	add.w	r1, r3, #32
    75b6:	2000      	movs	r0, #0
    75b8:	2800      	cmp	r0, #0
    75ba:	f000 80df 	beq.w	777c <hci_vs_init+0x2d8>
    75be:	f1bc 0f10 	cmp.w	ip, #16
    75c2:	f340 80e4 	ble.w	778e <hci_vs_init+0x2ea>
    75c6:	f04f 0c11 	mov.w	ip, #17
    75ca:	b142      	cbz	r2, 75de <hci_vs_init+0x13a>
    75cc:	2104      	movs	r1, #4
    75ce:	7239      	strb	r1, [r7, #8]
    75d0:	2100      	movs	r1, #0
    75d2:	7279      	strb	r1, [r7, #9]
    75d4:	72b9      	strb	r1, [r7, #10]
    75d6:	2101      	movs	r1, #1
    75d8:	72f9      	strb	r1, [r7, #11]
    75da:	68b8      	ldr	r0, [r7, #8]
    75dc:	6118      	str	r0, [r3, #16]
    75de:	2100      	movs	r1, #0
    75e0:	f36f 0100 	bfc	r1, #0, #1
    75e4:	f36f 0141 	bfc	r1, #1, #1
    75e8:	f36f 0182 	bfc	r1, #2, #1
    75ec:	f36f 01c5 	bfc	r1, #3, #3
    75f0:	2303      	movs	r3, #3
    75f2:	f363 1188 	bfi	r1, r3, #6, #3
    75f6:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    75fa:	f36c 2152 	bfi	r1, ip, #9, #10
    75fe:	f36f 41de 	bfc	r1, #19, #12
    7602:	f36f 71df 	bfc	r1, #31, #1
    7606:	2300      	movs	r3, #0
    7608:	486b      	ldr	r0, [pc, #428]	; (77b8 <hci_vs_init+0x314>)
    760a:	f7fa fe1d 	bl	2248 <z_impl_z_log_msg_static_create>
    760e:	46ad      	mov	sp, r5
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    7610:	7965      	ldrb	r5, [r4, #5]
    7612:	4628      	mov	r0, r5
    7614:	f7fe f9f8 	bl	5a08 <vs_fw_variant>
    7618:	f894 8006 	ldrb.w	r8, [r4, #6]
    761c:	f8b4 e007 	ldrh.w	lr, [r4, #7]
    7620:	f8d4 c009 	ldr.w	ip, [r4, #9]
    7624:	2302      	movs	r3, #2
    7626:	723b      	strb	r3, [r7, #8]
    7628:	466c      	mov	r4, sp
    762a:	b08c      	sub	sp, #48	; 0x30
    762c:	466b      	mov	r3, sp
    762e:	f113 0210 	adds.w	r2, r3, #16
    7632:	f000 80af 	beq.w	7794 <hci_vs_init+0x2f0>
    7636:	211d      	movs	r1, #29
    7638:	b11a      	cbz	r2, 7642 <hci_vs_init+0x19e>
    763a:	2904      	cmp	r1, #4
    763c:	dd01      	ble.n	7642 <hci_vs_init+0x19e>
    763e:	4e60      	ldr	r6, [pc, #384]	; (77c0 <hci_vs_init+0x31c>)
    7640:	615e      	str	r6, [r3, #20]
    7642:	2602      	movs	r6, #2
    7644:	713e      	strb	r6, [r7, #4]
    7646:	b112      	cbz	r2, 764e <hci_vs_init+0x1aa>
    7648:	2908      	cmp	r1, #8
    764a:	dd00      	ble.n	764e <hci_vs_init+0x1aa>
    764c:	6198      	str	r0, [r3, #24]
    764e:	b112      	cbz	r2, 7656 <hci_vs_init+0x1b2>
    7650:	290c      	cmp	r1, #12
    7652:	dd00      	ble.n	7656 <hci_vs_init+0x1b2>
    7654:	61dd      	str	r5, [r3, #28]
    7656:	b11a      	cbz	r2, 7660 <hci_vs_init+0x1bc>
    7658:	2910      	cmp	r1, #16
    765a:	dd01      	ble.n	7660 <hci_vs_init+0x1bc>
    765c:	f8c3 8020 	str.w	r8, [r3, #32]
    7660:	b11a      	cbz	r2, 766a <hci_vs_init+0x1c6>
    7662:	2914      	cmp	r1, #20
    7664:	dd01      	ble.n	766a <hci_vs_init+0x1c6>
    7666:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
    766a:	b11a      	cbz	r2, 7674 <hci_vs_init+0x1d0>
    766c:	2918      	cmp	r1, #24
    766e:	dd01      	ble.n	7674 <hci_vs_init+0x1d0>
    7670:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
    7674:	b12a      	cbz	r2, 7682 <hci_vs_init+0x1de>
    7676:	f103 002c 	add.w	r0, r3, #44	; 0x2c
    767a:	2500      	movs	r5, #0
    767c:	2d00      	cmp	r5, #0
    767e:	f000 808c 	beq.w	779a <hci_vs_init+0x2f6>
    7682:	291c      	cmp	r1, #28
    7684:	f340 8092 	ble.w	77ac <hci_vs_init+0x308>
    7688:	251d      	movs	r5, #29
    768a:	b142      	cbz	r2, 769e <hci_vs_init+0x1fa>
    768c:	2107      	movs	r1, #7
    768e:	7239      	strb	r1, [r7, #8]
    7690:	2100      	movs	r1, #0
    7692:	7279      	strb	r1, [r7, #9]
    7694:	72b9      	strb	r1, [r7, #10]
    7696:	2101      	movs	r1, #1
    7698:	72f9      	strb	r1, [r7, #11]
    769a:	68b8      	ldr	r0, [r7, #8]
    769c:	6118      	str	r0, [r3, #16]
    769e:	2100      	movs	r1, #0
    76a0:	f36f 0100 	bfc	r1, #0, #1
    76a4:	f36f 0141 	bfc	r1, #1, #1
    76a8:	f36f 0182 	bfc	r1, #2, #1
    76ac:	f36f 01c5 	bfc	r1, #3, #3
    76b0:	2303      	movs	r3, #3
    76b2:	f363 1188 	bfi	r1, r3, #6, #3
    76b6:	f3c5 0509 	ubfx	r5, r5, #0, #10
    76ba:	f365 2152 	bfi	r1, r5, #9, #10
    76be:	f36f 41de 	bfc	r1, #19, #12
    76c2:	f36f 71df 	bfc	r1, #31, #1
    76c6:	2300      	movs	r3, #0
    76c8:	483b      	ldr	r0, [pc, #236]	; (77b8 <hci_vs_init+0x314>)
    76ca:	f7fa fdbd 	bl	2248 <z_impl_z_log_msg_static_create>
    76ce:	46a5      	mov	sp, r4
	net_buf_unref(rsp);
    76d0:	68f8      	ldr	r0, [r7, #12]
    76d2:	f012 fd4a 	bl	1a16a <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
    76d6:	f107 020c 	add.w	r2, r7, #12
    76da:	2100      	movs	r1, #0
    76dc:	f64f 4002 	movw	r0, #64514	; 0xfc02
    76e0:	f7ff fc0c 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    76e4:	2800      	cmp	r0, #0
    76e6:	d171      	bne.n	77cc <hci_vs_init+0x328>
	rp.cmds = (void *)rsp->data;
    76e8:	68fb      	ldr	r3, [r7, #12]
    76ea:	6899      	ldr	r1, [r3, #8]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
    76ec:	4c35      	ldr	r4, [pc, #212]	; (77c4 <hci_vs_init+0x320>)
    76ee:	2202      	movs	r2, #2
    76f0:	3101      	adds	r1, #1
    76f2:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
    76f6:	f010 f81b 	bl	17730 <memcpy>
	net_buf_unref(rsp);
    76fa:	68f8      	ldr	r0, [r7, #12]
    76fc:	f012 fd35 	bl	1a16a <net_buf_unref>
	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
    7700:	f894 30b9 	ldrb.w	r3, [r4, #185]	; 0xb9
    7704:	f013 0f04 	tst.w	r3, #4
    7708:	f040 8082 	bne.w	7810 <hci_vs_init+0x36c>
}
    770c:	3758      	adds	r7, #88	; 0x58
    770e:	46bd      	mov	sp, r7
    7710:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_WARN("Vendor HCI extensions not available");
    7714:	4b2c      	ldr	r3, [pc, #176]	; (77c8 <hci_vs_init+0x324>)
    7716:	657b      	str	r3, [r7, #84]	; 0x54
    7718:	2202      	movs	r2, #2
    771a:	723a      	strb	r2, [r7, #8]
    771c:	2300      	movs	r3, #0
    771e:	727b      	strb	r3, [r7, #9]
    7720:	72bb      	strb	r3, [r7, #10]
    7722:	72fb      	strb	r3, [r7, #11]
    7724:	68b9      	ldr	r1, [r7, #8]
    7726:	6539      	str	r1, [r7, #80]	; 0x50
    7728:	4619      	mov	r1, r3
    772a:	f363 0100 	bfi	r1, r3, #0, #1
    772e:	f363 0141 	bfi	r1, r3, #1, #1
    7732:	f363 0182 	bfi	r1, r3, #2, #1
    7736:	f363 01c5 	bfi	r1, r3, #3, #3
    773a:	f362 1188 	bfi	r1, r2, #6, #3
    773e:	2208      	movs	r2, #8
    7740:	f362 2152 	bfi	r1, r2, #9, #10
    7744:	f363 41de 	bfi	r1, r3, #19, #12
    7748:	f363 71df 	bfi	r1, r3, #31, #1
    774c:	f107 0250 	add.w	r2, r7, #80	; 0x50
    7750:	4819      	ldr	r0, [pc, #100]	; (77b8 <hci_vs_init+0x314>)
    7752:	f7fa fd79 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    7756:	e7d9      	b.n	770c <hci_vs_init+0x268>
	BT_INFO("HW Platform: %s (0x%04x)",
    7758:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    775c:	e6c2      	b.n	74e4 <hci_vs_init+0x40>
    775e:	f107 0658 	add.w	r6, r7, #88	; 0x58
    7762:	4406      	add	r6, r0
    7764:	f816 6c54 	ldrb.w	r6, [r6, #-84]
    7768:	f801 6b01 	strb.w	r6, [r1], #1
    776c:	3001      	adds	r0, #1
    776e:	e6cf      	b.n	7510 <hci_vs_init+0x6c>
    7770:	f06f 0c1b 	mvn.w	ip, #27
    7774:	e6d5      	b.n	7522 <hci_vs_init+0x7e>
	BT_INFO("HW Variant: %s (0x%04x)",
    7776:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    777a:	e707      	b.n	758c <hci_vs_init+0xe8>
    777c:	f107 0658 	add.w	r6, r7, #88	; 0x58
    7780:	4406      	add	r6, r0
    7782:	f816 6c54 	ldrb.w	r6, [r6, #-84]
    7786:	f801 6b01 	strb.w	r6, [r1], #1
    778a:	3001      	adds	r0, #1
    778c:	e714      	b.n	75b8 <hci_vs_init+0x114>
    778e:	f06f 0c1b 	mvn.w	ip, #27
    7792:	e71a      	b.n	75ca <hci_vs_init+0x126>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
    7794:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7798:	e74e      	b.n	7638 <hci_vs_init+0x194>
    779a:	f107 0658 	add.w	r6, r7, #88	; 0x58
    779e:	442e      	add	r6, r5
    77a0:	f816 6c54 	ldrb.w	r6, [r6, #-84]
    77a4:	f800 6b01 	strb.w	r6, [r0], #1
    77a8:	3501      	adds	r5, #1
    77aa:	e767      	b.n	767c <hci_vs_init+0x1d8>
    77ac:	f06f 051b 	mvn.w	r5, #27
    77b0:	e76b      	b.n	768a <hci_vs_init+0x1e6>
    77b2:	bf00      	nop
    77b4:	0001e428 	.word	0x0001e428
    77b8:	0001cffc 	.word	0x0001cffc
    77bc:	0001e444 	.word	0x0001e444
    77c0:	0001e45c 	.word	0x0001e45c
    77c4:	20000000 	.word	0x20000000
    77c8:	0001e404 	.word	0x0001e404
		BT_WARN("Failed to read supported vendor commands");
    77cc:	4b2b      	ldr	r3, [pc, #172]	; (787c <hci_vs_init+0x3d8>)
    77ce:	63fb      	str	r3, [r7, #60]	; 0x3c
    77d0:	2202      	movs	r2, #2
    77d2:	723a      	strb	r2, [r7, #8]
    77d4:	2300      	movs	r3, #0
    77d6:	727b      	strb	r3, [r7, #9]
    77d8:	72bb      	strb	r3, [r7, #10]
    77da:	72fb      	strb	r3, [r7, #11]
    77dc:	68b9      	ldr	r1, [r7, #8]
    77de:	63b9      	str	r1, [r7, #56]	; 0x38
    77e0:	4619      	mov	r1, r3
    77e2:	f363 0100 	bfi	r1, r3, #0, #1
    77e6:	f363 0141 	bfi	r1, r3, #1, #1
    77ea:	f363 0182 	bfi	r1, r3, #2, #1
    77ee:	f363 01c5 	bfi	r1, r3, #3, #3
    77f2:	f362 1188 	bfi	r1, r2, #6, #3
    77f6:	2208      	movs	r2, #8
    77f8:	f362 2152 	bfi	r1, r2, #9, #10
    77fc:	f363 41de 	bfi	r1, r3, #19, #12
    7800:	f363 71df 	bfi	r1, r3, #31, #1
    7804:	f107 0238 	add.w	r2, r7, #56	; 0x38
    7808:	481d      	ldr	r0, [pc, #116]	; (7880 <hci_vs_init+0x3dc>)
    780a:	f7fa fd1d 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    780e:	e77d      	b.n	770c <hci_vs_init+0x268>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
    7810:	f107 020c 	add.w	r2, r7, #12
    7814:	2100      	movs	r1, #0
    7816:	f64f 4003 	movw	r0, #64515	; 0xfc03
    781a:	f7ff fb6f 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    781e:	b950      	cbnz	r0, 7836 <hci_vs_init+0x392>
		rp.feat = (void *)rsp->data;
    7820:	68fb      	ldr	r3, [r7, #12]
    7822:	6899      	ldr	r1, [r3, #8]
		memcpy(bt_dev.vs_features, rp.feat->features,
    7824:	2201      	movs	r2, #1
    7826:	4411      	add	r1, r2
    7828:	4816      	ldr	r0, [pc, #88]	; (7884 <hci_vs_init+0x3e0>)
    782a:	f00f ff81 	bl	17730 <memcpy>
		net_buf_unref(rsp);
    782e:	68f8      	ldr	r0, [r7, #12]
    7830:	f012 fc9b 	bl	1a16a <net_buf_unref>
    7834:	e76a      	b.n	770c <hci_vs_init+0x268>
			BT_WARN("Failed to read supported vendor features");
    7836:	4b14      	ldr	r3, [pc, #80]	; (7888 <hci_vs_init+0x3e4>)
    7838:	627b      	str	r3, [r7, #36]	; 0x24
    783a:	2202      	movs	r2, #2
    783c:	723a      	strb	r2, [r7, #8]
    783e:	2300      	movs	r3, #0
    7840:	727b      	strb	r3, [r7, #9]
    7842:	72bb      	strb	r3, [r7, #10]
    7844:	72fb      	strb	r3, [r7, #11]
    7846:	68b9      	ldr	r1, [r7, #8]
    7848:	6239      	str	r1, [r7, #32]
    784a:	4619      	mov	r1, r3
    784c:	f363 0100 	bfi	r1, r3, #0, #1
    7850:	f363 0141 	bfi	r1, r3, #1, #1
    7854:	f363 0182 	bfi	r1, r3, #2, #1
    7858:	f363 01c5 	bfi	r1, r3, #3, #3
    785c:	f362 1188 	bfi	r1, r2, #6, #3
    7860:	2208      	movs	r2, #8
    7862:	f362 2152 	bfi	r1, r2, #9, #10
    7866:	f363 41de 	bfi	r1, r3, #19, #12
    786a:	f363 71df 	bfi	r1, r3, #31, #1
    786e:	f107 0220 	add.w	r2, r7, #32
    7872:	4803      	ldr	r0, [pc, #12]	; (7880 <hci_vs_init+0x3dc>)
    7874:	f7fa fce8 	bl	2248 <z_impl_z_log_msg_static_create>
			return;
    7878:	e748      	b.n	770c <hci_vs_init+0x268>
    787a:	bf00      	nop
    787c:	0001e48c 	.word	0x0001e48c
    7880:	0001cffc 	.word	0x0001cffc
    7884:	200000b8 	.word	0x200000b8
    7888:	0001e4b8 	.word	0x0001e4b8

0000788c <hci_init>:
{
    788c:	b500      	push	{lr}
    788e:	b089      	sub	sp, #36	; 0x24
	err = common_init();
    7890:	f7ff fc58 	bl	7144 <common_init>
	if (err) {
    7894:	4603      	mov	r3, r0
    7896:	b118      	cbz	r0, 78a0 <hci_init+0x14>
}
    7898:	4618      	mov	r0, r3
    789a:	b009      	add	sp, #36	; 0x24
    789c:	f85d fb04 	ldr.w	pc, [sp], #4
	err = le_init();
    78a0:	f7ff fd26 	bl	72f0 <le_init>
	if (err) {
    78a4:	4603      	mov	r3, r0
    78a6:	2800      	cmp	r0, #0
    78a8:	d1f6      	bne.n	7898 <hci_init+0xc>
	if (BT_FEAT_BREDR(bt_dev.features)) {
    78aa:	4b21      	ldr	r3, [pc, #132]	; (7930 <hci_init+0xa4>)
    78ac:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
    78b0:	f013 0f20 	tst.w	r3, #32
    78b4:	d00e      	beq.n	78d4 <hci_init+0x48>
	else if (!bt_dev.le.acl_mtu) {
    78b6:	4b1e      	ldr	r3, [pc, #120]	; (7930 <hci_init+0xa4>)
    78b8:	f8b3 30fc 	ldrh.w	r3, [r3, #252]	; 0xfc
    78bc:	b183      	cbz	r3, 78e0 <hci_init+0x54>
	err = set_event_mask();
    78be:	f010 f810 	bl	178e2 <set_event_mask>
	if (err) {
    78c2:	4603      	mov	r3, r0
    78c4:	2800      	cmp	r0, #0
    78c6:	d1e7      	bne.n	7898 <hci_init+0xc>
	hci_vs_init();
    78c8:	f7ff fdec 	bl	74a4 <hci_vs_init>
	err = bt_id_init();
    78cc:	f001 faa6 	bl	8e1c <bt_id_init>
    78d0:	4603      	mov	r3, r0
	if (err) {
    78d2:	e7e1      	b.n	7898 <hci_init+0xc>
		err = bt_br_init();
    78d4:	f7ff fdca 	bl	746c <bt_br_init>
		if (err) {
    78d8:	4603      	mov	r3, r0
    78da:	2800      	cmp	r0, #0
    78dc:	d0ef      	beq.n	78be <hci_init+0x32>
    78de:	e7db      	b.n	7898 <hci_init+0xc>
		BT_ERR("ACL BR/EDR buffers not initialized");
    78e0:	4b14      	ldr	r3, [pc, #80]	; (7934 <hci_init+0xa8>)
    78e2:	9307      	str	r3, [sp, #28]
    78e4:	2302      	movs	r3, #2
    78e6:	f88d 3004 	strb.w	r3, [sp, #4]
    78ea:	2300      	movs	r3, #0
    78ec:	f88d 3005 	strb.w	r3, [sp, #5]
    78f0:	f88d 3006 	strb.w	r3, [sp, #6]
    78f4:	f88d 3007 	strb.w	r3, [sp, #7]
    78f8:	9a01      	ldr	r2, [sp, #4]
    78fa:	9206      	str	r2, [sp, #24]
    78fc:	4619      	mov	r1, r3
    78fe:	f363 0100 	bfi	r1, r3, #0, #1
    7902:	f363 0141 	bfi	r1, r3, #1, #1
    7906:	f363 0182 	bfi	r1, r3, #2, #1
    790a:	f363 01c5 	bfi	r1, r3, #3, #3
    790e:	2201      	movs	r2, #1
    7910:	f362 1188 	bfi	r1, r2, #6, #3
    7914:	2208      	movs	r2, #8
    7916:	f362 2152 	bfi	r1, r2, #9, #10
    791a:	f363 41de 	bfi	r1, r3, #19, #12
    791e:	f363 71df 	bfi	r1, r3, #31, #1
    7922:	aa06      	add	r2, sp, #24
    7924:	4804      	ldr	r0, [pc, #16]	; (7938 <hci_init+0xac>)
    7926:	f7fa fc8f 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    792a:	f06f 0304 	mvn.w	r3, #4
    792e:	e7b3      	b.n	7898 <hci_init+0xc>
    7930:	20000000 	.word	0x20000000
    7934:	0001e4e4 	.word	0x0001e4e4
    7938:	0001cffc 	.word	0x0001cffc

0000793c <bt_hci_le_rand>:
{
    793c:	b570      	push	{r4, r5, r6, lr}
    793e:	b082      	sub	sp, #8
    7940:	4606      	mov	r6, r0
    7942:	460c      	mov	r4, r1
	if (!BT_CMD_TEST(bt_dev.supported_commands, 27, 7)) {
    7944:	4b12      	ldr	r3, [pc, #72]	; (7990 <bt_hci_le_rand+0x54>)
    7946:	f993 3093 	ldrsb.w	r3, [r3, #147]	; 0x93
    794a:	2b00      	cmp	r3, #0
    794c:	da1d      	bge.n	798a <bt_hci_le_rand+0x4e>
	while (len > 0) {
    794e:	b1c4      	cbz	r4, 7982 <bt_hci_le_rand+0x46>
		count = MIN(len, sizeof(rp->rand));
    7950:	4625      	mov	r5, r4
    7952:	2c08      	cmp	r4, #8
    7954:	bf28      	it	cs
    7956:	2508      	movcs	r5, #8
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_RAND, NULL, &rsp);
    7958:	aa01      	add	r2, sp, #4
    795a:	2100      	movs	r1, #0
    795c:	f242 0018 	movw	r0, #8216	; 0x2018
    7960:	f7ff facc 	bl	6efc <bt_hci_cmd_send_sync>
		if (err) {
    7964:	4603      	mov	r3, r0
    7966:	b968      	cbnz	r0, 7984 <bt_hci_le_rand+0x48>
		rp = (void *)rsp->data;
    7968:	9b01      	ldr	r3, [sp, #4]
    796a:	6899      	ldr	r1, [r3, #8]
		memcpy(buffer, rp->rand, count);
    796c:	462a      	mov	r2, r5
    796e:	3101      	adds	r1, #1
    7970:	4630      	mov	r0, r6
    7972:	f00f fedd 	bl	17730 <memcpy>
		net_buf_unref(rsp);
    7976:	9801      	ldr	r0, [sp, #4]
    7978:	f012 fbf7 	bl	1a16a <net_buf_unref>
		buffer = (uint8_t *)buffer + count;
    797c:	442e      	add	r6, r5
		len -= count;
    797e:	1b64      	subs	r4, r4, r5
    7980:	e7e5      	b.n	794e <bt_hci_le_rand+0x12>
	return 0;
    7982:	2300      	movs	r3, #0
}
    7984:	4618      	mov	r0, r3
    7986:	b002      	add	sp, #8
    7988:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOTSUP;
    798a:	f06f 0385 	mvn.w	r3, #133	; 0x85
    798e:	e7f9      	b.n	7984 <bt_hci_le_rand+0x48>
    7990:	20000000 	.word	0x20000000

00007994 <conn_auto_initiate>:
	if (conn->state != BT_CONN_CONNECTED) {
    7994:	7a83      	ldrb	r3, [r0, #10]
    7996:	2b07      	cmp	r3, #7
    7998:	d000      	beq.n	799c <conn_auto_initiate+0x8>
    799a:	4770      	bx	lr
{
    799c:	b5f0      	push	{r4, r5, r6, r7, lr}
    799e:	b085      	sub	sp, #20
    79a0:	af02      	add	r7, sp, #8
    79a2:	4604      	mov	r4, r0
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    79a4:	1d03      	adds	r3, r0, #4
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    79a6:	e8d3 3faf 	lda	r3, [r3]
    79aa:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    79ae:	d142      	bne.n	7a36 <conn_auto_initiate+0xa2>
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
    79b0:	78c3      	ldrb	r3, [r0, #3]
	if (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&
    79b2:	b12b      	cbz	r3, 79c0 <conn_auto_initiate+0x2c>
	     BT_FEAT_LE_PER_INIT_FEAT_XCHG(bt_dev.le.features))) {
    79b4:	4b78      	ldr	r3, [pc, #480]	; (7b98 <conn_auto_initiate+0x204>)
    79b6:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
	    ((conn->role == BT_HCI_ROLE_CENTRAL) ||
    79ba:	f013 0f08 	tst.w	r3, #8
    79be:	d03a      	beq.n	7a36 <conn_auto_initiate+0xa2>
		err = hci_le_read_remote_features(conn);
    79c0:	4620      	mov	r0, r4
    79c2:	f00f ffb0 	bl	17926 <hci_le_read_remote_features>
		if (err) {
    79c6:	4606      	mov	r6, r0
    79c8:	b3a8      	cbz	r0, 7a36 <conn_auto_initiate+0xa2>
			BT_ERR("Failed read remote features (%d)", err);
    79ca:	466d      	mov	r5, sp
    79cc:	b088      	sub	sp, #32
    79ce:	ab02      	add	r3, sp, #8
    79d0:	f113 0210 	adds.w	r2, r3, #16
    79d4:	d049      	beq.n	7a6a <conn_auto_initiate+0xd6>
    79d6:	210c      	movs	r1, #12
    79d8:	b11a      	cbz	r2, 79e2 <conn_auto_initiate+0x4e>
    79da:	2904      	cmp	r1, #4
    79dc:	dd01      	ble.n	79e2 <conn_auto_initiate+0x4e>
    79de:	486f      	ldr	r0, [pc, #444]	; (7b9c <conn_auto_initiate+0x208>)
    79e0:	6158      	str	r0, [r3, #20]
    79e2:	b112      	cbz	r2, 79ea <conn_auto_initiate+0x56>
    79e4:	2908      	cmp	r1, #8
    79e6:	dd00      	ble.n	79ea <conn_auto_initiate+0x56>
    79e8:	619e      	str	r6, [r3, #24]
    79ea:	290b      	cmp	r1, #11
    79ec:	dd40      	ble.n	7a70 <conn_auto_initiate+0xdc>
    79ee:	f04f 0c0c 	mov.w	ip, #12
    79f2:	b13a      	cbz	r2, 7a04 <conn_auto_initiate+0x70>
    79f4:	2103      	movs	r1, #3
    79f6:	7139      	strb	r1, [r7, #4]
    79f8:	2100      	movs	r1, #0
    79fa:	7179      	strb	r1, [r7, #5]
    79fc:	71b9      	strb	r1, [r7, #6]
    79fe:	71f9      	strb	r1, [r7, #7]
    7a00:	6878      	ldr	r0, [r7, #4]
    7a02:	6118      	str	r0, [r3, #16]
    7a04:	2100      	movs	r1, #0
    7a06:	f36f 0100 	bfc	r1, #0, #1
    7a0a:	f36f 0141 	bfc	r1, #1, #1
    7a0e:	f36f 0182 	bfc	r1, #2, #1
    7a12:	f36f 01c5 	bfc	r1, #3, #3
    7a16:	2301      	movs	r3, #1
    7a18:	f363 1188 	bfi	r1, r3, #6, #3
    7a1c:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    7a20:	f36c 2152 	bfi	r1, ip, #9, #10
    7a24:	f36f 41de 	bfc	r1, #19, #12
    7a28:	f36f 71df 	bfc	r1, #31, #1
    7a2c:	2300      	movs	r3, #0
    7a2e:	485c      	ldr	r0, [pc, #368]	; (7ba0 <conn_auto_initiate+0x20c>)
    7a30:	f7fa fc0a 	bl	2248 <z_impl_z_log_msg_static_create>
    7a34:	46ad      	mov	sp, r5
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&
    7a36:	4b58      	ldr	r3, [pc, #352]	; (7b98 <conn_auto_initiate+0x204>)
    7a38:	f893 30d1 	ldrb.w	r3, [r3, #209]	; 0xd1
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
    7a3c:	f013 0f01 	tst.w	r3, #1
    7a40:	d003      	beq.n	7a4a <conn_auto_initiate+0xb6>
	    !skip_auto_phy_update_on_conn_establishment(conn)) {
    7a42:	4620      	mov	r0, r4
    7a44:	f00f ff33 	bl	178ae <skip_auto_phy_update_on_conn_establishment>
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&
    7a48:	b1a8      	cbz	r0, 7a76 <conn_auto_initiate+0xe2>
	    BT_FEAT_LE_DLE(bt_dev.le.features)) {
    7a4a:	4b53      	ldr	r3, [pc, #332]	; (7b98 <conn_auto_initiate+0x204>)
    7a4c:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
	if (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&
    7a50:	f013 0f20 	tst.w	r3, #32
    7a54:	d006      	beq.n	7a64 <conn_auto_initiate+0xd0>
		if (IS_BT_QUIRK_NO_AUTO_DLE(&bt_dev)) {
    7a56:	4b50      	ldr	r3, [pc, #320]	; (7b98 <conn_auto_initiate+0x204>)
    7a58:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
    7a5c:	689b      	ldr	r3, [r3, #8]
    7a5e:	f013 0f02 	tst.w	r3, #2
    7a62:	d14e      	bne.n	7b02 <conn_auto_initiate+0x16e>
}
    7a64:	370c      	adds	r7, #12
    7a66:	46bd      	mov	sp, r7
    7a68:	bdf0      	pop	{r4, r5, r6, r7, pc}
			BT_ERR("Failed read remote features (%d)", err);
    7a6a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7a6e:	e7b3      	b.n	79d8 <conn_auto_initiate+0x44>
    7a70:	f06f 0c1b 	mvn.w	ip, #27
    7a74:	e7bd      	b.n	79f2 <conn_auto_initiate+0x5e>
		err = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,
    7a76:	2100      	movs	r1, #0
    7a78:	9100      	str	r1, [sp, #0]
    7a7a:	2302      	movs	r3, #2
    7a7c:	461a      	mov	r2, r3
    7a7e:	4620      	mov	r0, r4
    7a80:	f00f ffa1 	bl	179c6 <bt_le_set_phy>
		if (err) {
    7a84:	4605      	mov	r5, r0
    7a86:	2800      	cmp	r0, #0
    7a88:	d0df      	beq.n	7a4a <conn_auto_initiate+0xb6>
			BT_ERR("Failed LE Set PHY (%d)", err);
    7a8a:	466e      	mov	r6, sp
    7a8c:	b088      	sub	sp, #32
    7a8e:	ab02      	add	r3, sp, #8
    7a90:	f113 0210 	adds.w	r2, r3, #16
    7a94:	d02f      	beq.n	7af6 <conn_auto_initiate+0x162>
    7a96:	210c      	movs	r1, #12
    7a98:	b11a      	cbz	r2, 7aa2 <conn_auto_initiate+0x10e>
    7a9a:	2904      	cmp	r1, #4
    7a9c:	dd01      	ble.n	7aa2 <conn_auto_initiate+0x10e>
    7a9e:	4841      	ldr	r0, [pc, #260]	; (7ba4 <conn_auto_initiate+0x210>)
    7aa0:	6158      	str	r0, [r3, #20]
    7aa2:	b112      	cbz	r2, 7aaa <conn_auto_initiate+0x116>
    7aa4:	2908      	cmp	r1, #8
    7aa6:	dd00      	ble.n	7aaa <conn_auto_initiate+0x116>
    7aa8:	619d      	str	r5, [r3, #24]
    7aaa:	290b      	cmp	r1, #11
    7aac:	dd26      	ble.n	7afc <conn_auto_initiate+0x168>
    7aae:	250c      	movs	r5, #12
    7ab0:	b13a      	cbz	r2, 7ac2 <conn_auto_initiate+0x12e>
    7ab2:	2103      	movs	r1, #3
    7ab4:	7139      	strb	r1, [r7, #4]
    7ab6:	2100      	movs	r1, #0
    7ab8:	7179      	strb	r1, [r7, #5]
    7aba:	71b9      	strb	r1, [r7, #6]
    7abc:	71f9      	strb	r1, [r7, #7]
    7abe:	6878      	ldr	r0, [r7, #4]
    7ac0:	6118      	str	r0, [r3, #16]
    7ac2:	2100      	movs	r1, #0
    7ac4:	f36f 0100 	bfc	r1, #0, #1
    7ac8:	f36f 0141 	bfc	r1, #1, #1
    7acc:	f36f 0182 	bfc	r1, #2, #1
    7ad0:	f36f 01c5 	bfc	r1, #3, #3
    7ad4:	2301      	movs	r3, #1
    7ad6:	f363 1188 	bfi	r1, r3, #6, #3
    7ada:	f405 737b 	and.w	r3, r5, #1004	; 0x3ec
    7ade:	f363 2152 	bfi	r1, r3, #9, #10
    7ae2:	f36f 41de 	bfc	r1, #19, #12
    7ae6:	f36f 71df 	bfc	r1, #31, #1
    7aea:	2300      	movs	r3, #0
    7aec:	482c      	ldr	r0, [pc, #176]	; (7ba0 <conn_auto_initiate+0x20c>)
    7aee:	f7fa fbab 	bl	2248 <z_impl_z_log_msg_static_create>
    7af2:	46b5      	mov	sp, r6
    7af4:	e7a9      	b.n	7a4a <conn_auto_initiate+0xb6>
    7af6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7afa:	e7cd      	b.n	7a98 <conn_auto_initiate+0x104>
    7afc:	f06f 051b 	mvn.w	r5, #27
    7b00:	e7d6      	b.n	7ab0 <conn_auto_initiate+0x11c>
			err = hci_le_read_max_data_len(&tx_octets, &tx_time);
    7b02:	1cb9      	adds	r1, r7, #2
    7b04:	4638      	mov	r0, r7
    7b06:	f7ff fb6f 	bl	71e8 <hci_le_read_max_data_len>
			if (!err) {
    7b0a:	2800      	cmp	r0, #0
    7b0c:	d1aa      	bne.n	7a64 <conn_auto_initiate+0xd0>
				err = bt_le_set_data_len(conn,
    7b0e:	887a      	ldrh	r2, [r7, #2]
    7b10:	8839      	ldrh	r1, [r7, #0]
    7b12:	4620      	mov	r0, r4
    7b14:	f00f ff3a 	bl	1798c <bt_le_set_data_len>
				if (err) {
    7b18:	4604      	mov	r4, r0
    7b1a:	2800      	cmp	r0, #0
    7b1c:	d0a2      	beq.n	7a64 <conn_auto_initiate+0xd0>
					BT_ERR("Failed to set data len (%d)", err);
    7b1e:	466d      	mov	r5, sp
    7b20:	b088      	sub	sp, #32
    7b22:	ab02      	add	r3, sp, #8
    7b24:	f113 0210 	adds.w	r2, r3, #16
    7b28:	d02f      	beq.n	7b8a <conn_auto_initiate+0x1f6>
    7b2a:	210c      	movs	r1, #12
    7b2c:	b11a      	cbz	r2, 7b36 <conn_auto_initiate+0x1a2>
    7b2e:	2904      	cmp	r1, #4
    7b30:	dd01      	ble.n	7b36 <conn_auto_initiate+0x1a2>
    7b32:	481d      	ldr	r0, [pc, #116]	; (7ba8 <conn_auto_initiate+0x214>)
    7b34:	6158      	str	r0, [r3, #20]
    7b36:	b112      	cbz	r2, 7b3e <conn_auto_initiate+0x1aa>
    7b38:	2908      	cmp	r1, #8
    7b3a:	dd00      	ble.n	7b3e <conn_auto_initiate+0x1aa>
    7b3c:	619c      	str	r4, [r3, #24]
    7b3e:	290b      	cmp	r1, #11
    7b40:	dd26      	ble.n	7b90 <conn_auto_initiate+0x1fc>
    7b42:	240c      	movs	r4, #12
    7b44:	b13a      	cbz	r2, 7b56 <conn_auto_initiate+0x1c2>
    7b46:	2103      	movs	r1, #3
    7b48:	7139      	strb	r1, [r7, #4]
    7b4a:	2100      	movs	r1, #0
    7b4c:	7179      	strb	r1, [r7, #5]
    7b4e:	71b9      	strb	r1, [r7, #6]
    7b50:	71f9      	strb	r1, [r7, #7]
    7b52:	6878      	ldr	r0, [r7, #4]
    7b54:	6118      	str	r0, [r3, #16]
    7b56:	2100      	movs	r1, #0
    7b58:	f36f 0100 	bfc	r1, #0, #1
    7b5c:	f36f 0141 	bfc	r1, #1, #1
    7b60:	f36f 0182 	bfc	r1, #2, #1
    7b64:	f36f 01c5 	bfc	r1, #3, #3
    7b68:	2301      	movs	r3, #1
    7b6a:	f363 1188 	bfi	r1, r3, #6, #3
    7b6e:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    7b72:	f363 2152 	bfi	r1, r3, #9, #10
    7b76:	f36f 41de 	bfc	r1, #19, #12
    7b7a:	f36f 71df 	bfc	r1, #31, #1
    7b7e:	2300      	movs	r3, #0
    7b80:	4807      	ldr	r0, [pc, #28]	; (7ba0 <conn_auto_initiate+0x20c>)
    7b82:	f7fa fb61 	bl	2248 <z_impl_z_log_msg_static_create>
    7b86:	46ad      	mov	sp, r5
		}
    7b88:	e76c      	b.n	7a64 <conn_auto_initiate+0xd0>
					BT_ERR("Failed to set data len (%d)", err);
    7b8a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7b8e:	e7cd      	b.n	7b2c <conn_auto_initiate+0x198>
    7b90:	f06f 041b 	mvn.w	r4, #27
    7b94:	e7d6      	b.n	7b44 <conn_auto_initiate+0x1b0>
    7b96:	bf00      	nop
    7b98:	20000000 	.word	0x20000000
    7b9c:	0001e508 	.word	0x0001e508
    7ba0:	0001cffc 	.word	0x0001cffc
    7ba4:	0001e52c 	.word	0x0001e52c
    7ba8:	0001e544 	.word	0x0001e544

00007bac <bt_hci_le_enh_conn_complete>:
{
    7bac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7bb0:	b087      	sub	sp, #28
    7bb2:	af00      	add	r7, sp, #0
    7bb4:	4604      	mov	r4, r0
	uint16_t handle = sys_le16_to_cpu(evt->handle);
    7bb6:	f8b0 8001 	ldrh.w	r8, [r0, #1]
    7bba:	fa1f f988 	uxth.w	r9, r8
	bool is_disconnected = conn_handle_is_disconnected(handle);
    7bbe:	4648      	mov	r0, r9
    7bc0:	f7fd fe9a 	bl	58f8 <conn_handle_is_disconnected>
    7bc4:	4606      	mov	r6, r0
	if (evt->status) {
    7bc6:	7820      	ldrb	r0, [r4, #0]
    7bc8:	2800      	cmp	r0, #0
    7bca:	d040      	beq.n	7c4e <bt_hci_le_enh_conn_complete+0xa2>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7bcc:	283c      	cmp	r0, #60	; 0x3c
    7bce:	d035      	beq.n	7c3c <bt_hci_le_enh_conn_complete+0x90>
		BT_WARN("Unexpected status 0x%02x", evt->status);
    7bd0:	466d      	mov	r5, sp
    7bd2:	b088      	sub	sp, #32
    7bd4:	466b      	mov	r3, sp
    7bd6:	f113 0210 	adds.w	r2, r3, #16
    7bda:	d032      	beq.n	7c42 <bt_hci_le_enh_conn_complete+0x96>
    7bdc:	210c      	movs	r1, #12
    7bde:	b11a      	cbz	r2, 7be8 <bt_hci_le_enh_conn_complete+0x3c>
    7be0:	2904      	cmp	r1, #4
    7be2:	dd01      	ble.n	7be8 <bt_hci_le_enh_conn_complete+0x3c>
    7be4:	4c91      	ldr	r4, [pc, #580]	; (7e2c <bt_hci_le_enh_conn_complete+0x280>)
    7be6:	615c      	str	r4, [r3, #20]
    7be8:	b112      	cbz	r2, 7bf0 <bt_hci_le_enh_conn_complete+0x44>
    7bea:	2908      	cmp	r1, #8
    7bec:	dd00      	ble.n	7bf0 <bt_hci_le_enh_conn_complete+0x44>
    7bee:	6198      	str	r0, [r3, #24]
    7bf0:	290b      	cmp	r1, #11
    7bf2:	dd29      	ble.n	7c48 <bt_hci_le_enh_conn_complete+0x9c>
    7bf4:	240c      	movs	r4, #12
    7bf6:	b13a      	cbz	r2, 7c08 <bt_hci_le_enh_conn_complete+0x5c>
    7bf8:	2103      	movs	r1, #3
    7bfa:	7139      	strb	r1, [r7, #4]
    7bfc:	2100      	movs	r1, #0
    7bfe:	7179      	strb	r1, [r7, #5]
    7c00:	71b9      	strb	r1, [r7, #6]
    7c02:	71f9      	strb	r1, [r7, #7]
    7c04:	6878      	ldr	r0, [r7, #4]
    7c06:	6118      	str	r0, [r3, #16]
    7c08:	2100      	movs	r1, #0
    7c0a:	f36f 0100 	bfc	r1, #0, #1
    7c0e:	f36f 0141 	bfc	r1, #1, #1
    7c12:	f36f 0182 	bfc	r1, #2, #1
    7c16:	f36f 01c5 	bfc	r1, #3, #3
    7c1a:	2302      	movs	r3, #2
    7c1c:	f363 1188 	bfi	r1, r3, #6, #3
    7c20:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    7c24:	f364 2152 	bfi	r1, r4, #9, #10
    7c28:	f36f 41de 	bfc	r1, #19, #12
    7c2c:	f36f 71df 	bfc	r1, #31, #1
    7c30:	2300      	movs	r3, #0
    7c32:	487f      	ldr	r0, [pc, #508]	; (7e30 <bt_hci_le_enh_conn_complete+0x284>)
    7c34:	f7fa fb08 	bl	2248 <z_impl_z_log_msg_static_create>
    7c38:	46ad      	mov	sp, r5
		return;
    7c3a:	e056      	b.n	7cea <bt_hci_le_enh_conn_complete+0x13e>
			le_conn_complete_adv_timeout();
    7c3c:	f7fe f9d2 	bl	5fe4 <le_conn_complete_adv_timeout>
			return;
    7c40:	e053      	b.n	7cea <bt_hci_le_enh_conn_complete+0x13e>
		BT_WARN("Unexpected status 0x%02x", evt->status);
    7c42:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7c46:	e7ca      	b.n	7bde <bt_hci_le_enh_conn_complete+0x32>
    7c48:	f06f 041b 	mvn.w	r4, #27
    7c4c:	e7d3      	b.n	7bf6 <bt_hci_le_enh_conn_complete+0x4a>
	if (evt->peer_addr.type == BT_ADDR_LE_PUBLIC_ID ||
    7c4e:	7923      	ldrb	r3, [r4, #4]
    7c50:	3b02      	subs	r3, #2
    7c52:	b2db      	uxtb	r3, r3
    7c54:	2b01      	cmp	r3, #1
    7c56:	d94c      	bls.n	7cf2 <bt_hci_le_enh_conn_complete+0x146>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
    7c58:	78e3      	ldrb	r3, [r4, #3]
    7c5a:	2b01      	cmp	r3, #1
    7c5c:	d05c      	beq.n	7d18 <bt_hci_le_enh_conn_complete+0x16c>
				bt_lookup_id_addr(id, &evt->peer_addr));
    7c5e:	1d25      	adds	r5, r4, #4
		bt_addr_le_copy(&id_addr,
    7c60:	4629      	mov	r1, r5
    7c62:	f00f ff77 	bl	17b54 <bt_lookup_id_addr>
    7c66:	4601      	mov	r1, r0
	memcpy(dst, src, sizeof(*dst));
    7c68:	2207      	movs	r2, #7
    7c6a:	f107 0008 	add.w	r0, r7, #8
    7c6e:	f00f fd5f 	bl	17730 <memcpy>
    7c72:	2207      	movs	r2, #7
    7c74:	4629      	mov	r1, r5
    7c76:	f107 0010 	add.w	r0, r7, #16
    7c7a:	f00f fd59 	bl	17730 <memcpy>
	conn = find_pending_connect(evt->role, &id_addr);
    7c7e:	f107 0108 	add.w	r1, r7, #8
    7c82:	78e0      	ldrb	r0, [r4, #3]
    7c84:	f7fe f988 	bl	5f98 <find_pending_connect>
    7c88:	4605      	mov	r5, r0
	    evt->role == BT_HCI_ROLE_PERIPHERAL &&
    7c8a:	78e3      	ldrb	r3, [r4, #3]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7c8c:	2b01      	cmp	r3, #1
    7c8e:	d047      	beq.n	7d20 <bt_hci_le_enh_conn_complete+0x174>
	if (!conn) {
    7c90:	2d00      	cmp	r5, #0
    7c92:	d054      	beq.n	7d3e <bt_hci_le_enh_conn_complete+0x192>
	conn->handle = handle;
    7c94:	4628      	mov	r0, r5
    7c96:	f820 8b88 	strh.w	r8, [r0], #136
    7c9a:	2207      	movs	r2, #7
    7c9c:	f107 0108 	add.w	r1, r7, #8
    7ca0:	f00f fd46 	bl	17730 <memcpy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
    7ca4:	f8b4 3017 	ldrh.w	r3, [r4, #23]
    7ca8:	f8a5 309e 	strh.w	r3, [r5, #158]	; 0x9e
	conn->le.latency = sys_le16_to_cpu(evt->latency);
    7cac:	f8b4 3019 	ldrh.w	r3, [r4, #25]
    7cb0:	f8a5 30a4 	strh.w	r3, [r5, #164]	; 0xa4
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
    7cb4:	f8b4 301b 	ldrh.w	r3, [r4, #27]
    7cb8:	f8a5 30a6 	strh.w	r3, [r5, #166]	; 0xa6
	conn->role = evt->role;
    7cbc:	78e3      	ldrb	r3, [r4, #3]
    7cbe:	70eb      	strb	r3, [r5, #3]
	conn->err = 0U;
    7cc0:	2200      	movs	r2, #0
    7cc2:	726a      	strb	r2, [r5, #9]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    7cc4:	2b01      	cmp	r3, #1
    7cc6:	f000 8090 	beq.w	7dea <bt_hci_le_enh_conn_complete+0x23e>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
    7cca:	2107      	movs	r1, #7
    7ccc:	4628      	mov	r0, r5
    7cce:	f002 f96f 	bl	9fb0 <bt_conn_set_state>
	if (is_disconnected) {
    7cd2:	2e00      	cmp	r6, #0
    7cd4:	f040 80a5 	bne.w	7e22 <bt_hci_le_enh_conn_complete+0x276>
	bt_conn_connected(conn);
    7cd8:	4628      	mov	r0, r5
    7cda:	f010 fa40 	bl	1815e <bt_conn_connected>
	conn_auto_initiate(conn);
    7cde:	4628      	mov	r0, r5
    7ce0:	f7ff fe58 	bl	7994 <conn_auto_initiate>
	bt_conn_unref(conn);
    7ce4:	4628      	mov	r0, r5
    7ce6:	f010 f9f9 	bl	180dc <bt_conn_unref>
}
    7cea:	371c      	adds	r7, #28
    7cec:	46bd      	mov	sp, r7
    7cee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    7cf2:	2207      	movs	r2, #7
    7cf4:	1d21      	adds	r1, r4, #4
    7cf6:	f107 0008 	add.w	r0, r7, #8
    7cfa:	f00f fd19 	bl	17730 <memcpy>
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
    7cfe:	7a3b      	ldrb	r3, [r7, #8]
    7d00:	3b02      	subs	r3, #2
    7d02:	723b      	strb	r3, [r7, #8]
	memcpy(dst, src, sizeof(*dst));
    7d04:	2206      	movs	r2, #6
    7d06:	f104 0111 	add.w	r1, r4, #17
    7d0a:	f107 0011 	add.w	r0, r7, #17
    7d0e:	f00f fd0f 	bl	17730 <memcpy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
    7d12:	2301      	movs	r3, #1
    7d14:	743b      	strb	r3, [r7, #16]
    7d16:	e7b2      	b.n	7c7e <bt_hci_le_enh_conn_complete+0xd2>
		uint8_t id = evt->role == BT_HCI_ROLE_PERIPHERAL ? bt_dev.adv_conn_id :
    7d18:	4b46      	ldr	r3, [pc, #280]	; (7e34 <bt_hci_le_enh_conn_complete+0x288>)
    7d1a:	f893 0067 	ldrb.w	r0, [r3, #103]	; 0x67
    7d1e:	e79e      	b.n	7c5e <bt_hci_le_enh_conn_complete+0xb2>
		struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    7d20:	f001 fa56 	bl	91d0 <bt_le_adv_lookup_legacy>
		atomic_clear_bit(adv->flags, BT_ADV_ENABLED);
    7d24:	f100 0310 	add.w	r3, r0, #16
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    7d28:	e8d3 2fef 	ldaex	r2, [r3]
    7d2c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    7d30:	e8c3 2fe1 	stlex	r1, r2, [r3]
    7d34:	2900      	cmp	r1, #0
    7d36:	d1f7      	bne.n	7d28 <bt_hci_le_enh_conn_complete+0x17c>
		(void)bt_le_lim_adv_cancel_timeout(adv);
    7d38:	f010 f86f 	bl	17e1a <bt_le_lim_adv_cancel_timeout>
    7d3c:	e7a8      	b.n	7c90 <bt_hci_le_enh_conn_complete+0xe4>
		BT_ERR("No pending conn for peer %s",
    7d3e:	1d20      	adds	r0, r4, #4
    7d40:	f7fd fcb2 	bl	56a8 <bt_addr_le_str_real>
    7d44:	2302      	movs	r3, #2
    7d46:	713b      	strb	r3, [r7, #4]
    7d48:	466c      	mov	r4, sp
    7d4a:	b088      	sub	sp, #32
    7d4c:	466b      	mov	r3, sp
    7d4e:	f113 0210 	adds.w	r2, r3, #16
    7d52:	d03b      	beq.n	7dcc <bt_hci_le_enh_conn_complete+0x220>
    7d54:	250d      	movs	r5, #13
    7d56:	b11a      	cbz	r2, 7d60 <bt_hci_le_enh_conn_complete+0x1b4>
    7d58:	2d04      	cmp	r5, #4
    7d5a:	dd01      	ble.n	7d60 <bt_hci_le_enh_conn_complete+0x1b4>
    7d5c:	4936      	ldr	r1, [pc, #216]	; (7e38 <bt_hci_le_enh_conn_complete+0x28c>)
    7d5e:	6159      	str	r1, [r3, #20]
    7d60:	2102      	movs	r1, #2
    7d62:	7039      	strb	r1, [r7, #0]
    7d64:	b112      	cbz	r2, 7d6c <bt_hci_le_enh_conn_complete+0x1c0>
    7d66:	2d08      	cmp	r5, #8
    7d68:	dd00      	ble.n	7d6c <bt_hci_le_enh_conn_complete+0x1c0>
    7d6a:	6198      	str	r0, [r3, #24]
    7d6c:	b11a      	cbz	r2, 7d76 <bt_hci_le_enh_conn_complete+0x1ca>
    7d6e:	f103 011c 	add.w	r1, r3, #28
    7d72:	2000      	movs	r0, #0
    7d74:	b368      	cbz	r0, 7dd2 <bt_hci_le_enh_conn_complete+0x226>
    7d76:	2d0c      	cmp	r5, #12
    7d78:	dd34      	ble.n	7de4 <bt_hci_le_enh_conn_complete+0x238>
    7d7a:	250d      	movs	r5, #13
    7d7c:	b142      	cbz	r2, 7d90 <bt_hci_le_enh_conn_complete+0x1e4>
    7d7e:	2103      	movs	r1, #3
    7d80:	7139      	strb	r1, [r7, #4]
    7d82:	2100      	movs	r1, #0
    7d84:	7179      	strb	r1, [r7, #5]
    7d86:	71b9      	strb	r1, [r7, #6]
    7d88:	2101      	movs	r1, #1
    7d8a:	71f9      	strb	r1, [r7, #7]
    7d8c:	6878      	ldr	r0, [r7, #4]
    7d8e:	6118      	str	r0, [r3, #16]
    7d90:	2100      	movs	r1, #0
    7d92:	f36f 0100 	bfc	r1, #0, #1
    7d96:	f36f 0141 	bfc	r1, #1, #1
    7d9a:	f36f 0182 	bfc	r1, #2, #1
    7d9e:	f36f 01c5 	bfc	r1, #3, #3
    7da2:	2301      	movs	r3, #1
    7da4:	f363 1188 	bfi	r1, r3, #6, #3
    7da8:	f3c5 0509 	ubfx	r5, r5, #0, #10
    7dac:	f365 2152 	bfi	r1, r5, #9, #10
    7db0:	f36f 41de 	bfc	r1, #19, #12
    7db4:	f36f 71df 	bfc	r1, #31, #1
    7db8:	2300      	movs	r3, #0
    7dba:	481d      	ldr	r0, [pc, #116]	; (7e30 <bt_hci_le_enh_conn_complete+0x284>)
    7dbc:	f7fa fa44 	bl	2248 <z_impl_z_log_msg_static_create>
    7dc0:	46a5      	mov	sp, r4
		bt_hci_disconnect(handle, BT_HCI_ERR_UNSPECIFIED);
    7dc2:	211f      	movs	r1, #31
    7dc4:	4648      	mov	r0, r9
    7dc6:	f00f fdc7 	bl	17958 <bt_hci_disconnect>
		return;
    7dca:	e78e      	b.n	7cea <bt_hci_le_enh_conn_complete+0x13e>
		BT_ERR("No pending conn for peer %s",
    7dcc:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    7dd0:	e7c1      	b.n	7d56 <bt_hci_le_enh_conn_complete+0x1aa>
    7dd2:	f107 0618 	add.w	r6, r7, #24
    7dd6:	4406      	add	r6, r0
    7dd8:	f816 6c18 	ldrb.w	r6, [r6, #-24]
    7ddc:	f801 6b01 	strb.w	r6, [r1], #1
    7de0:	3001      	adds	r0, #1
    7de2:	e7c7      	b.n	7d74 <bt_hci_le_enh_conn_complete+0x1c8>
    7de4:	f06f 051b 	mvn.w	r5, #27
    7de8:	e7c8      	b.n	7d7c <bt_hci_le_enh_conn_complete+0x1d0>
	memcpy(dst, src, sizeof(*dst));
    7dea:	2207      	movs	r2, #7
    7dec:	f107 0110 	add.w	r1, r7, #16
    7df0:	f105 008f 	add.w	r0, r5, #143	; 0x8f
    7df4:	f00f fc9c 	bl	17730 <memcpy>
			struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    7df8:	f001 f9ea 	bl	91d0 <bt_le_adv_lookup_legacy>
						&bt_dev.id_addr[conn->id]);
    7dfc:	7a29      	ldrb	r1, [r5, #8]
    7dfe:	4c0d      	ldr	r4, [pc, #52]	; (7e34 <bt_hci_le_enh_conn_complete+0x288>)
    7e00:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
    7e04:	2207      	movs	r2, #7
    7e06:	4421      	add	r1, r4
    7e08:	f105 0096 	add.w	r0, r5, #150	; 0x96
    7e0c:	f00f fc90 	bl	17730 <memcpy>
		if (BT_LE_STATES_PER_CONN_ADV(bt_dev.le.states)) {
    7e10:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
    7e14:	f013 0f40 	tst.w	r3, #64	; 0x40
    7e18:	f43f af57 	beq.w	7cca <bt_hci_le_enh_conn_complete+0x11e>
			bt_le_adv_resume();
    7e1c:	f010 f802 	bl	17e24 <bt_le_adv_resume>
    7e20:	e753      	b.n	7cca <bt_hci_le_enh_conn_complete+0x11e>
		bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
    7e22:	2101      	movs	r1, #1
    7e24:	4628      	mov	r0, r5
    7e26:	f002 f8c3 	bl	9fb0 <bt_conn_set_state>
    7e2a:	e755      	b.n	7cd8 <bt_hci_le_enh_conn_complete+0x12c>
    7e2c:	0001e560 	.word	0x0001e560
    7e30:	0001cffc 	.word	0x0001cffc
    7e34:	20000000 	.word	0x20000000
    7e38:	0001e57c 	.word	0x0001e57c

00007e3c <bt_send>:
{
    7e3c:	b508      	push	{r3, lr}
	return bt_dev.drv->send(buf);
    7e3e:	4b03      	ldr	r3, [pc, #12]	; (7e4c <bt_send+0x10>)
    7e40:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
    7e44:	695b      	ldr	r3, [r3, #20]
    7e46:	4798      	blx	r3
}
    7e48:	bd08      	pop	{r3, pc}
    7e4a:	bf00      	nop
    7e4c:	20000000 	.word	0x20000000

00007e50 <bt_hci_cmd_send>:
{
    7e50:	b5f0      	push	{r4, r5, r6, r7, lr}
    7e52:	b083      	sub	sp, #12
    7e54:	af00      	add	r7, sp, #0
    7e56:	4604      	mov	r4, r0
	if (!buf) {
    7e58:	460d      	mov	r5, r1
    7e5a:	b161      	cbz	r1, 7e76 <bt_hci_cmd_send+0x26>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
    7e5c:	f640 4335 	movw	r3, #3125	; 0xc35
    7e60:	429c      	cmp	r4, r3
    7e62:	d010      	beq.n	7e86 <bt_hci_cmd_send+0x36>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
    7e64:	4629      	mov	r1, r5
    7e66:	482b      	ldr	r0, [pc, #172]	; (7f14 <bt_hci_cmd_send+0xc4>)
    7e68:	f012 f971 	bl	1a14e <net_buf_put>
	return 0;
    7e6c:	2400      	movs	r4, #0
}
    7e6e:	4620      	mov	r0, r4
    7e70:	370c      	adds	r7, #12
    7e72:	46bd      	mov	sp, r7
    7e74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		buf = bt_hci_cmd_create(opcode, 0);
    7e76:	f7ff f803 	bl	6e80 <bt_hci_cmd_create>
		if (!buf) {
    7e7a:	4605      	mov	r5, r0
    7e7c:	2800      	cmp	r0, #0
    7e7e:	d1ed      	bne.n	7e5c <bt_hci_cmd_send+0xc>
			return -ENOBUFS;
    7e80:	f06f 0468 	mvn.w	r4, #104	; 0x68
    7e84:	e7f3      	b.n	7e6e <bt_hci_cmd_send+0x1e>
		err = bt_send(buf);
    7e86:	4628      	mov	r0, r5
    7e88:	f7ff ffd8 	bl	7e3c <bt_send>
		if (err) {
    7e8c:	4604      	mov	r4, r0
    7e8e:	2800      	cmp	r0, #0
    7e90:	d0ed      	beq.n	7e6e <bt_hci_cmd_send+0x1e>
			BT_ERR("Unable to send to driver (err %d)", err);
    7e92:	466e      	mov	r6, sp
    7e94:	b088      	sub	sp, #32
    7e96:	466b      	mov	r3, sp
    7e98:	f113 0210 	adds.w	r2, r3, #16
    7e9c:	d033      	beq.n	7f06 <bt_hci_cmd_send+0xb6>
    7e9e:	210c      	movs	r1, #12
    7ea0:	b11a      	cbz	r2, 7eaa <bt_hci_cmd_send+0x5a>
    7ea2:	2904      	cmp	r1, #4
    7ea4:	dd01      	ble.n	7eaa <bt_hci_cmd_send+0x5a>
    7ea6:	481c      	ldr	r0, [pc, #112]	; (7f18 <bt_hci_cmd_send+0xc8>)
    7ea8:	6158      	str	r0, [r3, #20]
    7eaa:	b112      	cbz	r2, 7eb2 <bt_hci_cmd_send+0x62>
    7eac:	2908      	cmp	r1, #8
    7eae:	dd00      	ble.n	7eb2 <bt_hci_cmd_send+0x62>
    7eb0:	619c      	str	r4, [r3, #24]
    7eb2:	290b      	cmp	r1, #11
    7eb4:	dd2a      	ble.n	7f0c <bt_hci_cmd_send+0xbc>
    7eb6:	f04f 0c0c 	mov.w	ip, #12
    7eba:	b13a      	cbz	r2, 7ecc <bt_hci_cmd_send+0x7c>
    7ebc:	2103      	movs	r1, #3
    7ebe:	7139      	strb	r1, [r7, #4]
    7ec0:	2100      	movs	r1, #0
    7ec2:	7179      	strb	r1, [r7, #5]
    7ec4:	71b9      	strb	r1, [r7, #6]
    7ec6:	71f9      	strb	r1, [r7, #7]
    7ec8:	6878      	ldr	r0, [r7, #4]
    7eca:	6118      	str	r0, [r3, #16]
    7ecc:	2100      	movs	r1, #0
    7ece:	f36f 0100 	bfc	r1, #0, #1
    7ed2:	f36f 0141 	bfc	r1, #1, #1
    7ed6:	f36f 0182 	bfc	r1, #2, #1
    7eda:	f36f 01c5 	bfc	r1, #3, #3
    7ede:	2301      	movs	r3, #1
    7ee0:	f363 1188 	bfi	r1, r3, #6, #3
    7ee4:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    7ee8:	f36c 2152 	bfi	r1, ip, #9, #10
    7eec:	f36f 41de 	bfc	r1, #19, #12
    7ef0:	f36f 71df 	bfc	r1, #31, #1
    7ef4:	2300      	movs	r3, #0
    7ef6:	4809      	ldr	r0, [pc, #36]	; (7f1c <bt_hci_cmd_send+0xcc>)
    7ef8:	f7fa f9a6 	bl	2248 <z_impl_z_log_msg_static_create>
    7efc:	46b5      	mov	sp, r6
			net_buf_unref(buf);
    7efe:	4628      	mov	r0, r5
    7f00:	f012 f933 	bl	1a16a <net_buf_unref>
		return err;
    7f04:	e7b3      	b.n	7e6e <bt_hci_cmd_send+0x1e>
			BT_ERR("Unable to send to driver (err %d)", err);
    7f06:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    7f0a:	e7c9      	b.n	7ea0 <bt_hci_cmd_send+0x50>
    7f0c:	f06f 0c1b 	mvn.w	ip, #27
    7f10:	e7d3      	b.n	7eba <bt_hci_cmd_send+0x6a>
    7f12:	bf00      	nop
    7f14:	2000013c 	.word	0x2000013c
    7f18:	0001e598 	.word	0x0001e598
    7f1c:	0001cffc 	.word	0x0001cffc

00007f20 <bt_hci_host_num_completed_packets>:
{
    7f20:	b5f0      	push	{r4, r5, r6, r7, lr}
    7f22:	b08f      	sub	sp, #60	; 0x3c
    7f24:	af00      	add	r7, sp, #0
    7f26:	4604      	mov	r4, r0
	uint16_t handle = acl(buf)->handle;
    7f28:	8ac5      	ldrh	r5, [r0, #22]
	uint8_t index = acl(buf)->index;
    7f2a:	7d46      	ldrb	r6, [r0, #21]
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    7f2c:	7980      	ldrb	r0, [r0, #6]
    7f2e:	f005 fe9f 	bl	dc70 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
    7f32:	4621      	mov	r1, r4
    7f34:	f014 f924 	bl	1c180 <k_queue_prepend>
	if (!BT_CMD_TEST(bt_dev.supported_commands, 10, 5)) {
    7f38:	4b5b      	ldr	r3, [pc, #364]	; (80a8 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xa8>)
    7f3a:	f893 3082 	ldrb.w	r3, [r3, #130]	; 0x82
    7f3e:	f013 0f20 	tst.w	r3, #32
    7f42:	d102      	bne.n	7f4a <bt_hci_host_num_completed_packets+0x2a>
}
    7f44:	373c      	adds	r7, #60	; 0x3c
    7f46:	46bd      	mov	sp, r7
    7f48:	bdf0      	pop	{r4, r5, r6, r7, pc}
	conn = bt_conn_lookup_index(index);
    7f4a:	4630      	mov	r0, r6
    7f4c:	f002 fcca 	bl	a8e4 <bt_conn_lookup_index>
	if (!conn) {
    7f50:	4604      	mov	r4, r0
    7f52:	b328      	cbz	r0, 7fa0 <bt_hci_host_num_completed_packets+0x80>
	if (conn->state != BT_CONN_CONNECTED &&
    7f54:	7a83      	ldrb	r3, [r0, #10]
    7f56:	3b07      	subs	r3, #7
    7f58:	b2db      	uxtb	r3, r3
    7f5a:	2b01      	cmp	r3, #1
    7f5c:	d85c      	bhi.n	8018 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x18>
	bt_conn_unref(conn);
    7f5e:	f010 f8bd 	bl	180dc <bt_conn_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS,
    7f62:	2105      	movs	r1, #5
    7f64:	f640 4035 	movw	r0, #3125	; 0xc35
    7f68:	f7fe ff8a 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    7f6c:	4604      	mov	r4, r0
    7f6e:	2800      	cmp	r0, #0
    7f70:	d077      	beq.n	8062 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x62>
	return net_buf_simple_add(&buf->b, len);
    7f72:	f100 0608 	add.w	r6, r0, #8
    7f76:	2101      	movs	r1, #1
    7f78:	4630      	mov	r0, r6
    7f7a:	f012 f940 	bl	1a1fe <net_buf_simple_add>
	cp->num_handles = sys_cpu_to_le16(1);
    7f7e:	2301      	movs	r3, #1
    7f80:	7003      	strb	r3, [r0, #0]
    7f82:	2104      	movs	r1, #4
    7f84:	4630      	mov	r0, r6
    7f86:	f012 f93a 	bl	1a1fe <net_buf_simple_add>
	hc->handle = sys_cpu_to_le16(handle);
    7f8a:	8005      	strh	r5, [r0, #0]
	hc->count  = sys_cpu_to_le16(1);
    7f8c:	2301      	movs	r3, #1
    7f8e:	7083      	strb	r3, [r0, #2]
    7f90:	2300      	movs	r3, #0
    7f92:	70c3      	strb	r3, [r0, #3]
	bt_hci_cmd_send(BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS, buf);
    7f94:	4621      	mov	r1, r4
    7f96:	f640 4035 	movw	r0, #3125	; 0xc35
    7f9a:	f7ff ff59 	bl	7e50 <bt_hci_cmd_send>
    7f9e:	e7d1      	b.n	7f44 <bt_hci_host_num_completed_packets+0x24>
		BT_WARN("Unable to look up conn with index 0x%02x", index);
    7fa0:	466d      	mov	r5, sp
    7fa2:	b088      	sub	sp, #32
    7fa4:	466b      	mov	r3, sp
    7fa6:	f113 0210 	adds.w	r2, r3, #16
    7faa:	d02f      	beq.n	800c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xc>
    7fac:	210c      	movs	r1, #12
    7fae:	b11a      	cbz	r2, 7fb8 <bt_hci_host_num_completed_packets+0x98>
    7fb0:	2904      	cmp	r1, #4
    7fb2:	dd01      	ble.n	7fb8 <bt_hci_host_num_completed_packets+0x98>
    7fb4:	483d      	ldr	r0, [pc, #244]	; (80ac <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xac>)
    7fb6:	6158      	str	r0, [r3, #20]
    7fb8:	b112      	cbz	r2, 7fc0 <bt_hci_host_num_completed_packets+0xa0>
    7fba:	2908      	cmp	r1, #8
    7fbc:	dd00      	ble.n	7fc0 <bt_hci_host_num_completed_packets+0xa0>
    7fbe:	619e      	str	r6, [r3, #24]
    7fc0:	290b      	cmp	r1, #11
    7fc2:	dd26      	ble.n	8012 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x12>
    7fc4:	240c      	movs	r4, #12
    7fc6:	b13a      	cbz	r2, 7fd8 <bt_hci_host_num_completed_packets+0xb8>
    7fc8:	2103      	movs	r1, #3
    7fca:	7139      	strb	r1, [r7, #4]
    7fcc:	2100      	movs	r1, #0
    7fce:	7179      	strb	r1, [r7, #5]
    7fd0:	71b9      	strb	r1, [r7, #6]
    7fd2:	71f9      	strb	r1, [r7, #7]
    7fd4:	6878      	ldr	r0, [r7, #4]
    7fd6:	6118      	str	r0, [r3, #16]
    7fd8:	2100      	movs	r1, #0
    7fda:	f36f 0100 	bfc	r1, #0, #1
    7fde:	f36f 0141 	bfc	r1, #1, #1
    7fe2:	f36f 0182 	bfc	r1, #2, #1
    7fe6:	f36f 01c5 	bfc	r1, #3, #3
    7fea:	2302      	movs	r3, #2
    7fec:	f363 1188 	bfi	r1, r3, #6, #3
    7ff0:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    7ff4:	f364 2152 	bfi	r1, r4, #9, #10
    7ff8:	f36f 41de 	bfc	r1, #19, #12
    7ffc:	f36f 71df 	bfc	r1, #31, #1
    8000:	2300      	movs	r3, #0
    8002:	482b      	ldr	r0, [pc, #172]	; (80b0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xb0>)
    8004:	f7fa f920 	bl	2248 <z_impl_z_log_msg_static_create>
    8008:	46ad      	mov	sp, r5
		return;
    800a:	e79b      	b.n	7f44 <bt_hci_host_num_completed_packets+0x24>
		BT_WARN("Unable to look up conn with index 0x%02x", index);
    800c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    8010:	e7cd      	b.n	7fae <bt_hci_host_num_completed_packets+0x8e>
    8012:	f06f 041b 	mvn.w	r4, #27
    8016:	e7d6      	b.n	7fc6 <bt_hci_host_num_completed_packets+0xa6>
		BT_WARN("Not reporting packet for non-connected conn");
    8018:	4b26      	ldr	r3, [pc, #152]	; (80b4 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xb4>)
    801a:	637b      	str	r3, [r7, #52]	; 0x34
    801c:	2202      	movs	r2, #2
    801e:	713a      	strb	r2, [r7, #4]
    8020:	2300      	movs	r3, #0
    8022:	717b      	strb	r3, [r7, #5]
    8024:	71bb      	strb	r3, [r7, #6]
    8026:	71fb      	strb	r3, [r7, #7]
    8028:	6879      	ldr	r1, [r7, #4]
    802a:	6339      	str	r1, [r7, #48]	; 0x30
    802c:	4619      	mov	r1, r3
    802e:	f363 0100 	bfi	r1, r3, #0, #1
    8032:	f363 0141 	bfi	r1, r3, #1, #1
    8036:	f363 0182 	bfi	r1, r3, #2, #1
    803a:	f363 01c5 	bfi	r1, r3, #3, #3
    803e:	f362 1188 	bfi	r1, r2, #6, #3
    8042:	2208      	movs	r2, #8
    8044:	f362 2152 	bfi	r1, r2, #9, #10
    8048:	f363 41de 	bfi	r1, r3, #19, #12
    804c:	f363 71df 	bfi	r1, r3, #31, #1
    8050:	f107 0230 	add.w	r2, r7, #48	; 0x30
    8054:	4816      	ldr	r0, [pc, #88]	; (80b0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xb0>)
    8056:	f7fa f8f7 	bl	2248 <z_impl_z_log_msg_static_create>
		bt_conn_unref(conn);
    805a:	4620      	mov	r0, r4
    805c:	f010 f83e 	bl	180dc <bt_conn_unref>
		return;
    8060:	e770      	b.n	7f44 <bt_hci_host_num_completed_packets+0x24>
		BT_ERR("Unable to allocate new HCI command");
    8062:	4b15      	ldr	r3, [pc, #84]	; (80b8 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xb8>)
    8064:	61fb      	str	r3, [r7, #28]
    8066:	2302      	movs	r3, #2
    8068:	713b      	strb	r3, [r7, #4]
    806a:	2300      	movs	r3, #0
    806c:	717b      	strb	r3, [r7, #5]
    806e:	71bb      	strb	r3, [r7, #6]
    8070:	71fb      	strb	r3, [r7, #7]
    8072:	687a      	ldr	r2, [r7, #4]
    8074:	61ba      	str	r2, [r7, #24]
    8076:	4619      	mov	r1, r3
    8078:	f363 0100 	bfi	r1, r3, #0, #1
    807c:	f363 0141 	bfi	r1, r3, #1, #1
    8080:	f363 0182 	bfi	r1, r3, #2, #1
    8084:	f363 01c5 	bfi	r1, r3, #3, #3
    8088:	2201      	movs	r2, #1
    808a:	f362 1188 	bfi	r1, r2, #6, #3
    808e:	2208      	movs	r2, #8
    8090:	f362 2152 	bfi	r1, r2, #9, #10
    8094:	f363 41de 	bfi	r1, r3, #19, #12
    8098:	f363 71df 	bfi	r1, r3, #31, #1
    809c:	f107 0218 	add.w	r2, r7, #24
    80a0:	4803      	ldr	r0, [pc, #12]	; (80b0 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xb0>)
    80a2:	f7fa f8d1 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    80a6:	e74d      	b.n	7f44 <bt_hci_host_num_completed_packets+0x24>
    80a8:	20000000 	.word	0x20000000
    80ac:	0001e5bc 	.word	0x0001e5bc
    80b0:	0001cffc 	.word	0x0001cffc
    80b4:	0001e5e8 	.word	0x0001e5e8
    80b8:	0001e614 	.word	0x0001e614

000080bc <le_conn_param_neg_reply>:
{
    80bc:	b570      	push	{r4, r5, r6, lr}
    80be:	b088      	sub	sp, #32
    80c0:	4605      	mov	r5, r0
    80c2:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
    80c4:	2103      	movs	r1, #3
    80c6:	f242 0021 	movw	r0, #8225	; 0x2021
    80ca:	f7fe fed9 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    80ce:	b168      	cbz	r0, 80ec <le_conn_param_neg_reply+0x30>
    80d0:	4606      	mov	r6, r0
    80d2:	2103      	movs	r1, #3
    80d4:	3008      	adds	r0, #8
    80d6:	f012 f892 	bl	1a1fe <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(handle);
    80da:	8005      	strh	r5, [r0, #0]
	cp->reason = sys_cpu_to_le16(reason);
    80dc:	7084      	strb	r4, [r0, #2]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
    80de:	4631      	mov	r1, r6
    80e0:	f242 0021 	movw	r0, #8225	; 0x2021
    80e4:	f7ff feb4 	bl	7e50 <bt_hci_cmd_send>
}
    80e8:	b008      	add	sp, #32
    80ea:	bd70      	pop	{r4, r5, r6, pc}
		BT_ERR("Unable to allocate buffer");
    80ec:	4b12      	ldr	r3, [pc, #72]	; (8138 <le_conn_param_neg_reply+0x7c>)
    80ee:	9307      	str	r3, [sp, #28]
    80f0:	2302      	movs	r3, #2
    80f2:	f88d 3004 	strb.w	r3, [sp, #4]
    80f6:	2300      	movs	r3, #0
    80f8:	f88d 3005 	strb.w	r3, [sp, #5]
    80fc:	f88d 3006 	strb.w	r3, [sp, #6]
    8100:	f88d 3007 	strb.w	r3, [sp, #7]
    8104:	9a01      	ldr	r2, [sp, #4]
    8106:	9206      	str	r2, [sp, #24]
    8108:	4619      	mov	r1, r3
    810a:	f363 0100 	bfi	r1, r3, #0, #1
    810e:	f363 0141 	bfi	r1, r3, #1, #1
    8112:	f363 0182 	bfi	r1, r3, #2, #1
    8116:	f363 01c5 	bfi	r1, r3, #3, #3
    811a:	2201      	movs	r2, #1
    811c:	f362 1188 	bfi	r1, r2, #6, #3
    8120:	2208      	movs	r2, #8
    8122:	f362 2152 	bfi	r1, r2, #9, #10
    8126:	f363 41de 	bfi	r1, r3, #19, #12
    812a:	f363 71df 	bfi	r1, r3, #31, #1
    812e:	aa06      	add	r2, sp, #24
    8130:	4802      	ldr	r0, [pc, #8]	; (813c <le_conn_param_neg_reply+0x80>)
    8132:	f7fa f889 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    8136:	e7d7      	b.n	80e8 <le_conn_param_neg_reply+0x2c>
    8138:	0001e638 	.word	0x0001e638
    813c:	0001cffc 	.word	0x0001cffc

00008140 <le_conn_param_req>:
{
    8140:	b5f0      	push	{r4, r5, r6, r7, lr}
    8142:	b085      	sub	sp, #20
    8144:	af00      	add	r7, sp, #0
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
    8146:	6883      	ldr	r3, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
    8148:	881c      	ldrh	r4, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
    814a:	885a      	ldrh	r2, [r3, #2]
    814c:	813a      	strh	r2, [r7, #8]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
    814e:	889a      	ldrh	r2, [r3, #4]
    8150:	817a      	strh	r2, [r7, #10]
	param.latency = sys_le16_to_cpu(evt->latency);
    8152:	88da      	ldrh	r2, [r3, #6]
    8154:	81ba      	strh	r2, [r7, #12]
	param.timeout = sys_le16_to_cpu(evt->timeout);
    8156:	891b      	ldrh	r3, [r3, #8]
    8158:	81fb      	strh	r3, [r7, #14]
	conn = bt_conn_lookup_handle(handle);
    815a:	4620      	mov	r0, r4
    815c:	f001 ff1e 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
    8160:	b180      	cbz	r0, 8184 <le_conn_param_req+0x44>
    8162:	4605      	mov	r5, r0
	if (!le_param_req(conn, &param)) {
    8164:	f107 0108 	add.w	r1, r7, #8
    8168:	f002 f94e 	bl	a408 <le_param_req>
    816c:	2800      	cmp	r0, #0
    816e:	d149      	bne.n	8204 <le_conn_param_req+0xc4>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
    8170:	211e      	movs	r1, #30
    8172:	4620      	mov	r0, r4
    8174:	f7ff ffa2 	bl	80bc <le_conn_param_neg_reply>
	bt_conn_unref(conn);
    8178:	4628      	mov	r0, r5
    817a:	f00f ffaf 	bl	180dc <bt_conn_unref>
}
    817e:	3714      	adds	r7, #20
    8180:	46bd      	mov	sp, r7
    8182:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("Unable to lookup conn for handle %u", handle);
    8184:	466e      	mov	r6, sp
    8186:	b088      	sub	sp, #32
    8188:	466b      	mov	r3, sp
    818a:	f113 0210 	adds.w	r2, r3, #16
    818e:	d033      	beq.n	81f8 <le_conn_param_req+0xb8>
    8190:	210c      	movs	r1, #12
    8192:	b11a      	cbz	r2, 819c <le_conn_param_req+0x5c>
    8194:	2904      	cmp	r1, #4
    8196:	dd01      	ble.n	819c <le_conn_param_req+0x5c>
    8198:	481d      	ldr	r0, [pc, #116]	; (8210 <le_conn_param_req+0xd0>)
    819a:	6158      	str	r0, [r3, #20]
    819c:	b112      	cbz	r2, 81a4 <le_conn_param_req+0x64>
    819e:	2908      	cmp	r1, #8
    81a0:	dd00      	ble.n	81a4 <le_conn_param_req+0x64>
    81a2:	619c      	str	r4, [r3, #24]
    81a4:	290b      	cmp	r1, #11
    81a6:	dd2a      	ble.n	81fe <le_conn_param_req+0xbe>
    81a8:	250c      	movs	r5, #12
    81aa:	b13a      	cbz	r2, 81bc <le_conn_param_req+0x7c>
    81ac:	2103      	movs	r1, #3
    81ae:	7139      	strb	r1, [r7, #4]
    81b0:	2100      	movs	r1, #0
    81b2:	7179      	strb	r1, [r7, #5]
    81b4:	71b9      	strb	r1, [r7, #6]
    81b6:	71f9      	strb	r1, [r7, #7]
    81b8:	6878      	ldr	r0, [r7, #4]
    81ba:	6118      	str	r0, [r3, #16]
    81bc:	2100      	movs	r1, #0
    81be:	f36f 0100 	bfc	r1, #0, #1
    81c2:	f36f 0141 	bfc	r1, #1, #1
    81c6:	f36f 0182 	bfc	r1, #2, #1
    81ca:	f36f 01c5 	bfc	r1, #3, #3
    81ce:	2301      	movs	r3, #1
    81d0:	f363 1188 	bfi	r1, r3, #6, #3
    81d4:	f405 737b 	and.w	r3, r5, #1004	; 0x3ec
    81d8:	f363 2152 	bfi	r1, r3, #9, #10
    81dc:	f36f 41de 	bfc	r1, #19, #12
    81e0:	f36f 71df 	bfc	r1, #31, #1
    81e4:	2300      	movs	r3, #0
    81e6:	480b      	ldr	r0, [pc, #44]	; (8214 <le_conn_param_req+0xd4>)
    81e8:	f7fa f82e 	bl	2248 <z_impl_z_log_msg_static_create>
    81ec:	46b5      	mov	sp, r6
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
    81ee:	2102      	movs	r1, #2
    81f0:	4620      	mov	r0, r4
    81f2:	f7ff ff63 	bl	80bc <le_conn_param_neg_reply>
		return;
    81f6:	e7c2      	b.n	817e <le_conn_param_req+0x3e>
		BT_ERR("Unable to lookup conn for handle %u", handle);
    81f8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    81fc:	e7c9      	b.n	8192 <le_conn_param_req+0x52>
    81fe:	f06f 051b 	mvn.w	r5, #27
    8202:	e7d2      	b.n	81aa <le_conn_param_req+0x6a>
		le_conn_param_req_reply(handle, &param);
    8204:	f107 0108 	add.w	r1, r7, #8
    8208:	4620      	mov	r0, r4
    820a:	f00f fc6b 	bl	17ae4 <le_conn_param_req_reply>
    820e:	e7b3      	b.n	8178 <le_conn_param_req+0x38>
    8210:	0001e120 	.word	0x0001e120
    8214:	0001cffc 	.word	0x0001cffc

00008218 <send_cmd>:
{
    8218:	b5f0      	push	{r4, r5, r6, r7, lr}
    821a:	b089      	sub	sp, #36	; 0x24
    821c:	af00      	add	r7, sp, #0
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
    821e:	2200      	movs	r2, #0
    8220:	2300      	movs	r3, #0
    8222:	4854      	ldr	r0, [pc, #336]	; (8374 <send_cmd+0x15c>)
    8224:	f011 ff15 	bl	1a052 <net_buf_get>
	BT_ASSERT(buf);
    8228:	4605      	mov	r5, r0
    822a:	2800      	cmp	r0, #0
    822c:	f000 808d 	beq.w	834a <send_cmd+0x132>
    8230:	4c51      	ldr	r4, [pc, #324]	; (8378 <send_cmd+0x160>)
    8232:	f04f 32ff 	mov.w	r2, #4294967295
    8236:	f04f 33ff 	mov.w	r3, #4294967295
    823a:	f504 708c 	add.w	r0, r4, #280	; 0x118
    823e:	f00b fccf 	bl	13be0 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
    8242:	f8d4 3130 	ldr.w	r3, [r4, #304]	; 0x130
    8246:	b34b      	cbz	r3, 829c <send_cmd+0x84>
		BT_ERR("Uncleared pending sent_cmd");
    8248:	4b4c      	ldr	r3, [pc, #304]	; (837c <send_cmd+0x164>)
    824a:	61fb      	str	r3, [r7, #28]
    824c:	2302      	movs	r3, #2
    824e:	713b      	strb	r3, [r7, #4]
    8250:	2400      	movs	r4, #0
    8252:	717c      	strb	r4, [r7, #5]
    8254:	71bc      	strb	r4, [r7, #6]
    8256:	71fc      	strb	r4, [r7, #7]
    8258:	687b      	ldr	r3, [r7, #4]
    825a:	61bb      	str	r3, [r7, #24]
    825c:	4621      	mov	r1, r4
    825e:	f364 0100 	bfi	r1, r4, #0, #1
    8262:	f364 0141 	bfi	r1, r4, #1, #1
    8266:	f364 0182 	bfi	r1, r4, #2, #1
    826a:	f364 01c5 	bfi	r1, r4, #3, #3
    826e:	2301      	movs	r3, #1
    8270:	f363 1188 	bfi	r1, r3, #6, #3
    8274:	2308      	movs	r3, #8
    8276:	f363 2152 	bfi	r1, r3, #9, #10
    827a:	f364 41de 	bfi	r1, r4, #19, #12
    827e:	f364 71df 	bfi	r1, r4, #31, #1
    8282:	4623      	mov	r3, r4
    8284:	f107 0218 	add.w	r2, r7, #24
    8288:	483d      	ldr	r0, [pc, #244]	; (8380 <send_cmd+0x168>)
    828a:	f7f9 ffdd 	bl	2248 <z_impl_z_log_msg_static_create>
		net_buf_unref(bt_dev.sent_cmd);
    828e:	4e3a      	ldr	r6, [pc, #232]	; (8378 <send_cmd+0x160>)
    8290:	f8d6 0130 	ldr.w	r0, [r6, #304]	; 0x130
    8294:	f011 ff69 	bl	1a16a <net_buf_unref>
		bt_dev.sent_cmd = NULL;
    8298:	f8c6 4130 	str.w	r4, [r6, #304]	; 0x130
	bt_dev.sent_cmd = net_buf_ref(buf);
    829c:	4628      	mov	r0, r5
    829e:	f011 ff8a 	bl	1a1b6 <net_buf_ref>
    82a2:	4b35      	ldr	r3, [pc, #212]	; (8378 <send_cmd+0x160>)
    82a4:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130
	err = bt_send(buf);
    82a8:	4628      	mov	r0, r5
    82aa:	f7ff fdc7 	bl	7e3c <bt_send>
	if (err) {
    82ae:	4604      	mov	r4, r0
    82b0:	2800      	cmp	r0, #0
    82b2:	d047      	beq.n	8344 <send_cmd+0x12c>
		BT_ERR("Unable to send to driver (err %d)", err);
    82b4:	466e      	mov	r6, sp
    82b6:	b088      	sub	sp, #32
    82b8:	466b      	mov	r3, sp
    82ba:	f113 0210 	adds.w	r2, r3, #16
    82be:	d052      	beq.n	8366 <send_cmd+0x14e>
    82c0:	210c      	movs	r1, #12
    82c2:	b11a      	cbz	r2, 82cc <send_cmd+0xb4>
    82c4:	2904      	cmp	r1, #4
    82c6:	dd01      	ble.n	82cc <send_cmd+0xb4>
    82c8:	482e      	ldr	r0, [pc, #184]	; (8384 <send_cmd+0x16c>)
    82ca:	6158      	str	r0, [r3, #20]
    82cc:	b112      	cbz	r2, 82d4 <send_cmd+0xbc>
    82ce:	2908      	cmp	r1, #8
    82d0:	dd00      	ble.n	82d4 <send_cmd+0xbc>
    82d2:	619c      	str	r4, [r3, #24]
    82d4:	290b      	cmp	r1, #11
    82d6:	dd49      	ble.n	836c <send_cmd+0x154>
    82d8:	240c      	movs	r4, #12
    82da:	b13a      	cbz	r2, 82ec <send_cmd+0xd4>
    82dc:	2103      	movs	r1, #3
    82de:	7139      	strb	r1, [r7, #4]
    82e0:	2100      	movs	r1, #0
    82e2:	7179      	strb	r1, [r7, #5]
    82e4:	71b9      	strb	r1, [r7, #6]
    82e6:	71f9      	strb	r1, [r7, #7]
    82e8:	6878      	ldr	r0, [r7, #4]
    82ea:	6118      	str	r0, [r3, #16]
    82ec:	2100      	movs	r1, #0
    82ee:	f36f 0100 	bfc	r1, #0, #1
    82f2:	f36f 0141 	bfc	r1, #1, #1
    82f6:	f36f 0182 	bfc	r1, #2, #1
    82fa:	f36f 01c5 	bfc	r1, #3, #3
    82fe:	2301      	movs	r3, #1
    8300:	f363 1188 	bfi	r1, r3, #6, #3
    8304:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    8308:	f364 2152 	bfi	r1, r4, #9, #10
    830c:	f36f 41de 	bfc	r1, #19, #12
    8310:	f36f 71df 	bfc	r1, #31, #1
    8314:	2300      	movs	r3, #0
    8316:	481a      	ldr	r0, [pc, #104]	; (8380 <send_cmd+0x168>)
    8318:	f7f9 ff96 	bl	2248 <z_impl_z_log_msg_static_create>
    831c:	46b5      	mov	sp, r6
	z_impl_k_sem_give(sem);
    831e:	481a      	ldr	r0, [pc, #104]	; (8388 <send_cmd+0x170>)
    8320:	f00b fc36 	bl	13b90 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED, buf);
    8324:	4628      	mov	r0, r5
    8326:	f011 fde1 	bl	19eec <net_buf_id>
    832a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    832e:	4b17      	ldr	r3, [pc, #92]	; (838c <send_cmd+0x174>)
    8330:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    8334:	462a      	mov	r2, r5
    8336:	211f      	movs	r1, #31
    8338:	8840      	ldrh	r0, [r0, #2]
    833a:	f7fe f871 	bl	6420 <hci_cmd_done>
		net_buf_unref(buf);
    833e:	4628      	mov	r0, r5
    8340:	f011 ff13 	bl	1a16a <net_buf_unref>
}
    8344:	3724      	adds	r7, #36	; 0x24
    8346:	46bd      	mov	sp, r7
    8348:	bdf0      	pop	{r4, r5, r6, r7, pc}
	BT_ASSERT(buf);
    834a:	f640 136c 	movw	r3, #2412	; 0x96c
    834e:	4a10      	ldr	r2, [pc, #64]	; (8390 <send_cmd+0x178>)
    8350:	4910      	ldr	r1, [pc, #64]	; (8394 <send_cmd+0x17c>)
    8352:	4811      	ldr	r0, [pc, #68]	; (8398 <send_cmd+0x180>)
    8354:	f00d ffa9 	bl	162aa <assert_print>
    8358:	4040      	eors	r0, r0
    835a:	f380 8811 	msr	BASEPRI, r0
    835e:	f04f 0003 	mov.w	r0, #3
    8362:	df02      	svc	2
    8364:	e764      	b.n	8230 <send_cmd+0x18>
		BT_ERR("Unable to send to driver (err %d)", err);
    8366:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    836a:	e7aa      	b.n	82c2 <send_cmd+0xaa>
    836c:	f06f 041b 	mvn.w	r4, #27
    8370:	e7b3      	b.n	82da <send_cmd+0xc2>
    8372:	bf00      	nop
    8374:	2000013c 	.word	0x2000013c
    8378:	20000000 	.word	0x20000000
    837c:	0001e654 	.word	0x0001e654
    8380:	0001cffc 	.word	0x0001cffc
    8384:	0001e598 	.word	0x0001e598
    8388:	20000118 	.word	0x20000118
    838c:	2000224c 	.word	0x2000224c
    8390:	0001e24c 	.word	0x0001e24c
    8394:	0001f418 	.word	0x0001f418
    8398:	0001e29c 	.word	0x0001e29c

0000839c <process_events>:
{
    839c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    83a0:	b082      	sub	sp, #8
    83a2:	af00      	add	r7, sp, #0
    83a4:	4604      	mov	r4, r0
    83a6:	460d      	mov	r5, r1
	BT_DBG("count %d", count);
    83a8:	e03b      	b.n	8422 <process_events+0x86>
				send_cmd();
    83aa:	f7ff ff35 	bl	8218 <send_cmd>
    83ae:	e036      	b.n	841e <process_events+0x82>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    83b0:	46e8      	mov	r8, sp
    83b2:	b088      	sub	sp, #32
    83b4:	4669      	mov	r1, sp
    83b6:	f111 0210 	adds.w	r2, r1, #16
    83ba:	d044      	beq.n	8446 <process_events+0xaa>
    83bc:	200c      	movs	r0, #12
    83be:	b12a      	cbz	r2, 83cc <process_events+0x30>
    83c0:	2804      	cmp	r0, #4
    83c2:	dd03      	ble.n	83cc <process_events+0x30>
    83c4:	f8df c094 	ldr.w	ip, [pc, #148]	; 845c <process_events+0xc0>
    83c8:	f8c1 c014 	str.w	ip, [r1, #20]
    83cc:	b112      	cbz	r2, 83d4 <process_events+0x38>
    83ce:	2808      	cmp	r0, #8
    83d0:	dd00      	ble.n	83d4 <process_events+0x38>
    83d2:	618b      	str	r3, [r1, #24]
    83d4:	280b      	cmp	r0, #11
    83d6:	dd39      	ble.n	844c <process_events+0xb0>
    83d8:	230c      	movs	r3, #12
    83da:	b13a      	cbz	r2, 83ec <process_events+0x50>
    83dc:	2003      	movs	r0, #3
    83de:	7138      	strb	r0, [r7, #4]
    83e0:	2000      	movs	r0, #0
    83e2:	7178      	strb	r0, [r7, #5]
    83e4:	71b8      	strb	r0, [r7, #6]
    83e6:	71f8      	strb	r0, [r7, #7]
    83e8:	6878      	ldr	r0, [r7, #4]
    83ea:	6108      	str	r0, [r1, #16]
    83ec:	f36f 0600 	bfc	r6, #0, #1
    83f0:	f36f 0641 	bfc	r6, #1, #1
    83f4:	f36f 0682 	bfc	r6, #2, #1
    83f8:	f36f 06c5 	bfc	r6, #3, #3
    83fc:	2102      	movs	r1, #2
    83fe:	f361 1688 	bfi	r6, r1, #6, #3
    8402:	f403 737b 	and.w	r3, r3, #1004	; 0x3ec
    8406:	f363 2652 	bfi	r6, r3, #9, #10
    840a:	f36f 46de 	bfc	r6, #19, #12
    840e:	f36f 76df 	bfc	r6, #31, #1
    8412:	2300      	movs	r3, #0
    8414:	4631      	mov	r1, r6
    8416:	4812      	ldr	r0, [pc, #72]	; (8460 <process_events+0xc4>)
    8418:	f7f9 ff16 	bl	2248 <z_impl_z_log_msg_static_create>
    841c:	46c5      	mov	sp, r8
	for (; count; ev++, count--) {
    841e:	3414      	adds	r4, #20
    8420:	3d01      	subs	r5, #1
    8422:	b1b5      	cbz	r5, 8452 <process_events+0xb6>
		switch (ev->state) {
    8424:	68e3      	ldr	r3, [r4, #12]
    8426:	f3c3 3345 	ubfx	r3, r3, #13, #6
    842a:	2b01      	cmp	r3, #1
    842c:	d9f7      	bls.n	841e <process_events+0x82>
    842e:	2b04      	cmp	r3, #4
    8430:	d1be      	bne.n	83b0 <process_events+0x14>
			if (ev->tag == BT_EVENT_CMD_TX) {
    8432:	7b23      	ldrb	r3, [r4, #12]
    8434:	2b00      	cmp	r3, #0
    8436:	d0b8      	beq.n	83aa <process_events+0xe>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
    8438:	2b01      	cmp	r3, #1
    843a:	d1f0      	bne.n	841e <process_events+0x82>
					conn = CONTAINER_OF(ev->fifo,
    843c:	6920      	ldr	r0, [r4, #16]
					bt_conn_process_tx(conn);
    843e:	3838      	subs	r0, #56	; 0x38
    8440:	f002 fa0c 	bl	a85c <bt_conn_process_tx>
    8444:	e7eb      	b.n	841e <process_events+0x82>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
    8446:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    844a:	e7b8      	b.n	83be <process_events+0x22>
    844c:	f06f 031b 	mvn.w	r3, #27
    8450:	e7c3      	b.n	83da <process_events+0x3e>
}
    8452:	3708      	adds	r7, #8
    8454:	46bd      	mov	sp, r7
    8456:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    845a:	bf00      	nop
    845c:	0001e670 	.word	0x0001e670
    8460:	0001cffc 	.word	0x0001cffc

00008464 <hci_tx_thread>:
{
    8464:	b538      	push	{r3, r4, r5, lr}
    8466:	e012      	b.n	848e <hci_tx_thread+0x2a>
		BT_ASSERT(err == 0);
    8468:	f640 13d3 	movw	r3, #2515	; 0x9d3
    846c:	4a12      	ldr	r2, [pc, #72]	; (84b8 <hci_tx_thread+0x54>)
    846e:	4913      	ldr	r1, [pc, #76]	; (84bc <hci_tx_thread+0x58>)
    8470:	4813      	ldr	r0, [pc, #76]	; (84c0 <hci_tx_thread+0x5c>)
    8472:	f00d ff1a 	bl	162aa <assert_print>
    8476:	4040      	eors	r0, r0
    8478:	f380 8811 	msr	BASEPRI, r0
    847c:	f04f 0003 	mov.w	r0, #3
    8480:	df02      	svc	2
		process_events(events, ev_count);
    8482:	4621      	mov	r1, r4
    8484:	480f      	ldr	r0, [pc, #60]	; (84c4 <hci_tx_thread+0x60>)
    8486:	f7ff ff89 	bl	839c <process_events>
	z_impl_k_yield();
    848a:	f00c f8bd 	bl	14608 <z_impl_k_yield>
		events[0].state = K_POLL_STATE_NOT_READY;
    848e:	4d0d      	ldr	r5, [pc, #52]	; (84c4 <hci_tx_thread+0x60>)
    8490:	68eb      	ldr	r3, [r5, #12]
    8492:	f36f 3352 	bfc	r3, #13, #6
    8496:	60eb      	str	r3, [r5, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
    8498:	f105 0014 	add.w	r0, r5, #20
    849c:	f001 fd5a 	bl	9f54 <bt_conn_prepare_events>
    84a0:	1c44      	adds	r4, r0, #1
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm2 = { .val = timeout };
		return (int) arch_syscall_invoke4(parm0.x, parm1.x, parm2.split.lo, parm2.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    84a2:	f04f 32ff 	mov.w	r2, #4294967295
    84a6:	f04f 33ff 	mov.w	r3, #4294967295
    84aa:	4621      	mov	r1, r4
    84ac:	4628      	mov	r0, r5
    84ae:	f00c fde9 	bl	15084 <z_impl_k_poll>
		BT_ASSERT(err == 0);
    84b2:	2800      	cmp	r0, #0
    84b4:	d1d8      	bne.n	8468 <hci_tx_thread+0x4>
    84b6:	e7e4      	b.n	8482 <hci_tx_thread+0x1e>
    84b8:	0001e24c 	.word	0x0001e24c
    84bc:	0001e348 	.word	0x0001e348
    84c0:	0001e29c 	.word	0x0001e29c
    84c4:	20000218 	.word	0x20000218

000084c8 <hci_event_prio>:
{
    84c8:	b570      	push	{r4, r5, r6, lr}
    84ca:	b082      	sub	sp, #8
    84cc:	4604      	mov	r4, r0
	net_buf_simple_save(&buf->b, &state);
    84ce:	f100 0508 	add.w	r5, r0, #8
	state->offset = net_buf_simple_headroom(buf);
    84d2:	4628      	mov	r0, r5
    84d4:	f011 fedb 	bl	1a28e <net_buf_simple_headroom>
    84d8:	f8ad 0004 	strh.w	r0, [sp, #4]
	state->len = buf->len;
    84dc:	89a3      	ldrh	r3, [r4, #12]
    84de:	f8ad 3006 	strh.w	r3, [sp, #6]
	BT_ASSERT(buf->len >= sizeof(*hdr));
    84e2:	2b01      	cmp	r3, #1
    84e4:	d915      	bls.n	8512 <hci_event_prio+0x4a>
	return net_buf_simple_pull_mem(&buf->b, len);
    84e6:	2102      	movs	r1, #2
    84e8:	4628      	mov	r0, r5
    84ea:	f011 fec0 	bl	1a26e <net_buf_simple_pull_mem>
    84ee:	4605      	mov	r5, r0
	evt_flags = bt_hci_evt_get_flags(hdr->evt);
    84f0:	7803      	ldrb	r3, [r0, #0]
	switch (evt) {
    84f2:	3b05      	subs	r3, #5
    84f4:	2b15      	cmp	r3, #21
    84f6:	d81c      	bhi.n	8532 <hci_event_prio+0x6a>
    84f8:	e8df f003 	tbb	[pc, r3]
    84fc:	1b1b1b19 	.word	0x1b1b1b19
    8500:	1b1b1b1b 	.word	0x1b1b1b1b
    8504:	1b32321b 	.word	0x1b32321b
    8508:	1b321b1b 	.word	0x1b321b1b
    850c:	1b1b1b1b 	.word	0x1b1b1b1b
    8510:	321b      	.short	0x321b
	BT_ASSERT(buf->len >= sizeof(*hdr));
    8512:	f640 536f 	movw	r3, #3439	; 0xd6f
    8516:	4a1c      	ldr	r2, [pc, #112]	; (8588 <hci_event_prio+0xc0>)
    8518:	491c      	ldr	r1, [pc, #112]	; (858c <hci_event_prio+0xc4>)
    851a:	481d      	ldr	r0, [pc, #116]	; (8590 <hci_event_prio+0xc8>)
    851c:	f00d fec5 	bl	162aa <assert_print>
    8520:	4040      	eors	r0, r0
    8522:	f380 8811 	msr	BASEPRI, r0
    8526:	f04f 0003 	mov.w	r0, #3
    852a:	df02      	svc	2
    852c:	e7db      	b.n	84e6 <hci_event_prio+0x1e>
    852e:	2603      	movs	r6, #3
    8530:	e000      	b.n	8534 <hci_event_prio+0x6c>
		return BT_HCI_EVT_FLAG_RECV;
    8532:	2602      	movs	r6, #2
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    8534:	f016 0f01 	tst.w	r6, #1
    8538:	d014      	beq.n	8564 <hci_event_prio+0x9c>
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
    853a:	2305      	movs	r3, #5
    853c:	4a15      	ldr	r2, [pc, #84]	; (8594 <hci_event_prio+0xcc>)
    853e:	4621      	mov	r1, r4
    8540:	7828      	ldrb	r0, [r5, #0]
    8542:	f7fe f961 	bl	6808 <handle_event>
	if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    8546:	f016 0f02 	tst.w	r6, #2
    854a:	d019      	beq.n	8580 <hci_event_prio+0xb8>
	buf->data = buf->__buf + state->offset;
    854c:	6923      	ldr	r3, [r4, #16]
    854e:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    8552:	4413      	add	r3, r2
    8554:	60a3      	str	r3, [r4, #8]
	buf->len = state->len;
    8556:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    855a:	81a3      	strh	r3, [r4, #12]
}
    855c:	b002      	add	sp, #8
    855e:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_EVT_FLAG_RECV_PRIO;
    8560:	2601      	movs	r6, #1
    8562:	e7e7      	b.n	8534 <hci_event_prio+0x6c>
	BT_ASSERT(evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO);
    8564:	f640 5373 	movw	r3, #3443	; 0xd73
    8568:	4a07      	ldr	r2, [pc, #28]	; (8588 <hci_event_prio+0xc0>)
    856a:	490b      	ldr	r1, [pc, #44]	; (8598 <hci_event_prio+0xd0>)
    856c:	4808      	ldr	r0, [pc, #32]	; (8590 <hci_event_prio+0xc8>)
    856e:	f00d fe9c 	bl	162aa <assert_print>
    8572:	4040      	eors	r0, r0
    8574:	f380 8811 	msr	BASEPRI, r0
    8578:	f04f 0003 	mov.w	r0, #3
    857c:	df02      	svc	2
    857e:	e7dc      	b.n	853a <hci_event_prio+0x72>
		net_buf_unref(buf);
    8580:	4620      	mov	r0, r4
    8582:	f011 fdf2 	bl	1a16a <net_buf_unref>
}
    8586:	e7e9      	b.n	855c <hci_event_prio+0x94>
    8588:	0001e24c 	.word	0x0001e24c
    858c:	0001e280 	.word	0x0001e280
    8590:	0001e29c 	.word	0x0001e29c
    8594:	0001e794 	.word	0x0001e794
    8598:	0001e694 	.word	0x0001e694

0000859c <bt_recv>:
{
    859c:	b5f0      	push	{r4, r5, r6, r7, lr}
    859e:	b083      	sub	sp, #12
    85a0:	af00      	add	r7, sp, #0
    85a2:	4604      	mov	r4, r0
	return (enum bt_buf_type)((struct bt_buf_data *)net_buf_user_data(buf))
    85a4:	7d05      	ldrb	r5, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    85a6:	2d01      	cmp	r5, #1
    85a8:	d009      	beq.n	85be <bt_recv+0x22>
    85aa:	4628      	mov	r0, r5
    85ac:	2d03      	cmp	r5, #3
    85ae:	d12c      	bne.n	860a <bt_recv+0x6e>
		rx_queue_put(buf);
    85b0:	4620      	mov	r0, r4
    85b2:	f7fe f9ad 	bl	6910 <rx_queue_put>
		return 0;
    85b6:	2000      	movs	r0, #0
}
    85b8:	370c      	adds	r7, #12
    85ba:	46bd      	mov	sp, r7
    85bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		struct bt_hci_evt_hdr *hdr = (void *)buf->data;
    85be:	6883      	ldr	r3, [r0, #8]
		uint8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
    85c0:	781b      	ldrb	r3, [r3, #0]
	switch (evt) {
    85c2:	3b05      	subs	r3, #5
    85c4:	2b15      	cmp	r3, #21
    85c6:	d80e      	bhi.n	85e6 <bt_recv+0x4a>
    85c8:	e8df f003 	tbb	[pc, r3]
    85cc:	0d0d0d0b 	.word	0x0d0d0d0b
    85d0:	0d0d0d0d 	.word	0x0d0d0d0d
    85d4:	0d0e0e0d 	.word	0x0d0e0e0d
    85d8:	0d0e0d0d 	.word	0x0d0e0d0d
    85dc:	0d0d0d0d 	.word	0x0d0d0d0d
    85e0:	0e0d      	.short	0x0e0d
    85e2:	2503      	movs	r5, #3
    85e4:	e000      	b.n	85e8 <bt_recv+0x4c>
		return BT_HCI_EVT_FLAG_RECV;
    85e6:	2502      	movs	r5, #2
		if (evt_flags & BT_HCI_EVT_FLAG_RECV_PRIO) {
    85e8:	f015 0f01 	tst.w	r5, #1
    85ec:	d104      	bne.n	85f8 <bt_recv+0x5c>
		if (evt_flags & BT_HCI_EVT_FLAG_RECV) {
    85ee:	f015 0f02 	tst.w	r5, #2
    85f2:	d105      	bne.n	8600 <bt_recv+0x64>
		return 0;
    85f4:	2000      	movs	r0, #0
    85f6:	e7df      	b.n	85b8 <bt_recv+0x1c>
			hci_event_prio(buf);
    85f8:	4620      	mov	r0, r4
    85fa:	f7ff ff65 	bl	84c8 <hci_event_prio>
    85fe:	e7f6      	b.n	85ee <bt_recv+0x52>
			rx_queue_put(buf);
    8600:	4620      	mov	r0, r4
    8602:	f7fe f985 	bl	6910 <rx_queue_put>
		return 0;
    8606:	2000      	movs	r0, #0
    8608:	e7d6      	b.n	85b8 <bt_recv+0x1c>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    860a:	466e      	mov	r6, sp
    860c:	b088      	sub	sp, #32
    860e:	466b      	mov	r3, sp
    8610:	f113 0210 	adds.w	r2, r3, #16
    8614:	d034      	beq.n	8680 <bt_recv+0xe4>
    8616:	210c      	movs	r1, #12
    8618:	b11a      	cbz	r2, 8622 <bt_recv+0x86>
    861a:	2904      	cmp	r1, #4
    861c:	dd01      	ble.n	8622 <bt_recv+0x86>
    861e:	4d1b      	ldr	r5, [pc, #108]	; (868c <bt_recv+0xf0>)
    8620:	615d      	str	r5, [r3, #20]
    8622:	b112      	cbz	r2, 862a <bt_recv+0x8e>
    8624:	2908      	cmp	r1, #8
    8626:	dd00      	ble.n	862a <bt_recv+0x8e>
    8628:	6198      	str	r0, [r3, #24]
    862a:	290b      	cmp	r1, #11
    862c:	dd2b      	ble.n	8686 <bt_recv+0xea>
    862e:	250c      	movs	r5, #12
    8630:	b13a      	cbz	r2, 8642 <bt_recv+0xa6>
    8632:	2103      	movs	r1, #3
    8634:	7139      	strb	r1, [r7, #4]
    8636:	2100      	movs	r1, #0
    8638:	7179      	strb	r1, [r7, #5]
    863a:	71b9      	strb	r1, [r7, #6]
    863c:	71f9      	strb	r1, [r7, #7]
    863e:	6878      	ldr	r0, [r7, #4]
    8640:	6118      	str	r0, [r3, #16]
    8642:	2100      	movs	r1, #0
    8644:	f36f 0100 	bfc	r1, #0, #1
    8648:	f36f 0141 	bfc	r1, #1, #1
    864c:	f36f 0182 	bfc	r1, #2, #1
    8650:	f36f 01c5 	bfc	r1, #3, #3
    8654:	2301      	movs	r3, #1
    8656:	f363 1188 	bfi	r1, r3, #6, #3
    865a:	f405 737b 	and.w	r3, r5, #1004	; 0x3ec
    865e:	f363 2152 	bfi	r1, r3, #9, #10
    8662:	f36f 41de 	bfc	r1, #19, #12
    8666:	f36f 71df 	bfc	r1, #31, #1
    866a:	2300      	movs	r3, #0
    866c:	4808      	ldr	r0, [pc, #32]	; (8690 <bt_recv+0xf4>)
    866e:	f7f9 fdeb 	bl	2248 <z_impl_z_log_msg_static_create>
    8672:	46b5      	mov	sp, r6
		net_buf_unref(buf);
    8674:	4620      	mov	r0, r4
    8676:	f011 fd78 	bl	1a16a <net_buf_unref>
		return -EINVAL;
    867a:	f06f 0015 	mvn.w	r0, #21
    867e:	e79b      	b.n	85b8 <bt_recv+0x1c>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
    8680:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    8684:	e7c8      	b.n	8618 <bt_recv+0x7c>
    8686:	f06f 051b 	mvn.w	r5, #27
    868a:	e7d1      	b.n	8630 <bt_recv+0x94>
    868c:	0001e6b0 	.word	0x0001e6b0
    8690:	0001cffc 	.word	0x0001cffc

00008694 <bt_hci_driver_register>:
	if (bt_dev.drv) {
    8694:	4b0a      	ldr	r3, [pc, #40]	; (86c0 <bt_hci_driver_register+0x2c>)
    8696:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
    869a:	b943      	cbnz	r3, 86ae <bt_hci_driver_register+0x1a>
	if (!drv->open || !drv->send) {
    869c:	68c3      	ldr	r3, [r0, #12]
    869e:	b14b      	cbz	r3, 86b4 <bt_hci_driver_register+0x20>
    86a0:	6943      	ldr	r3, [r0, #20]
    86a2:	b153      	cbz	r3, 86ba <bt_hci_driver_register+0x26>
	bt_dev.drv = drv;
    86a4:	4b06      	ldr	r3, [pc, #24]	; (86c0 <bt_hci_driver_register+0x2c>)
    86a6:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
	return 0;
    86aa:	2000      	movs	r0, #0
    86ac:	4770      	bx	lr
		return -EALREADY;
    86ae:	f06f 0077 	mvn.w	r0, #119	; 0x77
    86b2:	4770      	bx	lr
		return -EINVAL;
    86b4:	f06f 0015 	mvn.w	r0, #21
    86b8:	4770      	bx	lr
    86ba:	f06f 0015 	mvn.w	r0, #21
}
    86be:	4770      	bx	lr
    86c0:	20000000 	.word	0x20000000

000086c4 <bt_finalize_init>:
{
    86c4:	b508      	push	{r3, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    86c6:	4b06      	ldr	r3, [pc, #24]	; (86e0 <bt_finalize_init+0x1c>)
    86c8:	e8d3 2fef 	ldaex	r2, [r3]
    86cc:	f042 0204 	orr.w	r2, r2, #4
    86d0:	e8c3 2fe1 	stlex	r1, r2, [r3]
    86d4:	2900      	cmp	r1, #0
    86d6:	d1f7      	bne.n	86c8 <bt_finalize_init+0x4>
	bt_dev_show_info();
    86d8:	f7fd faa8 	bl	5c2c <bt_dev_show_info>
}
    86dc:	bd08      	pop	{r3, pc}
    86de:	bf00      	nop
    86e0:	200000cc 	.word	0x200000cc

000086e4 <init_work>:
{
    86e4:	b508      	push	{r3, lr}
	err = bt_init();
    86e6:	f00f fa22 	bl	17b2e <bt_init>
	if (ready_cb) {
    86ea:	4b02      	ldr	r3, [pc, #8]	; (86f4 <init_work+0x10>)
    86ec:	681b      	ldr	r3, [r3, #0]
    86ee:	b103      	cbz	r3, 86f2 <init_work+0xe>
		ready_cb(err);
    86f0:	4798      	blx	r3
}
    86f2:	bd08      	pop	{r3, pc}
    86f4:	200022c8 	.word	0x200022c8

000086f8 <bt_enable>:
#endif /* !CONFIG_BT_RECV_BLOCKING */

int bt_enable(bt_ready_cb_t cb)
{
    86f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    86fc:	b090      	sub	sp, #64	; 0x40
    86fe:	af08      	add	r7, sp, #32
	int err;

	if (!bt_dev.drv) {
    8700:	4b63      	ldr	r3, [pc, #396]	; (8890 <bt_enable+0x198>)
    8702:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
    8706:	2b00      	cmp	r3, #0
    8708:	d05a      	beq.n	87c0 <bt_enable+0xc8>
    870a:	4605      	mov	r5, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    870c:	4b61      	ldr	r3, [pc, #388]	; (8894 <bt_enable+0x19c>)
    870e:	e8d3 2fef 	ldaex	r2, [r3]
    8712:	f022 0202 	bic.w	r2, r2, #2
    8716:	e8c3 2fe1 	stlex	r1, r2, [r3]
    871a:	2900      	cmp	r1, #0
    871c:	d1f7      	bne.n	870e <bt_enable+0x16>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    871e:	e8d3 2fef 	ldaex	r2, [r3]
    8722:	f042 0101 	orr.w	r1, r2, #1
    8726:	e8c3 1fe0 	stlex	r0, r1, [r3]
    872a:	2800      	cmp	r0, #0
    872c:	d1f7      	bne.n	871e <bt_enable+0x26>
		return -ENODEV;
	}

	atomic_clear_bit(bt_dev.flags, BT_DEV_DISABLE);

	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    872e:	f012 0f01 	tst.w	r2, #1
    8732:	f040 80aa 	bne.w	888a <bt_enable+0x192>
		if (err) {
			BT_WARN("Failed to set device name (%d)", err);
		}
	}

	ready_cb = cb;
    8736:	4b58      	ldr	r3, [pc, #352]	; (8898 <bt_enable+0x1a0>)
    8738:	601d      	str	r5, [r3, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
    873a:	4e55      	ldr	r6, [pc, #340]	; (8890 <bt_enable+0x198>)
    873c:	2201      	movs	r2, #1
    873e:	4611      	mov	r1, r2
    8740:	f506 708c 	add.w	r0, r6, #280	; 0x118
    8744:	f013 fd66 	bl	1c214 <z_impl_k_sem_init>
	z_impl_k_queue_init(queue);
    8748:	f506 709e 	add.w	r0, r6, #316	; 0x13c
    874c:	f013 fd00 	bl	1c150 <z_impl_k_queue_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    8750:	f8df 8148 	ldr.w	r8, [pc, #328]	; 889c <bt_enable+0x1a4>
    8754:	2200      	movs	r2, #0
    8756:	2300      	movs	r3, #0
    8758:	e9cd 2306 	strd	r2, r3, [sp, #24]
    875c:	2400      	movs	r4, #0
    875e:	9404      	str	r4, [sp, #16]
    8760:	f06f 0308 	mvn.w	r3, #8
    8764:	9303      	str	r3, [sp, #12]
    8766:	9402      	str	r4, [sp, #8]
    8768:	9401      	str	r4, [sp, #4]
    876a:	9400      	str	r4, [sp, #0]
    876c:	4b4c      	ldr	r3, [pc, #304]	; (88a0 <bt_enable+0x1a8>)
    876e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    8772:	494c      	ldr	r1, [pc, #304]	; (88a4 <bt_enable+0x1ac>)
    8774:	4640      	mov	r0, r8
    8776:	f013 fc21 	bl	1bfbc <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    877a:	494b      	ldr	r1, [pc, #300]	; (88a8 <bt_enable+0x1b0>)
    877c:	4640      	mov	r0, r8
    877e:	f00b f819 	bl	137b4 <z_impl_k_thread_name_set>
			0, K_NO_WAIT);
	k_thread_name_set(&tx_thread_data, "BT TX");

#if defined(CONFIG_BT_RECV_WORKQ_BT)
	/* RX thread */
	k_work_queue_start(&bt_workq, rx_thread_stack,
    8782:	f8df 8128 	ldr.w	r8, [pc, #296]	; 88ac <bt_enable+0x1b4>
    8786:	9400      	str	r4, [sp, #0]
    8788:	f06f 0307 	mvn.w	r3, #7
    878c:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
    8790:	4947      	ldr	r1, [pc, #284]	; (88b0 <bt_enable+0x1b8>)
    8792:	4640      	mov	r0, r8
    8794:	f00b fbcc 	bl	13f30 <k_work_queue_start>
    8798:	4946      	ldr	r1, [pc, #280]	; (88b4 <bt_enable+0x1bc>)
    879a:	4640      	mov	r0, r8
    879c:	f00b f80a 	bl	137b4 <z_impl_k_thread_name_set>
			   CONFIG_BT_RX_STACK_SIZE,
			   K_PRIO_COOP(CONFIG_BT_RX_PRIO), NULL);
	k_thread_name_set(&bt_workq.thread, "BT RX");
#endif

	err = bt_dev.drv->open();
    87a0:	f8d6 3154 	ldr.w	r3, [r6, #340]	; 0x154
    87a4:	68db      	ldr	r3, [r3, #12]
    87a6:	4798      	blx	r3
	if (err) {
    87a8:	4604      	mov	r4, r0
    87aa:	bb70      	cbnz	r0, 880a <bt_enable+0x112>
		return err;
	}

	bt_monitor_send(BT_MONITOR_OPEN_INDEX, NULL, 0);

	if (!cb) {
    87ac:	2d00      	cmp	r5, #0
    87ae:	d068      	beq.n	8882 <bt_enable+0x18a>
		return bt_init();
	}

	k_work_submit(&bt_dev.init);
    87b0:	4841      	ldr	r0, [pc, #260]	; (88b8 <bt_enable+0x1c0>)
    87b2:	f00b fbb5 	bl	13f20 <k_work_submit>
	return 0;
}
    87b6:	4620      	mov	r0, r4
    87b8:	3720      	adds	r7, #32
    87ba:	46bd      	mov	sp, r7
    87bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("No HCI driver registered");
    87c0:	4b3e      	ldr	r3, [pc, #248]	; (88bc <bt_enable+0x1c4>)
    87c2:	61fb      	str	r3, [r7, #28]
    87c4:	2302      	movs	r3, #2
    87c6:	713b      	strb	r3, [r7, #4]
    87c8:	2300      	movs	r3, #0
    87ca:	717b      	strb	r3, [r7, #5]
    87cc:	71bb      	strb	r3, [r7, #6]
    87ce:	71fb      	strb	r3, [r7, #7]
    87d0:	687a      	ldr	r2, [r7, #4]
    87d2:	61ba      	str	r2, [r7, #24]
    87d4:	4619      	mov	r1, r3
    87d6:	f363 0100 	bfi	r1, r3, #0, #1
    87da:	f363 0141 	bfi	r1, r3, #1, #1
    87de:	f363 0182 	bfi	r1, r3, #2, #1
    87e2:	f363 01c5 	bfi	r1, r3, #3, #3
    87e6:	2201      	movs	r2, #1
    87e8:	f362 1188 	bfi	r1, r2, #6, #3
    87ec:	2208      	movs	r2, #8
    87ee:	f362 2152 	bfi	r1, r2, #9, #10
    87f2:	f363 41de 	bfi	r1, r3, #19, #12
    87f6:	f363 71df 	bfi	r1, r3, #31, #1
    87fa:	f107 0218 	add.w	r2, r7, #24
    87fe:	4830      	ldr	r0, [pc, #192]	; (88c0 <bt_enable+0x1c8>)
    8800:	f7f9 fd22 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ENODEV;
    8804:	f06f 0412 	mvn.w	r4, #18
    8808:	e7d5      	b.n	87b6 <bt_enable+0xbe>
		BT_ERR("HCI driver open failed (%d)", err);
    880a:	466e      	mov	r6, sp
    880c:	b088      	sub	sp, #32
    880e:	4633      	mov	r3, r6
    8810:	f116 0210 	adds.w	r2, r6, #16
    8814:	d02f      	beq.n	8876 <bt_enable+0x17e>
    8816:	210c      	movs	r1, #12
    8818:	b11a      	cbz	r2, 8822 <bt_enable+0x12a>
    881a:	2904      	cmp	r1, #4
    881c:	dd01      	ble.n	8822 <bt_enable+0x12a>
    881e:	4829      	ldr	r0, [pc, #164]	; (88c4 <bt_enable+0x1cc>)
    8820:	6158      	str	r0, [r3, #20]
    8822:	b112      	cbz	r2, 882a <bt_enable+0x132>
    8824:	2908      	cmp	r1, #8
    8826:	dd00      	ble.n	882a <bt_enable+0x132>
    8828:	619c      	str	r4, [r3, #24]
    882a:	290b      	cmp	r1, #11
    882c:	dd26      	ble.n	887c <bt_enable+0x184>
    882e:	250c      	movs	r5, #12
    8830:	b13a      	cbz	r2, 8842 <bt_enable+0x14a>
    8832:	2103      	movs	r1, #3
    8834:	7139      	strb	r1, [r7, #4]
    8836:	2100      	movs	r1, #0
    8838:	7179      	strb	r1, [r7, #5]
    883a:	71b9      	strb	r1, [r7, #6]
    883c:	71f9      	strb	r1, [r7, #7]
    883e:	6878      	ldr	r0, [r7, #4]
    8840:	6118      	str	r0, [r3, #16]
    8842:	2100      	movs	r1, #0
    8844:	f36f 0100 	bfc	r1, #0, #1
    8848:	f36f 0141 	bfc	r1, #1, #1
    884c:	f36f 0182 	bfc	r1, #2, #1
    8850:	f36f 01c5 	bfc	r1, #3, #3
    8854:	2301      	movs	r3, #1
    8856:	f363 1188 	bfi	r1, r3, #6, #3
    885a:	f405 737b 	and.w	r3, r5, #1004	; 0x3ec
    885e:	f363 2152 	bfi	r1, r3, #9, #10
    8862:	f36f 41de 	bfc	r1, #19, #12
    8866:	f36f 71df 	bfc	r1, #31, #1
    886a:	2300      	movs	r3, #0
    886c:	4814      	ldr	r0, [pc, #80]	; (88c0 <bt_enable+0x1c8>)
    886e:	f7f9 fceb 	bl	2248 <z_impl_z_log_msg_static_create>
    8872:	46b5      	mov	sp, r6
		return err;
    8874:	e79f      	b.n	87b6 <bt_enable+0xbe>
		BT_ERR("HCI driver open failed (%d)", err);
    8876:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    887a:	e7cd      	b.n	8818 <bt_enable+0x120>
    887c:	f06f 051b 	mvn.w	r5, #27
    8880:	e7d6      	b.n	8830 <bt_enable+0x138>
		return bt_init();
    8882:	f00f f954 	bl	17b2e <bt_init>
    8886:	4604      	mov	r4, r0
    8888:	e795      	b.n	87b6 <bt_enable+0xbe>
		return -EALREADY;
    888a:	f06f 0477 	mvn.w	r4, #119	; 0x77
    888e:	e792      	b.n	87b6 <bt_enable+0xbe>
    8890:	20000000 	.word	0x20000000
    8894:	200000cc 	.word	0x200000cc
    8898:	200022c8 	.word	0x200022c8
    889c:	200015e8 	.word	0x200015e8
    88a0:	00008465 	.word	0x00008465
    88a4:	200039d0 	.word	0x200039d0
    88a8:	0001e6e0 	.word	0x0001e6e0
    88ac:	20001510 	.word	0x20001510
    88b0:	20003520 	.word	0x20003520
    88b4:	0001e6e8 	.word	0x0001e6e8
    88b8:	200000bc 	.word	0x200000bc
    88bc:	0001e6c4 	.word	0x0001e6c4
    88c0:	0001cffc 	.word	0x0001cffc
    88c4:	0001e6f0 	.word	0x0001e6f0

000088c8 <bt_get_name>:
#if defined(CONFIG_BT_DEVICE_NAME_DYNAMIC)
	return bt_dev.name;
#else
	return CONFIG_BT_DEVICE_NAME;
#endif
}
    88c8:	4800      	ldr	r0, [pc, #0]	; (88cc <bt_get_name+0x4>)
    88ca:	4770      	bx	lr
    88cc:	0001d360 	.word	0x0001d360

000088d0 <id_find>:
		*count = bt_dev.id_count;
	}
}

static int id_find(const bt_addr_le_t *addr)
{
    88d0:	b570      	push	{r4, r5, r6, lr}
    88d2:	4605      	mov	r5, r0
	uint8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
    88d4:	2400      	movs	r4, #0
    88d6:	e001      	b.n	88dc <id_find+0xc>
    88d8:	3401      	adds	r4, #1
    88da:	b2e4      	uxtb	r4, r4
    88dc:	4b09      	ldr	r3, [pc, #36]	; (8904 <id_find+0x34>)
    88de:	79db      	ldrb	r3, [r3, #7]
    88e0:	42a3      	cmp	r3, r4
    88e2:	d90b      	bls.n	88fc <id_find+0x2c>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
    88e4:	4626      	mov	r6, r4
    88e6:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
    88ea:	2207      	movs	r2, #7
    88ec:	4905      	ldr	r1, [pc, #20]	; (8904 <id_find+0x34>)
    88ee:	4419      	add	r1, r3
    88f0:	4628      	mov	r0, r5
    88f2:	f00e ff0b 	bl	1770c <memcmp>
    88f6:	2800      	cmp	r0, #0
    88f8:	d1ee      	bne.n	88d8 <id_find+0x8>
    88fa:	e001      	b.n	8900 <id_find+0x30>
			return id;
		}
	}

	return -ENOENT;
    88fc:	f06f 0601 	mvn.w	r6, #1
}
    8900:	4630      	mov	r0, r6
    8902:	bd70      	pop	{r4, r5, r6, pc}
    8904:	20000000 	.word	0x20000000

00008908 <set_random_address>:
{
    8908:	b570      	push	{r4, r5, r6, lr}
    890a:	4604      	mov	r4, r0
	return memcmp(a, b, sizeof(*a));
    890c:	2206      	movs	r2, #6
    890e:	4914      	ldr	r1, [pc, #80]	; (8960 <set_random_address+0x58>)
    8910:	f00e fefc 	bl	1770c <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
    8914:	4605      	mov	r5, r0
    8916:	b908      	cbnz	r0, 891c <set_random_address+0x14>
}
    8918:	4628      	mov	r0, r5
    891a:	bd70      	pop	{r4, r5, r6, pc}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
    891c:	2106      	movs	r1, #6
    891e:	f242 0005 	movw	r0, #8197	; 0x2005
    8922:	f7fe faad 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    8926:	4605      	mov	r5, r0
    8928:	b1b8      	cbz	r0, 895a <set_random_address+0x52>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    892a:	2206      	movs	r2, #6
    892c:	4621      	mov	r1, r4
    892e:	3008      	adds	r0, #8
    8930:	f011 fc6b 	bl	1a20a <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
    8934:	2200      	movs	r2, #0
    8936:	4629      	mov	r1, r5
    8938:	f242 0005 	movw	r0, #8197	; 0x2005
    893c:	f7fe fade 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    8940:	4605      	mov	r5, r0
    8942:	2800      	cmp	r0, #0
    8944:	d1e8      	bne.n	8918 <set_random_address+0x10>
	memcpy(dst, src, sizeof(*dst));
    8946:	4e06      	ldr	r6, [pc, #24]	; (8960 <set_random_address+0x58>)
    8948:	2206      	movs	r2, #6
    894a:	4621      	mov	r1, r4
    894c:	4630      	mov	r0, r6
    894e:	f00e feef 	bl	17730 <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
    8952:	2301      	movs	r3, #1
    8954:	f806 3c01 	strb.w	r3, [r6, #-1]
	return 0;
    8958:	e7de      	b.n	8918 <set_random_address+0x10>
		return -ENOBUFS;
    895a:	f06f 0568 	mvn.w	r5, #104	; 0x68
    895e:	e7db      	b.n	8918 <set_random_address+0x10>
    8960:	20000061 	.word	0x20000061

00008964 <id_create>:

static int id_create(uint8_t id, bt_addr_le_t *addr, uint8_t *irk)
{
    8964:	b530      	push	{r4, r5, lr}
    8966:	b085      	sub	sp, #20
    8968:	4604      	mov	r4, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    896a:	460d      	mov	r5, r1
    896c:	b149      	cbz	r1, 8982 <id_create+0x1e>
    896e:	2300      	movs	r3, #0
    8970:	9302      	str	r3, [sp, #8]
    8972:	f8cd 300b 	str.w	r3, [sp, #11]
	return memcmp(a, b, sizeof(*a));
    8976:	2207      	movs	r2, #7
    8978:	a902      	add	r1, sp, #8
    897a:	4628      	mov	r0, r5
    897c:	f00e fec6 	bl	1770c <memcmp>
    8980:	b9e0      	cbnz	r0, 89bc <id_create+0x58>
		bt_addr_le_t new_addr;

		do {
			int err;

			err = bt_addr_le_create_static(&new_addr);
    8982:	4668      	mov	r0, sp
    8984:	f00e ff85 	bl	17892 <bt_addr_le_create_static>
			if (err) {
    8988:	4603      	mov	r3, r0
    898a:	b9a0      	cbnz	r0, 89b6 <id_create+0x52>
				return err;
			}
			/* Make sure we didn't generate a duplicate */
		} while (id_find(&new_addr) >= 0);
    898c:	4668      	mov	r0, sp
    898e:	f7ff ff9f 	bl	88d0 <id_find>
    8992:	2800      	cmp	r0, #0
    8994:	daf5      	bge.n	8982 <id_create+0x1e>

		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
    8996:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    899a:	4b0d      	ldr	r3, [pc, #52]	; (89d0 <id_create+0x6c>)
    899c:	441c      	add	r4, r3
	memcpy(dst, src, sizeof(*dst));
    899e:	2207      	movs	r2, #7
    89a0:	4669      	mov	r1, sp
    89a2:	4620      	mov	r0, r4
    89a4:	f00e fec4 	bl	17730 <memcpy>

		if (addr) {
    89a8:	b125      	cbz	r5, 89b4 <id_create+0x50>
    89aa:	2207      	movs	r2, #7
    89ac:	4621      	mov	r1, r4
    89ae:	4628      	mov	r0, r5
    89b0:	f00e febe 	bl	17730 <memcpy>
	if (IS_ENABLED(CONFIG_BT_SETTINGS) &&
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
		bt_settings_save_id();
	}

	return 0;
    89b4:	2300      	movs	r3, #0
}
    89b6:	4618      	mov	r0, r3
    89b8:	b005      	add	sp, #20
    89ba:	bd30      	pop	{r4, r5, pc}
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
    89bc:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    89c0:	2207      	movs	r2, #7
    89c2:	4629      	mov	r1, r5
    89c4:	4802      	ldr	r0, [pc, #8]	; (89d0 <id_create+0x6c>)
    89c6:	4420      	add	r0, r4
    89c8:	f00e feb2 	bl	17730 <memcpy>
}
    89cc:	e7f2      	b.n	89b4 <id_create+0x50>
    89ce:	bf00      	nop
    89d0:	20000000 	.word	0x20000000

000089d4 <bt_id_create>:

int bt_id_create(bt_addr_le_t *addr, uint8_t *irk)
{
    89d4:	b570      	push	{r4, r5, r6, lr}
    89d6:	b08e      	sub	sp, #56	; 0x38
    89d8:	460c      	mov	r4, r1
	int new_id, err;

	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
    89da:	4605      	mov	r5, r0
    89dc:	2800      	cmp	r0, #0
    89de:	d03d      	beq.n	8a5c <bt_id_create+0x88>
    89e0:	2300      	movs	r3, #0
    89e2:	9304      	str	r3, [sp, #16]
    89e4:	f8cd 3013 	str.w	r3, [sp, #19]
	return memcmp(a, b, sizeof(*a));
    89e8:	2207      	movs	r2, #7
    89ea:	a904      	add	r1, sp, #16
    89ec:	f00e fe8e 	bl	1770c <memcmp>
    89f0:	b3a0      	cbz	r0, 8a5c <bt_id_create+0x88>
		if (addr->type != BT_ADDR_LE_RANDOM ||
    89f2:	782b      	ldrb	r3, [r5, #0]
    89f4:	2b01      	cmp	r3, #1
    89f6:	d104      	bne.n	8a02 <bt_id_create+0x2e>
		    !BT_ADDR_IS_STATIC(&addr->a)) {
    89f8:	79ab      	ldrb	r3, [r5, #6]
		if (addr->type != BT_ADDR_LE_RANDOM ||
    89fa:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    89fe:	2bc0      	cmp	r3, #192	; 0xc0
    8a00:	d027      	beq.n	8a52 <bt_id_create+0x7e>
			BT_ERR("Only static random identity address supported");
    8a02:	4b30      	ldr	r3, [pc, #192]	; (8ac4 <bt_id_create+0xf0>)
    8a04:	930d      	str	r3, [sp, #52]	; 0x34
    8a06:	2302      	movs	r3, #2
    8a08:	f88d 3000 	strb.w	r3, [sp]
    8a0c:	2300      	movs	r3, #0
    8a0e:	f88d 3001 	strb.w	r3, [sp, #1]
    8a12:	f88d 3002 	strb.w	r3, [sp, #2]
    8a16:	f88d 3003 	strb.w	r3, [sp, #3]
    8a1a:	9a00      	ldr	r2, [sp, #0]
    8a1c:	920c      	str	r2, [sp, #48]	; 0x30
    8a1e:	4619      	mov	r1, r3
    8a20:	f363 0100 	bfi	r1, r3, #0, #1
    8a24:	f363 0141 	bfi	r1, r3, #1, #1
    8a28:	f363 0182 	bfi	r1, r3, #2, #1
    8a2c:	f363 01c5 	bfi	r1, r3, #3, #3
    8a30:	2201      	movs	r2, #1
    8a32:	f362 1188 	bfi	r1, r2, #6, #3
    8a36:	2208      	movs	r2, #8
    8a38:	f362 2152 	bfi	r1, r2, #9, #10
    8a3c:	f363 41de 	bfi	r1, r3, #19, #12
    8a40:	f363 71df 	bfi	r1, r3, #31, #1
    8a44:	aa0c      	add	r2, sp, #48	; 0x30
    8a46:	4820      	ldr	r0, [pc, #128]	; (8ac8 <bt_id_create+0xf4>)
    8a48:	f7f9 fbfe 	bl	2248 <z_impl_z_log_msg_static_create>
			return -EINVAL;
    8a4c:	f06f 0015 	mvn.w	r0, #21
    8a50:	e029      	b.n	8aa6 <bt_id_create+0xd2>
		}

		if (id_find(addr) >= 0) {
    8a52:	4628      	mov	r0, r5
    8a54:	f7ff ff3c 	bl	88d0 <id_find>
    8a58:	2800      	cmp	r0, #0
    8a5a:	da26      	bge.n	8aaa <bt_id_create+0xd6>
			return -EALREADY;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
    8a5c:	bb5c      	cbnz	r4, 8ab6 <bt_id_create+0xe2>
		return -EINVAL;
	}

	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
    8a5e:	4b1b      	ldr	r3, [pc, #108]	; (8acc <bt_id_create+0xf8>)
    8a60:	79db      	ldrb	r3, [r3, #7]
    8a62:	2b01      	cmp	r3, #1
    8a64:	d02a      	beq.n	8abc <bt_id_create+0xe8>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    8a66:	4b1a      	ldr	r3, [pc, #104]	; (8ad0 <bt_id_create+0xfc>)
    8a68:	e8d3 3faf 	lda	r3, [r3]
		return -ENOMEM;
	}

	/* bt_rand is not available before Bluetooth enable has been called */
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ENABLE)) {
    8a6c:	f013 0f01 	tst.w	r3, #1
    8a70:	d10e      	bne.n	8a90 <bt_id_create+0xbc>
		uint8_t zero_irk[16] = { 0 };
    8a72:	2300      	movs	r3, #0
    8a74:	9300      	str	r3, [sp, #0]
    8a76:	9301      	str	r3, [sp, #4]
    8a78:	9302      	str	r3, [sp, #8]
    8a7a:	9303      	str	r3, [sp, #12]

		if (!(addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY))) {
    8a7c:	b1c5      	cbz	r5, 8ab0 <bt_id_create+0xdc>
    8a7e:	9306      	str	r3, [sp, #24]
    8a80:	f8cd 301b 	str.w	r3, [sp, #27]
    8a84:	2207      	movs	r2, #7
    8a86:	a906      	add	r1, sp, #24
    8a88:	4628      	mov	r0, r5
    8a8a:	f00e fe3f 	bl	1770c <memcmp>
    8a8e:	b178      	cbz	r0, 8ab0 <bt_id_create+0xdc>
		    !(irk && memcmp(irk, zero_irk, 16))) {
			return -EINVAL;
		}
	}

	new_id = bt_dev.id_count++;
    8a90:	4b0e      	ldr	r3, [pc, #56]	; (8acc <bt_id_create+0xf8>)
    8a92:	79de      	ldrb	r6, [r3, #7]
    8a94:	1c72      	adds	r2, r6, #1
    8a96:	71da      	strb	r2, [r3, #7]
	err = id_create(new_id, addr, irk);
    8a98:	4622      	mov	r2, r4
    8a9a:	4629      	mov	r1, r5
    8a9c:	4630      	mov	r0, r6
    8a9e:	f7ff ff61 	bl	8964 <id_create>
	if (err) {
    8aa2:	b900      	cbnz	r0, 8aa6 <bt_id_create+0xd2>
		return err;
	}

	return new_id;
    8aa4:	4630      	mov	r0, r6
}
    8aa6:	b00e      	add	sp, #56	; 0x38
    8aa8:	bd70      	pop	{r4, r5, r6, pc}
			return -EALREADY;
    8aaa:	f06f 0077 	mvn.w	r0, #119	; 0x77
    8aae:	e7fa      	b.n	8aa6 <bt_id_create+0xd2>
			return -EINVAL;
    8ab0:	f06f 0015 	mvn.w	r0, #21
    8ab4:	e7f7      	b.n	8aa6 <bt_id_create+0xd2>
		return -EINVAL;
    8ab6:	f06f 0015 	mvn.w	r0, #21
    8aba:	e7f4      	b.n	8aa6 <bt_id_create+0xd2>
		return -ENOMEM;
    8abc:	f06f 000b 	mvn.w	r0, #11
    8ac0:	e7f1      	b.n	8aa6 <bt_id_create+0xd2>
    8ac2:	bf00      	nop
    8ac4:	0001e7cc 	.word	0x0001e7cc
    8ac8:	0001d00c 	.word	0x0001d00c
    8acc:	20000000 	.word	0x20000000
    8ad0:	200000cc 	.word	0x200000cc

00008ad4 <bt_id_read_public_addr>:
#endif /* defined(CONFIG_BT_HCI_VS_EXT) */
}
#endif /* defined(CONFIG_BT_PRIVACY) */

uint8_t bt_id_read_public_addr(bt_addr_le_t *addr)
{
    8ad4:	b530      	push	{r4, r5, lr}
    8ad6:	b08d      	sub	sp, #52	; 0x34
    8ad8:	4605      	mov	r5, r0
	struct bt_hci_rp_read_bd_addr *rp;
	struct net_buf *rsp;
	int err;

	/* Read Bluetooth Address */
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
    8ada:	aa01      	add	r2, sp, #4
    8adc:	2100      	movs	r1, #0
    8ade:	f241 0009 	movw	r0, #4105	; 0x1009
    8ae2:	f7fe fa0b 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    8ae6:	b9f0      	cbnz	r0, 8b26 <bt_id_read_public_addr+0x52>
		BT_WARN("Failed to read public address");
		return 0U;
	}

	rp = (void *)rsp->data;
    8ae8:	9b01      	ldr	r3, [sp, #4]
    8aea:	689c      	ldr	r4, [r3, #8]

	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    8aec:	3401      	adds	r4, #1
    8aee:	2300      	movs	r3, #0
    8af0:	9302      	str	r3, [sp, #8]
    8af2:	f8ad 300c 	strh.w	r3, [sp, #12]
	return memcmp(a, b, sizeof(*a));
    8af6:	2206      	movs	r2, #6
    8af8:	a902      	add	r1, sp, #8
    8afa:	4620      	mov	r0, r4
    8afc:	f00e fe06 	bl	1770c <memcmp>
    8b00:	b158      	cbz	r0, 8b1a <bt_id_read_public_addr+0x46>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
    8b02:	4b22      	ldr	r3, [pc, #136]	; (8b8c <bt_id_read_public_addr+0xb8>)
    8b04:	e893 0003 	ldmia.w	r3, {r0, r1}
    8b08:	9004      	str	r0, [sp, #16]
    8b0a:	f8ad 1014 	strh.w	r1, [sp, #20]
    8b0e:	2206      	movs	r2, #6
    8b10:	a904      	add	r1, sp, #16
    8b12:	4620      	mov	r0, r4
    8b14:	f00e fdfa 	bl	1770c <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
    8b18:	bb60      	cbnz	r0, 8b74 <bt_id_read_public_addr+0xa0>
		BT_DBG("Controller has no public address");
		net_buf_unref(rsp);
    8b1a:	9801      	ldr	r0, [sp, #4]
    8b1c:	f011 fb25 	bl	1a16a <net_buf_unref>
		return 0U;
    8b20:	2000      	movs	r0, #0
	bt_addr_copy(&addr->a, &rp->bdaddr);
	addr->type = BT_ADDR_LE_PUBLIC;

	net_buf_unref(rsp);
	return 1U;
}
    8b22:	b00d      	add	sp, #52	; 0x34
    8b24:	bd30      	pop	{r4, r5, pc}
		BT_WARN("Failed to read public address");
    8b26:	4b1a      	ldr	r3, [pc, #104]	; (8b90 <bt_id_read_public_addr+0xbc>)
    8b28:	930b      	str	r3, [sp, #44]	; 0x2c
    8b2a:	2302      	movs	r3, #2
    8b2c:	f88d 3000 	strb.w	r3, [sp]
    8b30:	2400      	movs	r4, #0
    8b32:	f88d 4001 	strb.w	r4, [sp, #1]
    8b36:	f88d 4002 	strb.w	r4, [sp, #2]
    8b3a:	f88d 4003 	strb.w	r4, [sp, #3]
    8b3e:	9a00      	ldr	r2, [sp, #0]
    8b40:	920a      	str	r2, [sp, #40]	; 0x28
    8b42:	4621      	mov	r1, r4
    8b44:	f364 0100 	bfi	r1, r4, #0, #1
    8b48:	f364 0141 	bfi	r1, r4, #1, #1
    8b4c:	f364 0182 	bfi	r1, r4, #2, #1
    8b50:	f364 01c5 	bfi	r1, r4, #3, #3
    8b54:	f363 1188 	bfi	r1, r3, #6, #3
    8b58:	2308      	movs	r3, #8
    8b5a:	f363 2152 	bfi	r1, r3, #9, #10
    8b5e:	f364 41de 	bfi	r1, r4, #19, #12
    8b62:	f364 71df 	bfi	r1, r4, #31, #1
    8b66:	4623      	mov	r3, r4
    8b68:	aa0a      	add	r2, sp, #40	; 0x28
    8b6a:	480a      	ldr	r0, [pc, #40]	; (8b94 <bt_id_read_public_addr+0xc0>)
    8b6c:	f7f9 fb6c 	bl	2248 <z_impl_z_log_msg_static_create>
		return 0U;
    8b70:	4620      	mov	r0, r4
    8b72:	e7d6      	b.n	8b22 <bt_id_read_public_addr+0x4e>
	memcpy(dst, src, sizeof(*dst));
    8b74:	2206      	movs	r2, #6
    8b76:	4621      	mov	r1, r4
    8b78:	1c68      	adds	r0, r5, #1
    8b7a:	f00e fdd9 	bl	17730 <memcpy>
	addr->type = BT_ADDR_LE_PUBLIC;
    8b7e:	2300      	movs	r3, #0
    8b80:	702b      	strb	r3, [r5, #0]
	net_buf_unref(rsp);
    8b82:	9801      	ldr	r0, [sp, #4]
    8b84:	f011 faf1 	bl	1a16a <net_buf_unref>
	return 1U;
    8b88:	2001      	movs	r0, #1
    8b8a:	e7ca      	b.n	8b22 <bt_id_read_public_addr+0x4e>
    8b8c:	0001d1c0 	.word	0x0001d1c0
    8b90:	0001e7fc 	.word	0x0001e7fc
    8b94:	0001d00c 	.word	0x0001d00c

00008b98 <bt_setup_public_id_addr>:

int bt_setup_public_id_addr(void)
{
    8b98:	b500      	push	{lr}
    8b9a:	b083      	sub	sp, #12
	bt_addr_le_t addr;
	uint8_t *irk = NULL;

	bt_dev.id_count = bt_id_read_public_addr(&addr);
    8b9c:	4668      	mov	r0, sp
    8b9e:	f7ff ff99 	bl	8ad4 <bt_id_read_public_addr>
    8ba2:	4b06      	ldr	r3, [pc, #24]	; (8bbc <bt_setup_public_id_addr+0x24>)
    8ba4:	71d8      	strb	r0, [r3, #7]

	if (!bt_dev.id_count) {
    8ba6:	b918      	cbnz	r0, 8bb0 <bt_setup_public_id_addr+0x18>
		return 0;
    8ba8:	2000      	movs	r0, #0
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}
#endif /* defined(CONFIG_BT_PRIVACY) */

	return id_create(BT_ID_DEFAULT, &addr, irk);
}
    8baa:	b003      	add	sp, #12
    8bac:	f85d fb04 	ldr.w	pc, [sp], #4
	return id_create(BT_ID_DEFAULT, &addr, irk);
    8bb0:	2200      	movs	r2, #0
    8bb2:	4669      	mov	r1, sp
    8bb4:	4610      	mov	r0, r2
    8bb6:	f7ff fed5 	bl	8964 <id_create>
    8bba:	e7f6      	b.n	8baa <bt_setup_public_id_addr+0x12>
    8bbc:	20000000 	.word	0x20000000

00008bc0 <bt_read_static_addr>:

#if defined(CONFIG_BT_HCI_VS_EXT)
uint8_t bt_read_static_addr(struct bt_hci_vs_static_addr addrs[], uint8_t size)
{
    8bc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8bc4:	b094      	sub	sp, #80	; 0x50
	struct bt_hci_rp_vs_read_static_addrs *rp;
	struct net_buf *rsp;
	int err, i;
	uint8_t cnt;

	if (!BT_VS_CMD_READ_STATIC_ADDRS(bt_dev.vs_commands)) {
    8bc6:	4b4c      	ldr	r3, [pc, #304]	; (8cf8 <bt_read_static_addr+0x138>)
    8bc8:	f893 50ba 	ldrb.w	r5, [r3, #186]	; 0xba
    8bcc:	f015 0501 	ands.w	r5, r5, #1
    8bd0:	d010      	beq.n	8bf4 <bt_read_static_addr+0x34>
    8bd2:	4607      	mov	r7, r0
    8bd4:	4688      	mov	r8, r1
		BT_WARN("Read Static Addresses command not available");
		return 0;
	}

	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
    8bd6:	aa01      	add	r2, sp, #4
    8bd8:	2100      	movs	r1, #0
    8bda:	f64f 4009 	movw	r0, #64521	; 0xfc09
    8bde:	f7fe f98d 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    8be2:	4604      	mov	r4, r0
    8be4:	bb58      	cbnz	r0, 8c3e <bt_read_static_addr+0x7e>
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	rp = (void *)rsp->data;
    8be6:	9b01      	ldr	r3, [sp, #4]
    8be8:	689e      	ldr	r6, [r3, #8]
	cnt = MIN(rp->num_addrs, size);
    8bea:	7875      	ldrb	r5, [r6, #1]
    8bec:	4545      	cmp	r5, r8
    8bee:	bf28      	it	cs
    8bf0:	4645      	movcs	r5, r8
		BT_WARN("Invalid Vendor HCI extensions");
		net_buf_unref(rsp);
		return 0;
	}

	for (i = 0; i < cnt; i++) {
    8bf2:	e051      	b.n	8c98 <bt_read_static_addr+0xd8>
		BT_WARN("Read Static Addresses command not available");
    8bf4:	4b41      	ldr	r3, [pc, #260]	; (8cfc <bt_read_static_addr+0x13c>)
    8bf6:	9313      	str	r3, [sp, #76]	; 0x4c
    8bf8:	2202      	movs	r2, #2
    8bfa:	f88d 2000 	strb.w	r2, [sp]
    8bfe:	2300      	movs	r3, #0
    8c00:	f88d 3001 	strb.w	r3, [sp, #1]
    8c04:	f88d 3002 	strb.w	r3, [sp, #2]
    8c08:	f88d 3003 	strb.w	r3, [sp, #3]
    8c0c:	9900      	ldr	r1, [sp, #0]
    8c0e:	9112      	str	r1, [sp, #72]	; 0x48
    8c10:	4619      	mov	r1, r3
    8c12:	f363 0100 	bfi	r1, r3, #0, #1
    8c16:	f363 0141 	bfi	r1, r3, #1, #1
    8c1a:	f363 0182 	bfi	r1, r3, #2, #1
    8c1e:	f363 01c5 	bfi	r1, r3, #3, #3
    8c22:	f362 1188 	bfi	r1, r2, #6, #3
    8c26:	2208      	movs	r2, #8
    8c28:	f362 2152 	bfi	r1, r2, #9, #10
    8c2c:	f363 41de 	bfi	r1, r3, #19, #12
    8c30:	f363 71df 	bfi	r1, r3, #31, #1
    8c34:	aa12      	add	r2, sp, #72	; 0x48
    8c36:	4832      	ldr	r0, [pc, #200]	; (8d00 <bt_read_static_addr+0x140>)
    8c38:	f7f9 fb06 	bl	2248 <z_impl_z_log_msg_static_create>
		return 0;
    8c3c:	e032      	b.n	8ca4 <bt_read_static_addr+0xe4>
		BT_WARN("Failed to read static addresses");
    8c3e:	4b31      	ldr	r3, [pc, #196]	; (8d04 <bt_read_static_addr+0x144>)
    8c40:	930d      	str	r3, [sp, #52]	; 0x34
    8c42:	2302      	movs	r3, #2
    8c44:	f88d 3000 	strb.w	r3, [sp]
    8c48:	2500      	movs	r5, #0
    8c4a:	f88d 5001 	strb.w	r5, [sp, #1]
    8c4e:	f88d 5002 	strb.w	r5, [sp, #2]
    8c52:	f88d 5003 	strb.w	r5, [sp, #3]
    8c56:	9a00      	ldr	r2, [sp, #0]
    8c58:	920c      	str	r2, [sp, #48]	; 0x30
    8c5a:	4629      	mov	r1, r5
    8c5c:	f365 0100 	bfi	r1, r5, #0, #1
    8c60:	f365 0141 	bfi	r1, r5, #1, #1
    8c64:	f365 0182 	bfi	r1, r5, #2, #1
    8c68:	f365 01c5 	bfi	r1, r5, #3, #3
    8c6c:	f363 1188 	bfi	r1, r3, #6, #3
    8c70:	2308      	movs	r3, #8
    8c72:	f363 2152 	bfi	r1, r3, #9, #10
    8c76:	f365 41de 	bfi	r1, r5, #19, #12
    8c7a:	f365 71df 	bfi	r1, r5, #31, #1
    8c7e:	462b      	mov	r3, r5
    8c80:	aa0c      	add	r2, sp, #48	; 0x30
    8c82:	481f      	ldr	r0, [pc, #124]	; (8d00 <bt_read_static_addr+0x140>)
    8c84:	f7f9 fae0 	bl	2248 <z_impl_z_log_msg_static_create>
		return 0;
    8c88:	e00c      	b.n	8ca4 <bt_read_static_addr+0xe4>
		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
    8c8a:	2216      	movs	r2, #22
    8c8c:	1cb1      	adds	r1, r6, #2
    8c8e:	fb02 7004 	mla	r0, r2, r4, r7
    8c92:	f00e fd4d 	bl	17730 <memcpy>
	for (i = 0; i < cnt; i++) {
    8c96:	3401      	adds	r4, #1
    8c98:	42a5      	cmp	r5, r4
    8c9a:	dcf6      	bgt.n	8c8a <bt_read_static_addr+0xca>
	}

	net_buf_unref(rsp);
    8c9c:	9801      	ldr	r0, [sp, #4]
    8c9e:	f011 fa64 	bl	1a16a <net_buf_unref>
	if (!cnt) {
    8ca2:	b11d      	cbz	r5, 8cac <bt_read_static_addr+0xec>
		BT_WARN("No static addresses stored in controller");
	}

	return cnt;
}
    8ca4:	4628      	mov	r0, r5
    8ca6:	b014      	add	sp, #80	; 0x50
    8ca8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_WARN("No static addresses stored in controller");
    8cac:	4b16      	ldr	r3, [pc, #88]	; (8d08 <bt_read_static_addr+0x148>)
    8cae:	9307      	str	r3, [sp, #28]
    8cb0:	2202      	movs	r2, #2
    8cb2:	f88d 2000 	strb.w	r2, [sp]
    8cb6:	2300      	movs	r3, #0
    8cb8:	f88d 3001 	strb.w	r3, [sp, #1]
    8cbc:	f88d 3002 	strb.w	r3, [sp, #2]
    8cc0:	f88d 3003 	strb.w	r3, [sp, #3]
    8cc4:	9900      	ldr	r1, [sp, #0]
    8cc6:	9106      	str	r1, [sp, #24]
    8cc8:	4619      	mov	r1, r3
    8cca:	f363 0100 	bfi	r1, r3, #0, #1
    8cce:	f363 0141 	bfi	r1, r3, #1, #1
    8cd2:	f363 0182 	bfi	r1, r3, #2, #1
    8cd6:	f363 01c5 	bfi	r1, r3, #3, #3
    8cda:	f362 1188 	bfi	r1, r2, #6, #3
    8cde:	2208      	movs	r2, #8
    8ce0:	f362 2152 	bfi	r1, r2, #9, #10
    8ce4:	f363 41de 	bfi	r1, r3, #19, #12
    8ce8:	f363 71df 	bfi	r1, r3, #31, #1
    8cec:	aa06      	add	r2, sp, #24
    8cee:	4804      	ldr	r0, [pc, #16]	; (8d00 <bt_read_static_addr+0x140>)
    8cf0:	f7f9 faaa 	bl	2248 <z_impl_z_log_msg_static_create>
    8cf4:	e7d6      	b.n	8ca4 <bt_read_static_addr+0xe4>
    8cf6:	bf00      	nop
    8cf8:	20000000 	.word	0x20000000
    8cfc:	0001e81c 	.word	0x0001e81c
    8d00:	0001d00c 	.word	0x0001d00c
    8d04:	0001e848 	.word	0x0001e848
    8d08:	0001e868 	.word	0x0001e868

00008d0c <bt_setup_random_id_addr>:
#endif /* CONFIG_BT_HCI_VS_EXT */

int bt_setup_random_id_addr(void)
{
    8d0c:	b510      	push	{r4, lr}
    8d0e:	b088      	sub	sp, #32
#if defined(CONFIG_BT_HCI_VS_EXT) || defined(CONFIG_BT_CTLR)
	/* Only read the addresses if the user has not already configured one or
	 * more identities (!bt_dev.id_count).
	 */
	if (!bt_dev.id_count) {
    8d10:	4b17      	ldr	r3, [pc, #92]	; (8d70 <bt_setup_random_id_addr+0x64>)
    8d12:	79dc      	ldrb	r4, [r3, #7]
    8d14:	b934      	cbnz	r4, 8d24 <bt_setup_random_id_addr+0x18>
		struct bt_hci_vs_static_addr addrs[CONFIG_BT_ID_MAX];

		bt_dev.id_count = bt_read_static_addr(addrs, CONFIG_BT_ID_MAX);
    8d16:	2101      	movs	r1, #1
    8d18:	a802      	add	r0, sp, #8
    8d1a:	f7ff ff51 	bl	8bc0 <bt_read_static_addr>
    8d1e:	4b14      	ldr	r3, [pc, #80]	; (8d70 <bt_setup_random_id_addr+0x64>)
    8d20:	71d8      	strb	r0, [r3, #7]

		if (bt_dev.id_count) {
    8d22:	b948      	cbnz	r0, 8d38 <bt_setup_random_id_addr+0x2c>

	if (IS_ENABLED(CONFIG_BT_PRIVACY) && IS_ENABLED(CONFIG_BT_SETTINGS)) {
		atomic_set_bit(bt_dev.flags, BT_DEV_STORE_ID);
	}

	return bt_id_create(NULL, NULL);
    8d24:	2100      	movs	r1, #0
    8d26:	4608      	mov	r0, r1
    8d28:	f7ff fe54 	bl	89d4 <bt_id_create>
    8d2c:	4603      	mov	r3, r0
}
    8d2e:	4618      	mov	r0, r3
    8d30:	b008      	add	sp, #32
    8d32:	bd10      	pop	{r4, pc}
			for (uint8_t i = 0; i < bt_dev.id_count; i++) {
    8d34:	3401      	adds	r4, #1
    8d36:	b2e4      	uxtb	r4, r4
    8d38:	4b0d      	ldr	r3, [pc, #52]	; (8d70 <bt_setup_random_id_addr+0x64>)
    8d3a:	79db      	ldrb	r3, [r3, #7]
    8d3c:	42a3      	cmp	r3, r4
    8d3e:	d914      	bls.n	8d6a <bt_setup_random_id_addr+0x5e>
    8d40:	2206      	movs	r2, #6
    8d42:	2116      	movs	r1, #22
    8d44:	ab02      	add	r3, sp, #8
    8d46:	fb01 3104 	mla	r1, r1, r4, r3
    8d4a:	f10d 0001 	add.w	r0, sp, #1
    8d4e:	f00e fcef 	bl	17730 <memcpy>
				addr.type = BT_ADDR_LE_RANDOM;
    8d52:	2301      	movs	r3, #1
    8d54:	f88d 3000 	strb.w	r3, [sp]
				err = id_create(i, &addr, irk);
    8d58:	2200      	movs	r2, #0
    8d5a:	4669      	mov	r1, sp
    8d5c:	4620      	mov	r0, r4
    8d5e:	f7ff fe01 	bl	8964 <id_create>
				if (err) {
    8d62:	4603      	mov	r3, r0
    8d64:	2800      	cmp	r0, #0
    8d66:	d0e5      	beq.n	8d34 <bt_setup_random_id_addr+0x28>
    8d68:	e7e1      	b.n	8d2e <bt_setup_random_id_addr+0x22>
			return 0;
    8d6a:	2300      	movs	r3, #0
    8d6c:	e7df      	b.n	8d2e <bt_setup_random_id_addr+0x22>
    8d6e:	bf00      	nop
    8d70:	20000000 	.word	0x20000000

00008d74 <bt_id_set_adv_own_addr>:
}
#endif /* defined(CONFIG_BT_OBSERVER) */

int bt_id_set_adv_own_addr(struct bt_le_ext_adv *adv, uint32_t options,
			   bool dir_adv, uint8_t *own_addr_type)
{
    8d74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8d76:	460d      	mov	r5, r1
    8d78:	461e      	mov	r6, r3
	const bt_addr_le_t *id_addr;
	int err = 0;

	/* Set which local identity address we're advertising with */
	id_addr = &bt_dev.id_addr[adv->id];
    8d7a:	7804      	ldrb	r4, [r0, #0]

	if (options & BT_LE_ADV_OPT_CONNECTABLE) {
    8d7c:	f011 0f01 	tst.w	r1, #1
    8d80:	d027      	beq.n	8dd2 <bt_id_set_adv_own_addr+0x5e>
    8d82:	4617      	mov	r7, r2
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    8d84:	b142      	cbz	r2, 8d98 <bt_id_set_adv_own_addr+0x24>
    8d86:	f011 0f20 	tst.w	r1, #32
    8d8a:	d005      	beq.n	8d98 <bt_id_set_adv_own_addr+0x24>
		    !BT_FEAT_LE_PRIVACY(bt_dev.le.features)) {
    8d8c:	4b22      	ldr	r3, [pc, #136]	; (8e18 <bt_id_set_adv_own_addr+0xa4>)
    8d8e:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
		if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA) &&
    8d92:	f013 0f40 	tst.w	r3, #64	; 0x40
    8d96:	d038      	beq.n	8e0a <bt_id_set_adv_own_addr+0x96>
			 * If Static Random address is used as Identity
			 * address we need to restore it before advertising
			 * is enabled. Otherwise NRPA used for active scan
			 * could be used for advertising.
			 */
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    8d98:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
    8d9c:	4a1e      	ldr	r2, [pc, #120]	; (8e18 <bt_id_set_adv_own_addr+0xa4>)
    8d9e:	5cd3      	ldrb	r3, [r2, r3]
    8da0:	2b01      	cmp	r3, #1
    8da2:	d00d      	beq.n	8dc0 <bt_id_set_adv_own_addr+0x4c>
				if (err) {
					return err;
				}
			}

			*own_addr_type = id_addr->type;
    8da4:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    8da8:	4b1b      	ldr	r3, [pc, #108]	; (8e18 <bt_id_set_adv_own_addr+0xa4>)
    8daa:	5d1b      	ldrb	r3, [r3, r4]
    8dac:	7033      	strb	r3, [r6, #0]

			if (dir_adv && (options & BT_LE_ADV_OPT_DIR_ADDR_RPA)) {
    8dae:	b37f      	cbz	r7, 8e10 <bt_id_set_adv_own_addr+0x9c>
    8db0:	f015 0f20 	tst.w	r5, #32
    8db4:	d02e      	beq.n	8e14 <bt_id_set_adv_own_addr+0xa0>
				*own_addr_type |= BT_HCI_OWN_ADDR_RPA_MASK;
    8db6:	f043 0302 	orr.w	r3, r3, #2
    8dba:	7033      	strb	r3, [r6, #0]
		if (err) {
			return err;
		}
	}

	return 0;
    8dbc:	2000      	movs	r0, #0
    8dbe:	e017      	b.n	8df0 <bt_id_set_adv_own_addr+0x7c>
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    8dc0:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    8dc4:	4411      	add	r1, r2
    8dc6:	3101      	adds	r1, #1
    8dc8:	f00e fec6 	bl	17b58 <bt_id_set_adv_random_addr>
				if (err) {
    8dcc:	2800      	cmp	r0, #0
    8dce:	d0e9      	beq.n	8da4 <bt_id_set_adv_own_addr+0x30>
    8dd0:	e00e      	b.n	8df0 <bt_id_set_adv_own_addr+0x7c>
		if (options & BT_LE_ADV_OPT_USE_IDENTITY) {
    8dd2:	f011 0f04 	tst.w	r1, #4
    8dd6:	d013      	beq.n	8e00 <bt_id_set_adv_own_addr+0x8c>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
    8dd8:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
    8ddc:	4a0e      	ldr	r2, [pc, #56]	; (8e18 <bt_id_set_adv_own_addr+0xa4>)
    8dde:	5cd3      	ldrb	r3, [r2, r3]
    8de0:	2b01      	cmp	r3, #1
    8de2:	d006      	beq.n	8df2 <bt_id_set_adv_own_addr+0x7e>
	int err = 0;
    8de4:	2000      	movs	r0, #0
			*own_addr_type = id_addr->type;
    8de6:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    8dea:	4b0b      	ldr	r3, [pc, #44]	; (8e18 <bt_id_set_adv_own_addr+0xa4>)
    8dec:	5d1b      	ldrb	r3, [r3, r4]
    8dee:	7033      	strb	r3, [r6, #0]
}
    8df0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				err = bt_id_set_adv_random_addr(adv, &id_addr->a);
    8df2:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
    8df6:	4411      	add	r1, r2
    8df8:	3101      	adds	r1, #1
    8dfa:	f00e fead 	bl	17b58 <bt_id_set_adv_random_addr>
    8dfe:	e7f2      	b.n	8de6 <bt_id_set_adv_own_addr+0x72>
			err = bt_id_set_adv_private_addr(adv);
    8e00:	f00e feaf 	bl	17b62 <bt_id_set_adv_private_addr>
			*own_addr_type = BT_ADDR_LE_RANDOM;
    8e04:	2301      	movs	r3, #1
    8e06:	7033      	strb	r3, [r6, #0]
		if (err) {
    8e08:	e7f2      	b.n	8df0 <bt_id_set_adv_own_addr+0x7c>
			return -ENOTSUP;
    8e0a:	f06f 0085 	mvn.w	r0, #133	; 0x85
    8e0e:	e7ef      	b.n	8df0 <bt_id_set_adv_own_addr+0x7c>
	return 0;
    8e10:	2000      	movs	r0, #0
    8e12:	e7ed      	b.n	8df0 <bt_id_set_adv_own_addr+0x7c>
    8e14:	2000      	movs	r0, #0
    8e16:	e7eb      	b.n	8df0 <bt_id_set_adv_own_addr+0x7c>
    8e18:	20000000 	.word	0x20000000

00008e1c <bt_id_init>:
}
#endif /* !defined(CONFIG_BT_SMP_OOB_LEGACY_PAIR_ONLY) */
#endif /* defined(CONFIG_BT_SMP) */

int bt_id_init(void)
{
    8e1c:	b510      	push	{r4, lr}
    8e1e:	b094      	sub	sp, #80	; 0x50
	int err;

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    8e20:	4b45      	ldr	r3, [pc, #276]	; (8f38 <bt_id_init+0x11c>)
    8e22:	79db      	ldrb	r3, [r3, #7]
    8e24:	b133      	cbz	r3, 8e34 <bt_id_init+0x18>
			BT_ERR("Unable to set identity address");
			return err;
		}
	}

	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
    8e26:	4b44      	ldr	r3, [pc, #272]	; (8f38 <bt_id_init+0x11c>)
    8e28:	79db      	ldrb	r3, [r3, #7]
    8e2a:	b373      	cbz	r3, 8e8a <bt_id_init+0x6e>

#if defined(CONFIG_BT_PRIVACY)
	k_work_init_delayable(&bt_dev.rpa_update, rpa_timeout);
#endif

	return 0;
    8e2c:	2400      	movs	r4, #0
}
    8e2e:	4620      	mov	r0, r4
    8e30:	b014      	add	sp, #80	; 0x50
    8e32:	bd10      	pop	{r4, pc}
		err = bt_setup_public_id_addr();
    8e34:	f7ff feb0 	bl	8b98 <bt_setup_public_id_addr>
		if (err) {
    8e38:	4604      	mov	r4, r0
    8e3a:	2800      	cmp	r0, #0
    8e3c:	d0f3      	beq.n	8e26 <bt_id_init+0xa>
			BT_ERR("Unable to set identity address");
    8e3e:	4b3f      	ldr	r3, [pc, #252]	; (8f3c <bt_id_init+0x120>)
    8e40:	9307      	str	r3, [sp, #28]
    8e42:	2302      	movs	r3, #2
    8e44:	f88d 3004 	strb.w	r3, [sp, #4]
    8e48:	2300      	movs	r3, #0
    8e4a:	f88d 3005 	strb.w	r3, [sp, #5]
    8e4e:	f88d 3006 	strb.w	r3, [sp, #6]
    8e52:	f88d 3007 	strb.w	r3, [sp, #7]
    8e56:	9a01      	ldr	r2, [sp, #4]
    8e58:	9206      	str	r2, [sp, #24]
    8e5a:	4619      	mov	r1, r3
    8e5c:	f363 0100 	bfi	r1, r3, #0, #1
    8e60:	f363 0141 	bfi	r1, r3, #1, #1
    8e64:	f363 0182 	bfi	r1, r3, #2, #1
    8e68:	f363 01c5 	bfi	r1, r3, #3, #3
    8e6c:	2201      	movs	r2, #1
    8e6e:	f362 1188 	bfi	r1, r2, #6, #3
    8e72:	2208      	movs	r2, #8
    8e74:	f362 2152 	bfi	r1, r2, #9, #10
    8e78:	f363 41de 	bfi	r1, r3, #19, #12
    8e7c:	f363 71df 	bfi	r1, r3, #31, #1
    8e80:	aa06      	add	r2, sp, #24
    8e82:	482f      	ldr	r0, [pc, #188]	; (8f40 <bt_id_init+0x124>)
    8e84:	f7f9 f9e0 	bl	2248 <z_impl_z_log_msg_static_create>
			return err;
    8e88:	e7d1      	b.n	8e2e <bt_id_init+0x12>
		err = bt_setup_random_id_addr();
    8e8a:	f7ff ff3f 	bl	8d0c <bt_setup_random_id_addr>
		if (err) {
    8e8e:	4604      	mov	r4, r0
    8e90:	bb58      	cbnz	r0, 8eea <bt_id_init+0xce>
		err = set_random_address(&bt_dev.id_addr[0].a);
    8e92:	482c      	ldr	r0, [pc, #176]	; (8f44 <bt_id_init+0x128>)
    8e94:	f7ff fd38 	bl	8908 <set_random_address>
		if (err) {
    8e98:	4604      	mov	r4, r0
    8e9a:	2800      	cmp	r0, #0
    8e9c:	d0c7      	beq.n	8e2e <bt_id_init+0x12>
			BT_ERR("Unable to set random address");
    8e9e:	4b2a      	ldr	r3, [pc, #168]	; (8f48 <bt_id_init+0x12c>)
    8ea0:	930d      	str	r3, [sp, #52]	; 0x34
    8ea2:	2302      	movs	r3, #2
    8ea4:	f88d 3004 	strb.w	r3, [sp, #4]
    8ea8:	2300      	movs	r3, #0
    8eaa:	f88d 3005 	strb.w	r3, [sp, #5]
    8eae:	f88d 3006 	strb.w	r3, [sp, #6]
    8eb2:	f88d 3007 	strb.w	r3, [sp, #7]
    8eb6:	9a01      	ldr	r2, [sp, #4]
    8eb8:	920c      	str	r2, [sp, #48]	; 0x30
    8eba:	4619      	mov	r1, r3
    8ebc:	f363 0100 	bfi	r1, r3, #0, #1
    8ec0:	f363 0141 	bfi	r1, r3, #1, #1
    8ec4:	f363 0182 	bfi	r1, r3, #2, #1
    8ec8:	f363 01c5 	bfi	r1, r3, #3, #3
    8ecc:	2201      	movs	r2, #1
    8ece:	f362 1188 	bfi	r1, r2, #6, #3
    8ed2:	2208      	movs	r2, #8
    8ed4:	f362 2152 	bfi	r1, r2, #9, #10
    8ed8:	f363 41de 	bfi	r1, r3, #19, #12
    8edc:	f363 71df 	bfi	r1, r3, #31, #1
    8ee0:	aa0c      	add	r2, sp, #48	; 0x30
    8ee2:	4817      	ldr	r0, [pc, #92]	; (8f40 <bt_id_init+0x124>)
    8ee4:	f7f9 f9b0 	bl	2248 <z_impl_z_log_msg_static_create>
			return err;
    8ee8:	e7a1      	b.n	8e2e <bt_id_init+0x12>
			BT_ERR("Unable to set identity address");
    8eea:	4b14      	ldr	r3, [pc, #80]	; (8f3c <bt_id_init+0x120>)
    8eec:	9313      	str	r3, [sp, #76]	; 0x4c
    8eee:	2302      	movs	r3, #2
    8ef0:	f88d 3004 	strb.w	r3, [sp, #4]
    8ef4:	2300      	movs	r3, #0
    8ef6:	f88d 3005 	strb.w	r3, [sp, #5]
    8efa:	f88d 3006 	strb.w	r3, [sp, #6]
    8efe:	f88d 3007 	strb.w	r3, [sp, #7]
    8f02:	9a01      	ldr	r2, [sp, #4]
    8f04:	9212      	str	r2, [sp, #72]	; 0x48
    8f06:	4619      	mov	r1, r3
    8f08:	f363 0100 	bfi	r1, r3, #0, #1
    8f0c:	f363 0141 	bfi	r1, r3, #1, #1
    8f10:	f363 0182 	bfi	r1, r3, #2, #1
    8f14:	f363 01c5 	bfi	r1, r3, #3, #3
    8f18:	2201      	movs	r2, #1
    8f1a:	f362 1188 	bfi	r1, r2, #6, #3
    8f1e:	2208      	movs	r2, #8
    8f20:	f362 2152 	bfi	r1, r2, #9, #10
    8f24:	f363 41de 	bfi	r1, r3, #19, #12
    8f28:	f363 71df 	bfi	r1, r3, #31, #1
    8f2c:	aa12      	add	r2, sp, #72	; 0x48
    8f2e:	4804      	ldr	r0, [pc, #16]	; (8f40 <bt_id_init+0x124>)
    8f30:	f7f9 f98a 	bl	2248 <z_impl_z_log_msg_static_create>
			return err;
    8f34:	e77b      	b.n	8e2e <bt_id_init+0x12>
    8f36:	bf00      	nop
    8f38:	20000000 	.word	0x20000000
    8f3c:	0001e894 	.word	0x0001e894
    8f40:	0001d00c 	.word	0x0001d00c
    8f44:	20000001 	.word	0x20000001
    8f48:	0001e8b4 	.word	0x0001e8b4

00008f4c <adv_new_legacy>:
	bt_dev.adv = adv_new();
	return bt_dev.adv;
#else
	return &bt_dev.adv;
#endif
}
    8f4c:	4800      	ldr	r0, [pc, #0]	; (8f50 <adv_new_legacy+0x4>)
    8f4e:	4770      	bx	lr
    8f50:	20000018 	.word	0x20000018

00008f54 <set_data_add_complete>:
	return valid_adv_ext_param(param);
}

static int set_data_add_complete(uint8_t *set_data, uint8_t set_data_len_max,
			const struct bt_ad *ad, size_t ad_len, uint8_t *data_len)
{
    8f54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f58:	b08b      	sub	sp, #44	; 0x2c
    8f5a:	4607      	mov	r7, r0
    8f5c:	4689      	mov	r9, r1
    8f5e:	9201      	str	r2, [sp, #4]
    8f60:	9300      	str	r3, [sp, #0]
	uint8_t set_data_len = 0;

	for (size_t i = 0; i < ad_len; i++) {
    8f62:	f04f 0b00 	mov.w	fp, #0
	uint8_t set_data_len = 0;
    8f66:	465c      	mov	r4, fp
	for (size_t i = 0; i < ad_len; i++) {
    8f68:	9b00      	ldr	r3, [sp, #0]
    8f6a:	459b      	cmp	fp, r3
    8f6c:	d25b      	bcs.n	9026 <set_data_add_complete+0xd2>
		const struct bt_data *data = ad[i].data;
    8f6e:	9b01      	ldr	r3, [sp, #4]
    8f70:	eb03 0acb 	add.w	sl, r3, fp, lsl #3
    8f74:	f853 803b 	ldr.w	r8, [r3, fp, lsl #3]

		for (size_t j = 0; j < ad[i].len; j++) {
    8f78:	2500      	movs	r5, #0
    8f7a:	e03a      	b.n	8ff2 <set_data_add_complete+0x9e>
				ssize_t shortened_len = set_data_len_max -
							(set_data_len + 2);

				if (!(type == BT_DATA_NAME_COMPLETE &&
				      shortened_len > 0)) {
					BT_ERR("Too big advertising data");
    8f7c:	4b2c      	ldr	r3, [pc, #176]	; (9030 <set_data_add_complete+0xdc>)
    8f7e:	9309      	str	r3, [sp, #36]	; 0x24
    8f80:	2302      	movs	r3, #2
    8f82:	f88d 300c 	strb.w	r3, [sp, #12]
    8f86:	2300      	movs	r3, #0
    8f88:	f88d 300d 	strb.w	r3, [sp, #13]
    8f8c:	f88d 300e 	strb.w	r3, [sp, #14]
    8f90:	f88d 300f 	strb.w	r3, [sp, #15]
    8f94:	9a03      	ldr	r2, [sp, #12]
    8f96:	9208      	str	r2, [sp, #32]
    8f98:	4619      	mov	r1, r3
    8f9a:	f363 0100 	bfi	r1, r3, #0, #1
    8f9e:	f363 0141 	bfi	r1, r3, #1, #1
    8fa2:	f363 0182 	bfi	r1, r3, #2, #1
    8fa6:	f363 01c5 	bfi	r1, r3, #3, #3
    8faa:	2201      	movs	r2, #1
    8fac:	f362 1188 	bfi	r1, r2, #6, #3
    8fb0:	2208      	movs	r2, #8
    8fb2:	f362 2152 	bfi	r1, r2, #9, #10
    8fb6:	f363 41de 	bfi	r1, r3, #19, #12
    8fba:	f363 71df 	bfi	r1, r3, #31, #1
    8fbe:	aa08      	add	r2, sp, #32
    8fc0:	481c      	ldr	r0, [pc, #112]	; (9034 <set_data_add_complete+0xe0>)
    8fc2:	f7f9 f941 	bl	2248 <z_impl_z_log_msg_static_create>
					return -EINVAL;
    8fc6:	f06f 0015 	mvn.w	r0, #21
		}
	}

	*data_len = set_data_len;
	return 0;
}
    8fca:	b00b      	add	sp, #44	; 0x2c
    8fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			set_data[set_data_len++] = len + 1;
    8fd0:	b2d6      	uxtb	r6, r2
    8fd2:	1c63      	adds	r3, r4, #1
    8fd4:	b2db      	uxtb	r3, r3
    8fd6:	f106 0e01 	add.w	lr, r6, #1
    8fda:	f807 e00c 	strb.w	lr, [r7, ip]
			set_data[set_data_len++] = type;
    8fde:	3402      	adds	r4, #2
    8fe0:	b2e4      	uxtb	r4, r4
    8fe2:	54f8      	strb	r0, [r7, r3]
			memcpy(&set_data[set_data_len], data[j].data, len);
    8fe4:	6849      	ldr	r1, [r1, #4]
    8fe6:	1938      	adds	r0, r7, r4
    8fe8:	f00e fba2 	bl	17730 <memcpy>
			set_data_len += len;
    8fec:	4434      	add	r4, r6
    8fee:	b2e4      	uxtb	r4, r4
		for (size_t j = 0; j < ad[i].len; j++) {
    8ff0:	3501      	adds	r5, #1
    8ff2:	f8da 3004 	ldr.w	r3, [sl, #4]
    8ff6:	429d      	cmp	r5, r3
    8ff8:	d212      	bcs.n	9020 <set_data_add_complete+0xcc>
			size_t len = data[j].data_len;
    8ffa:	eb08 01c5 	add.w	r1, r8, r5, lsl #3
    8ffe:	784a      	ldrb	r2, [r1, #1]
			uint8_t type = data[j].type;
    9000:	f818 0035 	ldrb.w	r0, [r8, r5, lsl #3]
			if ((set_data_len + len + 2) > set_data_len_max) {
    9004:	46a4      	mov	ip, r4
    9006:	18a3      	adds	r3, r4, r2
    9008:	3302      	adds	r3, #2
    900a:	454b      	cmp	r3, r9
    900c:	d9e0      	bls.n	8fd0 <set_data_add_complete+0x7c>
							(set_data_len + 2);
    900e:	1ca2      	adds	r2, r4, #2
				ssize_t shortened_len = set_data_len_max -
    9010:	eba9 0202 	sub.w	r2, r9, r2
				if (!(type == BT_DATA_NAME_COMPLETE &&
    9014:	2809      	cmp	r0, #9
    9016:	d1b1      	bne.n	8f7c <set_data_add_complete+0x28>
    9018:	2a00      	cmp	r2, #0
    901a:	ddaf      	ble.n	8f7c <set_data_add_complete+0x28>
				type = BT_DATA_NAME_SHORTENED;
    901c:	2008      	movs	r0, #8
    901e:	e7d7      	b.n	8fd0 <set_data_add_complete+0x7c>
	for (size_t i = 0; i < ad_len; i++) {
    9020:	f10b 0b01 	add.w	fp, fp, #1
    9024:	e7a0      	b.n	8f68 <set_data_add_complete+0x14>
	*data_len = set_data_len;
    9026:	9b14      	ldr	r3, [sp, #80]	; 0x50
    9028:	701c      	strb	r4, [r3, #0]
	return 0;
    902a:	2000      	movs	r0, #0
    902c:	e7cd      	b.n	8fca <set_data_add_complete+0x76>
    902e:	bf00      	nop
    9030:	0001e8dc 	.word	0x0001e8dc
    9034:	0001cfcc 	.word	0x0001cfcc

00009038 <valid_adv_ext_param>:
{
    9038:	b510      	push	{r4, lr}
    903a:	b082      	sub	sp, #8
    903c:	4604      	mov	r4, r0
	if (param->id >= bt_dev.id_count ||
    903e:	7800      	ldrb	r0, [r0, #0]
    9040:	4b23      	ldr	r3, [pc, #140]	; (90d0 <valid_adv_ext_param+0x98>)
    9042:	79db      	ldrb	r3, [r3, #7]
    9044:	4298      	cmp	r0, r3
    9046:	d302      	bcc.n	904e <valid_adv_ext_param+0x16>
		return false;
    9048:	2000      	movs	r0, #0
}
    904a:	b002      	add	sp, #8
    904c:	bd10      	pop	{r4, pc}
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
    904e:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
    9052:	2300      	movs	r3, #0
    9054:	9300      	str	r3, [sp, #0]
    9056:	f8cd 3003 	str.w	r3, [sp, #3]
	return memcmp(a, b, sizeof(*a));
    905a:	2207      	movs	r2, #7
    905c:	4669      	mov	r1, sp
    905e:	4b1c      	ldr	r3, [pc, #112]	; (90d0 <valid_adv_ext_param+0x98>)
    9060:	4418      	add	r0, r3
    9062:	f00e fb53 	bl	1770c <memcmp>
	if (param->id >= bt_dev.id_count ||
    9066:	2800      	cmp	r0, #0
    9068:	d0ee      	beq.n	9048 <valid_adv_ext_param+0x10>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    906a:	6863      	ldr	r3, [r4, #4]
    906c:	f013 0f01 	tst.w	r3, #1
    9070:	d107      	bne.n	9082 <valid_adv_ext_param+0x4a>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    9072:	4a17      	ldr	r2, [pc, #92]	; (90d0 <valid_adv_ext_param+0x98>)
    9074:	f892 2068 	ldrb.w	r2, [r2, #104]	; 0x68
    9078:	2a08      	cmp	r2, #8
    907a:	d802      	bhi.n	9082 <valid_adv_ext_param+0x4a>
		    param->interval_min < 0x00a0) {
    907c:	68a2      	ldr	r2, [r4, #8]
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
    907e:	2a9f      	cmp	r2, #159	; 0x9f
    9080:	d91b      	bls.n	90ba <valid_adv_ext_param+0x82>
	if ((param->options & (BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY |
    9082:	f013 0f30 	tst.w	r3, #48	; 0x30
    9086:	d001      	beq.n	908c <valid_adv_ext_param+0x54>
	    !param->peer) {
    9088:	6922      	ldr	r2, [r4, #16]
			       BT_LE_ADV_OPT_DIR_ADDR_RPA)) &&
    908a:	b1c2      	cbz	r2, 90be <valid_adv_ext_param+0x86>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    908c:	f013 0f10 	tst.w	r3, #16
    9090:	d108      	bne.n	90a4 <valid_adv_ext_param+0x6c>
	    !param->peer) {
    9092:	6922      	ldr	r2, [r4, #16]
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) ||
    9094:	b132      	cbz	r2, 90a4 <valid_adv_ext_param+0x6c>
	    (param->options & BT_LE_ADV_OPT_DISABLE_CHAN_38) &&
    9096:	f403 3360 	and.w	r3, r3, #229376	; 0x38000
	if ((param->options & BT_LE_ADV_OPT_DISABLE_CHAN_37) &&
    909a:	f5b3 3f60 	cmp.w	r3, #229376	; 0x38000
    909e:	d014      	beq.n	90ca <valid_adv_ext_param+0x92>
	return true;
    90a0:	2001      	movs	r0, #1
    90a2:	e7d2      	b.n	904a <valid_adv_ext_param+0x12>
		if (param->interval_min > param->interval_max ||
    90a4:	68a2      	ldr	r2, [r4, #8]
    90a6:	68e1      	ldr	r1, [r4, #12]
    90a8:	428a      	cmp	r2, r1
    90aa:	d80a      	bhi.n	90c2 <valid_adv_ext_param+0x8a>
    90ac:	2a1f      	cmp	r2, #31
    90ae:	d90a      	bls.n	90c6 <valid_adv_ext_param+0x8e>
		    param->interval_min < 0x0020 ||
    90b0:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
    90b4:	d9ef      	bls.n	9096 <valid_adv_ext_param+0x5e>
			return false;
    90b6:	2000      	movs	r0, #0
    90b8:	e7c7      	b.n	904a <valid_adv_ext_param+0x12>
			return false;
    90ba:	2000      	movs	r0, #0
    90bc:	e7c5      	b.n	904a <valid_adv_ext_param+0x12>
		return false;
    90be:	2000      	movs	r0, #0
    90c0:	e7c3      	b.n	904a <valid_adv_ext_param+0x12>
			return false;
    90c2:	2000      	movs	r0, #0
    90c4:	e7c1      	b.n	904a <valid_adv_ext_param+0x12>
    90c6:	2000      	movs	r0, #0
    90c8:	e7bf      	b.n	904a <valid_adv_ext_param+0x12>
		return false;
    90ca:	2000      	movs	r0, #0
    90cc:	e7bd      	b.n	904a <valid_adv_ext_param+0x12>
    90ce:	bf00      	nop
    90d0:	20000000 	.word	0x20000000

000090d4 <le_adv_start_add_conn>:
	return channel_map;
}

static int le_adv_start_add_conn(const struct bt_le_ext_adv *adv,
				 struct bt_conn **out_conn)
{
    90d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    90d6:	b085      	sub	sp, #20
    90d8:	4604      	mov	r4, r0
    90da:	460f      	mov	r7, r1
	struct bt_conn *conn;

	bt_dev.adv_conn_id = adv->id;
    90dc:	4605      	mov	r5, r0
    90de:	f815 2b09 	ldrb.w	r2, [r5], #9
    90e2:	4b1f      	ldr	r3, [pc, #124]	; (9160 <le_adv_start_add_conn+0x8c>)
    90e4:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    90e8:	2300      	movs	r3, #0
    90ea:	9300      	str	r3, [sp, #0]
    90ec:	f8cd 3003 	str.w	r3, [sp, #3]
    90f0:	2207      	movs	r2, #7
    90f2:	4669      	mov	r1, sp
    90f4:	4628      	mov	r0, r5
    90f6:	f00e fb09 	bl	1770c <memcmp>
    90fa:	b9b8      	cbnz	r0, 912c <le_adv_start_add_conn+0x58>
    90fc:	4606      	mov	r6, r0
		/* Undirected advertising */
		conn = bt_conn_add_le(adv->id, BT_ADDR_LE_NONE);
    90fe:	4b19      	ldr	r3, [pc, #100]	; (9164 <le_adv_start_add_conn+0x90>)
    9100:	e893 0003 	ldmia.w	r3, {r0, r1}
    9104:	9002      	str	r0, [sp, #8]
    9106:	f8ad 100c 	strh.w	r1, [sp, #12]
    910a:	0c09      	lsrs	r1, r1, #16
    910c:	f88d 100e 	strb.w	r1, [sp, #14]
    9110:	a902      	add	r1, sp, #8
    9112:	7820      	ldrb	r0, [r4, #0]
    9114:	f00f f82d 	bl	18172 <bt_conn_add_le>
		if (!conn) {
    9118:	4604      	mov	r4, r0
    911a:	b120      	cbz	r0, 9126 <le_adv_start_add_conn+0x52>
			return -ENOMEM;
		}

		bt_conn_set_state(conn, BT_CONN_CONNECTING_ADV);
    911c:	2104      	movs	r1, #4
    911e:	f000 ff47 	bl	9fb0 <bt_conn_set_state>
		*out_conn = conn;
    9122:	603c      	str	r4, [r7, #0]
		return 0;
    9124:	e012      	b.n	914c <le_adv_start_add_conn+0x78>
			return -ENOMEM;
    9126:	f06f 060b 	mvn.w	r6, #11
    912a:	e00f      	b.n	914c <le_adv_start_add_conn+0x78>
	}

	if (bt_conn_exists_le(adv->id, &adv->target_addr)) {
    912c:	4629      	mov	r1, r5
    912e:	7820      	ldrb	r0, [r4, #0]
    9130:	f001 f9c8 	bl	a4c4 <bt_conn_exists_le>
    9134:	b968      	cbnz	r0, 9152 <le_adv_start_add_conn+0x7e>
		return -EINVAL;
	}

	conn = bt_conn_add_le(adv->id, &adv->target_addr);
    9136:	4629      	mov	r1, r5
    9138:	7820      	ldrb	r0, [r4, #0]
    913a:	f00f f81a 	bl	18172 <bt_conn_add_le>
	if (!conn) {
    913e:	4604      	mov	r4, r0
    9140:	b150      	cbz	r0, 9158 <le_adv_start_add_conn+0x84>
		return -ENOMEM;
	}

	bt_conn_set_state(conn, BT_CONN_CONNECTING_DIR_ADV);
    9142:	2105      	movs	r1, #5
    9144:	f000 ff34 	bl	9fb0 <bt_conn_set_state>
	*out_conn = conn;
    9148:	603c      	str	r4, [r7, #0]
	return 0;
    914a:	2600      	movs	r6, #0
}
    914c:	4630      	mov	r0, r6
    914e:	b005      	add	sp, #20
    9150:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
    9152:	f06f 0615 	mvn.w	r6, #21
    9156:	e7f9      	b.n	914c <le_adv_start_add_conn+0x78>
		return -ENOMEM;
    9158:	f06f 060b 	mvn.w	r6, #11
    915c:	e7f6      	b.n	914c <le_adv_start_add_conn+0x78>
    915e:	bf00      	nop
    9160:	20000000 	.word	0x20000000
    9164:	0001d1c8 	.word	0x0001d1c8

00009168 <le_adv_stop_free_conn>:

static void le_adv_stop_free_conn(const struct bt_le_ext_adv *adv, uint8_t status)
{
    9168:	b570      	push	{r4, r5, r6, lr}
    916a:	b084      	sub	sp, #16
    916c:	4604      	mov	r4, r0
    916e:	460e      	mov	r6, r1
	struct bt_conn *conn;

	if (!bt_addr_le_cmp(&adv->target_addr, BT_ADDR_LE_ANY)) {
    9170:	f100 0509 	add.w	r5, r0, #9
    9174:	2300      	movs	r3, #0
    9176:	9300      	str	r3, [sp, #0]
    9178:	f8cd 3003 	str.w	r3, [sp, #3]
    917c:	2207      	movs	r2, #7
    917e:	4669      	mov	r1, sp
    9180:	4628      	mov	r0, r5
    9182:	f00e fac3 	bl	1770c <memcmp>
    9186:	b9c8      	cbnz	r0, 91bc <le_adv_stop_free_conn+0x54>
		conn = bt_conn_lookup_state_le(adv->id, BT_ADDR_LE_NONE,
    9188:	4b10      	ldr	r3, [pc, #64]	; (91cc <le_adv_stop_free_conn+0x64>)
    918a:	e893 0003 	ldmia.w	r3, {r0, r1}
    918e:	9002      	str	r0, [sp, #8]
    9190:	f8ad 100c 	strh.w	r1, [sp, #12]
    9194:	0c09      	lsrs	r1, r1, #16
    9196:	f88d 100e 	strb.w	r1, [sp, #14]
    919a:	2204      	movs	r2, #4
    919c:	a902      	add	r1, sp, #8
    919e:	7820      	ldrb	r0, [r4, #0]
    91a0:	f001 fa2a 	bl	a5f8 <bt_conn_lookup_state_le>
    91a4:	4604      	mov	r4, r0
	} else {
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
					       BT_CONN_CONNECTING_DIR_ADV);
	}

	if (conn) {
    91a6:	b13c      	cbz	r4, 91b8 <le_adv_stop_free_conn+0x50>
		conn->err = status;
    91a8:	7266      	strb	r6, [r4, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    91aa:	2100      	movs	r1, #0
    91ac:	4620      	mov	r0, r4
    91ae:	f000 feff 	bl	9fb0 <bt_conn_set_state>
		bt_conn_unref(conn);
    91b2:	4620      	mov	r0, r4
    91b4:	f00e ff92 	bl	180dc <bt_conn_unref>
	}
}
    91b8:	b004      	add	sp, #16
    91ba:	bd70      	pop	{r4, r5, r6, pc}
		conn = bt_conn_lookup_state_le(adv->id, &adv->target_addr,
    91bc:	2205      	movs	r2, #5
    91be:	4629      	mov	r1, r5
    91c0:	7820      	ldrb	r0, [r4, #0]
    91c2:	f001 fa19 	bl	a5f8 <bt_conn_lookup_state_le>
    91c6:	4604      	mov	r4, r0
    91c8:	e7ed      	b.n	91a6 <le_adv_stop_free_conn+0x3e>
    91ca:	bf00      	nop
    91cc:	0001d1c8 	.word	0x0001d1c8

000091d0 <bt_le_adv_lookup_legacy>:
}
    91d0:	4800      	ldr	r0, [pc, #0]	; (91d4 <bt_le_adv_lookup_legacy+0x4>)
    91d2:	4770      	bx	lr
    91d4:	20000018 	.word	0x20000018

000091d8 <bt_le_adv_start_legacy>:

int bt_le_adv_start_legacy(struct bt_le_ext_adv *adv,
			   const struct bt_le_adv_param *param,
			   const struct bt_data *ad, size_t ad_len,
			   const struct bt_data *sd, size_t sd_len)
{
    91d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    91dc:	b095      	sub	sp, #84	; 0x54
    91de:	9204      	str	r2, [sp, #16]
    91e0:	9305      	str	r3, [sp, #20]
	struct bt_hci_cp_le_set_adv_param set_param;
	struct bt_conn *conn = NULL;
    91e2:	2300      	movs	r3, #0
    91e4:	9307      	str	r3, [sp, #28]
	struct net_buf *buf;
	bool dir_adv = (param->peer != NULL), scannable = false;
    91e6:	690f      	ldr	r7, [r1, #16]
    91e8:	ebb7 0b03 	subs.w	fp, r7, r3
    91ec:	bf18      	it	ne
    91ee:	f04f 0b01 	movne.w	fp, #1
    91f2:	4bba      	ldr	r3, [pc, #744]	; (94dc <bt_le_adv_start_legacy+0x304>)
    91f4:	e8d3 3faf 	lda	r3, [r3]
	enum adv_name_type name_type;

	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    91f8:	f013 0f04 	tst.w	r3, #4
    91fc:	f000 819b 	beq.w	9536 <bt_le_adv_start_legacy+0x35e>
    9200:	4605      	mov	r5, r0
    9202:	460c      	mov	r4, r1
		return -EAGAIN;
	}

	if (!valid_adv_param(param)) {
    9204:	4608      	mov	r0, r1
    9206:	f00e fdb7 	bl	17d78 <valid_adv_param>
    920a:	2800      	cmp	r0, #0
    920c:	f000 8196 	beq.w	953c <bt_le_adv_start_legacy+0x364>
		return -EINVAL;
	}

	if (!bt_id_adv_random_addr_check(param)) {
    9210:	4620      	mov	r0, r4
    9212:	f00e fcbb 	bl	17b8c <bt_id_adv_random_addr_check>
    9216:	4681      	mov	r9, r0
    9218:	2800      	cmp	r0, #0
    921a:	f000 8192 	beq.w	9542 <bt_le_adv_start_legacy+0x36a>
		return -EINVAL;
	}

	if (atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    921e:	f105 0610 	add.w	r6, r5, #16
    9222:	e8d6 3faf 	lda	r3, [r6]
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
    9226:	f3c3 1a80 	ubfx	sl, r3, #6, #1
    922a:	f013 0f40 	tst.w	r3, #64	; 0x40
    922e:	f040 818b 	bne.w	9548 <bt_le_adv_start_legacy+0x370>
		return -EALREADY;
	}

	(void)memset(&set_param, 0, sizeof(set_param));
    9232:	220f      	movs	r2, #15
    9234:	2100      	movs	r1, #0
    9236:	a808      	add	r0, sp, #32
    9238:	f00e faa9 	bl	1778e <memset>

	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
    923c:	68a3      	ldr	r3, [r4, #8]
    923e:	f8ad 3020 	strh.w	r3, [sp, #32]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
    9242:	68e3      	ldr	r3, [r4, #12]
    9244:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	set_param.channel_map  = get_adv_channel_map(param->options);
    9248:	f8d4 8004 	ldr.w	r8, [r4, #4]
    924c:	4640      	mov	r0, r8
    924e:	f00e fcc0 	bl	17bd2 <get_adv_channel_map>
    9252:	f88d 002d 	strb.w	r0, [sp, #45]	; 0x2d
	set_param.filter_policy = get_filter_policy(param->options);
    9256:	4640      	mov	r0, r8
    9258:	f00e fcb9 	bl	17bce <get_filter_policy>
    925c:	f88d 002e 	strb.w	r0, [sp, #46]	; 0x2e

	if (adv->id != param->id) {
    9260:	782a      	ldrb	r2, [r5, #0]
    9262:	7823      	ldrb	r3, [r4, #0]
    9264:	429a      	cmp	r2, r3
    9266:	d008      	beq.n	927a <bt_le_adv_start_legacy+0xa2>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    9268:	4b9c      	ldr	r3, [pc, #624]	; (94dc <bt_le_adv_start_legacy+0x304>)
    926a:	e8d3 2fef 	ldaex	r2, [r3]
    926e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
    9272:	e8c3 2fe1 	stlex	r1, r2, [r3]
    9276:	2900      	cmp	r1, #0
    9278:	d1f7      	bne.n	926a <bt_le_adv_start_legacy+0x92>
		atomic_clear_bit(bt_dev.flags, BT_DEV_RPA_VALID);
	}

	adv->id = param->id;
    927a:	7823      	ldrb	r3, [r4, #0]
    927c:	702b      	strb	r3, [r5, #0]
	bt_dev.adv_conn_id = adv->id;
    927e:	4a98      	ldr	r2, [pc, #608]	; (94e0 <bt_le_adv_start_legacy+0x308>)
    9280:	f882 3067 	strb.w	r3, [r2, #103]	; 0x67

	err = bt_id_set_adv_own_addr(adv, param->options, dir_adv,
    9284:	f10d 0325 	add.w	r3, sp, #37	; 0x25
    9288:	465a      	mov	r2, fp
    928a:	6861      	ldr	r1, [r4, #4]
    928c:	4628      	mov	r0, r5
    928e:	f7ff fd71 	bl	8d74 <bt_id_set_adv_own_addr>
				     &set_param.own_addr_type);
	if (err) {
    9292:	4680      	mov	r8, r0
    9294:	2800      	cmp	r0, #0
    9296:	f040 80d4 	bne.w	9442 <bt_le_adv_start_legacy+0x26a>
		return err;
	}

	if (dir_adv) {
    929a:	b1e7      	cbz	r7, 92d6 <bt_le_adv_start_legacy+0xfe>
	memcpy(dst, src, sizeof(*dst));
    929c:	2207      	movs	r2, #7
    929e:	6921      	ldr	r1, [r4, #16]
    92a0:	f105 0009 	add.w	r0, r5, #9
    92a4:	f00e fa44 	bl	17730 <memcpy>
		bt_addr_le_copy(&adv->target_addr, param->peer);
	} else {
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
	}

	name_type = get_adv_name_type_param(param);
    92a8:	4620      	mov	r0, r4
    92aa:	f00e fd76 	bl	17d9a <get_adv_name_type_param>
    92ae:	4683      	mov	fp, r0

	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
    92b0:	6863      	ldr	r3, [r4, #4]
    92b2:	f013 0f01 	tst.w	r3, #1
    92b6:	d021      	beq.n	92fc <bt_le_adv_start_legacy+0x124>
		if (dir_adv) {
    92b8:	b1e7      	cbz	r7, 92f4 <bt_le_adv_start_legacy+0x11c>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
    92ba:	f013 0f10 	tst.w	r3, #16
    92be:	d015      	beq.n	92ec <bt_le_adv_start_legacy+0x114>
				set_param.type = BT_HCI_ADV_DIRECT_IND_LOW_DUTY;
    92c0:	2304      	movs	r3, #4
    92c2:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    92c6:	2207      	movs	r2, #7
    92c8:	6921      	ldr	r1, [r4, #16]
    92ca:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    92ce:	f00e fa2f 	bl	17730 <memcpy>
	bool dir_adv = (param->peer != NULL), scannable = false;
    92d2:	46d1      	mov	r9, sl
}
    92d4:	e01a      	b.n	930c <bt_le_adv_start_legacy+0x134>
		bt_addr_le_copy(&adv->target_addr, BT_ADDR_LE_ANY);
    92d6:	2300      	movs	r3, #0
    92d8:	930c      	str	r3, [sp, #48]	; 0x30
    92da:	f8cd 3033 	str.w	r3, [sp, #51]	; 0x33
	memcpy(dst, src, sizeof(*dst));
    92de:	2207      	movs	r2, #7
    92e0:	a90c      	add	r1, sp, #48	; 0x30
    92e2:	f105 0009 	add.w	r0, r5, #9
    92e6:	f00e fa23 	bl	17730 <memcpy>
    92ea:	e7dd      	b.n	92a8 <bt_le_adv_start_legacy+0xd0>
			} else {
				set_param.type = BT_HCI_ADV_DIRECT_IND;
    92ec:	2301      	movs	r3, #1
    92ee:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    92f2:	e7e8      	b.n	92c6 <bt_le_adv_start_legacy+0xee>
			}

			bt_addr_le_copy(&set_param.direct_addr, param->peer);
		} else {
			scannable = true;
			set_param.type = BT_HCI_ADV_IND;
    92f4:	2300      	movs	r3, #0
    92f6:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    92fa:	e007      	b.n	930c <bt_le_adv_start_legacy+0x134>
		}
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
    92fc:	f413 7f00 	tst.w	r3, #512	; 0x200
    9300:	d101      	bne.n	9306 <bt_le_adv_start_legacy+0x12e>
    9302:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    9304:	b35b      	cbz	r3, 935e <bt_le_adv_start_legacy+0x186>
		   (name_type == ADV_NAME_TYPE_SD)) {
		scannable = true;
		set_param.type = BT_HCI_ADV_SCAN_IND;
    9306:	2302      	movs	r3, #2
    9308:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	} else {
		set_param.type = BT_HCI_ADV_NONCONN_IND;
	}

	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
    930c:	210f      	movs	r1, #15
    930e:	f242 0006 	movw	r0, #8198	; 0x2006
    9312:	f7fd fdb5 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
    9316:	4680      	mov	r8, r0
    9318:	2800      	cmp	r0, #0
    931a:	f000 8118 	beq.w	954e <bt_le_adv_start_legacy+0x376>
    931e:	220f      	movs	r2, #15
    9320:	a908      	add	r1, sp, #32
    9322:	3008      	adds	r0, #8
    9324:	f010 ff71 	bl	1a20a <net_buf_simple_add_mem>
		return -ENOBUFS;
	}

	net_buf_add_mem(buf, &set_param, sizeof(set_param));

	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
    9328:	2200      	movs	r2, #0
    932a:	4641      	mov	r1, r8
    932c:	f242 0006 	movw	r0, #8198	; 0x2006
    9330:	f7fd fde4 	bl	6efc <bt_hci_cmd_send_sync>
	if (err) {
    9334:	4680      	mov	r8, r0
    9336:	2800      	cmp	r0, #0
    9338:	f040 8083 	bne.w	9442 <bt_le_adv_start_legacy+0x26a>
		return err;
	}

	if (!dir_adv) {
    933c:	b1b7      	cbz	r7, 936c <bt_le_adv_start_legacy+0x194>
			return err;
		}
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
	    (param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
    933e:	6863      	ldr	r3, [r4, #4]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    9340:	f013 0f01 	tst.w	r3, #1
    9344:	d02a      	beq.n	939c <bt_le_adv_start_legacy+0x1c4>
		err = le_adv_start_add_conn(adv, &conn);
    9346:	a907      	add	r1, sp, #28
    9348:	4628      	mov	r0, r5
    934a:	f7ff fec3 	bl	90d4 <le_adv_start_add_conn>
		if (err) {
    934e:	b328      	cbz	r0, 939c <bt_le_adv_start_legacy+0x1c4>
			if (err == -ENOMEM && !dir_adv &&
    9350:	f110 0f0c 	cmn.w	r0, #12
    9354:	f040 80fe 	bne.w	9554 <bt_le_adv_start_legacy+0x37c>
    9358:	b1d7      	cbz	r7, 9390 <bt_le_adv_start_legacy+0x1b8>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
				goto set_adv_state;
			}

			return err;
    935a:	4680      	mov	r8, r0
    935c:	e071      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
	} else if ((param->options & BT_LE_ADV_OPT_SCANNABLE) || sd ||
    935e:	2802      	cmp	r0, #2
    9360:	d0d1      	beq.n	9306 <bt_le_adv_start_legacy+0x12e>
		set_param.type = BT_HCI_ADV_NONCONN_IND;
    9362:	2303      	movs	r3, #3
    9364:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	bool dir_adv = (param->peer != NULL), scannable = false;
    9368:	46d1      	mov	r9, sl
    936a:	e7cf      	b.n	930c <bt_le_adv_start_legacy+0x134>
		err = le_adv_update(adv, ad, ad_len, sd, sd_len, false,
    936c:	f8cd b00c 	str.w	fp, [sp, #12]
    9370:	f8cd 9008 	str.w	r9, [sp, #8]
    9374:	2300      	movs	r3, #0
    9376:	9301      	str	r3, [sp, #4]
    9378:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    937a:	9300      	str	r3, [sp, #0]
    937c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    937e:	9a05      	ldr	r2, [sp, #20]
    9380:	9904      	ldr	r1, [sp, #16]
    9382:	4628      	mov	r0, r5
    9384:	f00e fc71 	bl	17c6a <le_adv_update>
		if (err) {
    9388:	2800      	cmp	r0, #0
    938a:	d0d8      	beq.n	933e <bt_le_adv_start_legacy+0x166>
			return err;
    938c:	4680      	mov	r8, r0
    938e:	e058      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
			    !(param->options & BT_LE_ADV_OPT_ONE_TIME)) {
    9390:	6862      	ldr	r2, [r4, #4]
			if (err == -ENOMEM && !dir_adv &&
    9392:	f012 0f02 	tst.w	r2, #2
    9396:	d00c      	beq.n	93b2 <bt_le_adv_start_legacy+0x1da>
			return err;
    9398:	4680      	mov	r8, r0
    939a:	e052      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
		}
	}

	err = bt_le_adv_set_enable(adv, true);
    939c:	2101      	movs	r1, #1
    939e:	4628      	mov	r0, r5
    93a0:	f00e fd37 	bl	17e12 <bt_le_adv_set_enable>
	if (err) {
    93a4:	4605      	mov	r5, r0
    93a6:	2800      	cmp	r0, #0
    93a8:	d14f      	bne.n	944a <bt_le_adv_start_legacy+0x272>
		}

		return err;
	}

	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    93aa:	9807      	ldr	r0, [sp, #28]
    93ac:	b108      	cbz	r0, 93b2 <bt_le_adv_start_legacy+0x1da>
		/* If undirected connectable advertiser we have created a
		 * connection object that we don't yet give to the application.
		 * Since we don't give the application a reference to manage in
		 * this case, we need to release this reference here
		 */
		bt_conn_unref(conn);
    93ae:	f00e fe95 	bl	180dc <bt_conn_unref>
	}

set_adv_state:
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    93b2:	2f00      	cmp	r7, #0
    93b4:	d078      	beq.n	94a8 <bt_le_adv_start_legacy+0x2d0>
    93b6:	4643      	mov	r3, r8
	if (val) {
    93b8:	f013 0f01 	tst.w	r3, #1
    93bc:	d07c      	beq.n	94b8 <bt_le_adv_start_legacy+0x2e0>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    93be:	e8d6 3fef 	ldaex	r3, [r6]
    93c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    93c6:	e8c6 3fe2 	stlex	r2, r3, [r6]
    93ca:	2a00      	cmp	r2, #0
    93cc:	d1f7      	bne.n	93be <bt_le_adv_start_legacy+0x1e6>
    93ce:	f1bb 0f01 	cmp.w	fp, #1
    93d2:	d17a      	bne.n	94ca <bt_le_adv_start_legacy+0x2f2>
    93d4:	e8d6 3fef 	ldaex	r3, [r6]
    93d8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    93dc:	e8c6 3fe2 	stlex	r2, r3, [r6]
    93e0:	2a00      	cmp	r2, #0
    93e2:	d1f7      	bne.n	93d4 <bt_le_adv_start_legacy+0x1fc>
    93e4:	f1bb 0f02 	cmp.w	fp, #2
    93e8:	f040 8080 	bne.w	94ec <bt_le_adv_start_legacy+0x314>
    93ec:	e8d6 3fef 	ldaex	r3, [r6]
    93f0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    93f4:	e8c6 3fe2 	stlex	r2, r3, [r6]
    93f8:	2a00      	cmp	r2, #0
    93fa:	d1f7      	bne.n	93ec <bt_le_adv_start_legacy+0x214>

	atomic_set_bit_to(adv->flags, BT_ADV_INCLUDE_NAME_SD,
			  name_type == ADV_NAME_TYPE_SD);

	atomic_set_bit_to(adv->flags, BT_ADV_CONNECTABLE,
			  param->options & BT_LE_ADV_OPT_CONNECTABLE);
    93fc:	6863      	ldr	r3, [r4, #4]
    93fe:	f013 0f01 	tst.w	r3, #1
    9402:	d07d      	beq.n	9500 <bt_le_adv_start_legacy+0x328>
    9404:	e8d6 3fef 	ldaex	r3, [r6]
    9408:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    940c:	e8c6 3fe2 	stlex	r2, r3, [r6]
    9410:	2a00      	cmp	r2, #0
    9412:	d1f7      	bne.n	9404 <bt_le_adv_start_legacy+0x22c>
    9414:	f1b9 0f00 	cmp.w	r9, #0
    9418:	d07b      	beq.n	9512 <bt_le_adv_start_legacy+0x33a>
    941a:	e8d6 3fef 	ldaex	r3, [r6]
    941e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    9422:	e8c6 3fe2 	stlex	r2, r3, [r6]
    9426:	2a00      	cmp	r2, #0
    9428:	d1f7      	bne.n	941a <bt_le_adv_start_legacy+0x242>

	atomic_set_bit_to(adv->flags, BT_ADV_SCANNABLE, scannable);

	atomic_set_bit_to(adv->flags, BT_ADV_USE_IDENTITY,
			  param->options & BT_LE_ADV_OPT_USE_IDENTITY);
    942a:	6863      	ldr	r3, [r4, #4]
    942c:	f013 0f04 	tst.w	r3, #4
    9430:	d078      	beq.n	9524 <bt_le_adv_start_legacy+0x34c>
    9432:	e8d6 3fef 	ldaex	r3, [r6]
    9436:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    943a:	e8c6 3fe2 	stlex	r2, r3, [r6]
    943e:	2a00      	cmp	r2, #0
    9440:	d1f7      	bne.n	9432 <bt_le_adv_start_legacy+0x25a>

	return 0;
}
    9442:	4640      	mov	r0, r8
    9444:	b015      	add	sp, #84	; 0x54
    9446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		BT_ERR("Failed to start advertiser");
    944a:	4b26      	ldr	r3, [pc, #152]	; (94e4 <bt_le_adv_start_legacy+0x30c>)
    944c:	9313      	str	r3, [sp, #76]	; 0x4c
    944e:	2302      	movs	r3, #2
    9450:	f88d 3018 	strb.w	r3, [sp, #24]
    9454:	2300      	movs	r3, #0
    9456:	f88d 3019 	strb.w	r3, [sp, #25]
    945a:	f88d 301a 	strb.w	r3, [sp, #26]
    945e:	f88d 301b 	strb.w	r3, [sp, #27]
    9462:	9a06      	ldr	r2, [sp, #24]
    9464:	9212      	str	r2, [sp, #72]	; 0x48
    9466:	4619      	mov	r1, r3
    9468:	f363 0100 	bfi	r1, r3, #0, #1
    946c:	f363 0141 	bfi	r1, r3, #1, #1
    9470:	f363 0182 	bfi	r1, r3, #2, #1
    9474:	f363 01c5 	bfi	r1, r3, #3, #3
    9478:	2201      	movs	r2, #1
    947a:	f362 1188 	bfi	r1, r2, #6, #3
    947e:	2208      	movs	r2, #8
    9480:	f362 2152 	bfi	r1, r2, #9, #10
    9484:	f363 41de 	bfi	r1, r3, #19, #12
    9488:	f363 71df 	bfi	r1, r3, #31, #1
    948c:	aa12      	add	r2, sp, #72	; 0x48
    948e:	4816      	ldr	r0, [pc, #88]	; (94e8 <bt_le_adv_start_legacy+0x310>)
    9490:	f7f8 feda 	bl	2248 <z_impl_z_log_msg_static_create>
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn) {
    9494:	9807      	ldr	r0, [sp, #28]
    9496:	b128      	cbz	r0, 94a4 <bt_le_adv_start_legacy+0x2cc>
			bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
    9498:	2100      	movs	r1, #0
    949a:	f000 fd89 	bl	9fb0 <bt_conn_set_state>
			bt_conn_unref(conn);
    949e:	9807      	ldr	r0, [sp, #28]
    94a0:	f00e fe1c 	bl	180dc <bt_conn_unref>
		return err;
    94a4:	46a8      	mov	r8, r5
    94a6:	e7cc      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
			  !(param->options & BT_LE_ADV_OPT_ONE_TIME));
    94a8:	6863      	ldr	r3, [r4, #4]
	atomic_set_bit_to(adv->flags, BT_ADV_PERSIST, !dir_adv &&
    94aa:	f013 0f02 	tst.w	r3, #2
    94ae:	d001      	beq.n	94b4 <bt_le_adv_start_legacy+0x2dc>
    94b0:	4643      	mov	r3, r8
    94b2:	e781      	b.n	93b8 <bt_le_adv_start_legacy+0x1e0>
    94b4:	2301      	movs	r3, #1
    94b6:	e77f      	b.n	93b8 <bt_le_adv_start_legacy+0x1e0>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    94b8:	e8d6 3fef 	ldaex	r3, [r6]
    94bc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    94c0:	e8c6 3fe2 	stlex	r2, r3, [r6]
    94c4:	2a00      	cmp	r2, #0
    94c6:	d082      	beq.n	93ce <bt_le_adv_start_legacy+0x1f6>
    94c8:	e7f6      	b.n	94b8 <bt_le_adv_start_legacy+0x2e0>
    94ca:	e8d6 3fef 	ldaex	r3, [r6]
    94ce:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    94d2:	e8c6 3fe2 	stlex	r2, r3, [r6]
    94d6:	2a00      	cmp	r2, #0
    94d8:	d084      	beq.n	93e4 <bt_le_adv_start_legacy+0x20c>
    94da:	e7f6      	b.n	94ca <bt_le_adv_start_legacy+0x2f2>
    94dc:	200000cc 	.word	0x200000cc
    94e0:	20000000 	.word	0x20000000
    94e4:	0001e8f8 	.word	0x0001e8f8
    94e8:	0001cfcc 	.word	0x0001cfcc
    94ec:	e8d6 3fef 	ldaex	r3, [r6]
    94f0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    94f4:	e8c6 3fe2 	stlex	r2, r3, [r6]
    94f8:	2a00      	cmp	r2, #0
    94fa:	f43f af7f 	beq.w	93fc <bt_le_adv_start_legacy+0x224>
    94fe:	e7f5      	b.n	94ec <bt_le_adv_start_legacy+0x314>
    9500:	e8d6 3fef 	ldaex	r3, [r6]
    9504:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    9508:	e8c6 3fe2 	stlex	r2, r3, [r6]
    950c:	2a00      	cmp	r2, #0
    950e:	d081      	beq.n	9414 <bt_le_adv_start_legacy+0x23c>
    9510:	e7f6      	b.n	9500 <bt_le_adv_start_legacy+0x328>
    9512:	e8d6 3fef 	ldaex	r3, [r6]
    9516:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    951a:	e8c6 3fe2 	stlex	r2, r3, [r6]
    951e:	2a00      	cmp	r2, #0
    9520:	d083      	beq.n	942a <bt_le_adv_start_legacy+0x252>
    9522:	e7f6      	b.n	9512 <bt_le_adv_start_legacy+0x33a>
    9524:	e8d6 3fef 	ldaex	r3, [r6]
    9528:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    952c:	e8c6 3fe2 	stlex	r2, r3, [r6]
    9530:	2a00      	cmp	r2, #0
    9532:	d086      	beq.n	9442 <bt_le_adv_start_legacy+0x26a>
    9534:	e7f6      	b.n	9524 <bt_le_adv_start_legacy+0x34c>
		return -EAGAIN;
    9536:	f06f 080a 	mvn.w	r8, #10
    953a:	e782      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
		return -EINVAL;
    953c:	f06f 0815 	mvn.w	r8, #21
    9540:	e77f      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
		return -EINVAL;
    9542:	f06f 0815 	mvn.w	r8, #21
    9546:	e77c      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
		return -EALREADY;
    9548:	f06f 0877 	mvn.w	r8, #119	; 0x77
    954c:	e779      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
		return -ENOBUFS;
    954e:	f06f 0868 	mvn.w	r8, #104	; 0x68
    9552:	e776      	b.n	9442 <bt_le_adv_start_legacy+0x26a>
			return err;
    9554:	4680      	mov	r8, r0
    9556:	e774      	b.n	9442 <bt_le_adv_start_legacy+0x26a>

00009558 <bt_le_adv_start>:
}

int bt_le_adv_start(const struct bt_le_adv_param *param,
		    const struct bt_data *ad, size_t ad_len,
		    const struct bt_data *sd, size_t sd_len)
{
    9558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    955c:	b082      	sub	sp, #8
    955e:	4606      	mov	r6, r0
    9560:	460c      	mov	r4, r1
    9562:	4615      	mov	r5, r2
    9564:	461f      	mov	r7, r3
	struct bt_le_ext_adv *adv = adv_new_legacy();
    9566:	f7ff fcf1 	bl	8f4c <adv_new_legacy>
	int err;

	if (!adv) {
    956a:	b1f8      	cbz	r0, 95ac <bt_le_adv_start+0x54>
    956c:	4680      	mov	r8, r0

	if (IS_ENABLED(CONFIG_BT_EXT_ADV) &&
	    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {
		err = bt_le_adv_start_ext(adv, param, ad, ad_len, sd, sd_len);
	} else {
		err = bt_le_adv_start_legacy(adv, param, ad, ad_len, sd, sd_len);
    956e:	9b08      	ldr	r3, [sp, #32]
    9570:	9301      	str	r3, [sp, #4]
    9572:	9700      	str	r7, [sp, #0]
    9574:	462b      	mov	r3, r5
    9576:	4622      	mov	r2, r4
    9578:	4631      	mov	r1, r6
    957a:	f7ff fe2d 	bl	91d8 <bt_le_adv_start_legacy>
    957e:	4606      	mov	r6, r0

	if (err) {
		bt_le_adv_delete_legacy();
	}

	if (ad_is_limited(ad, ad_len)) {
    9580:	4629      	mov	r1, r5
    9582:	4620      	mov	r0, r4
    9584:	f00e fb04 	bl	17b90 <ad_is_limited>
    9588:	b918      	cbnz	r0, 9592 <bt_le_adv_start+0x3a>
		k_work_reschedule(&adv->lim_adv_timeout_work,
				  K_SECONDS(CONFIG_BT_LIM_ADV_TIMEOUT));
	}

	return err;
}
    958a:	4630      	mov	r0, r6
    958c:	b002      	add	sp, #8
    958e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		k_work_init_delayable(&adv->lim_adv_timeout_work, adv_timeout);
    9592:	f108 0818 	add.w	r8, r8, #24
    9596:	4907      	ldr	r1, [pc, #28]	; (95b4 <bt_le_adv_start+0x5c>)
    9598:	4640      	mov	r0, r8
    959a:	f012 feef 	bl	1c37c <k_work_init_delayable>
		k_work_reschedule(&adv->lim_adv_timeout_work,
    959e:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    95a2:	2300      	movs	r3, #0
    95a4:	4640      	mov	r0, r8
    95a6:	f00a fd09 	bl	13fbc <k_work_reschedule>
    95aa:	e7ee      	b.n	958a <bt_le_adv_start+0x32>
		return -ENOMEM;
    95ac:	f06f 060b 	mvn.w	r6, #11
    95b0:	e7eb      	b.n	958a <bt_le_adv_start+0x32>
    95b2:	bf00      	nop
    95b4:	00009665 	.word	0x00009665

000095b8 <bt_le_adv_stop>:

int bt_le_adv_stop(void)
{
    95b8:	b510      	push	{r4, lr}
    95ba:	b088      	sub	sp, #32
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
    95bc:	f7ff fe08 	bl	91d0 <bt_le_adv_lookup_legacy>
	int err;

	if (!adv) {
    95c0:	b1a0      	cbz	r0, 95ec <bt_le_adv_stop+0x34>
    95c2:	4604      	mov	r4, r0
		BT_ERR("No valid legacy adv");
		return 0;
	}

	(void)bt_le_lim_adv_cancel_timeout(adv);
    95c4:	f00e fc29 	bl	17e1a <bt_le_lim_adv_cancel_timeout>

	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(adv->flags, BT_ADV_PERSIST);
    95c8:	f104 0310 	add.w	r3, r4, #16
    95cc:	e8d3 2fef 	ldaex	r2, [r3]
    95d0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
    95d4:	e8c3 2fe1 	stlex	r1, r2, [r3]
    95d8:	2900      	cmp	r1, #0
    95da:	d1f7      	bne.n	95cc <bt_le_adv_stop+0x14>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    95dc:	e8d3 2faf 	lda	r2, [r3]

	if (!atomic_test_bit(adv->flags, BT_ADV_ENABLED)) {
    95e0:	f012 0f40 	tst.w	r2, #64	; 0x40
    95e4:	d12a      	bne.n	963c <bt_le_adv_stop+0x84>
		/* Legacy advertiser exists, but is not currently advertising.
		 * This happens when keep advertising behavior is active but
		 * no conn object is available to do connectable advertising.
		 */
		bt_le_adv_delete_legacy();
		return 0;
    95e6:	2000      	movs	r0, #0
		}
	}
#endif /* defined(CONFIG_BT_OBSERVER) */

	return 0;
}
    95e8:	b008      	add	sp, #32
    95ea:	bd10      	pop	{r4, pc}
		BT_ERR("No valid legacy adv");
    95ec:	4b1b      	ldr	r3, [pc, #108]	; (965c <bt_le_adv_stop+0xa4>)
    95ee:	9307      	str	r3, [sp, #28]
    95f0:	2302      	movs	r3, #2
    95f2:	f88d 3004 	strb.w	r3, [sp, #4]
    95f6:	2400      	movs	r4, #0
    95f8:	f88d 4005 	strb.w	r4, [sp, #5]
    95fc:	f88d 4006 	strb.w	r4, [sp, #6]
    9600:	f88d 4007 	strb.w	r4, [sp, #7]
    9604:	9b01      	ldr	r3, [sp, #4]
    9606:	9306      	str	r3, [sp, #24]
    9608:	4621      	mov	r1, r4
    960a:	f364 0100 	bfi	r1, r4, #0, #1
    960e:	f364 0141 	bfi	r1, r4, #1, #1
    9612:	f364 0182 	bfi	r1, r4, #2, #1
    9616:	f364 01c5 	bfi	r1, r4, #3, #3
    961a:	2301      	movs	r3, #1
    961c:	f363 1188 	bfi	r1, r3, #6, #3
    9620:	2308      	movs	r3, #8
    9622:	f363 2152 	bfi	r1, r3, #9, #10
    9626:	f364 41de 	bfi	r1, r4, #19, #12
    962a:	f364 71df 	bfi	r1, r4, #31, #1
    962e:	4623      	mov	r3, r4
    9630:	aa06      	add	r2, sp, #24
    9632:	480b      	ldr	r0, [pc, #44]	; (9660 <bt_le_adv_stop+0xa8>)
    9634:	f7f8 fe08 	bl	2248 <z_impl_z_log_msg_static_create>
		return 0;
    9638:	4620      	mov	r0, r4
    963a:	e7d5      	b.n	95e8 <bt_le_adv_stop+0x30>
    963c:	e8d3 3faf 	lda	r3, [r3]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    9640:	f413 7f00 	tst.w	r3, #512	; 0x200
    9644:	d104      	bne.n	9650 <bt_le_adv_stop+0x98>
		err = bt_le_adv_set_enable_legacy(adv, false);
    9646:	2100      	movs	r1, #0
    9648:	4620      	mov	r0, r4
    964a:	f00e fbba 	bl	17dc2 <bt_le_adv_set_enable_legacy>
		if (err) {
    964e:	e7cb      	b.n	95e8 <bt_le_adv_stop+0x30>
		le_adv_stop_free_conn(adv, 0);
    9650:	2100      	movs	r1, #0
    9652:	4620      	mov	r0, r4
    9654:	f7ff fd88 	bl	9168 <le_adv_stop_free_conn>
    9658:	e7f5      	b.n	9646 <bt_le_adv_stop+0x8e>
    965a:	bf00      	nop
    965c:	0001e914 	.word	0x0001e914
    9660:	0001cfcc 	.word	0x0001cfcc

00009664 <adv_timeout>:
}
#endif /* defined(CONFIG_BT_EXT_ADV) */


static void adv_timeout(struct k_work *work)
{
    9664:	b590      	push	{r4, r7, lr}
    9666:	b083      	sub	sp, #12
    9668:	af00      	add	r7, sp, #0
		err = bt_le_adv_stop();
	} else {
		err = bt_le_ext_adv_stop(adv);
	}
#else
	err = bt_le_adv_stop();
    966a:	f7ff ffa5 	bl	95b8 <bt_le_adv_stop>
#endif
	BT_WARN("Failed to stop advertising: %d", err);
    966e:	b088      	sub	sp, #32
    9670:	466b      	mov	r3, sp
    9672:	f113 0210 	adds.w	r2, r3, #16
    9676:	d031      	beq.n	96dc <adv_timeout+0x78>
    9678:	210c      	movs	r1, #12
    967a:	b11a      	cbz	r2, 9684 <adv_timeout+0x20>
    967c:	2904      	cmp	r1, #4
    967e:	dd01      	ble.n	9684 <adv_timeout+0x20>
    9680:	4c19      	ldr	r4, [pc, #100]	; (96e8 <adv_timeout+0x84>)
    9682:	615c      	str	r4, [r3, #20]
    9684:	b112      	cbz	r2, 968c <adv_timeout+0x28>
    9686:	2908      	cmp	r1, #8
    9688:	dd00      	ble.n	968c <adv_timeout+0x28>
    968a:	6198      	str	r0, [r3, #24]
    968c:	290b      	cmp	r1, #11
    968e:	dd28      	ble.n	96e2 <adv_timeout+0x7e>
    9690:	f04f 0c0c 	mov.w	ip, #12
    9694:	b13a      	cbz	r2, 96a6 <adv_timeout+0x42>
    9696:	2103      	movs	r1, #3
    9698:	7139      	strb	r1, [r7, #4]
    969a:	2100      	movs	r1, #0
    969c:	7179      	strb	r1, [r7, #5]
    969e:	71b9      	strb	r1, [r7, #6]
    96a0:	71f9      	strb	r1, [r7, #7]
    96a2:	6878      	ldr	r0, [r7, #4]
    96a4:	6118      	str	r0, [r3, #16]
    96a6:	2100      	movs	r1, #0
    96a8:	f36f 0100 	bfc	r1, #0, #1
    96ac:	f36f 0141 	bfc	r1, #1, #1
    96b0:	f36f 0182 	bfc	r1, #2, #1
    96b4:	f36f 01c5 	bfc	r1, #3, #3
    96b8:	2302      	movs	r3, #2
    96ba:	f363 1188 	bfi	r1, r3, #6, #3
    96be:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    96c2:	f36c 2152 	bfi	r1, ip, #9, #10
    96c6:	f36f 41de 	bfc	r1, #19, #12
    96ca:	f36f 71df 	bfc	r1, #31, #1
    96ce:	2300      	movs	r3, #0
    96d0:	4806      	ldr	r0, [pc, #24]	; (96ec <adv_timeout+0x88>)
    96d2:	f7f8 fdb9 	bl	2248 <z_impl_z_log_msg_static_create>
}
    96d6:	370c      	adds	r7, #12
    96d8:	46bd      	mov	sp, r7
    96da:	bd90      	pop	{r4, r7, pc}
	BT_WARN("Failed to stop advertising: %d", err);
    96dc:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    96e0:	e7cb      	b.n	967a <adv_timeout+0x16>
    96e2:	f06f 0c1b 	mvn.w	ip, #27
    96e6:	e7d5      	b.n	9694 <adv_timeout+0x30>
    96e8:	0001e928 	.word	0x0001e928
    96ec:	0001cfcc 	.word	0x0001cfcc

000096f0 <prng_reseed>:
#include "hci_core.h"

static struct tc_hmac_prng_struct prng;

static int prng_reseed(struct tc_hmac_prng_struct *h)
{
    96f0:	b530      	push	{r4, r5, lr}
    96f2:	b095      	sub	sp, #84	; 0x54
    96f4:	4604      	mov	r4, r0
	uint8_t seed[32];
	int64_t extra;
	int ret;

	ret = bt_hci_le_rand(seed, sizeof(seed));
    96f6:	2120      	movs	r1, #32
    96f8:	a806      	add	r0, sp, #24
    96fa:	f7fe f91f 	bl	793c <bt_hci_le_rand>
	if (ret) {
    96fe:	4605      	mov	r5, r0
    9700:	b110      	cbz	r0, 9708 <prng_reseed+0x18>
		BT_ERR("Failed to re-seed PRNG");
		return -EIO;
	}

	return 0;
}
    9702:	4628      	mov	r0, r5
    9704:	b015      	add	sp, #84	; 0x54
    9706:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_uptime_ticks();
    9708:	f013 f8fd 	bl	1c906 <z_impl_k_uptime_ticks>
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
    970c:	014a      	lsls	r2, r1, #5
    970e:	ea42 62d0 	orr.w	r2, r2, r0, lsr #27
    9712:	0143      	lsls	r3, r0, #5
    9714:	1a1b      	subs	r3, r3, r0
    9716:	eb62 0201 	sbc.w	r2, r2, r1
    971a:	0092      	lsls	r2, r2, #2
    971c:	ea42 7293 	orr.w	r2, r2, r3, lsr #30
    9720:	009b      	lsls	r3, r3, #2
    9722:	181b      	adds	r3, r3, r0
    9724:	eb42 0101 	adc.w	r1, r2, r1
    9728:	00c9      	lsls	r1, r1, #3
    972a:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
    972e:	f3c3 3310 	ubfx	r3, r3, #12, #17
    9732:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
    9736:	0bc9      	lsrs	r1, r1, #15
	extra = k_uptime_get();
    9738:	9304      	str	r3, [sp, #16]
    973a:	9105      	str	r1, [sp, #20]
	ret = tc_hmac_prng_reseed(h, seed, sizeof(seed), (uint8_t *)&extra,
    973c:	2308      	movs	r3, #8
    973e:	9300      	str	r3, [sp, #0]
    9740:	ab04      	add	r3, sp, #16
    9742:	2220      	movs	r2, #32
    9744:	a906      	add	r1, sp, #24
    9746:	4620      	mov	r0, r4
    9748:	f00d fe6f 	bl	1742a <tc_hmac_prng_reseed>
	if (ret == TC_CRYPTO_FAIL) {
    974c:	2800      	cmp	r0, #0
    974e:	d1d8      	bne.n	9702 <prng_reseed+0x12>
		BT_ERR("Failed to re-seed PRNG");
    9750:	4b13      	ldr	r3, [pc, #76]	; (97a0 <prng_reseed+0xb0>)
    9752:	9313      	str	r3, [sp, #76]	; 0x4c
    9754:	2302      	movs	r3, #2
    9756:	f88d 300c 	strb.w	r3, [sp, #12]
    975a:	2300      	movs	r3, #0
    975c:	f88d 300d 	strb.w	r3, [sp, #13]
    9760:	f88d 300e 	strb.w	r3, [sp, #14]
    9764:	f88d 300f 	strb.w	r3, [sp, #15]
    9768:	9a03      	ldr	r2, [sp, #12]
    976a:	9212      	str	r2, [sp, #72]	; 0x48
    976c:	4619      	mov	r1, r3
    976e:	f363 0100 	bfi	r1, r3, #0, #1
    9772:	f363 0141 	bfi	r1, r3, #1, #1
    9776:	f363 0182 	bfi	r1, r3, #2, #1
    977a:	f363 01c5 	bfi	r1, r3, #3, #3
    977e:	2201      	movs	r2, #1
    9780:	f362 1188 	bfi	r1, r2, #6, #3
    9784:	2208      	movs	r2, #8
    9786:	f362 2152 	bfi	r1, r2, #9, #10
    978a:	f363 41de 	bfi	r1, r3, #19, #12
    978e:	f363 71df 	bfi	r1, r3, #31, #1
    9792:	aa12      	add	r2, sp, #72	; 0x48
    9794:	4803      	ldr	r0, [pc, #12]	; (97a4 <prng_reseed+0xb4>)
    9796:	f7f8 fd57 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    979a:	f06f 0504 	mvn.w	r5, #4
    979e:	e7b0      	b.n	9702 <prng_reseed+0x12>
    97a0:	0001e950 	.word	0x0001e950
    97a4:	0001cfec 	.word	0x0001cfec

000097a8 <prng_init>:

int prng_init(void)
{
    97a8:	b500      	push	{lr}
    97aa:	b08b      	sub	sp, #44	; 0x2c
	uint8_t perso[8];
	int ret;

	ret = bt_hci_le_rand(perso, sizeof(perso));
    97ac:	2108      	movs	r1, #8
    97ae:	eb0d 0001 	add.w	r0, sp, r1
    97b2:	f7fe f8c3 	bl	793c <bt_hci_le_rand>
	if (ret) {
    97b6:	b110      	cbz	r0, 97be <prng_init+0x16>
		return -EIO;
	}

	/* re-seed is needed after init */
	return prng_reseed(&prng);
}
    97b8:	b00b      	add	sp, #44	; 0x2c
    97ba:	f85d fb04 	ldr.w	pc, [sp], #4
	ret = tc_hmac_prng_init(&prng, perso, sizeof(perso));
    97be:	2208      	movs	r2, #8
    97c0:	eb0d 0102 	add.w	r1, sp, r2
    97c4:	4817      	ldr	r0, [pc, #92]	; (9824 <prng_init+0x7c>)
    97c6:	f00d fe0d 	bl	173e4 <tc_hmac_prng_init>
	if (ret == TC_CRYPTO_FAIL) {
    97ca:	b118      	cbz	r0, 97d4 <prng_init+0x2c>
	return prng_reseed(&prng);
    97cc:	4815      	ldr	r0, [pc, #84]	; (9824 <prng_init+0x7c>)
    97ce:	f7ff ff8f 	bl	96f0 <prng_reseed>
    97d2:	e7f1      	b.n	97b8 <prng_init+0x10>
		BT_ERR("Failed to initialize PRNG");
    97d4:	4b14      	ldr	r3, [pc, #80]	; (9828 <prng_init+0x80>)
    97d6:	9309      	str	r3, [sp, #36]	; 0x24
    97d8:	2302      	movs	r3, #2
    97da:	f88d 3004 	strb.w	r3, [sp, #4]
    97de:	2300      	movs	r3, #0
    97e0:	f88d 3005 	strb.w	r3, [sp, #5]
    97e4:	f88d 3006 	strb.w	r3, [sp, #6]
    97e8:	f88d 3007 	strb.w	r3, [sp, #7]
    97ec:	9a01      	ldr	r2, [sp, #4]
    97ee:	9208      	str	r2, [sp, #32]
    97f0:	4619      	mov	r1, r3
    97f2:	f363 0100 	bfi	r1, r3, #0, #1
    97f6:	f363 0141 	bfi	r1, r3, #1, #1
    97fa:	f363 0182 	bfi	r1, r3, #2, #1
    97fe:	f363 01c5 	bfi	r1, r3, #3, #3
    9802:	2201      	movs	r2, #1
    9804:	f362 1188 	bfi	r1, r2, #6, #3
    9808:	2208      	movs	r2, #8
    980a:	f362 2152 	bfi	r1, r2, #9, #10
    980e:	f363 41de 	bfi	r1, r3, #19, #12
    9812:	f363 71df 	bfi	r1, r3, #31, #1
    9816:	aa08      	add	r2, sp, #32
    9818:	4804      	ldr	r0, [pc, #16]	; (982c <prng_init+0x84>)
    981a:	f7f8 fd15 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    981e:	f06f 0004 	mvn.w	r0, #4
    9822:	e7c9      	b.n	97b8 <prng_init+0x10>
    9824:	200016a0 	.word	0x200016a0
    9828:	0001e968 	.word	0x0001e968
    982c:	0001cfec 	.word	0x0001cfec

00009830 <bt_rand>:

#if defined(CONFIG_BT_HOST_CRYPTO_PRNG)
int bt_rand(void *buf, size_t len)
{
    9830:	b538      	push	{r3, r4, r5, lr}
    9832:	4604      	mov	r4, r0
    9834:	460d      	mov	r5, r1
	int ret;

	ret = tc_hmac_prng_generate(buf, len, &prng);
    9836:	4a0c      	ldr	r2, [pc, #48]	; (9868 <bt_rand+0x38>)
    9838:	f00d fe19 	bl	1746e <tc_hmac_prng_generate>
	if (ret == TC_HMAC_PRNG_RESEED_REQ) {
    983c:	f1b0 3fff 	cmp.w	r0, #4294967295
    9840:	d003      	beq.n	984a <bt_rand+0x1a>
		}

		ret = tc_hmac_prng_generate(buf, len, &prng);
	}

	if (ret == TC_CRYPTO_SUCCESS) {
    9842:	2801      	cmp	r0, #1
    9844:	d10c      	bne.n	9860 <bt_rand+0x30>
		return 0;
    9846:	2000      	movs	r0, #0
	}

	return -EIO;
}
    9848:	bd38      	pop	{r3, r4, r5, pc}
		ret = prng_reseed(&prng);
    984a:	4807      	ldr	r0, [pc, #28]	; (9868 <bt_rand+0x38>)
    984c:	f7ff ff50 	bl	96f0 <prng_reseed>
		if (ret) {
    9850:	2800      	cmp	r0, #0
    9852:	d1f9      	bne.n	9848 <bt_rand+0x18>
		ret = tc_hmac_prng_generate(buf, len, &prng);
    9854:	4a04      	ldr	r2, [pc, #16]	; (9868 <bt_rand+0x38>)
    9856:	4629      	mov	r1, r5
    9858:	4620      	mov	r0, r4
    985a:	f00d fe08 	bl	1746e <tc_hmac_prng_generate>
    985e:	e7f0      	b.n	9842 <bt_rand+0x12>
	return -EIO;
    9860:	f06f 0004 	mvn.w	r0, #4
    9864:	e7f0      	b.n	9848 <bt_rand+0x18>
    9866:	bf00      	nop
    9868:	200016a0 	.word	0x200016a0

0000986c <notify_connected>:
		return -ENOTCONN;
	}
}

static void notify_connected(struct bt_conn *conn)
{
    986c:	b538      	push	{r3, r4, r5, lr}
    986e:	4605      	mov	r5, r0
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
    9870:	4b0c      	ldr	r3, [pc, #48]	; (98a4 <notify_connected+0x38>)
    9872:	681c      	ldr	r4, [r3, #0]
    9874:	e003      	b.n	987e <notify_connected+0x12>
		if (cb->connected) {
			cb->connected(conn, conn->err);
    9876:	7a69      	ldrb	r1, [r5, #9]
    9878:	4628      	mov	r0, r5
    987a:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    987c:	6924      	ldr	r4, [r4, #16]
    987e:	b11c      	cbz	r4, 9888 <notify_connected+0x1c>
		if (cb->connected) {
    9880:	6823      	ldr	r3, [r4, #0]
    9882:	2b00      	cmp	r3, #0
    9884:	d1f7      	bne.n	9876 <notify_connected+0xa>
    9886:	e7f9      	b.n	987c <notify_connected+0x10>
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    9888:	4c07      	ldr	r4, [pc, #28]	; (98a8 <notify_connected+0x3c>)
    988a:	e000      	b.n	988e <notify_connected+0x22>
    988c:	3414      	adds	r4, #20
    988e:	4b07      	ldr	r3, [pc, #28]	; (98ac <notify_connected+0x40>)
    9890:	429c      	cmp	r4, r3
    9892:	d206      	bcs.n	98a2 <notify_connected+0x36>
		if (cb->connected) {
    9894:	6823      	ldr	r3, [r4, #0]
    9896:	2b00      	cmp	r3, #0
    9898:	d0f8      	beq.n	988c <notify_connected+0x20>
			cb->connected(conn, conn->err);
    989a:	7a69      	ldrb	r1, [r5, #9]
    989c:	4628      	mov	r0, r5
    989e:	4798      	blx	r3
    98a0:	e7f4      	b.n	988c <notify_connected+0x20>
		}
	}
}
    98a2:	bd38      	pop	{r3, r4, r5, pc}
    98a4:	200022cc 	.word	0x200022cc
    98a8:	0001cfa0 	.word	0x0001cfa0
    98ac:	0001cfb4 	.word	0x0001cfb4

000098b0 <notify_disconnected>:

static void notify_disconnected(struct bt_conn *conn)
{
    98b0:	b538      	push	{r3, r4, r5, lr}
    98b2:	4605      	mov	r5, r0
	struct bt_conn_cb *cb;

	for (cb = callback_list; cb; cb = cb->_next) {
    98b4:	4b0c      	ldr	r3, [pc, #48]	; (98e8 <notify_disconnected+0x38>)
    98b6:	681c      	ldr	r4, [r3, #0]
    98b8:	e003      	b.n	98c2 <notify_disconnected+0x12>
		if (cb->disconnected) {
			cb->disconnected(conn, conn->err);
    98ba:	7a69      	ldrb	r1, [r5, #9]
    98bc:	4628      	mov	r0, r5
    98be:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
    98c0:	6924      	ldr	r4, [r4, #16]
    98c2:	b11c      	cbz	r4, 98cc <notify_disconnected+0x1c>
		if (cb->disconnected) {
    98c4:	6863      	ldr	r3, [r4, #4]
    98c6:	2b00      	cmp	r3, #0
    98c8:	d1f7      	bne.n	98ba <notify_disconnected+0xa>
    98ca:	e7f9      	b.n	98c0 <notify_disconnected+0x10>
		}
	}

	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    98cc:	4c07      	ldr	r4, [pc, #28]	; (98ec <notify_disconnected+0x3c>)
    98ce:	e000      	b.n	98d2 <notify_disconnected+0x22>
    98d0:	3414      	adds	r4, #20
    98d2:	4b07      	ldr	r3, [pc, #28]	; (98f0 <notify_disconnected+0x40>)
    98d4:	429c      	cmp	r4, r3
    98d6:	d206      	bcs.n	98e6 <notify_disconnected+0x36>
		if (cb->disconnected) {
    98d8:	6863      	ldr	r3, [r4, #4]
    98da:	2b00      	cmp	r3, #0
    98dc:	d0f8      	beq.n	98d0 <notify_disconnected+0x20>
			cb->disconnected(conn, conn->err);
    98de:	7a69      	ldrb	r1, [r5, #9]
    98e0:	4628      	mov	r0, r5
    98e2:	4798      	blx	r3
    98e4:	e7f4      	b.n	98d0 <notify_disconnected+0x20>
		}
	}
}
    98e6:	bd38      	pop	{r3, r4, r5, pc}
    98e8:	200022cc 	.word	0x200022cc
    98ec:	0001cfa0 	.word	0x0001cfa0
    98f0:	0001cfb4 	.word	0x0001cfb4

000098f4 <tx_free>:
{
    98f4:	b508      	push	{r3, lr}
    98f6:	4601      	mov	r1, r0
	tx->cb = NULL;
    98f8:	2300      	movs	r3, #0
    98fa:	6043      	str	r3, [r0, #4]
	tx->user_data = NULL;
    98fc:	6083      	str	r3, [r0, #8]
	tx->pending_no_cb = 0U;
    98fe:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
    9900:	4801      	ldr	r0, [pc, #4]	; (9908 <tx_free+0x14>)
    9902:	f012 fc31 	bl	1c168 <k_queue_append>
}
    9906:	bd08      	pop	{r3, pc}
    9908:	2000066c 	.word	0x2000066c

0000990c <conn_tx_alloc>:
{
    990c:	b508      	push	{r3, lr}
	return z_impl_z_current_get();
    990e:	f00a ff37 	bl	14780 <z_impl_z_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
    9912:	4b08      	ldr	r3, [pc, #32]	; (9934 <conn_tx_alloc+0x28>)
    9914:	4283      	cmp	r3, r0
    9916:	d007      	beq.n	9928 <conn_tx_alloc+0x1c>
	return z_impl_k_queue_get(queue, timeout);
    9918:	f04f 32ff 	mov.w	r2, #4294967295
    991c:	f04f 33ff 	mov.w	r3, #4294967295
    9920:	4805      	ldr	r0, [pc, #20]	; (9938 <conn_tx_alloc+0x2c>)
    9922:	f00a f8fb 	bl	13b1c <z_impl_k_queue_get>
}
    9926:	bd08      	pop	{r3, pc}
    9928:	2200      	movs	r2, #0
    992a:	2300      	movs	r3, #0
    992c:	4802      	ldr	r0, [pc, #8]	; (9938 <conn_tx_alloc+0x2c>)
    992e:	f00a f8f5 	bl	13b1c <z_impl_k_queue_get>
		return k_fifo_get(&free_tx, K_NO_WAIT);
    9932:	e7f8      	b.n	9926 <conn_tx_alloc+0x1a>
    9934:	20001af8 	.word	0x20001af8
    9938:	2000066c 	.word	0x2000066c

0000993c <bt_conn_get_pkts>:
}
    993c:	4800      	ldr	r0, [pc, #0]	; (9940 <bt_conn_get_pkts+0x4>)
    993e:	4770      	bx	lr
    9940:	20000100 	.word	0x20000100

00009944 <send_frag>:
{
    9944:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9948:	b083      	sub	sp, #12
    994a:	af00      	add	r7, sp, #0
    994c:	4605      	mov	r5, r0
    994e:	460e      	mov	r6, r1
    9950:	4692      	mov	sl, r2
    9952:	461c      	mov	r4, r3
	struct bt_conn_tx *tx = tx_data(buf)->tx;
    9954:	f8d1 8014 	ldr.w	r8, [r1, #20]
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);
    9958:	f7ff fff0 	bl	993c <bt_conn_get_pkts>
    995c:	4681      	mov	r9, r0
	return z_impl_k_sem_take(sem, timeout);
    995e:	f04f 32ff 	mov.w	r2, #4294967295
    9962:	f04f 33ff 	mov.w	r3, #4294967295
    9966:	f00a f93b 	bl	13be0 <z_impl_k_sem_take>
	if (conn->state != BT_CONN_CONNECTED) {
    996a:	7aab      	ldrb	r3, [r5, #10]
    996c:	2b07      	cmp	r3, #7
    996e:	f040 80a3 	bne.w	9ab8 <send_frag+0x174>
    9972:	f04f 0220 	mov.w	r2, #32
    9976:	f3ef 8311 	mrs	r3, BASEPRI
    997a:	f382 8812 	msr	BASEPRI_MAX, r2
    997e:	f3bf 8f6f 	isb	sy
	if (tx) {
    9982:	f1b8 0f00 	cmp.w	r8, #0
    9986:	d01a      	beq.n	99be <send_frag+0x7a>
	parent->next = child;
    9988:	2200      	movs	r2, #0
    998a:	f8c8 2000 	str.w	r2, [r8]
	return list->tail;
    998e:	69aa      	ldr	r2, [r5, #24]
Z_GENLIST_APPEND(slist, snode)
    9990:	b182      	cbz	r2, 99b4 <send_frag+0x70>
	parent->next = child;
    9992:	f8c2 8000 	str.w	r8, [r2]
	list->tail = node;
    9996:	f8c5 8018 	str.w	r8, [r5, #24]
	__asm__ volatile(
    999a:	f383 8811 	msr	BASEPRI, r3
    999e:	f3bf 8f6f 	isb	sy
		err = send_acl(conn, buf, flags);
    99a2:	4652      	mov	r2, sl
    99a4:	4631      	mov	r1, r6
    99a6:	4628      	mov	r0, r5
    99a8:	f00e fab2 	bl	17f10 <send_acl>
	if (err) {
    99ac:	4684      	mov	ip, r0
    99ae:	b998      	cbnz	r0, 99d8 <send_frag+0x94>
	return true;
    99b0:	2001      	movs	r0, #1
    99b2:	e08f      	b.n	9ad4 <send_frag+0x190>
    99b4:	f8c5 8018 	str.w	r8, [r5, #24]
	list->head = node;
    99b8:	f8c5 8014 	str.w	r8, [r5, #20]
}
    99bc:	e7ed      	b.n	999a <send_frag+0x56>
	return list->tail;
    99be:	69aa      	ldr	r2, [r5, #24]
		if (tail_tx) {
    99c0:	b13a      	cbz	r2, 99d2 <send_frag+0x8e>
			pending_no_cb = &tail_tx->pending_no_cb;
    99c2:	f102 0b0c 	add.w	fp, r2, #12
		(*pending_no_cb)++;
    99c6:	f8db 2000 	ldr.w	r2, [fp]
    99ca:	3201      	adds	r2, #1
    99cc:	f8cb 2000 	str.w	r2, [fp]
    99d0:	e7e3      	b.n	999a <send_frag+0x56>
			pending_no_cb = &conn->pending_no_cb;
    99d2:	f105 0b1c 	add.w	fp, r5, #28
    99d6:	e7f6      	b.n	99c6 <send_frag+0x82>
		BT_ERR("Unable to send to driver (err %d)", err);
    99d8:	46ea      	mov	sl, sp
    99da:	b088      	sub	sp, #32
    99dc:	466b      	mov	r3, sp
    99de:	f113 0210 	adds.w	r2, r3, #16
    99e2:	d045      	beq.n	9a70 <send_frag+0x12c>
    99e4:	210c      	movs	r1, #12
    99e6:	b11a      	cbz	r2, 99f0 <send_frag+0xac>
    99e8:	2904      	cmp	r1, #4
    99ea:	dd01      	ble.n	99f0 <send_frag+0xac>
    99ec:	483e      	ldr	r0, [pc, #248]	; (9ae8 <send_frag+0x1a4>)
    99ee:	6158      	str	r0, [r3, #20]
    99f0:	b11a      	cbz	r2, 99fa <send_frag+0xb6>
    99f2:	2908      	cmp	r1, #8
    99f4:	dd01      	ble.n	99fa <send_frag+0xb6>
    99f6:	f8c3 c018 	str.w	ip, [r3, #24]
    99fa:	290b      	cmp	r1, #11
    99fc:	dd3b      	ble.n	9a76 <send_frag+0x132>
    99fe:	f04f 0c0c 	mov.w	ip, #12
    9a02:	b13a      	cbz	r2, 9a14 <send_frag+0xd0>
    9a04:	2103      	movs	r1, #3
    9a06:	7139      	strb	r1, [r7, #4]
    9a08:	2100      	movs	r1, #0
    9a0a:	7179      	strb	r1, [r7, #5]
    9a0c:	71b9      	strb	r1, [r7, #6]
    9a0e:	71f9      	strb	r1, [r7, #7]
    9a10:	6878      	ldr	r0, [r7, #4]
    9a12:	6118      	str	r0, [r3, #16]
    9a14:	2100      	movs	r1, #0
    9a16:	f36f 0100 	bfc	r1, #0, #1
    9a1a:	f36f 0141 	bfc	r1, #1, #1
    9a1e:	f36f 0182 	bfc	r1, #2, #1
    9a22:	f36f 01c5 	bfc	r1, #3, #3
    9a26:	2301      	movs	r3, #1
    9a28:	f363 1188 	bfi	r1, r3, #6, #3
    9a2c:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    9a30:	f36c 2152 	bfi	r1, ip, #9, #10
    9a34:	f36f 41de 	bfc	r1, #19, #12
    9a38:	f36f 71df 	bfc	r1, #31, #1
    9a3c:	2300      	movs	r3, #0
    9a3e:	482b      	ldr	r0, [pc, #172]	; (9aec <send_frag+0x1a8>)
    9a40:	f7f8 fc02 	bl	2248 <z_impl_z_log_msg_static_create>
    9a44:	46d5      	mov	sp, sl
	__asm__ volatile(
    9a46:	f04f 0320 	mov.w	r3, #32
    9a4a:	f3ef 8111 	mrs	r1, BASEPRI
    9a4e:	f383 8812 	msr	BASEPRI_MAX, r3
    9a52:	f3bf 8f6f 	isb	sy
		if (tx) {
    9a56:	f1b8 0f00 	cmp.w	r8, #0
    9a5a:	d024      	beq.n	9aa6 <send_frag+0x162>
			sys_slist_find_and_remove(&conn->tx_pending, &tx->node);
    9a5c:	f105 0014 	add.w	r0, r5, #20
	return list->head;
    9a60:	696b      	ldr	r3, [r5, #20]
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    9a62:	2200      	movs	r2, #0
    9a64:	b323      	cbz	r3, 9ab0 <send_frag+0x16c>
    9a66:	4598      	cmp	r8, r3
    9a68:	d008      	beq.n	9a7c <send_frag+0x138>
    9a6a:	461a      	mov	r2, r3
    9a6c:	681b      	ldr	r3, [r3, #0]
    9a6e:	e7f9      	b.n	9a64 <send_frag+0x120>
		BT_ERR("Unable to send to driver (err %d)", err);
    9a70:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    9a74:	e7b7      	b.n	99e6 <send_frag+0xa2>
    9a76:	f06f 0c1b 	mvn.w	ip, #27
    9a7a:	e7c2      	b.n	9a02 <send_frag+0xbe>
Z_GENLIST_REMOVE(slist, snode)
    9a7c:	b14a      	cbz	r2, 9a92 <send_frag+0x14e>
	return node->next;
    9a7e:	f8d8 3000 	ldr.w	r3, [r8]
	parent->next = child;
    9a82:	6013      	str	r3, [r2, #0]
	return list->tail;
    9a84:	6843      	ldr	r3, [r0, #4]
Z_GENLIST_REMOVE(slist, snode)
    9a86:	4598      	cmp	r8, r3
    9a88:	d00b      	beq.n	9aa2 <send_frag+0x15e>
	parent->next = child;
    9a8a:	2300      	movs	r3, #0
    9a8c:	f8c8 3000 	str.w	r3, [r8]
Z_GENLIST_REMOVE(slist, snode)
    9a90:	e00e      	b.n	9ab0 <send_frag+0x16c>
	return node->next;
    9a92:	f8d8 3000 	ldr.w	r3, [r8]
	list->head = node;
    9a96:	616b      	str	r3, [r5, #20]
	return list->tail;
    9a98:	6842      	ldr	r2, [r0, #4]
Z_GENLIST_REMOVE(slist, snode)
    9a9a:	4590      	cmp	r8, r2
    9a9c:	d1f5      	bne.n	9a8a <send_frag+0x146>
	list->tail = node;
    9a9e:	6043      	str	r3, [r0, #4]
}
    9aa0:	e7f3      	b.n	9a8a <send_frag+0x146>
	list->tail = node;
    9aa2:	6042      	str	r2, [r0, #4]
}
    9aa4:	e7f1      	b.n	9a8a <send_frag+0x146>
			(*pending_no_cb)--;
    9aa6:	f8db 3000 	ldr.w	r3, [fp]
    9aaa:	3b01      	subs	r3, #1
    9aac:	f8cb 3000 	str.w	r3, [fp]
	__asm__ volatile(
    9ab0:	f381 8811 	msr	BASEPRI, r1
    9ab4:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
    9ab8:	4648      	mov	r0, r9
    9aba:	f00a f869 	bl	13b90 <z_impl_k_sem_give>
	if (tx) {
    9abe:	f1b8 0f00 	cmp.w	r8, #0
    9ac2:	d005      	beq.n	9ad0 <send_frag+0x18c>
		tx_data(buf)->tx = NULL;
    9ac4:	2300      	movs	r3, #0
    9ac6:	6173      	str	r3, [r6, #20]
		conn_tx_destroy(conn, tx);
    9ac8:	4641      	mov	r1, r8
    9aca:	4628      	mov	r0, r5
    9acc:	f00e fa13 	bl	17ef6 <conn_tx_destroy>
	if (always_consume) {
    9ad0:	b924      	cbnz	r4, 9adc <send_frag+0x198>
	return false;
    9ad2:	4620      	mov	r0, r4
}
    9ad4:	370c      	adds	r7, #12
    9ad6:	46bd      	mov	sp, r7
    9ad8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		net_buf_unref(buf);
    9adc:	4630      	mov	r0, r6
    9ade:	f010 fb44 	bl	1a16a <net_buf_unref>
	return false;
    9ae2:	2000      	movs	r0, #0
    9ae4:	e7f6      	b.n	9ad4 <send_frag+0x190>
    9ae6:	bf00      	nop
    9ae8:	0001e598 	.word	0x0001e598
    9aec:	0001cfe4 	.word	0x0001cfe4

00009af0 <bt_conn_new>:
{
    9af0:	b538      	push	{r3, r4, r5, lr}
	for (i = 0; i < size; i++) {
    9af2:	2300      	movs	r3, #0
    9af4:	428b      	cmp	r3, r1
    9af6:	d225      	bcs.n	9b44 <bt_conn_new+0x54>
		if (atomic_cas(&conns[i].ref, 0, 1)) {
    9af8:	eb03 0443 	add.w	r4, r3, r3, lsl #1
    9afc:	eb00 1484 	add.w	r4, r0, r4, lsl #6
    9b00:	f104 02b8 	add.w	r2, r4, #184	; 0xb8
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    9b04:	f04f 0c01 	mov.w	ip, #1
    9b08:	e8d2 efef 	ldaex	lr, [r2]
    9b0c:	f1be 0f00 	cmp.w	lr, #0
    9b10:	d103      	bne.n	9b1a <bt_conn_new+0x2a>
    9b12:	e8c2 cfe5 	stlex	r5, ip, [r2]
    9b16:	2d00      	cmp	r5, #0
    9b18:	d1f6      	bne.n	9b08 <bt_conn_new+0x18>
    9b1a:	d111      	bne.n	9b40 <bt_conn_new+0x50>
	if (!conn) {
    9b1c:	b174      	cbz	r4, 9b3c <bt_conn_new+0x4c>
	(void)memset(conn, 0, offsetof(struct bt_conn, ref));
    9b1e:	22b8      	movs	r2, #184	; 0xb8
    9b20:	2100      	movs	r1, #0
    9b22:	4620      	mov	r0, r4
    9b24:	f00d fe33 	bl	1778e <memset>
	k_work_init_delayable(&conn->deferred_work, deferred_work);
    9b28:	4907      	ldr	r1, [pc, #28]	; (9b48 <bt_conn_new+0x58>)
    9b2a:	f104 0058 	add.w	r0, r4, #88	; 0x58
    9b2e:	f012 fc25 	bl	1c37c <k_work_init_delayable>
	k_work_init(&conn->tx_complete_work, tx_complete_work);
    9b32:	4906      	ldr	r1, [pc, #24]	; (9b4c <bt_conn_new+0x5c>)
    9b34:	f104 0028 	add.w	r0, r4, #40	; 0x28
    9b38:	f012 fbec 	bl	1c314 <k_work_init>
}
    9b3c:	4620      	mov	r0, r4
    9b3e:	bd38      	pop	{r3, r4, r5, pc}
	for (i = 0; i < size; i++) {
    9b40:	4463      	add	r3, ip
    9b42:	e7d7      	b.n	9af4 <bt_conn_new+0x4>
	struct bt_conn *conn = NULL;
    9b44:	2400      	movs	r4, #0
    9b46:	e7e9      	b.n	9b1c <bt_conn_new+0x2c>
    9b48:	0000a6cd 	.word	0x0000a6cd
    9b4c:	00017eed 	.word	0x00017eed

00009b50 <acl_conn_new>:

	atomic_set_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_UPDATE);
}

static struct bt_conn *acl_conn_new(void)
{
    9b50:	b508      	push	{r3, lr}
	return bt_conn_new(acl_conns, ARRAY_SIZE(acl_conns));
    9b52:	2101      	movs	r1, #1
    9b54:	4801      	ldr	r0, [pc, #4]	; (9b5c <acl_conn_new+0xc>)
    9b56:	f7ff ffcb 	bl	9af0 <bt_conn_new>
}
    9b5a:	bd08      	pop	{r3, pc}
    9b5c:	200017d8 	.word	0x200017d8

00009b60 <bt_acl_recv>:
{
    9b60:	b5f0      	push	{r4, r5, r6, r7, lr}
    9b62:	b095      	sub	sp, #84	; 0x54
    9b64:	af00      	add	r7, sp, #0
    9b66:	4604      	mov	r4, r0
    9b68:	460d      	mov	r5, r1
	switch (flags) {
    9b6a:	2a01      	cmp	r2, #1
    9b6c:	d07d      	beq.n	9c6a <bt_acl_recv+0x10a>
    9b6e:	4613      	mov	r3, r2
    9b70:	2a02      	cmp	r2, #2
    9b72:	f040 80e7 	bne.w	9d44 <bt_acl_recv+0x1e4>
		if (conn->rx) {
    9b76:	6903      	ldr	r3, [r0, #16]
    9b78:	b323      	cbz	r3, 9bc4 <bt_acl_recv+0x64>
			BT_ERR("Unexpected first L2CAP frame");
    9b7a:	4b9c      	ldr	r3, [pc, #624]	; (9dec <bt_acl_recv+0x28c>)
    9b7c:	61fb      	str	r3, [r7, #28]
    9b7e:	2302      	movs	r3, #2
    9b80:	713b      	strb	r3, [r7, #4]
    9b82:	2300      	movs	r3, #0
    9b84:	717b      	strb	r3, [r7, #5]
    9b86:	71bb      	strb	r3, [r7, #6]
    9b88:	71fb      	strb	r3, [r7, #7]
    9b8a:	687a      	ldr	r2, [r7, #4]
    9b8c:	61ba      	str	r2, [r7, #24]
    9b8e:	4619      	mov	r1, r3
    9b90:	f363 0100 	bfi	r1, r3, #0, #1
    9b94:	f363 0141 	bfi	r1, r3, #1, #1
    9b98:	f363 0182 	bfi	r1, r3, #2, #1
    9b9c:	f363 01c5 	bfi	r1, r3, #3, #3
    9ba0:	2201      	movs	r2, #1
    9ba2:	f362 1188 	bfi	r1, r2, #6, #3
    9ba6:	2208      	movs	r2, #8
    9ba8:	f362 2152 	bfi	r1, r2, #9, #10
    9bac:	f363 41de 	bfi	r1, r3, #19, #12
    9bb0:	f363 71df 	bfi	r1, r3, #31, #1
    9bb4:	f107 0218 	add.w	r2, r7, #24
    9bb8:	488d      	ldr	r0, [pc, #564]	; (9df0 <bt_acl_recv+0x290>)
    9bba:	f7f8 fb45 	bl	2248 <z_impl_z_log_msg_static_create>
			bt_conn_reset_rx_state(conn);
    9bbe:	4620      	mov	r0, r4
    9bc0:	f00e fa0a 	bl	17fd8 <bt_conn_reset_rx_state>
		conn->rx = buf;
    9bc4:	6125      	str	r5, [r4, #16]
	if (conn->rx->len < sizeof(uint16_t)) {
    9bc6:	6921      	ldr	r1, [r4, #16]
    9bc8:	8988      	ldrh	r0, [r1, #12]
    9bca:	2801      	cmp	r0, #1
    9bcc:	f240 80f7 	bls.w	9dbe <bt_acl_recv+0x25e>
	acl_total_len = sys_get_le16(conn->rx->data) + sizeof(struct bt_l2cap_hdr);
    9bd0:	688a      	ldr	r2, [r1, #8]
	return ((uint16_t)src[1] << 8) | src[0];
    9bd2:	7855      	ldrb	r5, [r2, #1]
    9bd4:	7813      	ldrb	r3, [r2, #0]
    9bd6:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    9bda:	3304      	adds	r3, #4
    9bdc:	b29b      	uxth	r3, r3
	if (conn->rx->len < acl_total_len) {
    9bde:	4283      	cmp	r3, r0
    9be0:	f200 80ed 	bhi.w	9dbe <bt_acl_recv+0x25e>
	if (conn->rx->len > acl_total_len) {
    9be4:	f080 80fa 	bcs.w	9ddc <bt_acl_recv+0x27c>
		BT_ERR("ACL len mismatch (%u > %u)",
    9be8:	466d      	mov	r5, sp
    9bea:	b088      	sub	sp, #32
    9bec:	4669      	mov	r1, sp
    9bee:	f111 0210 	adds.w	r2, r1, #16
    9bf2:	f000 80ed 	beq.w	9dd0 <bt_acl_recv+0x270>
    9bf6:	2610      	movs	r6, #16
    9bf8:	b12a      	cbz	r2, 9c06 <bt_acl_recv+0xa6>
    9bfa:	2e04      	cmp	r6, #4
    9bfc:	dd03      	ble.n	9c06 <bt_acl_recv+0xa6>
    9bfe:	f8df c1f4 	ldr.w	ip, [pc, #500]	; 9df4 <bt_acl_recv+0x294>
    9c02:	f8c1 c014 	str.w	ip, [r1, #20]
    9c06:	b112      	cbz	r2, 9c0e <bt_acl_recv+0xae>
    9c08:	2e08      	cmp	r6, #8
    9c0a:	dd00      	ble.n	9c0e <bt_acl_recv+0xae>
    9c0c:	6188      	str	r0, [r1, #24]
    9c0e:	b112      	cbz	r2, 9c16 <bt_acl_recv+0xb6>
    9c10:	2e0c      	cmp	r6, #12
    9c12:	dd00      	ble.n	9c16 <bt_acl_recv+0xb6>
    9c14:	61cb      	str	r3, [r1, #28]
    9c16:	2e0f      	cmp	r6, #15
    9c18:	f340 80dd 	ble.w	9dd6 <bt_acl_recv+0x276>
    9c1c:	2310      	movs	r3, #16
    9c1e:	b13a      	cbz	r2, 9c30 <bt_acl_recv+0xd0>
    9c20:	2004      	movs	r0, #4
    9c22:	7138      	strb	r0, [r7, #4]
    9c24:	2000      	movs	r0, #0
    9c26:	7178      	strb	r0, [r7, #5]
    9c28:	71b8      	strb	r0, [r7, #6]
    9c2a:	71f8      	strb	r0, [r7, #7]
    9c2c:	6878      	ldr	r0, [r7, #4]
    9c2e:	6108      	str	r0, [r1, #16]
    9c30:	2100      	movs	r1, #0
    9c32:	f36f 0100 	bfc	r1, #0, #1
    9c36:	f36f 0141 	bfc	r1, #1, #1
    9c3a:	f36f 0182 	bfc	r1, #2, #1
    9c3e:	f36f 01c5 	bfc	r1, #3, #3
    9c42:	2001      	movs	r0, #1
    9c44:	f360 1188 	bfi	r1, r0, #6, #3
    9c48:	f403 737d 	and.w	r3, r3, #1012	; 0x3f4
    9c4c:	f363 2152 	bfi	r1, r3, #9, #10
    9c50:	f36f 41de 	bfc	r1, #19, #12
    9c54:	f36f 71df 	bfc	r1, #31, #1
    9c58:	2300      	movs	r3, #0
    9c5a:	4865      	ldr	r0, [pc, #404]	; (9df0 <bt_acl_recv+0x290>)
    9c5c:	f7f8 faf4 	bl	2248 <z_impl_z_log_msg_static_create>
    9c60:	46ad      	mov	sp, r5
		bt_conn_reset_rx_state(conn);
    9c62:	4620      	mov	r0, r4
    9c64:	f00e f9b8 	bl	17fd8 <bt_conn_reset_rx_state>
		return;
    9c68:	e0a9      	b.n	9dbe <bt_acl_recv+0x25e>
		if (!conn->rx) {
    9c6a:	6900      	ldr	r0, [r0, #16]
    9c6c:	b180      	cbz	r0, 9c90 <bt_acl_recv+0x130>
		if (!buf->len) {
    9c6e:	898e      	ldrh	r6, [r1, #12]
    9c70:	b3be      	cbz	r6, 9ce2 <bt_acl_recv+0x182>
 *
 * @return Number of bytes available at the end of the buffer.
 */
static inline size_t net_buf_tailroom(struct net_buf *buf)
{
	return net_buf_simple_tailroom(&buf->b);
    9c72:	3008      	adds	r0, #8
    9c74:	f010 fb0f 	bl	1a296 <net_buf_simple_tailroom>
		if (buf->len > net_buf_tailroom(conn->rx)) {
    9c78:	42b0      	cmp	r0, r6
    9c7a:	d336      	bcc.n	9cea <bt_acl_recv+0x18a>
		net_buf_add_mem(conn->rx, buf->data, buf->len);
    9c7c:	6920      	ldr	r0, [r4, #16]
	return net_buf_simple_add_mem(&buf->b, mem, len);
    9c7e:	89aa      	ldrh	r2, [r5, #12]
    9c80:	68a9      	ldr	r1, [r5, #8]
    9c82:	3008      	adds	r0, #8
    9c84:	f010 fac1 	bl	1a20a <net_buf_simple_add_mem>
		net_buf_unref(buf);
    9c88:	4628      	mov	r0, r5
    9c8a:	f010 fa6e 	bl	1a16a <net_buf_unref>
		break;
    9c8e:	e79a      	b.n	9bc6 <bt_acl_recv+0x66>
			BT_ERR("Unexpected L2CAP continuation");
    9c90:	4b59      	ldr	r3, [pc, #356]	; (9df8 <bt_acl_recv+0x298>)
    9c92:	64fb      	str	r3, [r7, #76]	; 0x4c
    9c94:	2302      	movs	r3, #2
    9c96:	713b      	strb	r3, [r7, #4]
    9c98:	2300      	movs	r3, #0
    9c9a:	717b      	strb	r3, [r7, #5]
    9c9c:	71bb      	strb	r3, [r7, #6]
    9c9e:	71fb      	strb	r3, [r7, #7]
    9ca0:	687a      	ldr	r2, [r7, #4]
    9ca2:	64ba      	str	r2, [r7, #72]	; 0x48
    9ca4:	4619      	mov	r1, r3
    9ca6:	f363 0100 	bfi	r1, r3, #0, #1
    9caa:	f363 0141 	bfi	r1, r3, #1, #1
    9cae:	f363 0182 	bfi	r1, r3, #2, #1
    9cb2:	f363 01c5 	bfi	r1, r3, #3, #3
    9cb6:	2201      	movs	r2, #1
    9cb8:	f362 1188 	bfi	r1, r2, #6, #3
    9cbc:	2208      	movs	r2, #8
    9cbe:	f362 2152 	bfi	r1, r2, #9, #10
    9cc2:	f363 41de 	bfi	r1, r3, #19, #12
    9cc6:	f363 71df 	bfi	r1, r3, #31, #1
    9cca:	f107 0248 	add.w	r2, r7, #72	; 0x48
    9cce:	4848      	ldr	r0, [pc, #288]	; (9df0 <bt_acl_recv+0x290>)
    9cd0:	f7f8 faba 	bl	2248 <z_impl_z_log_msg_static_create>
			bt_conn_reset_rx_state(conn);
    9cd4:	4620      	mov	r0, r4
    9cd6:	f00e f97f 	bl	17fd8 <bt_conn_reset_rx_state>
			net_buf_unref(buf);
    9cda:	4628      	mov	r0, r5
    9cdc:	f010 fa45 	bl	1a16a <net_buf_unref>
			return;
    9ce0:	e06d      	b.n	9dbe <bt_acl_recv+0x25e>
			net_buf_unref(buf);
    9ce2:	4608      	mov	r0, r1
    9ce4:	f010 fa41 	bl	1a16a <net_buf_unref>
			return;
    9ce8:	e069      	b.n	9dbe <bt_acl_recv+0x25e>
			BT_ERR("Not enough buffer space for L2CAP data");
    9cea:	4b44      	ldr	r3, [pc, #272]	; (9dfc <bt_acl_recv+0x29c>)
    9cec:	637b      	str	r3, [r7, #52]	; 0x34
    9cee:	2302      	movs	r3, #2
    9cf0:	713b      	strb	r3, [r7, #4]
    9cf2:	2600      	movs	r6, #0
    9cf4:	717e      	strb	r6, [r7, #5]
    9cf6:	71be      	strb	r6, [r7, #6]
    9cf8:	71fe      	strb	r6, [r7, #7]
    9cfa:	687b      	ldr	r3, [r7, #4]
    9cfc:	633b      	str	r3, [r7, #48]	; 0x30
    9cfe:	4631      	mov	r1, r6
    9d00:	f366 0100 	bfi	r1, r6, #0, #1
    9d04:	f366 0141 	bfi	r1, r6, #1, #1
    9d08:	f366 0182 	bfi	r1, r6, #2, #1
    9d0c:	f366 01c5 	bfi	r1, r6, #3, #3
    9d10:	2301      	movs	r3, #1
    9d12:	f363 1188 	bfi	r1, r3, #6, #3
    9d16:	2308      	movs	r3, #8
    9d18:	f363 2152 	bfi	r1, r3, #9, #10
    9d1c:	f366 41de 	bfi	r1, r6, #19, #12
    9d20:	f366 71df 	bfi	r1, r6, #31, #1
    9d24:	4633      	mov	r3, r6
    9d26:	f107 0230 	add.w	r2, r7, #48	; 0x30
    9d2a:	4831      	ldr	r0, [pc, #196]	; (9df0 <bt_acl_recv+0x290>)
    9d2c:	f7f8 fa8c 	bl	2248 <z_impl_z_log_msg_static_create>
			bt_l2cap_recv(conn, conn->rx, false);
    9d30:	4632      	mov	r2, r6
    9d32:	6921      	ldr	r1, [r4, #16]
    9d34:	4620      	mov	r0, r4
    9d36:	f001 f867 	bl	ae08 <bt_l2cap_recv>
			conn->rx = NULL;
    9d3a:	6126      	str	r6, [r4, #16]
			net_buf_unref(buf);
    9d3c:	4628      	mov	r0, r5
    9d3e:	f010 fa14 	bl	1a16a <net_buf_unref>
			return;
    9d42:	e03c      	b.n	9dbe <bt_acl_recv+0x25e>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    9d44:	466e      	mov	r6, sp
    9d46:	b088      	sub	sp, #32
    9d48:	4669      	mov	r1, sp
    9d4a:	f111 0210 	adds.w	r2, r1, #16
    9d4e:	d039      	beq.n	9dc4 <bt_acl_recv+0x264>
    9d50:	200c      	movs	r0, #12
    9d52:	b12a      	cbz	r2, 9d60 <bt_acl_recv+0x200>
    9d54:	2804      	cmp	r0, #4
    9d56:	dd03      	ble.n	9d60 <bt_acl_recv+0x200>
    9d58:	f8df c0a4 	ldr.w	ip, [pc, #164]	; 9e00 <bt_acl_recv+0x2a0>
    9d5c:	f8c1 c014 	str.w	ip, [r1, #20]
    9d60:	b112      	cbz	r2, 9d68 <bt_acl_recv+0x208>
    9d62:	2808      	cmp	r0, #8
    9d64:	dd00      	ble.n	9d68 <bt_acl_recv+0x208>
    9d66:	618b      	str	r3, [r1, #24]
    9d68:	280b      	cmp	r0, #11
    9d6a:	dd2e      	ble.n	9dca <bt_acl_recv+0x26a>
    9d6c:	230c      	movs	r3, #12
    9d6e:	b13a      	cbz	r2, 9d80 <bt_acl_recv+0x220>
    9d70:	2003      	movs	r0, #3
    9d72:	7138      	strb	r0, [r7, #4]
    9d74:	2000      	movs	r0, #0
    9d76:	7178      	strb	r0, [r7, #5]
    9d78:	71b8      	strb	r0, [r7, #6]
    9d7a:	71f8      	strb	r0, [r7, #7]
    9d7c:	6878      	ldr	r0, [r7, #4]
    9d7e:	6108      	str	r0, [r1, #16]
    9d80:	2100      	movs	r1, #0
    9d82:	f36f 0100 	bfc	r1, #0, #1
    9d86:	f36f 0141 	bfc	r1, #1, #1
    9d8a:	f36f 0182 	bfc	r1, #2, #1
    9d8e:	f36f 01c5 	bfc	r1, #3, #3
    9d92:	2001      	movs	r0, #1
    9d94:	f360 1188 	bfi	r1, r0, #6, #3
    9d98:	f403 737b 	and.w	r3, r3, #1004	; 0x3ec
    9d9c:	f363 2152 	bfi	r1, r3, #9, #10
    9da0:	f36f 41de 	bfc	r1, #19, #12
    9da4:	f36f 71df 	bfc	r1, #31, #1
    9da8:	2300      	movs	r3, #0
    9daa:	4811      	ldr	r0, [pc, #68]	; (9df0 <bt_acl_recv+0x290>)
    9dac:	f7f8 fa4c 	bl	2248 <z_impl_z_log_msg_static_create>
    9db0:	46b5      	mov	sp, r6
		bt_conn_reset_rx_state(conn);
    9db2:	4620      	mov	r0, r4
    9db4:	f00e f910 	bl	17fd8 <bt_conn_reset_rx_state>
		net_buf_unref(buf);
    9db8:	4628      	mov	r0, r5
    9dba:	f010 f9d6 	bl	1a16a <net_buf_unref>
}
    9dbe:	3754      	adds	r7, #84	; 0x54
    9dc0:	46bd      	mov	sp, r7
    9dc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
    9dc4:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    9dc8:	e7c3      	b.n	9d52 <bt_acl_recv+0x1f2>
    9dca:	f06f 031b 	mvn.w	r3, #27
    9dce:	e7ce      	b.n	9d6e <bt_acl_recv+0x20e>
		BT_ERR("ACL len mismatch (%u > %u)",
    9dd0:	f06f 4600 	mvn.w	r6, #2147483648	; 0x80000000
    9dd4:	e710      	b.n	9bf8 <bt_acl_recv+0x98>
    9dd6:	f06f 031b 	mvn.w	r3, #27
    9dda:	e720      	b.n	9c1e <bt_acl_recv+0xbe>
	conn->rx = NULL;
    9ddc:	2300      	movs	r3, #0
    9dde:	6123      	str	r3, [r4, #16]
	bt_l2cap_recv(conn, buf, true);
    9de0:	2201      	movs	r2, #1
    9de2:	4620      	mov	r0, r4
    9de4:	f001 f810 	bl	ae08 <bt_l2cap_recv>
    9de8:	e7e9      	b.n	9dbe <bt_acl_recv+0x25e>
    9dea:	bf00      	nop
    9dec:	0001e990 	.word	0x0001e990
    9df0:	0001cfe4 	.word	0x0001cfe4
    9df4:	0001ea18 	.word	0x0001ea18
    9df8:	0001e9b0 	.word	0x0001e9b0
    9dfc:	0001e9d0 	.word	0x0001e9d0
    9e00:	0001e9f8 	.word	0x0001e9f8

00009e04 <bt_conn_send_cb>:
{
    9e04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9e08:	b094      	sub	sp, #80	; 0x50
    9e0a:	461f      	mov	r7, r3
	if (conn->state != BT_CONN_CONNECTED) {
    9e0c:	7a83      	ldrb	r3, [r0, #10]
    9e0e:	2b07      	cmp	r3, #7
    9e10:	d11b      	bne.n	9e4a <bt_conn_send_cb+0x46>
    9e12:	4604      	mov	r4, r0
    9e14:	460d      	mov	r5, r1
    9e16:	4616      	mov	r6, r2
	if (cb) {
    9e18:	2a00      	cmp	r2, #0
    9e1a:	f000 8090 	beq.w	9f3e <bt_conn_send_cb+0x13a>
		tx = conn_tx_alloc();
    9e1e:	f7ff fd75 	bl	990c <conn_tx_alloc>
		if (!tx) {
    9e22:	4680      	mov	r8, r0
    9e24:	2800      	cmp	r0, #0
    9e26:	d038      	beq.n	9e9a <bt_conn_send_cb+0x96>
		if (conn->state != BT_CONN_CONNECTED) {
    9e28:	7aa3      	ldrb	r3, [r4, #10]
    9e2a:	2b07      	cmp	r3, #7
    9e2c:	d15d      	bne.n	9eea <bt_conn_send_cb+0xe6>
		tx->cb = cb;
    9e2e:	6046      	str	r6, [r0, #4]
		tx->user_data = user_data;
    9e30:	6087      	str	r7, [r0, #8]
		tx->pending_no_cb = 0U;
    9e32:	2300      	movs	r3, #0
    9e34:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
    9e36:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
    9e38:	4629      	mov	r1, r5
    9e3a:	f104 0038 	add.w	r0, r4, #56	; 0x38
    9e3e:	f010 f986 	bl	1a14e <net_buf_put>
	return 0;
    9e42:	2000      	movs	r0, #0
}
    9e44:	b014      	add	sp, #80	; 0x50
    9e46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("not connected!");
    9e4a:	4b3e      	ldr	r3, [pc, #248]	; (9f44 <bt_conn_send_cb+0x140>)
    9e4c:	9313      	str	r3, [sp, #76]	; 0x4c
    9e4e:	2302      	movs	r3, #2
    9e50:	f88d 3004 	strb.w	r3, [sp, #4]
    9e54:	2300      	movs	r3, #0
    9e56:	f88d 3005 	strb.w	r3, [sp, #5]
    9e5a:	f88d 3006 	strb.w	r3, [sp, #6]
    9e5e:	f88d 3007 	strb.w	r3, [sp, #7]
    9e62:	9a01      	ldr	r2, [sp, #4]
    9e64:	9212      	str	r2, [sp, #72]	; 0x48
    9e66:	4619      	mov	r1, r3
    9e68:	f363 0100 	bfi	r1, r3, #0, #1
    9e6c:	f363 0141 	bfi	r1, r3, #1, #1
    9e70:	f363 0182 	bfi	r1, r3, #2, #1
    9e74:	f363 01c5 	bfi	r1, r3, #3, #3
    9e78:	2201      	movs	r2, #1
    9e7a:	f362 1188 	bfi	r1, r2, #6, #3
    9e7e:	2208      	movs	r2, #8
    9e80:	f362 2152 	bfi	r1, r2, #9, #10
    9e84:	f363 41de 	bfi	r1, r3, #19, #12
    9e88:	f363 71df 	bfi	r1, r3, #31, #1
    9e8c:	aa12      	add	r2, sp, #72	; 0x48
    9e8e:	482e      	ldr	r0, [pc, #184]	; (9f48 <bt_conn_send_cb+0x144>)
    9e90:	f7f8 f9da 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ENOTCONN;
    9e94:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    9e98:	e7d4      	b.n	9e44 <bt_conn_send_cb+0x40>
			BT_ERR("Unable to allocate TX context");
    9e9a:	4b2c      	ldr	r3, [pc, #176]	; (9f4c <bt_conn_send_cb+0x148>)
    9e9c:	930d      	str	r3, [sp, #52]	; 0x34
    9e9e:	2302      	movs	r3, #2
    9ea0:	f88d 3004 	strb.w	r3, [sp, #4]
    9ea4:	2300      	movs	r3, #0
    9ea6:	f88d 3005 	strb.w	r3, [sp, #5]
    9eaa:	f88d 3006 	strb.w	r3, [sp, #6]
    9eae:	f88d 3007 	strb.w	r3, [sp, #7]
    9eb2:	9a01      	ldr	r2, [sp, #4]
    9eb4:	920c      	str	r2, [sp, #48]	; 0x30
    9eb6:	4619      	mov	r1, r3
    9eb8:	f363 0100 	bfi	r1, r3, #0, #1
    9ebc:	f363 0141 	bfi	r1, r3, #1, #1
    9ec0:	f363 0182 	bfi	r1, r3, #2, #1
    9ec4:	f363 01c5 	bfi	r1, r3, #3, #3
    9ec8:	2201      	movs	r2, #1
    9eca:	f362 1188 	bfi	r1, r2, #6, #3
    9ece:	2208      	movs	r2, #8
    9ed0:	f362 2152 	bfi	r1, r2, #9, #10
    9ed4:	f363 41de 	bfi	r1, r3, #19, #12
    9ed8:	f363 71df 	bfi	r1, r3, #31, #1
    9edc:	aa0c      	add	r2, sp, #48	; 0x30
    9ede:	481a      	ldr	r0, [pc, #104]	; (9f48 <bt_conn_send_cb+0x144>)
    9ee0:	f7f8 f9b2 	bl	2248 <z_impl_z_log_msg_static_create>
			return -ENOBUFS;
    9ee4:	f06f 0068 	mvn.w	r0, #104	; 0x68
    9ee8:	e7ac      	b.n	9e44 <bt_conn_send_cb+0x40>
			BT_WARN("Disconnected while allocating context");
    9eea:	4b19      	ldr	r3, [pc, #100]	; (9f50 <bt_conn_send_cb+0x14c>)
    9eec:	9307      	str	r3, [sp, #28]
    9eee:	2202      	movs	r2, #2
    9ef0:	f88d 2004 	strb.w	r2, [sp, #4]
    9ef4:	2300      	movs	r3, #0
    9ef6:	f88d 3005 	strb.w	r3, [sp, #5]
    9efa:	f88d 3006 	strb.w	r3, [sp, #6]
    9efe:	f88d 3007 	strb.w	r3, [sp, #7]
    9f02:	9901      	ldr	r1, [sp, #4]
    9f04:	9106      	str	r1, [sp, #24]
    9f06:	4619      	mov	r1, r3
    9f08:	f363 0100 	bfi	r1, r3, #0, #1
    9f0c:	f363 0141 	bfi	r1, r3, #1, #1
    9f10:	f363 0182 	bfi	r1, r3, #2, #1
    9f14:	f363 01c5 	bfi	r1, r3, #3, #3
    9f18:	f362 1188 	bfi	r1, r2, #6, #3
    9f1c:	2208      	movs	r2, #8
    9f1e:	f362 2152 	bfi	r1, r2, #9, #10
    9f22:	f363 41de 	bfi	r1, r3, #19, #12
    9f26:	f363 71df 	bfi	r1, r3, #31, #1
    9f2a:	aa06      	add	r2, sp, #24
    9f2c:	4806      	ldr	r0, [pc, #24]	; (9f48 <bt_conn_send_cb+0x144>)
    9f2e:	f7f8 f98b 	bl	2248 <z_impl_z_log_msg_static_create>
			tx_free(tx);
    9f32:	4640      	mov	r0, r8
    9f34:	f7ff fcde 	bl	98f4 <tx_free>
			return -ENOTCONN;
    9f38:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    9f3c:	e782      	b.n	9e44 <bt_conn_send_cb+0x40>
		tx_data(buf)->tx = NULL;
    9f3e:	2300      	movs	r3, #0
    9f40:	614b      	str	r3, [r1, #20]
    9f42:	e779      	b.n	9e38 <bt_conn_send_cb+0x34>
    9f44:	0001ea34 	.word	0x0001ea34
    9f48:	0001cfe4 	.word	0x0001cfe4
    9f4c:	0001ea44 	.word	0x0001ea44
    9f50:	0001ea64 	.word	0x0001ea64

00009f54 <bt_conn_prepare_events>:
{
    9f54:	b570      	push	{r4, r5, r6, lr}
    9f56:	4606      	mov	r6, r0
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_POLL_SIGNAL_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_init(sig);
    9f58:	4c0e      	ldr	r4, [pc, #56]	; (9f94 <bt_conn_prepare_events+0x40>)
    9f5a:	4620      	mov	r0, r4
    9f5c:	f012 fdc7 	bl	1caee <z_impl_k_poll_signal_init>
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
    9f60:	4623      	mov	r3, r4
    9f62:	2200      	movs	r2, #0
    9f64:	2101      	movs	r1, #1
    9f66:	4630      	mov	r0, r6
    9f68:	f012 fd99 	bl	1ca9e <k_poll_event_init>
    9f6c:	2501      	movs	r5, #1
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
    9f6e:	2400      	movs	r4, #0
    9f70:	b10c      	cbz	r4, 9f76 <bt_conn_prepare_events+0x22>
}
    9f72:	4628      	mov	r0, r5
    9f74:	bd70      	pop	{r4, r5, r6, pc}
		conn = &acl_conns[i];
    9f76:	eb04 0044 	add.w	r0, r4, r4, lsl #1
		if (!conn_prepare_events(conn, &events[ev_count])) {
    9f7a:	eb05 0185 	add.w	r1, r5, r5, lsl #2
    9f7e:	eb06 0181 	add.w	r1, r6, r1, lsl #2
    9f82:	4b05      	ldr	r3, [pc, #20]	; (9f98 <bt_conn_prepare_events+0x44>)
    9f84:	eb03 1080 	add.w	r0, r3, r0, lsl #6
    9f88:	f00e f850 	bl	1802c <conn_prepare_events>
    9f8c:	b900      	cbnz	r0, 9f90 <bt_conn_prepare_events+0x3c>
			ev_count++;
    9f8e:	3501      	adds	r5, #1
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
    9f90:	3401      	adds	r4, #1
    9f92:	e7ed      	b.n	9f70 <bt_conn_prepare_events+0x1c>
    9f94:	20000264 	.word	0x20000264
    9f98:	200017d8 	.word	0x200017d8

00009f9c <bt_conn_lookup_handle>:
{
    9f9c:	b508      	push	{r3, lr}
    9f9e:	4602      	mov	r2, r0
	conn = conn_lookup_handle(acl_conns, ARRAY_SIZE(acl_conns), handle);
    9fa0:	2101      	movs	r1, #1
    9fa2:	4802      	ldr	r0, [pc, #8]	; (9fac <bt_conn_lookup_handle+0x10>)
    9fa4:	f00e f8af 	bl	18106 <conn_lookup_handle>
}
    9fa8:	bd08      	pop	{r3, pc}
    9faa:	bf00      	nop
    9fac:	200017d8 	.word	0x200017d8

00009fb0 <bt_conn_set_state>:
{
    9fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
    9fb2:	b083      	sub	sp, #12
    9fb4:	af00      	add	r7, sp, #0
    9fb6:	460d      	mov	r5, r1
	if (conn->state == state) {
    9fb8:	7a86      	ldrb	r6, [r0, #10]
    9fba:	428e      	cmp	r6, r1
    9fbc:	d014      	beq.n	9fe8 <bt_conn_set_state+0x38>
    9fbe:	4604      	mov	r4, r0
	conn->state = state;
    9fc0:	7281      	strb	r1, [r0, #10]
	switch (old_state) {
    9fc2:	b916      	cbnz	r6, 9fca <bt_conn_set_state+0x1a>
		if (conn->type != BT_CONN_TYPE_ISO) {
    9fc4:	7883      	ldrb	r3, [r0, #2]
    9fc6:	2b08      	cmp	r3, #8
    9fc8:	d17c      	bne.n	a0c4 <bt_conn_set_state+0x114>
	switch (conn->state) {
    9fca:	7aa3      	ldrb	r3, [r4, #10]
    9fcc:	2b08      	cmp	r3, #8
    9fce:	f200 812b 	bhi.w	a228 <bt_conn_set_state+0x278>
    9fd2:	e8df f013 	tbh	[pc, r3, lsl #1]
    9fd6:	0093      	.short	0x0093
    9fd8:	00530125 	.word	0x00530125
    9fdc:	00530053 	.word	0x00530053
    9fe0:	00530053 	.word	0x00530053
    9fe4:	0053007a 	.word	0x0053007a
	switch (state) {
    9fe8:	2908      	cmp	r1, #8
    9fea:	d858      	bhi.n	a09e <bt_conn_set_state+0xee>
    9fec:	e8df f001 	tbb	[pc, r1]
    9ff0:	4f495905 	.word	0x4f495905
    9ff4:	53514b4d 	.word	0x53514b4d
    9ff8:	55          	.byte	0x55
    9ff9:	00          	.byte	0x00
    9ffa:	48a9      	ldr	r0, [pc, #676]	; (a2a0 <bt_conn_set_state+0x2f0>)
		BT_WARN("no transition %s", state2str(state));
    9ffc:	2302      	movs	r3, #2
    9ffe:	713b      	strb	r3, [r7, #4]
    a000:	466c      	mov	r4, sp
    a002:	b088      	sub	sp, #32
    a004:	466b      	mov	r3, sp
    a006:	f113 0210 	adds.w	r2, r3, #16
    a00a:	d04c      	beq.n	a0a6 <bt_conn_set_state+0xf6>
    a00c:	250d      	movs	r5, #13
    a00e:	b11a      	cbz	r2, a018 <bt_conn_set_state+0x68>
    a010:	2d04      	cmp	r5, #4
    a012:	dd01      	ble.n	a018 <bt_conn_set_state+0x68>
    a014:	49a3      	ldr	r1, [pc, #652]	; (a2a4 <bt_conn_set_state+0x2f4>)
    a016:	6159      	str	r1, [r3, #20]
    a018:	2102      	movs	r1, #2
    a01a:	7039      	strb	r1, [r7, #0]
    a01c:	b112      	cbz	r2, a024 <bt_conn_set_state+0x74>
    a01e:	2d08      	cmp	r5, #8
    a020:	dd00      	ble.n	a024 <bt_conn_set_state+0x74>
    a022:	6198      	str	r0, [r3, #24]
    a024:	b122      	cbz	r2, a030 <bt_conn_set_state+0x80>
    a026:	f103 011c 	add.w	r1, r3, #28
    a02a:	2000      	movs	r0, #0
    a02c:	2800      	cmp	r0, #0
    a02e:	d03d      	beq.n	a0ac <bt_conn_set_state+0xfc>
    a030:	2d0c      	cmp	r5, #12
    a032:	dd44      	ble.n	a0be <bt_conn_set_state+0x10e>
    a034:	250d      	movs	r5, #13
    a036:	b142      	cbz	r2, a04a <bt_conn_set_state+0x9a>
    a038:	2103      	movs	r1, #3
    a03a:	7139      	strb	r1, [r7, #4]
    a03c:	2100      	movs	r1, #0
    a03e:	7179      	strb	r1, [r7, #5]
    a040:	71b9      	strb	r1, [r7, #6]
    a042:	2101      	movs	r1, #1
    a044:	71f9      	strb	r1, [r7, #7]
    a046:	6878      	ldr	r0, [r7, #4]
    a048:	6118      	str	r0, [r3, #16]
    a04a:	2100      	movs	r1, #0
    a04c:	f36f 0100 	bfc	r1, #0, #1
    a050:	f36f 0141 	bfc	r1, #1, #1
    a054:	f36f 0182 	bfc	r1, #2, #1
    a058:	f36f 01c5 	bfc	r1, #3, #3
    a05c:	2302      	movs	r3, #2
    a05e:	f363 1188 	bfi	r1, r3, #6, #3
    a062:	f3c5 0309 	ubfx	r3, r5, #0, #10
    a066:	f363 2152 	bfi	r1, r3, #9, #10
    a06a:	f36f 41de 	bfc	r1, #19, #12
    a06e:	f36f 71df 	bfc	r1, #31, #1
    a072:	2300      	movs	r3, #0
    a074:	488c      	ldr	r0, [pc, #560]	; (a2a8 <bt_conn_set_state+0x2f8>)
    a076:	f7f8 f8e7 	bl	2248 <z_impl_z_log_msg_static_create>
    a07a:	46a5      	mov	sp, r4
}
    a07c:	370c      	adds	r7, #12
    a07e:	46bd      	mov	sp, r7
    a080:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return "connecting-scan";
    a082:	488a      	ldr	r0, [pc, #552]	; (a2ac <bt_conn_set_state+0x2fc>)
    a084:	e7ba      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "connecting-dir-adv";
    a086:	488a      	ldr	r0, [pc, #552]	; (a2b0 <bt_conn_set_state+0x300>)
    a088:	e7b8      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "connecting-adv";
    a08a:	488a      	ldr	r0, [pc, #552]	; (a2b4 <bt_conn_set_state+0x304>)
    a08c:	e7b6      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "connecting-auto";
    a08e:	488a      	ldr	r0, [pc, #552]	; (a2b8 <bt_conn_set_state+0x308>)
    a090:	e7b4      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "connecting";
    a092:	488a      	ldr	r0, [pc, #552]	; (a2bc <bt_conn_set_state+0x30c>)
    a094:	e7b2      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "connected";
    a096:	488a      	ldr	r0, [pc, #552]	; (a2c0 <bt_conn_set_state+0x310>)
    a098:	e7b0      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "disconnecting";
    a09a:	488a      	ldr	r0, [pc, #552]	; (a2c4 <bt_conn_set_state+0x314>)
    a09c:	e7ae      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "(unknown)";
    a09e:	488a      	ldr	r0, [pc, #552]	; (a2c8 <bt_conn_set_state+0x318>)
    a0a0:	e7ac      	b.n	9ffc <bt_conn_set_state+0x4c>
		return "disconnect-complete";
    a0a2:	488a      	ldr	r0, [pc, #552]	; (a2cc <bt_conn_set_state+0x31c>)
    a0a4:	e7aa      	b.n	9ffc <bt_conn_set_state+0x4c>
		BT_WARN("no transition %s", state2str(state));
    a0a6:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    a0aa:	e7b0      	b.n	a00e <bt_conn_set_state+0x5e>
    a0ac:	f107 0608 	add.w	r6, r7, #8
    a0b0:	4406      	add	r6, r0
    a0b2:	f816 6c08 	ldrb.w	r6, [r6, #-8]
    a0b6:	f801 6b01 	strb.w	r6, [r1], #1
    a0ba:	3001      	adds	r0, #1
    a0bc:	e7b6      	b.n	a02c <bt_conn_set_state+0x7c>
    a0be:	f06f 051b 	mvn.w	r5, #27
    a0c2:	e7b8      	b.n	a036 <bt_conn_set_state+0x86>
			bt_conn_ref(conn);
    a0c4:	f00d ffed 	bl	180a2 <bt_conn_ref>
    a0c8:	e77f      	b.n	9fca <bt_conn_set_state+0x1a>
		if (conn->type == BT_CONN_TYPE_SCO) {
    a0ca:	78a3      	ldrb	r3, [r4, #2]
    a0cc:	2b04      	cmp	r3, #4
    a0ce:	d0d5      	beq.n	a07c <bt_conn_set_state+0xcc>
		k_fifo_init(&conn->tx_queue);
    a0d0:	f104 0038 	add.w	r0, r4, #56	; 0x38
	z_impl_k_queue_init(queue);
    a0d4:	f012 f83c 	bl	1c150 <z_impl_k_queue_init>
		union { uintptr_t x; int val; } parm1 = { .val = result };
		return (int) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    a0d8:	2100      	movs	r1, #0
    a0da:	487d      	ldr	r0, [pc, #500]	; (a2d0 <bt_conn_set_state+0x320>)
    a0dc:	f00b f87e 	bl	151dc <z_impl_k_poll_signal_raise>
	list->head = NULL;
    a0e0:	2300      	movs	r3, #0
    a0e2:	6523      	str	r3, [r4, #80]	; 0x50
	list->tail = NULL;
    a0e4:	6563      	str	r3, [r4, #84]	; 0x54
		    conn->role == BT_CONN_ROLE_PERIPHERAL) {
    a0e6:	78e3      	ldrb	r3, [r4, #3]
		if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
    a0e8:	2b01      	cmp	r3, #1
    a0ea:	d1c7      	bne.n	a07c <bt_conn_set_state+0xcc>
			k_work_schedule(&conn->deferred_work,
    a0ec:	f44f 3220 	mov.w	r2, #163840	; 0x28000
    a0f0:	2300      	movs	r3, #0
    a0f2:	f104 0058 	add.w	r0, r4, #88	; 0x58
    a0f6:	f009 ff59 	bl	13fac <k_work_schedule>
    a0fa:	e7bf      	b.n	a07c <bt_conn_set_state+0xcc>
		if (conn->type == BT_CONN_TYPE_SCO) {
    a0fc:	78a3      	ldrb	r3, [r4, #2]
    a0fe:	2b04      	cmp	r3, #4
    a100:	d008      	beq.n	a114 <bt_conn_set_state+0x164>
		switch (old_state) {
    a102:	2e08      	cmp	r6, #8
    a104:	d8ba      	bhi.n	a07c <bt_conn_set_state+0xcc>
    a106:	e8df f006 	tbb	[pc, r6]
    a10a:	094f      	.short	0x094f
    a10c:	3d4b4733 	.word	0x3d4b4733
    a110:	4f29      	.short	0x4f29
    a112:	4f          	.byte	0x4f
    a113:	00          	.byte	0x00
			bt_conn_unref(conn);
    a114:	4620      	mov	r0, r4
    a116:	f00d ffe1 	bl	180dc <bt_conn_unref>
			break;
    a11a:	e7af      	b.n	a07c <bt_conn_set_state+0xcc>
			tx_notify(conn);
    a11c:	4620      	mov	r0, r4
    a11e:	f00d fec2 	bl	17ea6 <tx_notify>
			if ((conn->type == BT_CONN_TYPE_LE) &&
    a122:	78a3      	ldrb	r3, [r4, #2]
    a124:	2b01      	cmp	r3, #1
    a126:	d00d      	beq.n	a144 <bt_conn_set_state+0x194>
			atomic_set_bit(conn->flags, BT_CONN_CLEANUP);
    a128:	3404      	adds	r4, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a12a:	e8d4 3fef 	ldaex	r3, [r4]
    a12e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    a132:	e8c4 3fe2 	stlex	r2, r3, [r4]
    a136:	2a00      	cmp	r2, #0
    a138:	d1f7      	bne.n	a12a <bt_conn_set_state+0x17a>
    a13a:	2100      	movs	r1, #0
    a13c:	4864      	ldr	r0, [pc, #400]	; (a2d0 <bt_conn_set_state+0x320>)
    a13e:	f00b f84d 	bl	151dc <z_impl_k_poll_signal_raise>
    a142:	e79b      	b.n	a07c <bt_conn_set_state+0xcc>
			    (k_work_delayable_busy_get(&conn->deferred_work) &
    a144:	f104 0558 	add.w	r5, r4, #88	; 0x58
    a148:	4628      	mov	r0, r5
    a14a:	f012 f923 	bl	1c394 <k_work_delayable_busy_get>
			if ((conn->type == BT_CONN_TYPE_LE) &&
    a14e:	f010 0f0c 	tst.w	r0, #12
    a152:	d0e9      	beq.n	a128 <bt_conn_set_state+0x178>
				k_work_cancel_delayable(&conn->deferred_work);
    a154:	4628      	mov	r0, r5
    a156:	f012 f96d 	bl	1c434 <k_work_cancel_delayable>
    a15a:	e7e5      	b.n	a128 <bt_conn_set_state+0x178>
			if (conn->err) {
    a15c:	7a63      	ldrb	r3, [r4, #9]
    a15e:	b91b      	cbnz	r3, a168 <bt_conn_set_state+0x1b8>
			bt_conn_unref(conn);
    a160:	4620      	mov	r0, r4
    a162:	f00d ffbb 	bl	180dc <bt_conn_unref>
			break;
    a166:	e789      	b.n	a07c <bt_conn_set_state+0xcc>
				notify_connected(conn);
    a168:	4620      	mov	r0, r4
    a16a:	f7ff fb7f 	bl	986c <notify_connected>
    a16e:	e7f7      	b.n	a160 <bt_conn_set_state+0x1b0>
			if (conn->err) {
    a170:	7a63      	ldrb	r3, [r4, #9]
    a172:	b91b      	cbnz	r3, a17c <bt_conn_set_state+0x1cc>
			bt_conn_unref(conn);
    a174:	4620      	mov	r0, r4
    a176:	f00d ffb1 	bl	180dc <bt_conn_unref>
			break;
    a17a:	e77f      	b.n	a07c <bt_conn_set_state+0xcc>
				notify_connected(conn);
    a17c:	4620      	mov	r0, r4
    a17e:	f7ff fb75 	bl	986c <notify_connected>
    a182:	e7f7      	b.n	a174 <bt_conn_set_state+0x1c4>
			if (conn->err) {
    a184:	7a63      	ldrb	r3, [r4, #9]
    a186:	b91b      	cbnz	r3, a190 <bt_conn_set_state+0x1e0>
			bt_conn_unref(conn);
    a188:	4620      	mov	r0, r4
    a18a:	f00d ffa7 	bl	180dc <bt_conn_unref>
			break;
    a18e:	e775      	b.n	a07c <bt_conn_set_state+0xcc>
				notify_connected(conn);
    a190:	4620      	mov	r0, r4
    a192:	f7ff fb6b 	bl	986c <notify_connected>
    a196:	e7f7      	b.n	a188 <bt_conn_set_state+0x1d8>
			bt_conn_unref(conn);
    a198:	4620      	mov	r0, r4
    a19a:	f00d ff9f 	bl	180dc <bt_conn_unref>
			break;
    a19e:	e76d      	b.n	a07c <bt_conn_set_state+0xcc>
			bt_conn_unref(conn);
    a1a0:	4620      	mov	r0, r4
    a1a2:	f00d ff9b 	bl	180dc <bt_conn_unref>
			break;
    a1a6:	e769      	b.n	a07c <bt_conn_set_state+0xcc>
			BT_WARN("Invalid (%u) old state", state);
    a1a8:	466e      	mov	r6, sp
    a1aa:	b088      	sub	sp, #32
    a1ac:	466b      	mov	r3, sp
    a1ae:	f113 0210 	adds.w	r2, r3, #16
    a1b2:	d02f      	beq.n	a214 <bt_conn_set_state+0x264>
    a1b4:	210c      	movs	r1, #12
    a1b6:	b11a      	cbz	r2, a1c0 <bt_conn_set_state+0x210>
    a1b8:	2904      	cmp	r1, #4
    a1ba:	dd01      	ble.n	a1c0 <bt_conn_set_state+0x210>
    a1bc:	4845      	ldr	r0, [pc, #276]	; (a2d4 <bt_conn_set_state+0x324>)
    a1be:	6158      	str	r0, [r3, #20]
    a1c0:	b112      	cbz	r2, a1c8 <bt_conn_set_state+0x218>
    a1c2:	2908      	cmp	r1, #8
    a1c4:	dd00      	ble.n	a1c8 <bt_conn_set_state+0x218>
    a1c6:	619d      	str	r5, [r3, #24]
    a1c8:	290b      	cmp	r1, #11
    a1ca:	dd26      	ble.n	a21a <bt_conn_set_state+0x26a>
    a1cc:	240c      	movs	r4, #12
    a1ce:	b13a      	cbz	r2, a1e0 <bt_conn_set_state+0x230>
    a1d0:	2103      	movs	r1, #3
    a1d2:	7139      	strb	r1, [r7, #4]
    a1d4:	2100      	movs	r1, #0
    a1d6:	7179      	strb	r1, [r7, #5]
    a1d8:	71b9      	strb	r1, [r7, #6]
    a1da:	71f9      	strb	r1, [r7, #7]
    a1dc:	6878      	ldr	r0, [r7, #4]
    a1de:	6118      	str	r0, [r3, #16]
    a1e0:	2100      	movs	r1, #0
    a1e2:	f36f 0100 	bfc	r1, #0, #1
    a1e6:	f36f 0141 	bfc	r1, #1, #1
    a1ea:	f36f 0182 	bfc	r1, #2, #1
    a1ee:	f36f 01c5 	bfc	r1, #3, #3
    a1f2:	2302      	movs	r3, #2
    a1f4:	f363 1188 	bfi	r1, r3, #6, #3
    a1f8:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    a1fc:	f363 2152 	bfi	r1, r3, #9, #10
    a200:	f36f 41de 	bfc	r1, #19, #12
    a204:	f36f 71df 	bfc	r1, #31, #1
    a208:	2300      	movs	r3, #0
    a20a:	4827      	ldr	r0, [pc, #156]	; (a2a8 <bt_conn_set_state+0x2f8>)
    a20c:	f7f8 f81c 	bl	2248 <z_impl_z_log_msg_static_create>
    a210:	46b5      	mov	sp, r6
    a212:	e733      	b.n	a07c <bt_conn_set_state+0xcc>
    a214:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    a218:	e7cd      	b.n	a1b6 <bt_conn_set_state+0x206>
    a21a:	f06f 041b 	mvn.w	r4, #27
    a21e:	e7d6      	b.n	a1ce <bt_conn_set_state+0x21e>
		process_unack_tx(conn);
    a220:	4620      	mov	r0, r4
    a222:	f00d fe97 	bl	17f54 <process_unack_tx>
		break;
    a226:	e729      	b.n	a07c <bt_conn_set_state+0xcc>
		BT_WARN("no valid (%u) state was set", state);
    a228:	466e      	mov	r6, sp
    a22a:	b088      	sub	sp, #32
    a22c:	466b      	mov	r3, sp
    a22e:	f113 0210 	adds.w	r2, r3, #16
    a232:	d130      	bne.n	a296 <bt_conn_set_state+0x2e6>
    a234:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    a238:	b11a      	cbz	r2, a242 <bt_conn_set_state+0x292>
    a23a:	2904      	cmp	r1, #4
    a23c:	dd01      	ble.n	a242 <bt_conn_set_state+0x292>
    a23e:	4826      	ldr	r0, [pc, #152]	; (a2d8 <bt_conn_set_state+0x328>)
    a240:	6158      	str	r0, [r3, #20]
    a242:	b112      	cbz	r2, a24a <bt_conn_set_state+0x29a>
    a244:	2908      	cmp	r1, #8
    a246:	dd00      	ble.n	a24a <bt_conn_set_state+0x29a>
    a248:	619d      	str	r5, [r3, #24]
    a24a:	290b      	cmp	r1, #11
    a24c:	dd25      	ble.n	a29a <bt_conn_set_state+0x2ea>
    a24e:	240c      	movs	r4, #12
    a250:	b13a      	cbz	r2, a262 <bt_conn_set_state+0x2b2>
    a252:	2103      	movs	r1, #3
    a254:	7139      	strb	r1, [r7, #4]
    a256:	2100      	movs	r1, #0
    a258:	7179      	strb	r1, [r7, #5]
    a25a:	71b9      	strb	r1, [r7, #6]
    a25c:	71f9      	strb	r1, [r7, #7]
    a25e:	6878      	ldr	r0, [r7, #4]
    a260:	6118      	str	r0, [r3, #16]
    a262:	2100      	movs	r1, #0
    a264:	f36f 0100 	bfc	r1, #0, #1
    a268:	f36f 0141 	bfc	r1, #1, #1
    a26c:	f36f 0182 	bfc	r1, #2, #1
    a270:	f36f 01c5 	bfc	r1, #3, #3
    a274:	2302      	movs	r3, #2
    a276:	f363 1188 	bfi	r1, r3, #6, #3
    a27a:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    a27e:	f364 2152 	bfi	r1, r4, #9, #10
    a282:	f36f 41de 	bfc	r1, #19, #12
    a286:	f36f 71df 	bfc	r1, #31, #1
    a28a:	2300      	movs	r3, #0
    a28c:	4806      	ldr	r0, [pc, #24]	; (a2a8 <bt_conn_set_state+0x2f8>)
    a28e:	f7f7 ffdb 	bl	2248 <z_impl_z_log_msg_static_create>
    a292:	46b5      	mov	sp, r6
    a294:	e6f2      	b.n	a07c <bt_conn_set_state+0xcc>
    a296:	210c      	movs	r1, #12
    a298:	e7ce      	b.n	a238 <bt_conn_set_state+0x288>
    a29a:	f06f 041b 	mvn.w	r4, #27
    a29e:	e7d7      	b.n	a250 <bt_conn_set_state+0x2a0>
    a2a0:	0001eb0c 	.word	0x0001eb0c
    a2a4:	0001eb1c 	.word	0x0001eb1c
    a2a8:	0001cfe4 	.word	0x0001cfe4
    a2ac:	0001eaac 	.word	0x0001eaac
    a2b0:	0001eabc 	.word	0x0001eabc
    a2b4:	0001ead0 	.word	0x0001ead0
    a2b8:	0001eae0 	.word	0x0001eae0
    a2bc:	0001eaf0 	.word	0x0001eaf0
    a2c0:	0001eda4 	.word	0x0001eda4
    a2c4:	0001eafc 	.word	0x0001eafc
    a2c8:	0001ea8c 	.word	0x0001ea8c
    a2cc:	0001ea98 	.word	0x0001ea98
    a2d0:	20000264 	.word	0x20000264
    a2d4:	0001eb30 	.word	0x0001eb30
    a2d8:	0001eb48 	.word	0x0001eb48

0000a2dc <bt_conn_index>:
		index = conn - acl_conns;
    a2dc:	4b03      	ldr	r3, [pc, #12]	; (a2ec <bt_conn_index+0x10>)
    a2de:	1ac0      	subs	r0, r0, r3
    a2e0:	1180      	asrs	r0, r0, #6
    a2e2:	4b03      	ldr	r3, [pc, #12]	; (a2f0 <bt_conn_index+0x14>)
    a2e4:	fb03 f000 	mul.w	r0, r3, r0
}
    a2e8:	b2c0      	uxtb	r0, r0
    a2ea:	4770      	bx	lr
    a2ec:	200017d8 	.word	0x200017d8
    a2f0:	aaaaaaab 	.word	0xaaaaaaab

0000a2f4 <bt_conn_create_pdu_timeout>:
{
    a2f4:	b530      	push	{r4, r5, lr}
    a2f6:	b089      	sub	sp, #36	; 0x24
    a2f8:	460c      	mov	r4, r1
	if (!pool) {
    a2fa:	4601      	mov	r1, r0
    a2fc:	b158      	cbz	r0, a316 <bt_conn_create_pdu_timeout+0x22>
	return net_buf_alloc_fixed(pool, timeout);
    a2fe:	4608      	mov	r0, r1
    a300:	f00f fea0 	bl	1a044 <net_buf_alloc_fixed>
	if (!buf) {
    a304:	4605      	mov	r5, r0
    a306:	b140      	cbz	r0, a31a <bt_conn_create_pdu_timeout+0x26>
	net_buf_simple_reserve(&buf->b, reserve);
    a308:	1d61      	adds	r1, r4, #5
    a30a:	3008      	adds	r0, #8
    a30c:	f00f fec2 	bl	1a094 <net_buf_simple_reserve>
}
    a310:	4628      	mov	r0, r5
    a312:	b009      	add	sp, #36	; 0x24
    a314:	bd30      	pop	{r4, r5, pc}
		pool = &acl_tx_pool;
    a316:	4913      	ldr	r1, [pc, #76]	; (a364 <bt_conn_create_pdu_timeout+0x70>)
    a318:	e7f1      	b.n	a2fe <bt_conn_create_pdu_timeout+0xa>
		BT_WARN("Unable to allocate buffer within timeout");
    a31a:	4b13      	ldr	r3, [pc, #76]	; (a368 <bt_conn_create_pdu_timeout+0x74>)
    a31c:	9307      	str	r3, [sp, #28]
    a31e:	2202      	movs	r2, #2
    a320:	f88d 2004 	strb.w	r2, [sp, #4]
    a324:	2300      	movs	r3, #0
    a326:	f88d 3005 	strb.w	r3, [sp, #5]
    a32a:	f88d 3006 	strb.w	r3, [sp, #6]
    a32e:	f88d 3007 	strb.w	r3, [sp, #7]
    a332:	9901      	ldr	r1, [sp, #4]
    a334:	9106      	str	r1, [sp, #24]
    a336:	4619      	mov	r1, r3
    a338:	f363 0100 	bfi	r1, r3, #0, #1
    a33c:	f363 0141 	bfi	r1, r3, #1, #1
    a340:	f363 0182 	bfi	r1, r3, #2, #1
    a344:	f363 01c5 	bfi	r1, r3, #3, #3
    a348:	f362 1188 	bfi	r1, r2, #6, #3
    a34c:	2208      	movs	r2, #8
    a34e:	f362 2152 	bfi	r1, r2, #9, #10
    a352:	f363 41de 	bfi	r1, r3, #19, #12
    a356:	f363 71df 	bfi	r1, r3, #31, #1
    a35a:	aa06      	add	r2, sp, #24
    a35c:	4803      	ldr	r0, [pc, #12]	; (a36c <bt_conn_create_pdu_timeout+0x78>)
    a35e:	f7f7 ff73 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    a362:	e7d5      	b.n	a310 <bt_conn_create_pdu_timeout+0x1c>
    a364:	200006b0 	.word	0x200006b0
    a368:	0001eb64 	.word	0x0001eb64
    a36c:	0001cfe4 	.word	0x0001cfe4

0000a370 <notify_le_param_updated>:
{
    a370:	b570      	push	{r4, r5, r6, lr}
    a372:	4604      	mov	r4, r0
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
    a374:	1d03      	adds	r3, r0, #4
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    a376:	e8d3 2faf 	lda	r2, [r3]
    a37a:	f412 7f80 	tst.w	r2, #256	; 0x100
    a37e:	d00f      	beq.n	a3a0 <notify_le_param_updated+0x30>
	    conn->le.interval >= conn->le.interval_min &&
    a380:	f8b0 209e 	ldrh.w	r2, [r0, #158]	; 0x9e
    a384:	f8b0 10a0 	ldrh.w	r1, [r0, #160]	; 0xa0
	if (atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_SET) &&
    a388:	428a      	cmp	r2, r1
    a38a:	d309      	bcc.n	a3a0 <notify_le_param_updated+0x30>
	    conn->le.interval <= conn->le.interval_max &&
    a38c:	f8b0 10a2 	ldrh.w	r1, [r0, #162]	; 0xa2
	    conn->le.interval >= conn->le.interval_min &&
    a390:	428a      	cmp	r2, r1
    a392:	d805      	bhi.n	a3a0 <notify_le_param_updated+0x30>
	    conn->le.latency == conn->le.pending_latency &&
    a394:	f8d0 10a4 	ldr.w	r1, [r0, #164]	; 0xa4
    a398:	f8d0 20a8 	ldr.w	r2, [r0, #168]	; 0xa8
    a39c:	4291      	cmp	r1, r2
    a39e:	d002      	beq.n	a3a6 <notify_le_param_updated+0x36>
	for (cb = callback_list; cb; cb = cb->_next) {
    a3a0:	4b16      	ldr	r3, [pc, #88]	; (a3fc <notify_le_param_updated+0x8c>)
    a3a2:	681d      	ldr	r5, [r3, #0]
    a3a4:	e011      	b.n	a3ca <notify_le_param_updated+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    a3a6:	e8d3 2fef 	ldaex	r2, [r3]
    a3aa:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    a3ae:	e8c3 2fe1 	stlex	r1, r2, [r3]
    a3b2:	2900      	cmp	r1, #0
    a3b4:	d0f4      	beq.n	a3a0 <notify_le_param_updated+0x30>
    a3b6:	e7f6      	b.n	a3a6 <notify_le_param_updated+0x36>
			cb->le_param_updated(conn, conn->le.interval,
    a3b8:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
    a3bc:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
    a3c0:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
    a3c4:	4620      	mov	r0, r4
    a3c6:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
    a3c8:	692d      	ldr	r5, [r5, #16]
    a3ca:	b11d      	cbz	r5, a3d4 <notify_le_param_updated+0x64>
		if (cb->le_param_updated) {
    a3cc:	68ee      	ldr	r6, [r5, #12]
    a3ce:	2e00      	cmp	r6, #0
    a3d0:	d1f2      	bne.n	a3b8 <notify_le_param_updated+0x48>
    a3d2:	e7f9      	b.n	a3c8 <notify_le_param_updated+0x58>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    a3d4:	4d0a      	ldr	r5, [pc, #40]	; (a400 <notify_le_param_updated+0x90>)
    a3d6:	e000      	b.n	a3da <notify_le_param_updated+0x6a>
    a3d8:	3514      	adds	r5, #20
    a3da:	4b0a      	ldr	r3, [pc, #40]	; (a404 <notify_le_param_updated+0x94>)
    a3dc:	429d      	cmp	r5, r3
    a3de:	d20b      	bcs.n	a3f8 <notify_le_param_updated+0x88>
		if (cb->le_param_updated) {
    a3e0:	68ee      	ldr	r6, [r5, #12]
    a3e2:	2e00      	cmp	r6, #0
    a3e4:	d0f8      	beq.n	a3d8 <notify_le_param_updated+0x68>
			cb->le_param_updated(conn, conn->le.interval,
    a3e6:	f8b4 30a6 	ldrh.w	r3, [r4, #166]	; 0xa6
    a3ea:	f8b4 20a4 	ldrh.w	r2, [r4, #164]	; 0xa4
    a3ee:	f8b4 109e 	ldrh.w	r1, [r4, #158]	; 0x9e
    a3f2:	4620      	mov	r0, r4
    a3f4:	47b0      	blx	r6
    a3f6:	e7ef      	b.n	a3d8 <notify_le_param_updated+0x68>
}
    a3f8:	bd70      	pop	{r4, r5, r6, pc}
    a3fa:	bf00      	nop
    a3fc:	200022cc 	.word	0x200022cc
    a400:	0001cfa0 	.word	0x0001cfa0
    a404:	0001cfb4 	.word	0x0001cfb4

0000a408 <le_param_req>:
{
    a408:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a40a:	4606      	mov	r6, r0
    a40c:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    a40e:	4608      	mov	r0, r1
    a410:	f00d fb40 	bl	17a94 <bt_le_conn_params_valid>
    a414:	4607      	mov	r7, r0
    a416:	b338      	cbz	r0, a468 <le_param_req+0x60>
	for (cb = callback_list; cb; cb = cb->_next) {
    a418:	4b15      	ldr	r3, [pc, #84]	; (a470 <le_param_req+0x68>)
    a41a:	681c      	ldr	r4, [r3, #0]
    a41c:	e000      	b.n	a420 <le_param_req+0x18>
    a41e:	6924      	ldr	r4, [r4, #16]
    a420:	b16c      	cbz	r4, a43e <le_param_req+0x36>
		if (!cb->le_param_req) {
    a422:	68a3      	ldr	r3, [r4, #8]
    a424:	2b00      	cmp	r3, #0
    a426:	d0fa      	beq.n	a41e <le_param_req+0x16>
		if (!cb->le_param_req(conn, param)) {
    a428:	4629      	mov	r1, r5
    a42a:	4630      	mov	r0, r6
    a42c:	4798      	blx	r3
    a42e:	b1d0      	cbz	r0, a466 <le_param_req+0x5e>
		if (!bt_le_conn_params_valid(param)) {
    a430:	4628      	mov	r0, r5
    a432:	f00d fb2f 	bl	17a94 <bt_le_conn_params_valid>
    a436:	2800      	cmp	r0, #0
    a438:	d1f1      	bne.n	a41e <le_param_req+0x16>
			return false;
    a43a:	4607      	mov	r7, r0
    a43c:	e014      	b.n	a468 <le_param_req+0x60>
	STRUCT_SECTION_FOREACH(bt_conn_cb, cb) {
    a43e:	4c0d      	ldr	r4, [pc, #52]	; (a474 <le_param_req+0x6c>)
    a440:	e000      	b.n	a444 <le_param_req+0x3c>
    a442:	3414      	adds	r4, #20
    a444:	4b0c      	ldr	r3, [pc, #48]	; (a478 <le_param_req+0x70>)
    a446:	429c      	cmp	r4, r3
    a448:	d20e      	bcs.n	a468 <le_param_req+0x60>
		if (!cb->le_param_req) {
    a44a:	68a3      	ldr	r3, [r4, #8]
    a44c:	2b00      	cmp	r3, #0
    a44e:	d0f8      	beq.n	a442 <le_param_req+0x3a>
		if (!cb->le_param_req(conn, param)) {
    a450:	4629      	mov	r1, r5
    a452:	4630      	mov	r0, r6
    a454:	4798      	blx	r3
    a456:	b148      	cbz	r0, a46c <le_param_req+0x64>
		if (!bt_le_conn_params_valid(param)) {
    a458:	4628      	mov	r0, r5
    a45a:	f00d fb1b 	bl	17a94 <bt_le_conn_params_valid>
    a45e:	2800      	cmp	r0, #0
    a460:	d1ef      	bne.n	a442 <le_param_req+0x3a>
			return false;
    a462:	4607      	mov	r7, r0
    a464:	e000      	b.n	a468 <le_param_req+0x60>
			return false;
    a466:	4607      	mov	r7, r0
}
    a468:	4638      	mov	r0, r7
    a46a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return false;
    a46c:	4607      	mov	r7, r0
    a46e:	e7fb      	b.n	a468 <le_param_req+0x60>
    a470:	200022cc 	.word	0x200022cc
    a474:	0001cfa0 	.word	0x0001cfa0
    a478:	0001cfb4 	.word	0x0001cfb4

0000a47c <bt_conn_lookup_addr_le>:

	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
}

struct bt_conn *bt_conn_lookup_addr_le(uint8_t id, const bt_addr_le_t *peer)
{
    a47c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a47e:	4607      	mov	r7, r0
    a480:	460e      	mov	r6, r1
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
    a482:	2400      	movs	r4, #0
    a484:	b114      	cbz	r4, a48c <bt_conn_lookup_addr_le+0x10>
		}

		return conn;
	}

	return NULL;
    a486:	2500      	movs	r5, #0
}
    a488:	4628      	mov	r0, r5
    a48a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    a48c:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    a490:	480b      	ldr	r0, [pc, #44]	; (a4c0 <bt_conn_lookup_addr_le+0x44>)
    a492:	eb00 1083 	add.w	r0, r0, r3, lsl #6
    a496:	f00d fe04 	bl	180a2 <bt_conn_ref>
		if (!conn) {
    a49a:	4605      	mov	r5, r0
    a49c:	b170      	cbz	r0, a4bc <bt_conn_lookup_addr_le+0x40>
		if (conn->type != BT_CONN_TYPE_LE) {
    a49e:	7883      	ldrb	r3, [r0, #2]
    a4a0:	2b01      	cmp	r3, #1
    a4a2:	d109      	bne.n	a4b8 <bt_conn_lookup_addr_le+0x3c>
		if (!bt_conn_is_peer_addr_le(conn, id, peer)) {
    a4a4:	4632      	mov	r2, r6
    a4a6:	4639      	mov	r1, r7
    a4a8:	f00d fe7a 	bl	181a0 <bt_conn_is_peer_addr_le>
    a4ac:	2800      	cmp	r0, #0
    a4ae:	d1eb      	bne.n	a488 <bt_conn_lookup_addr_le+0xc>
			bt_conn_unref(conn);
    a4b0:	4628      	mov	r0, r5
    a4b2:	f00d fe13 	bl	180dc <bt_conn_unref>
			continue;
    a4b6:	e001      	b.n	a4bc <bt_conn_lookup_addr_le+0x40>
			bt_conn_unref(conn);
    a4b8:	f00d fe10 	bl	180dc <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
    a4bc:	3401      	adds	r4, #1
    a4be:	e7e1      	b.n	a484 <bt_conn_lookup_addr_le+0x8>
    a4c0:	200017d8 	.word	0x200017d8

0000a4c4 <bt_conn_exists_le>:
{
    a4c4:	b5b0      	push	{r4, r5, r7, lr}
    a4c6:	b082      	sub	sp, #8
    a4c8:	af00      	add	r7, sp, #0
	struct bt_conn *conn = bt_conn_lookup_addr_le(id, peer);
    a4ca:	f7ff ffd7 	bl	a47c <bt_conn_lookup_addr_le>
	if (conn) {
    a4ce:	2800      	cmp	r0, #0
    a4d0:	d078      	beq.n	a5c4 <bt_conn_exists_le+0x100>
    a4d2:	4604      	mov	r4, r0
		BT_WARN("Found valid connection in %s state",
    a4d4:	7a83      	ldrb	r3, [r0, #10]
	switch (state) {
    a4d6:	2b08      	cmp	r3, #8
    a4d8:	d861      	bhi.n	a59e <bt_conn_exists_le+0xda>
    a4da:	e8df f003 	tbb	[pc, r3]
    a4de:	6205      	.short	0x6205
    a4e0:	54565852 	.word	0x54565852
    a4e4:	5c5a      	.short	0x5c5a
    a4e6:	5e          	.byte	0x5e
    a4e7:	00          	.byte	0x00
    a4e8:	4837      	ldr	r0, [pc, #220]	; (a5c8 <bt_conn_exists_le+0x104>)
		BT_WARN("Found valid connection in %s state",
    a4ea:	2302      	movs	r3, #2
    a4ec:	713b      	strb	r3, [r7, #4]
    a4ee:	466d      	mov	r5, sp
    a4f0:	b088      	sub	sp, #32
    a4f2:	466b      	mov	r3, sp
    a4f4:	f113 0210 	adds.w	r2, r3, #16
    a4f8:	d055      	beq.n	a5a6 <bt_conn_exists_le+0xe2>
    a4fa:	f04f 0c0d 	mov.w	ip, #13
    a4fe:	b122      	cbz	r2, a50a <bt_conn_exists_le+0x46>
    a500:	f1bc 0f04 	cmp.w	ip, #4
    a504:	dd01      	ble.n	a50a <bt_conn_exists_le+0x46>
    a506:	4931      	ldr	r1, [pc, #196]	; (a5cc <bt_conn_exists_le+0x108>)
    a508:	6159      	str	r1, [r3, #20]
    a50a:	2102      	movs	r1, #2
    a50c:	7039      	strb	r1, [r7, #0]
    a50e:	b11a      	cbz	r2, a518 <bt_conn_exists_le+0x54>
    a510:	f1bc 0f08 	cmp.w	ip, #8
    a514:	dd00      	ble.n	a518 <bt_conn_exists_le+0x54>
    a516:	6198      	str	r0, [r3, #24]
    a518:	b122      	cbz	r2, a524 <bt_conn_exists_le+0x60>
    a51a:	f103 011c 	add.w	r1, r3, #28
    a51e:	2000      	movs	r0, #0
    a520:	2800      	cmp	r0, #0
    a522:	d043      	beq.n	a5ac <bt_conn_exists_le+0xe8>
    a524:	f1bc 0f0c 	cmp.w	ip, #12
    a528:	dd49      	ble.n	a5be <bt_conn_exists_le+0xfa>
    a52a:	f04f 0c0d 	mov.w	ip, #13
    a52e:	b142      	cbz	r2, a542 <bt_conn_exists_le+0x7e>
    a530:	2103      	movs	r1, #3
    a532:	7139      	strb	r1, [r7, #4]
    a534:	2100      	movs	r1, #0
    a536:	7179      	strb	r1, [r7, #5]
    a538:	71b9      	strb	r1, [r7, #6]
    a53a:	2101      	movs	r1, #1
    a53c:	71f9      	strb	r1, [r7, #7]
    a53e:	6878      	ldr	r0, [r7, #4]
    a540:	6118      	str	r0, [r3, #16]
    a542:	2100      	movs	r1, #0
    a544:	f36f 0100 	bfc	r1, #0, #1
    a548:	f36f 0141 	bfc	r1, #1, #1
    a54c:	f36f 0182 	bfc	r1, #2, #1
    a550:	f36f 01c5 	bfc	r1, #3, #3
    a554:	2302      	movs	r3, #2
    a556:	f363 1188 	bfi	r1, r3, #6, #3
    a55a:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    a55e:	f36c 2152 	bfi	r1, ip, #9, #10
    a562:	f36f 41de 	bfc	r1, #19, #12
    a566:	f36f 71df 	bfc	r1, #31, #1
    a56a:	2300      	movs	r3, #0
    a56c:	4818      	ldr	r0, [pc, #96]	; (a5d0 <bt_conn_exists_le+0x10c>)
    a56e:	f7f7 fe6b 	bl	2248 <z_impl_z_log_msg_static_create>
    a572:	46ad      	mov	sp, r5
		bt_conn_unref(conn);
    a574:	4620      	mov	r0, r4
    a576:	f00d fdb1 	bl	180dc <bt_conn_unref>
		return true;
    a57a:	2001      	movs	r0, #1
}
    a57c:	3708      	adds	r7, #8
    a57e:	46bd      	mov	sp, r7
    a580:	bdb0      	pop	{r4, r5, r7, pc}
		return "connecting-scan";
    a582:	4814      	ldr	r0, [pc, #80]	; (a5d4 <bt_conn_exists_le+0x110>)
    a584:	e7b1      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "connecting-dir-adv";
    a586:	4814      	ldr	r0, [pc, #80]	; (a5d8 <bt_conn_exists_le+0x114>)
    a588:	e7af      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "connecting-adv";
    a58a:	4814      	ldr	r0, [pc, #80]	; (a5dc <bt_conn_exists_le+0x118>)
    a58c:	e7ad      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "connecting-auto";
    a58e:	4814      	ldr	r0, [pc, #80]	; (a5e0 <bt_conn_exists_le+0x11c>)
    a590:	e7ab      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "connecting";
    a592:	4814      	ldr	r0, [pc, #80]	; (a5e4 <bt_conn_exists_le+0x120>)
    a594:	e7a9      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "connected";
    a596:	4814      	ldr	r0, [pc, #80]	; (a5e8 <bt_conn_exists_le+0x124>)
    a598:	e7a7      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "disconnecting";
    a59a:	4814      	ldr	r0, [pc, #80]	; (a5ec <bt_conn_exists_le+0x128>)
    a59c:	e7a5      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "(unknown)";
    a59e:	4814      	ldr	r0, [pc, #80]	; (a5f0 <bt_conn_exists_le+0x12c>)
    a5a0:	e7a3      	b.n	a4ea <bt_conn_exists_le+0x26>
		return "disconnect-complete";
    a5a2:	4814      	ldr	r0, [pc, #80]	; (a5f4 <bt_conn_exists_le+0x130>)
    a5a4:	e7a1      	b.n	a4ea <bt_conn_exists_le+0x26>
		BT_WARN("Found valid connection in %s state",
    a5a6:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    a5aa:	e7a8      	b.n	a4fe <bt_conn_exists_le+0x3a>
    a5ac:	f107 0e08 	add.w	lr, r7, #8
    a5b0:	4486      	add	lr, r0
    a5b2:	f81e ec08 	ldrb.w	lr, [lr, #-8]
    a5b6:	f801 eb01 	strb.w	lr, [r1], #1
    a5ba:	3001      	adds	r0, #1
    a5bc:	e7b0      	b.n	a520 <bt_conn_exists_le+0x5c>
    a5be:	f06f 0c1b 	mvn.w	ip, #27
    a5c2:	e7b4      	b.n	a52e <bt_conn_exists_le+0x6a>
	return false;
    a5c4:	2000      	movs	r0, #0
    a5c6:	e7d9      	b.n	a57c <bt_conn_exists_le+0xb8>
    a5c8:	0001eb0c 	.word	0x0001eb0c
    a5cc:	0001eb90 	.word	0x0001eb90
    a5d0:	0001cfe4 	.word	0x0001cfe4
    a5d4:	0001eaac 	.word	0x0001eaac
    a5d8:	0001eabc 	.word	0x0001eabc
    a5dc:	0001ead0 	.word	0x0001ead0
    a5e0:	0001eae0 	.word	0x0001eae0
    a5e4:	0001eaf0 	.word	0x0001eaf0
    a5e8:	0001eda4 	.word	0x0001eda4
    a5ec:	0001eafc 	.word	0x0001eafc
    a5f0:	0001ea8c 	.word	0x0001ea8c
    a5f4:	0001ea98 	.word	0x0001ea98

0000a5f8 <bt_conn_lookup_state_le>:

struct bt_conn *bt_conn_lookup_state_le(uint8_t id, const bt_addr_le_t *peer,
					const bt_conn_state_t state)
{
    a5f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a5fc:	4607      	mov	r7, r0
    a5fe:	460e      	mov	r6, r1
    a600:	4690      	mov	r8, r2
	int i;

	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
    a602:	2400      	movs	r4, #0
    a604:	b11c      	cbz	r4, a60e <bt_conn_lookup_state_le+0x16>
		}

		return conn;
	}

	return NULL;
    a606:	2500      	movs	r5, #0
}
    a608:	4628      	mov	r0, r5
    a60a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		struct bt_conn *conn = bt_conn_ref(&acl_conns[i]);
    a60e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    a612:	4811      	ldr	r0, [pc, #68]	; (a658 <bt_conn_lookup_state_le+0x60>)
    a614:	eb00 1083 	add.w	r0, r0, r3, lsl #6
    a618:	f00d fd43 	bl	180a2 <bt_conn_ref>
		if (!conn) {
    a61c:	4605      	mov	r5, r0
    a61e:	b188      	cbz	r0, a644 <bt_conn_lookup_state_le+0x4c>
		if (conn->type != BT_CONN_TYPE_LE) {
    a620:	7883      	ldrb	r3, [r0, #2]
    a622:	2b01      	cmp	r3, #1
    a624:	d110      	bne.n	a648 <bt_conn_lookup_state_le+0x50>
		if (peer && !bt_conn_is_peer_addr_le(conn, id, peer)) {
    a626:	b126      	cbz	r6, a632 <bt_conn_lookup_state_le+0x3a>
    a628:	4632      	mov	r2, r6
    a62a:	4639      	mov	r1, r7
    a62c:	f00d fdb8 	bl	181a0 <bt_conn_is_peer_addr_le>
    a630:	b168      	cbz	r0, a64e <bt_conn_lookup_state_le+0x56>
		if (!(conn->state == state && conn->id == id)) {
    a632:	7aab      	ldrb	r3, [r5, #10]
    a634:	4543      	cmp	r3, r8
    a636:	d102      	bne.n	a63e <bt_conn_lookup_state_le+0x46>
    a638:	7a2b      	ldrb	r3, [r5, #8]
    a63a:	42bb      	cmp	r3, r7
    a63c:	d0e4      	beq.n	a608 <bt_conn_lookup_state_le+0x10>
			bt_conn_unref(conn);
    a63e:	4628      	mov	r0, r5
    a640:	f00d fd4c 	bl	180dc <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(acl_conns); i++) {
    a644:	3401      	adds	r4, #1
    a646:	e7dd      	b.n	a604 <bt_conn_lookup_state_le+0xc>
			bt_conn_unref(conn);
    a648:	f00d fd48 	bl	180dc <bt_conn_unref>
			continue;
    a64c:	e7fa      	b.n	a644 <bt_conn_lookup_state_le+0x4c>
			bt_conn_unref(conn);
    a64e:	4628      	mov	r0, r5
    a650:	f00d fd44 	bl	180dc <bt_conn_unref>
			continue;
    a654:	e7f6      	b.n	a644 <bt_conn_lookup_state_le+0x4c>
    a656:	bf00      	nop
    a658:	200017d8 	.word	0x200017d8

0000a65c <send_conn_le_param_update>:
{
    a65c:	b538      	push	{r3, r4, r5, lr}
    a65e:	4604      	mov	r4, r0
    a660:	460d      	mov	r5, r1
	if (!bt_le_conn_params_valid(param)) {
    a662:	4608      	mov	r0, r1
    a664:	f00d fa16 	bl	17a94 <bt_le_conn_params_valid>
    a668:	b350      	cbz	r0, a6c0 <send_conn_le_param_update+0x64>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    a66a:	4b17      	ldr	r3, [pc, #92]	; (a6c8 <send_conn_le_param_update+0x6c>)
    a66c:	f893 30d0 	ldrb.w	r3, [r3, #208]	; 0xd0
    a670:	f013 0f02 	tst.w	r3, #2
    a674:	d004      	beq.n	a680 <send_conn_le_param_update+0x24>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    a676:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
    a67a:	f013 0f02 	tst.w	r3, #2
    a67e:	d113      	bne.n	a6a8 <send_conn_le_param_update+0x4c>
	     (conn->role == BT_HCI_ROLE_CENTRAL)) {
    a680:	78e3      	ldrb	r3, [r4, #3]
	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
    a682:	b9c3      	cbnz	r3, a6b6 <send_conn_le_param_update+0x5a>
		rc = bt_conn_le_conn_update(conn, param);
    a684:	4629      	mov	r1, r5
    a686:	4620      	mov	r0, r4
    a688:	f00d fdb1 	bl	181ee <bt_conn_le_conn_update>
		if (rc == 0) {
    a68c:	b9b8      	cbnz	r0, a6be <send_conn_le_param_update+0x62>
			conn->le.interval_min = param->interval_min;
    a68e:	882b      	ldrh	r3, [r5, #0]
    a690:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
			conn->le.interval_max = param->interval_max;
    a694:	886b      	ldrh	r3, [r5, #2]
    a696:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
			conn->le.pending_latency = param->latency;
    a69a:	88ab      	ldrh	r3, [r5, #4]
    a69c:	f8a4 30a8 	strh.w	r3, [r4, #168]	; 0xa8
			conn->le.pending_timeout = param->timeout;
    a6a0:	88eb      	ldrh	r3, [r5, #6]
    a6a2:	f8a4 30aa 	strh.w	r3, [r4, #170]	; 0xaa
		return rc;
    a6a6:	e00a      	b.n	a6be <send_conn_le_param_update+0x62>
	     !atomic_test_bit(conn->flags, BT_CONN_PERIPHERAL_PARAM_L2CAP)) ||
    a6a8:	1d23      	adds	r3, r4, #4
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    a6aa:	e8d3 3faf 	lda	r3, [r3]
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
    a6ae:	f413 7f00 	tst.w	r3, #512	; 0x200
    a6b2:	d1e5      	bne.n	a680 <send_conn_le_param_update+0x24>
    a6b4:	e7e6      	b.n	a684 <send_conn_le_param_update+0x28>
	return bt_l2cap_update_conn_param(conn, param);
    a6b6:	4629      	mov	r1, r5
    a6b8:	4620      	mov	r0, r4
    a6ba:	f00d fe66 	bl	1838a <bt_l2cap_update_conn_param>
}
    a6be:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    a6c0:	f06f 0015 	mvn.w	r0, #21
    a6c4:	e7fb      	b.n	a6be <send_conn_le_param_update+0x62>
    a6c6:	bf00      	nop
    a6c8:	20000000 	.word	0x20000000

0000a6cc <deferred_work>:
{
    a6cc:	b530      	push	{r4, r5, lr}
    a6ce:	b085      	sub	sp, #20
	struct bt_conn *conn = CONTAINER_OF(dwork, struct bt_conn, deferred_work);
    a6d0:	f1a0 0458 	sub.w	r4, r0, #88	; 0x58
	if (conn->state == BT_CONN_DISCONNECTED) {
    a6d4:	f810 3c4e 	ldrb.w	r3, [r0, #-78]
    a6d8:	b373      	cbz	r3, a738 <deferred_work+0x6c>
	if (conn->type != BT_CONN_TYPE_LE) {
    a6da:	f810 3c56 	ldrb.w	r3, [r0, #-86]
    a6de:	2b01      	cmp	r3, #1
    a6e0:	d128      	bne.n	a734 <deferred_work+0x68>
	if (atomic_test_and_clear_bit(conn->flags,
    a6e2:	f1a0 0554 	sub.w	r5, r0, #84	; 0x54
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    a6e6:	e8d5 3fef 	ldaex	r3, [r5]
    a6ea:	f423 7280 	bic.w	r2, r3, #256	; 0x100
    a6ee:	e8c5 2fe1 	stlex	r1, r2, [r5]
    a6f2:	2900      	cmp	r1, #0
    a6f4:	d1f7      	bne.n	a6e6 <deferred_work+0x1a>
    a6f6:	f413 7f80 	tst.w	r3, #256	; 0x100
    a6fa:	d027      	beq.n	a74c <deferred_work+0x80>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
    a6fc:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
    a700:	f8ad 3000 	strh.w	r3, [sp]
    a704:	f8b0 304a 	ldrh.w	r3, [r0, #74]	; 0x4a
    a708:	f8ad 3002 	strh.w	r3, [sp, #2]
    a70c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
    a710:	f8ad 3004 	strh.w	r3, [sp, #4]
    a714:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
    a718:	f8ad 3006 	strh.w	r3, [sp, #6]
		send_conn_le_param_update(conn, param);
    a71c:	4669      	mov	r1, sp
    a71e:	4620      	mov	r0, r4
    a720:	f7ff ff9c 	bl	a65c <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    a724:	e8d5 3fef 	ldaex	r3, [r5]
    a728:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    a72c:	e8c5 3fe2 	stlex	r2, r3, [r5]
    a730:	2a00      	cmp	r2, #0
    a732:	d1f7      	bne.n	a724 <deferred_work+0x58>
}
    a734:	b005      	add	sp, #20
    a736:	bd30      	pop	{r4, r5, pc}
		bt_l2cap_disconnected(conn);
    a738:	4620      	mov	r0, r4
    a73a:	f00d fdad 	bl	18298 <bt_l2cap_disconnected>
		notify_disconnected(conn);
    a73e:	4620      	mov	r0, r4
    a740:	f7ff f8b6 	bl	98b0 <notify_disconnected>
		bt_conn_unref(conn);
    a744:	4620      	mov	r0, r4
    a746:	f00d fcc9 	bl	180dc <bt_conn_unref>
		return;
    a74a:	e7f3      	b.n	a734 <deferred_work+0x68>
		param = BT_LE_CONN_PARAM(
    a74c:	4a05      	ldr	r2, [pc, #20]	; (a764 <deferred_work+0x98>)
    a74e:	ab02      	add	r3, sp, #8
    a750:	e892 0003 	ldmia.w	r2, {r0, r1}
    a754:	e883 0003 	stmia.w	r3, {r0, r1}
		send_conn_le_param_update(conn, param);
    a758:	4619      	mov	r1, r3
    a75a:	4620      	mov	r0, r4
    a75c:	f7ff ff7e 	bl	a65c <send_conn_le_param_update>
    a760:	e7e0      	b.n	a724 <deferred_work+0x58>
    a762:	bf00      	nop
    a764:	0001d1d0 	.word	0x0001d1d0

0000a768 <bt_conn_create_frag_timeout>:
						  k_timeout_t timeout,
						  const char *func, int line)
#else
struct net_buf *bt_conn_create_frag_timeout(size_t reserve, k_timeout_t timeout)
#endif
{
    a768:	b508      	push	{r3, lr}
    a76a:	4601      	mov	r1, r0

#if defined(CONFIG_NET_BUF_LOG)
	return bt_conn_create_pdu_timeout_debug(pool, reserve, timeout,
						func, line);
#else
	return bt_conn_create_pdu_timeout(pool, reserve, timeout);
    a76c:	4801      	ldr	r0, [pc, #4]	; (a774 <bt_conn_create_frag_timeout+0xc>)
    a76e:	f7ff fdc1 	bl	a2f4 <bt_conn_create_pdu_timeout>
#endif /* CONFIG_NET_BUF_LOG */
}
    a772:	bd08      	pop	{r3, pc}
    a774:	20000734 	.word	0x20000734

0000a778 <create_frag>:
{
    a778:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a77a:	4606      	mov	r6, r0
    a77c:	460d      	mov	r5, r1
		frag = bt_conn_create_frag(0);
    a77e:	f04f 32ff 	mov.w	r2, #4294967295
    a782:	f04f 33ff 	mov.w	r3, #4294967295
    a786:	2000      	movs	r0, #0
    a788:	f7ff ffee 	bl	a768 <bt_conn_create_frag_timeout>
    a78c:	4604      	mov	r4, r0
	if (conn->state != BT_CONN_CONNECTED) {
    a78e:	7ab3      	ldrb	r3, [r6, #10]
    a790:	2b07      	cmp	r3, #7
    a792:	d11a      	bne.n	a7ca <create_frag+0x52>
	tx_data(frag)->tx = NULL;
    a794:	2300      	movs	r3, #0
    a796:	6143      	str	r3, [r0, #20]
	return bt_dev.le.acl_mtu;
    a798:	4b10      	ldr	r3, [pc, #64]	; (a7dc <create_frag+0x64>)
    a79a:	f8b3 60fc 	ldrh.w	r6, [r3, #252]	; 0xfc
	return net_buf_simple_tailroom(&buf->b);
    a79e:	f100 0708 	add.w	r7, r0, #8
    a7a2:	4638      	mov	r0, r7
    a7a4:	f00f fd77 	bl	1a296 <net_buf_simple_tailroom>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    a7a8:	4286      	cmp	r6, r0
    a7aa:	d212      	bcs.n	a7d2 <create_frag+0x5a>
	return bt_dev.le.acl_mtu;
    a7ac:	4b0b      	ldr	r3, [pc, #44]	; (a7dc <create_frag+0x64>)
    a7ae:	f8b3 60fc 	ldrh.w	r6, [r3, #252]	; 0xfc
	return net_buf_simple_add_mem(&buf->b, mem, len);
    a7b2:	4632      	mov	r2, r6
    a7b4:	f855 1f08 	ldr.w	r1, [r5, #8]!
    a7b8:	4638      	mov	r0, r7
    a7ba:	f00f fd26 	bl	1a20a <net_buf_simple_add_mem>
	return net_buf_simple_pull(&buf->b, len);
    a7be:	4631      	mov	r1, r6
    a7c0:	4628      	mov	r0, r5
    a7c2:	f00f fd4c 	bl	1a25e <net_buf_simple_pull>
}
    a7c6:	4620      	mov	r0, r4
    a7c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		net_buf_unref(frag);
    a7ca:	f00f fcce 	bl	1a16a <net_buf_unref>
		return NULL;
    a7ce:	2400      	movs	r4, #0
    a7d0:	e7f9      	b.n	a7c6 <create_frag+0x4e>
	return net_buf_simple_tailroom(&buf->b);
    a7d2:	4638      	mov	r0, r7
    a7d4:	f00f fd5f 	bl	1a296 <net_buf_simple_tailroom>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
    a7d8:	b286      	uxth	r6, r0
    a7da:	e7ea      	b.n	a7b2 <create_frag+0x3a>
    a7dc:	20000000 	.word	0x20000000

0000a7e0 <send_buf>:
{
    a7e0:	b538      	push	{r3, r4, r5, lr}
    a7e2:	4605      	mov	r5, r0
    a7e4:	460c      	mov	r4, r1
	if (buf->len <= conn_mtu(conn)) {
    a7e6:	898b      	ldrh	r3, [r1, #12]
	return bt_dev.le.acl_mtu;
    a7e8:	4a1b      	ldr	r2, [pc, #108]	; (a858 <send_buf+0x78>)
    a7ea:	f8b2 20fc 	ldrh.w	r2, [r2, #252]	; 0xfc
	if (buf->len <= conn_mtu(conn)) {
    a7ee:	429a      	cmp	r2, r3
    a7f0:	d21f      	bcs.n	a832 <send_buf+0x52>
	frag = create_frag(conn, buf);
    a7f2:	f7ff ffc1 	bl	a778 <create_frag>
	if (!frag) {
    a7f6:	4601      	mov	r1, r0
    a7f8:	b350      	cbz	r0, a850 <send_buf+0x70>
	if (!send_frag(conn, frag, FRAG_START, true)) {
    a7fa:	2301      	movs	r3, #1
    a7fc:	2200      	movs	r2, #0
    a7fe:	4628      	mov	r0, r5
    a800:	f7ff f8a0 	bl	9944 <send_frag>
    a804:	4603      	mov	r3, r0
    a806:	b1c8      	cbz	r0, a83c <send_buf+0x5c>
	while (buf->len > conn_mtu(conn)) {
    a808:	89a3      	ldrh	r3, [r4, #12]
	return bt_dev.le.acl_mtu;
    a80a:	4a13      	ldr	r2, [pc, #76]	; (a858 <send_buf+0x78>)
    a80c:	f8b2 20fc 	ldrh.w	r2, [r2, #252]	; 0xfc
	while (buf->len > conn_mtu(conn)) {
    a810:	429a      	cmp	r2, r3
    a812:	d215      	bcs.n	a840 <send_buf+0x60>
		frag = create_frag(conn, buf);
    a814:	4621      	mov	r1, r4
    a816:	4628      	mov	r0, r5
    a818:	f7ff ffae 	bl	a778 <create_frag>
		if (!frag) {
    a81c:	4601      	mov	r1, r0
    a81e:	b1c8      	cbz	r0, a854 <send_buf+0x74>
		if (!send_frag(conn, frag, FRAG_CONT, true)) {
    a820:	2301      	movs	r3, #1
    a822:	461a      	mov	r2, r3
    a824:	4628      	mov	r0, r5
    a826:	f7ff f88d 	bl	9944 <send_frag>
    a82a:	4603      	mov	r3, r0
    a82c:	2800      	cmp	r0, #0
    a82e:	d1eb      	bne.n	a808 <send_buf+0x28>
    a830:	e004      	b.n	a83c <send_buf+0x5c>
		return send_frag(conn, buf, FRAG_SINGLE, false);
    a832:	2300      	movs	r3, #0
    a834:	2202      	movs	r2, #2
    a836:	f7ff f885 	bl	9944 <send_frag>
    a83a:	4603      	mov	r3, r0
}
    a83c:	4618      	mov	r0, r3
    a83e:	bd38      	pop	{r3, r4, r5, pc}
	return send_frag(conn, buf, FRAG_END, false);
    a840:	2300      	movs	r3, #0
    a842:	2203      	movs	r2, #3
    a844:	4621      	mov	r1, r4
    a846:	4628      	mov	r0, r5
    a848:	f7ff f87c 	bl	9944 <send_frag>
    a84c:	4603      	mov	r3, r0
    a84e:	e7f5      	b.n	a83c <send_buf+0x5c>
		return false;
    a850:	2300      	movs	r3, #0
    a852:	e7f3      	b.n	a83c <send_buf+0x5c>
			return false;
    a854:	2300      	movs	r3, #0
    a856:	e7f1      	b.n	a83c <send_buf+0x5c>
    a858:	20000000 	.word	0x20000000

0000a85c <bt_conn_process_tx>:
{
    a85c:	b570      	push	{r4, r5, r6, lr}
    a85e:	4604      	mov	r4, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
    a860:	7a83      	ldrb	r3, [r0, #10]
    a862:	b95b      	cbnz	r3, a87c <bt_conn_process_tx+0x20>
	    atomic_test_and_clear_bit(conn->flags, BT_CONN_CLEANUP)) {
    a864:	1d03      	adds	r3, r0, #4
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    a866:	e8d3 2fef 	ldaex	r2, [r3]
    a86a:	f022 0140 	bic.w	r1, r2, #64	; 0x40
    a86e:	e8c3 1fe0 	stlex	r0, r1, [r3]
    a872:	2800      	cmp	r0, #0
    a874:	d1f7      	bne.n	a866 <bt_conn_process_tx+0xa>
	if (conn->state == BT_CONN_DISCONNECTED &&
    a876:	f012 0f40 	tst.w	r2, #64	; 0x40
    a87a:	d10d      	bne.n	a898 <bt_conn_process_tx+0x3c>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
    a87c:	2200      	movs	r2, #0
    a87e:	2300      	movs	r3, #0
    a880:	f104 0038 	add.w	r0, r4, #56	; 0x38
    a884:	f00f fbe5 	bl	1a052 <net_buf_get>
	BT_ASSERT(buf);
    a888:	4605      	mov	r5, r0
    a88a:	b148      	cbz	r0, a8a0 <bt_conn_process_tx+0x44>
	if (!send_buf(conn, buf)) {
    a88c:	4629      	mov	r1, r5
    a88e:	4620      	mov	r0, r4
    a890:	f7ff ffa6 	bl	a7e0 <send_buf>
    a894:	b190      	cbz	r0, a8bc <bt_conn_process_tx+0x60>
}
    a896:	bd70      	pop	{r4, r5, r6, pc}
		conn_cleanup(conn);
    a898:	4620      	mov	r0, r4
    a89a:	f00d fba6 	bl	17fea <conn_cleanup>
		return;
    a89e:	e7fa      	b.n	a896 <bt_conn_process_tx+0x3a>
	BT_ASSERT(buf);
    a8a0:	f240 330b 	movw	r3, #779	; 0x30b
    a8a4:	4a0c      	ldr	r2, [pc, #48]	; (a8d8 <bt_conn_process_tx+0x7c>)
    a8a6:	490d      	ldr	r1, [pc, #52]	; (a8dc <bt_conn_process_tx+0x80>)
    a8a8:	480d      	ldr	r0, [pc, #52]	; (a8e0 <bt_conn_process_tx+0x84>)
    a8aa:	f00b fcfe 	bl	162aa <assert_print>
    a8ae:	4040      	eors	r0, r0
    a8b0:	f380 8811 	msr	BASEPRI, r0
    a8b4:	f04f 0003 	mov.w	r0, #3
    a8b8:	df02      	svc	2
    a8ba:	e7e7      	b.n	a88c <bt_conn_process_tx+0x30>
		struct bt_conn_tx *tx = tx_data(buf)->tx;
    a8bc:	696e      	ldr	r6, [r5, #20]
		tx_data(buf)->tx = NULL;
    a8be:	2300      	movs	r3, #0
    a8c0:	616b      	str	r3, [r5, #20]
		net_buf_unref(buf);
    a8c2:	4628      	mov	r0, r5
    a8c4:	f00f fc51 	bl	1a16a <net_buf_unref>
		if (tx) {
    a8c8:	2e00      	cmp	r6, #0
    a8ca:	d0e4      	beq.n	a896 <bt_conn_process_tx+0x3a>
			conn_tx_destroy(conn, tx);
    a8cc:	4631      	mov	r1, r6
    a8ce:	4620      	mov	r0, r4
    a8d0:	f00d fb11 	bl	17ef6 <conn_tx_destroy>
    a8d4:	e7df      	b.n	a896 <bt_conn_process_tx+0x3a>
    a8d6:	bf00      	nop
    a8d8:	0001ebb4 	.word	0x0001ebb4
    a8dc:	0001f418 	.word	0x0001f418
    a8e0:	0001e29c 	.word	0x0001e29c

0000a8e4 <bt_conn_lookup_index>:
}
#endif /* CONFIG_BT_SMP || CONFIG_BT_BREDR */

struct bt_conn *bt_conn_lookup_index(uint8_t index)
{
	if (index >= ARRAY_SIZE(acl_conns)) {
    a8e4:	b940      	cbnz	r0, a8f8 <bt_conn_lookup_index+0x14>
{
    a8e6:	b508      	push	{r3, lr}
		return NULL;
	}

	return bt_conn_ref(&acl_conns[index]);
    a8e8:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    a8ec:	4803      	ldr	r0, [pc, #12]	; (a8fc <bt_conn_lookup_index+0x18>)
    a8ee:	eb00 1083 	add.w	r0, r0, r3, lsl #6
    a8f2:	f00d fbd6 	bl	180a2 <bt_conn_ref>
}
    a8f6:	bd08      	pop	{r3, pc}
		return NULL;
    a8f8:	2000      	movs	r0, #0
}
    a8fa:	4770      	bx	lr
    a8fc:	200017d8 	.word	0x200017d8

0000a900 <bt_conn_init>:

int bt_conn_init(void)
{
    a900:	b510      	push	{r4, lr}
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
    a902:	2400      	movs	r4, #0
    a904:	e006      	b.n	a914 <bt_conn_init+0x14>
		k_fifo_put(&free_tx, &conn_tx[i]);
    a906:	490a      	ldr	r1, [pc, #40]	; (a930 <bt_conn_init+0x30>)
    a908:	eb01 1104 	add.w	r1, r1, r4, lsl #4
    a90c:	4809      	ldr	r0, [pc, #36]	; (a934 <bt_conn_init+0x34>)
    a90e:	f011 fc2b 	bl	1c168 <k_queue_append>
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
    a912:	3401      	adds	r4, #1
    a914:	2c02      	cmp	r4, #2
    a916:	d9f6      	bls.n	a906 <bt_conn_init+0x6>
	}

	bt_att_init();
    a918:	f001 fd90 	bl	c43c <bt_att_init>

	err = bt_smp_init();
    a91c:	f00f fabe 	bl	19e9c <bt_smp_init>
	if (err) {
    a920:	4604      	mov	r4, r0
    a922:	b108      	cbz	r0, a928 <bt_conn_init+0x28>
			bt_conn_unref(conn);
		}
	}

	return 0;
}
    a924:	4620      	mov	r0, r4
    a926:	bd10      	pop	{r4, pc}
	bt_l2cap_init();
    a928:	f00d fd5c 	bl	183e4 <bt_l2cap_init>
	return 0;
    a92c:	e7fa      	b.n	a924 <bt_conn_init+0x24>
    a92e:	bf00      	nop
    a930:	200022d0 	.word	0x200022d0
    a934:	2000066c 	.word	0x2000066c

0000a938 <get_ident>:

static uint8_t get_ident(void)
{
	static uint8_t ident;

	ident++;
    a938:	4a05      	ldr	r2, [pc, #20]	; (a950 <get_ident+0x18>)
    a93a:	7813      	ldrb	r3, [r2, #0]
    a93c:	3301      	adds	r3, #1
    a93e:	b2db      	uxtb	r3, r3
    a940:	7013      	strb	r3, [r2, #0]
	/* handle integer overflow (0 is not valid) */
	if (!ident) {
    a942:	b90b      	cbnz	r3, a948 <get_ident+0x10>
		ident++;
    a944:	3301      	adds	r3, #1
    a946:	7013      	strb	r3, [r2, #0]
	}

	return ident;
}
    a948:	4b01      	ldr	r3, [pc, #4]	; (a950 <get_ident+0x18>)
    a94a:	7818      	ldrb	r0, [r3, #0]
    a94c:	4770      	bx	lr
    a94e:	bf00      	nop
    a950:	200028fd 	.word	0x200028fd

0000a954 <l2cap_accept>:
	(void)k_work_cancel_delayable(&le_chan->rtx_work);
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}

static int l2cap_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
    a954:	b5b0      	push	{r4, r5, r7, lr}
    a956:	b082      	sub	sp, #8
    a958:	af00      	add	r7, sp, #0
    a95a:	4605      	mov	r5, r0
		.recv = l2cap_recv,
	};

	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
    a95c:	2000      	movs	r0, #0
    a95e:	2800      	cmp	r0, #0
    a960:	d03a      	beq.n	a9d8 <l2cap_accept+0x84>
		*chan = &l2cap->chan.chan;

		return 0;
	}

	BT_ERR("No available L2CAP context for conn %p", conn);
    a962:	466c      	mov	r4, sp
    a964:	b088      	sub	sp, #32
    a966:	466b      	mov	r3, sp
    a968:	f113 0210 	adds.w	r2, r3, #16
    a96c:	d044      	beq.n	a9f8 <l2cap_accept+0xa4>
    a96e:	210c      	movs	r1, #12
    a970:	b11a      	cbz	r2, a97a <l2cap_accept+0x26>
    a972:	2904      	cmp	r1, #4
    a974:	dd01      	ble.n	a97a <l2cap_accept+0x26>
    a976:	4823      	ldr	r0, [pc, #140]	; (aa04 <l2cap_accept+0xb0>)
    a978:	6158      	str	r0, [r3, #20]
    a97a:	b112      	cbz	r2, a982 <l2cap_accept+0x2e>
    a97c:	2908      	cmp	r1, #8
    a97e:	dd00      	ble.n	a982 <l2cap_accept+0x2e>
    a980:	619d      	str	r5, [r3, #24]
    a982:	290b      	cmp	r1, #11
    a984:	dd3b      	ble.n	a9fe <l2cap_accept+0xaa>
    a986:	f04f 0c0c 	mov.w	ip, #12
    a98a:	b13a      	cbz	r2, a99c <l2cap_accept+0x48>
    a98c:	2103      	movs	r1, #3
    a98e:	7139      	strb	r1, [r7, #4]
    a990:	2100      	movs	r1, #0
    a992:	7179      	strb	r1, [r7, #5]
    a994:	71b9      	strb	r1, [r7, #6]
    a996:	71f9      	strb	r1, [r7, #7]
    a998:	6878      	ldr	r0, [r7, #4]
    a99a:	6118      	str	r0, [r3, #16]
    a99c:	2100      	movs	r1, #0
    a99e:	f36f 0100 	bfc	r1, #0, #1
    a9a2:	f36f 0141 	bfc	r1, #1, #1
    a9a6:	f36f 0182 	bfc	r1, #2, #1
    a9aa:	f36f 01c5 	bfc	r1, #3, #3
    a9ae:	2301      	movs	r3, #1
    a9b0:	f363 1188 	bfi	r1, r3, #6, #3
    a9b4:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    a9b8:	f36c 2152 	bfi	r1, ip, #9, #10
    a9bc:	f36f 41de 	bfc	r1, #19, #12
    a9c0:	f36f 71df 	bfc	r1, #31, #1
    a9c4:	2300      	movs	r3, #0
    a9c6:	4810      	ldr	r0, [pc, #64]	; (aa08 <l2cap_accept+0xb4>)
    a9c8:	f7f7 fc3e 	bl	2248 <z_impl_z_log_msg_static_create>
    a9cc:	46a5      	mov	sp, r4

	return -ENOMEM;
    a9ce:	f06f 000b 	mvn.w	r0, #11
}
    a9d2:	3708      	adds	r7, #8
    a9d4:	46bd      	mov	sp, r7
    a9d6:	bdb0      	pop	{r4, r5, r7, pc}
		if (l2cap->chan.chan.conn) {
    a9d8:	238c      	movs	r3, #140	; 0x8c
    a9da:	fb00 f303 	mul.w	r3, r0, r3
    a9de:	4a0b      	ldr	r2, [pc, #44]	; (aa0c <l2cap_accept+0xb8>)
    a9e0:	58d3      	ldr	r3, [r2, r3]
    a9e2:	b10b      	cbz	r3, a9e8 <l2cap_accept+0x94>
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
    a9e4:	3001      	adds	r0, #1
    a9e6:	e7ba      	b.n	a95e <l2cap_accept+0xa>
		l2cap->chan.chan.ops = &ops;
    a9e8:	4b08      	ldr	r3, [pc, #32]	; (aa0c <l2cap_accept+0xb8>)
    a9ea:	228c      	movs	r2, #140	; 0x8c
    a9ec:	fb02 3300 	mla	r3, r2, r0, r3
    a9f0:	4a07      	ldr	r2, [pc, #28]	; (aa10 <l2cap_accept+0xbc>)
    a9f2:	605a      	str	r2, [r3, #4]
		*chan = &l2cap->chan.chan;
    a9f4:	600b      	str	r3, [r1, #0]
		return 0;
    a9f6:	e7ec      	b.n	a9d2 <l2cap_accept+0x7e>
	BT_ERR("No available L2CAP context for conn %p", conn);
    a9f8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    a9fc:	e7b8      	b.n	a970 <l2cap_accept+0x1c>
    a9fe:	f06f 0c1b 	mvn.w	ip, #27
    aa02:	e7c2      	b.n	a98a <l2cap_accept+0x36>
    aa04:	0001ec0c 	.word	0x0001ec0c
    aa08:	0001d014 	.word	0x0001d014
    aa0c:	20002300 	.word	0x20002300
    aa10:	0001ed7c 	.word	0x0001ed7c

0000aa14 <le_conn_param_rsp>:
	if (buf->len < sizeof(*rsp)) {
    aa14:	898b      	ldrh	r3, [r1, #12]
    aa16:	2b01      	cmp	r3, #1
    aa18:	d900      	bls.n	aa1c <le_conn_param_rsp+0x8>
    aa1a:	4770      	bx	lr
{
    aa1c:	b500      	push	{lr}
    aa1e:	b089      	sub	sp, #36	; 0x24
		BT_ERR("Too small LE conn param rsp");
    aa20:	4b13      	ldr	r3, [pc, #76]	; (aa70 <le_conn_param_rsp+0x5c>)
    aa22:	9307      	str	r3, [sp, #28]
    aa24:	2302      	movs	r3, #2
    aa26:	f88d 3004 	strb.w	r3, [sp, #4]
    aa2a:	2300      	movs	r3, #0
    aa2c:	f88d 3005 	strb.w	r3, [sp, #5]
    aa30:	f88d 3006 	strb.w	r3, [sp, #6]
    aa34:	f88d 3007 	strb.w	r3, [sp, #7]
    aa38:	9a01      	ldr	r2, [sp, #4]
    aa3a:	9206      	str	r2, [sp, #24]
    aa3c:	4619      	mov	r1, r3
    aa3e:	f363 0100 	bfi	r1, r3, #0, #1
    aa42:	f363 0141 	bfi	r1, r3, #1, #1
    aa46:	f363 0182 	bfi	r1, r3, #2, #1
    aa4a:	f363 01c5 	bfi	r1, r3, #3, #3
    aa4e:	2201      	movs	r2, #1
    aa50:	f362 1188 	bfi	r1, r2, #6, #3
    aa54:	2208      	movs	r2, #8
    aa56:	f362 2152 	bfi	r1, r2, #9, #10
    aa5a:	f363 41de 	bfi	r1, r3, #19, #12
    aa5e:	f363 71df 	bfi	r1, r3, #31, #1
    aa62:	aa06      	add	r2, sp, #24
    aa64:	4803      	ldr	r0, [pc, #12]	; (aa74 <le_conn_param_rsp+0x60>)
    aa66:	f7f7 fbef 	bl	2248 <z_impl_z_log_msg_static_create>
}
    aa6a:	b009      	add	sp, #36	; 0x24
    aa6c:	f85d fb04 	ldr.w	pc, [sp], #4
    aa70:	0001ec34 	.word	0x0001ec34
    aa74:	0001d014 	.word	0x0001d014

0000aa78 <l2cap_chan_add>:
{
    aa78:	b510      	push	{r4, lr}
    aa7a:	b088      	sub	sp, #32
	if (!le_chan) {
    aa7c:	b179      	cbz	r1, aa9e <l2cap_chan_add+0x26>
    aa7e:	460b      	mov	r3, r1
	atomic_clear(chan->status);
    aa80:	3110      	adds	r1, #16
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    aa82:	2400      	movs	r4, #0
    aa84:	e8d1 cfef 	ldaex	ip, [r1]
    aa88:	e8c1 4fee 	stlex	lr, r4, [r1]
    aa8c:	f1be 0f00 	cmp.w	lr, #0
    aa90:	d1f8      	bne.n	aa84 <l2cap_chan_add+0xc>
	bt_l2cap_chan_add(conn, chan, destroy);
    aa92:	4619      	mov	r1, r3
    aa94:	f00d fbf0 	bl	18278 <bt_l2cap_chan_add>
	return true;
    aa98:	2001      	movs	r0, #1
}
    aa9a:	b008      	add	sp, #32
    aa9c:	bd10      	pop	{r4, pc}
		BT_ERR("Unable to allocate L2CAP channel ID");
    aa9e:	4b14      	ldr	r3, [pc, #80]	; (aaf0 <l2cap_chan_add+0x78>)
    aaa0:	9307      	str	r3, [sp, #28]
    aaa2:	2302      	movs	r3, #2
    aaa4:	f88d 3004 	strb.w	r3, [sp, #4]
    aaa8:	2400      	movs	r4, #0
    aaaa:	f88d 4005 	strb.w	r4, [sp, #5]
    aaae:	f88d 4006 	strb.w	r4, [sp, #6]
    aab2:	f88d 4007 	strb.w	r4, [sp, #7]
    aab6:	9b01      	ldr	r3, [sp, #4]
    aab8:	9306      	str	r3, [sp, #24]
    aaba:	4621      	mov	r1, r4
    aabc:	f364 0100 	bfi	r1, r4, #0, #1
    aac0:	f364 0141 	bfi	r1, r4, #1, #1
    aac4:	f364 0182 	bfi	r1, r4, #2, #1
    aac8:	f364 01c5 	bfi	r1, r4, #3, #3
    aacc:	2301      	movs	r3, #1
    aace:	f363 1188 	bfi	r1, r3, #6, #3
    aad2:	2308      	movs	r3, #8
    aad4:	f363 2152 	bfi	r1, r3, #9, #10
    aad8:	f364 41de 	bfi	r1, r4, #19, #12
    aadc:	f364 71df 	bfi	r1, r4, #31, #1
    aae0:	4623      	mov	r3, r4
    aae2:	aa06      	add	r2, sp, #24
    aae4:	4803      	ldr	r0, [pc, #12]	; (aaf4 <l2cap_chan_add+0x7c>)
    aae6:	f7f7 fbaf 	bl	2248 <z_impl_z_log_msg_static_create>
		return false;
    aaea:	4620      	mov	r0, r4
    aaec:	e7d5      	b.n	aa9a <l2cap_chan_add+0x22>
    aaee:	bf00      	nop
    aaf0:	0001ec50 	.word	0x0001ec50
    aaf4:	0001d014 	.word	0x0001d014

0000aaf8 <bt_l2cap_connected>:
{
    aaf8:	b530      	push	{r4, r5, lr}
    aafa:	b083      	sub	sp, #12
    aafc:	4605      	mov	r5, r0
	STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
    aafe:	4c17      	ldr	r4, [pc, #92]	; (ab5c <bt_l2cap_connected+0x64>)
    ab00:	e000      	b.n	ab04 <bt_l2cap_connected+0xc>
    ab02:	340c      	adds	r4, #12
    ab04:	4b16      	ldr	r3, [pc, #88]	; (ab60 <bt_l2cap_connected+0x68>)
    ab06:	429c      	cmp	r4, r3
    ab08:	d226      	bcs.n	ab58 <bt_l2cap_connected+0x60>
		if (fchan->accept(conn, &chan) < 0) {
    ab0a:	6863      	ldr	r3, [r4, #4]
    ab0c:	a901      	add	r1, sp, #4
    ab0e:	4628      	mov	r0, r5
    ab10:	4798      	blx	r3
    ab12:	2800      	cmp	r0, #0
    ab14:	dbf5      	blt.n	ab02 <bt_l2cap_connected+0xa>
		le_chan = BT_L2CAP_LE_CHAN(chan);
    ab16:	9901      	ldr	r1, [sp, #4]
		le_chan->rx.cid = fchan->cid;
    ab18:	8823      	ldrh	r3, [r4, #0]
    ab1a:	828b      	strh	r3, [r1, #20]
		le_chan->tx.cid = fchan->cid;
    ab1c:	848b      	strh	r3, [r1, #36]	; 0x24
		if (!l2cap_chan_add(conn, chan, fchan->destroy)) {
    ab1e:	68a2      	ldr	r2, [r4, #8]
    ab20:	4628      	mov	r0, r5
    ab22:	f7ff ffa9 	bl	aa78 <l2cap_chan_add>
    ab26:	b1b8      	cbz	r0, ab58 <bt_l2cap_connected+0x60>
		if (chan->ops->connected) {
    ab28:	9801      	ldr	r0, [sp, #4]
    ab2a:	6843      	ldr	r3, [r0, #4]
    ab2c:	681b      	ldr	r3, [r3, #0]
    ab2e:	b103      	cbz	r3, ab32 <bt_l2cap_connected+0x3a>
			chan->ops->connected(chan);
    ab30:	4798      	blx	r3
		atomic_set_bit(chan->status, BT_L2CAP_STATUS_OUT);
    ab32:	9b01      	ldr	r3, [sp, #4]
    ab34:	3310      	adds	r3, #16
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    ab36:	e8d3 2fef 	ldaex	r2, [r3]
    ab3a:	f042 0201 	orr.w	r2, r2, #1
    ab3e:	e8c3 2fe1 	stlex	r1, r2, [r3]
    ab42:	2900      	cmp	r1, #0
    ab44:	d1f7      	bne.n	ab36 <bt_l2cap_connected+0x3e>
		if (chan->ops->status) {
    ab46:	9801      	ldr	r0, [sp, #4]
    ab48:	6843      	ldr	r3, [r0, #4]
    ab4a:	699b      	ldr	r3, [r3, #24]
    ab4c:	2b00      	cmp	r3, #0
    ab4e:	d0d8      	beq.n	ab02 <bt_l2cap_connected+0xa>
			chan->ops->status(chan, chan->status);
    ab50:	f100 0110 	add.w	r1, r0, #16
    ab54:	4798      	blx	r3
    ab56:	e7d4      	b.n	ab02 <bt_l2cap_connected+0xa>
}
    ab58:	b003      	add	sp, #12
    ab5a:	bd30      	pop	{r4, r5, pc}
    ab5c:	0001cf7c 	.word	0x0001cf7c
    ab60:	0001cfa0 	.word	0x0001cfa0

0000ab64 <l2cap_create_le_sig_pdu>:
{
    ab64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ab68:	b082      	sub	sp, #8
    ab6a:	af00      	add	r7, sp, #0
    ab6c:	460c      	mov	r4, r1
    ab6e:	4616      	mov	r6, r2
    ab70:	461d      	mov	r5, r3
	buf = bt_l2cap_create_pdu_timeout(pool, 0, L2CAP_RTX_TIMEOUT);
    ab72:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    ab76:	2300      	movs	r3, #0
    ab78:	2100      	movs	r1, #0
    ab7a:	4608      	mov	r0, r1
    ab7c:	f00d fbad 	bl	182da <bt_l2cap_create_pdu_timeout>
	if (!buf) {
    ab80:	4680      	mov	r8, r0
    ab82:	b158      	cbz	r0, ab9c <l2cap_create_le_sig_pdu+0x38>
	return net_buf_simple_add(&buf->b, len);
    ab84:	2104      	movs	r1, #4
    ab86:	3008      	adds	r0, #8
    ab88:	f00f fb39 	bl	1a1fe <net_buf_simple_add>
	hdr->code = code;
    ab8c:	7004      	strb	r4, [r0, #0]
	hdr->ident = ident;
    ab8e:	7046      	strb	r6, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
    ab90:	8045      	strh	r5, [r0, #2]
}
    ab92:	4640      	mov	r0, r8
    ab94:	3708      	adds	r7, #8
    ab96:	46bd      	mov	sp, r7
    ab98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
    ab9c:	466d      	mov	r5, sp
    ab9e:	b088      	sub	sp, #32
    aba0:	466b      	mov	r3, sp
    aba2:	f113 0210 	adds.w	r2, r3, #16
    aba6:	d02f      	beq.n	ac08 <l2cap_create_le_sig_pdu+0xa4>
    aba8:	210c      	movs	r1, #12
    abaa:	b11a      	cbz	r2, abb4 <l2cap_create_le_sig_pdu+0x50>
    abac:	2904      	cmp	r1, #4
    abae:	dd01      	ble.n	abb4 <l2cap_create_le_sig_pdu+0x50>
    abb0:	4818      	ldr	r0, [pc, #96]	; (ac14 <l2cap_create_le_sig_pdu+0xb0>)
    abb2:	6158      	str	r0, [r3, #20]
    abb4:	b112      	cbz	r2, abbc <l2cap_create_le_sig_pdu+0x58>
    abb6:	2908      	cmp	r1, #8
    abb8:	dd00      	ble.n	abbc <l2cap_create_le_sig_pdu+0x58>
    abba:	619c      	str	r4, [r3, #24]
    abbc:	290b      	cmp	r1, #11
    abbe:	dd26      	ble.n	ac0e <l2cap_create_le_sig_pdu+0xaa>
    abc0:	240c      	movs	r4, #12
    abc2:	b13a      	cbz	r2, abd4 <l2cap_create_le_sig_pdu+0x70>
    abc4:	2103      	movs	r1, #3
    abc6:	7139      	strb	r1, [r7, #4]
    abc8:	2100      	movs	r1, #0
    abca:	7179      	strb	r1, [r7, #5]
    abcc:	71b9      	strb	r1, [r7, #6]
    abce:	71f9      	strb	r1, [r7, #7]
    abd0:	6878      	ldr	r0, [r7, #4]
    abd2:	6118      	str	r0, [r3, #16]
    abd4:	2100      	movs	r1, #0
    abd6:	f36f 0100 	bfc	r1, #0, #1
    abda:	f36f 0141 	bfc	r1, #1, #1
    abde:	f36f 0182 	bfc	r1, #2, #1
    abe2:	f36f 01c5 	bfc	r1, #3, #3
    abe6:	2301      	movs	r3, #1
    abe8:	f363 1188 	bfi	r1, r3, #6, #3
    abec:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    abf0:	f364 2152 	bfi	r1, r4, #9, #10
    abf4:	f36f 41de 	bfc	r1, #19, #12
    abf8:	f36f 71df 	bfc	r1, #31, #1
    abfc:	2300      	movs	r3, #0
    abfe:	4806      	ldr	r0, [pc, #24]	; (ac18 <l2cap_create_le_sig_pdu+0xb4>)
    ac00:	f7f7 fb22 	bl	2248 <z_impl_z_log_msg_static_create>
    ac04:	46ad      	mov	sp, r5
		return NULL;
    ac06:	e7c4      	b.n	ab92 <l2cap_create_le_sig_pdu+0x2e>
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
    ac08:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    ac0c:	e7cd      	b.n	abaa <l2cap_create_le_sig_pdu+0x46>
    ac0e:	f06f 041b 	mvn.w	r4, #27
    ac12:	e7d6      	b.n	abc2 <l2cap_create_le_sig_pdu+0x5e>
    ac14:	0001ec74 	.word	0x0001ec74
    ac18:	0001d014 	.word	0x0001d014

0000ac1c <l2cap_recv>:
{
    ac1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ac1e:	b091      	sub	sp, #68	; 0x44
    ac20:	af02      	add	r7, sp, #8
	if (buf->len < sizeof(*hdr)) {
    ac22:	898b      	ldrh	r3, [r1, #12]
    ac24:	2b03      	cmp	r3, #3
    ac26:	d945      	bls.n	acb4 <l2cap_recv+0x98>
    ac28:	4606      	mov	r6, r0
    ac2a:	460c      	mov	r4, r1
	return net_buf_simple_pull_mem(&buf->b, len);
    ac2c:	2104      	movs	r1, #4
    ac2e:	f104 0008 	add.w	r0, r4, #8
    ac32:	f00f fb1c 	bl	1a26e <net_buf_simple_pull_mem>
    ac36:	4605      	mov	r5, r0
	len = sys_le16_to_cpu(hdr->len);
    ac38:	8841      	ldrh	r1, [r0, #2]
	if (buf->len != len) {
    ac3a:	89a0      	ldrh	r0, [r4, #12]
    ac3c:	4281      	cmp	r1, r0
    ac3e:	d065      	beq.n	ad0c <l2cap_recv+0xf0>
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
    ac40:	466d      	mov	r5, sp
    ac42:	b088      	sub	sp, #32
    ac44:	ab02      	add	r3, sp, #8
    ac46:	f113 0210 	adds.w	r2, r3, #16
    ac4a:	d059      	beq.n	ad00 <l2cap_recv+0xe4>
    ac4c:	2410      	movs	r4, #16
    ac4e:	b11a      	cbz	r2, ac58 <l2cap_recv+0x3c>
    ac50:	2c04      	cmp	r4, #4
    ac52:	dd01      	ble.n	ac58 <l2cap_recv+0x3c>
    ac54:	4e67      	ldr	r6, [pc, #412]	; (adf4 <l2cap_recv+0x1d8>)
    ac56:	615e      	str	r6, [r3, #20]
    ac58:	b112      	cbz	r2, ac60 <l2cap_recv+0x44>
    ac5a:	2c08      	cmp	r4, #8
    ac5c:	dd00      	ble.n	ac60 <l2cap_recv+0x44>
    ac5e:	6198      	str	r0, [r3, #24]
    ac60:	b112      	cbz	r2, ac68 <l2cap_recv+0x4c>
    ac62:	2c0c      	cmp	r4, #12
    ac64:	dd00      	ble.n	ac68 <l2cap_recv+0x4c>
    ac66:	61d9      	str	r1, [r3, #28]
    ac68:	2c0f      	cmp	r4, #15
    ac6a:	dd4c      	ble.n	ad06 <l2cap_recv+0xea>
    ac6c:	2410      	movs	r4, #16
    ac6e:	b13a      	cbz	r2, ac80 <l2cap_recv+0x64>
    ac70:	2104      	movs	r1, #4
    ac72:	7139      	strb	r1, [r7, #4]
    ac74:	2100      	movs	r1, #0
    ac76:	7179      	strb	r1, [r7, #5]
    ac78:	71b9      	strb	r1, [r7, #6]
    ac7a:	71f9      	strb	r1, [r7, #7]
    ac7c:	6878      	ldr	r0, [r7, #4]
    ac7e:	6118      	str	r0, [r3, #16]
    ac80:	2100      	movs	r1, #0
    ac82:	f36f 0100 	bfc	r1, #0, #1
    ac86:	f36f 0141 	bfc	r1, #1, #1
    ac8a:	f36f 0182 	bfc	r1, #2, #1
    ac8e:	f36f 01c5 	bfc	r1, #3, #3
    ac92:	2301      	movs	r3, #1
    ac94:	f363 1188 	bfi	r1, r3, #6, #3
    ac98:	f404 747d 	and.w	r4, r4, #1012	; 0x3f4
    ac9c:	f364 2152 	bfi	r1, r4, #9, #10
    aca0:	f36f 41de 	bfc	r1, #19, #12
    aca4:	f36f 71df 	bfc	r1, #31, #1
    aca8:	2300      	movs	r3, #0
    acaa:	4853      	ldr	r0, [pc, #332]	; (adf8 <l2cap_recv+0x1dc>)
    acac:	f7f7 facc 	bl	2248 <z_impl_z_log_msg_static_create>
    acb0:	46ad      	mov	sp, r5
		return 0;
    acb2:	e021      	b.n	acf8 <l2cap_recv+0xdc>
		BT_ERR("Too small L2CAP signaling PDU");
    acb4:	4b51      	ldr	r3, [pc, #324]	; (adfc <l2cap_recv+0x1e0>)
    acb6:	637b      	str	r3, [r7, #52]	; 0x34
    acb8:	2302      	movs	r3, #2
    acba:	713b      	strb	r3, [r7, #4]
    acbc:	2300      	movs	r3, #0
    acbe:	717b      	strb	r3, [r7, #5]
    acc0:	71bb      	strb	r3, [r7, #6]
    acc2:	71fb      	strb	r3, [r7, #7]
    acc4:	687a      	ldr	r2, [r7, #4]
    acc6:	633a      	str	r2, [r7, #48]	; 0x30
    acc8:	4619      	mov	r1, r3
    acca:	f363 0100 	bfi	r1, r3, #0, #1
    acce:	f363 0141 	bfi	r1, r3, #1, #1
    acd2:	f363 0182 	bfi	r1, r3, #2, #1
    acd6:	f363 01c5 	bfi	r1, r3, #3, #3
    acda:	2201      	movs	r2, #1
    acdc:	f362 1188 	bfi	r1, r2, #6, #3
    ace0:	2208      	movs	r2, #8
    ace2:	f362 2152 	bfi	r1, r2, #9, #10
    ace6:	f363 41de 	bfi	r1, r3, #19, #12
    acea:	f363 71df 	bfi	r1, r3, #31, #1
    acee:	f107 0230 	add.w	r2, r7, #48	; 0x30
    acf2:	4841      	ldr	r0, [pc, #260]	; (adf8 <l2cap_recv+0x1dc>)
    acf4:	f7f7 faa8 	bl	2248 <z_impl_z_log_msg_static_create>
}
    acf8:	2000      	movs	r0, #0
    acfa:	373c      	adds	r7, #60	; 0x3c
    acfc:	46bd      	mov	sp, r7
    acfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
    ad00:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
    ad04:	e7a3      	b.n	ac4e <l2cap_recv+0x32>
    ad06:	f06f 041b 	mvn.w	r4, #27
    ad0a:	e7b0      	b.n	ac6e <l2cap_recv+0x52>
	if (!hdr->ident) {
    ad0c:	786b      	ldrb	r3, [r5, #1]
    ad0e:	b14b      	cbz	r3, ad24 <l2cap_recv+0x108>
	switch (hdr->code) {
    ad10:	782b      	ldrb	r3, [r5, #0]
    ad12:	2b01      	cmp	r3, #1
    ad14:	d0f0      	beq.n	acf8 <l2cap_recv+0xdc>
    ad16:	2b13      	cmp	r3, #19
    ad18:	d127      	bne.n	ad6a <l2cap_recv+0x14e>
		le_conn_param_rsp(l2cap, buf);
    ad1a:	4621      	mov	r1, r4
    ad1c:	4630      	mov	r0, r6
    ad1e:	f7ff fe79 	bl	aa14 <le_conn_param_rsp>
		break;
    ad22:	e7e9      	b.n	acf8 <l2cap_recv+0xdc>
		BT_ERR("Invalid ident value in L2CAP PDU");
    ad24:	4b36      	ldr	r3, [pc, #216]	; (ae00 <l2cap_recv+0x1e4>)
    ad26:	61fb      	str	r3, [r7, #28]
    ad28:	2302      	movs	r3, #2
    ad2a:	713b      	strb	r3, [r7, #4]
    ad2c:	2300      	movs	r3, #0
    ad2e:	717b      	strb	r3, [r7, #5]
    ad30:	71bb      	strb	r3, [r7, #6]
    ad32:	71fb      	strb	r3, [r7, #7]
    ad34:	687a      	ldr	r2, [r7, #4]
    ad36:	61ba      	str	r2, [r7, #24]
    ad38:	4619      	mov	r1, r3
    ad3a:	f363 0100 	bfi	r1, r3, #0, #1
    ad3e:	f363 0141 	bfi	r1, r3, #1, #1
    ad42:	f363 0182 	bfi	r1, r3, #2, #1
    ad46:	f363 01c5 	bfi	r1, r3, #3, #3
    ad4a:	2201      	movs	r2, #1
    ad4c:	f362 1188 	bfi	r1, r2, #6, #3
    ad50:	2208      	movs	r2, #8
    ad52:	f362 2152 	bfi	r1, r2, #9, #10
    ad56:	f363 41de 	bfi	r1, r3, #19, #12
    ad5a:	f363 71df 	bfi	r1, r3, #31, #1
    ad5e:	f107 0218 	add.w	r2, r7, #24
    ad62:	4825      	ldr	r0, [pc, #148]	; (adf8 <l2cap_recv+0x1dc>)
    ad64:	f7f7 fa70 	bl	2248 <z_impl_z_log_msg_static_create>
		return 0;
    ad68:	e7c6      	b.n	acf8 <l2cap_recv+0xdc>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    ad6a:	466c      	mov	r4, sp
    ad6c:	b088      	sub	sp, #32
    ad6e:	a902      	add	r1, sp, #8
    ad70:	f111 0210 	adds.w	r2, r1, #16
    ad74:	d038      	beq.n	ade8 <l2cap_recv+0x1cc>
    ad76:	200c      	movs	r0, #12
    ad78:	b12a      	cbz	r2, ad86 <l2cap_recv+0x16a>
    ad7a:	2804      	cmp	r0, #4
    ad7c:	dd03      	ble.n	ad86 <l2cap_recv+0x16a>
    ad7e:	f8df c084 	ldr.w	ip, [pc, #132]	; ae04 <l2cap_recv+0x1e8>
    ad82:	f8c1 c014 	str.w	ip, [r1, #20]
    ad86:	b112      	cbz	r2, ad8e <l2cap_recv+0x172>
    ad88:	2808      	cmp	r0, #8
    ad8a:	dd00      	ble.n	ad8e <l2cap_recv+0x172>
    ad8c:	618b      	str	r3, [r1, #24]
    ad8e:	280b      	cmp	r0, #11
    ad90:	dd2d      	ble.n	adee <l2cap_recv+0x1d2>
    ad92:	230c      	movs	r3, #12
    ad94:	b13a      	cbz	r2, ada6 <l2cap_recv+0x18a>
    ad96:	2003      	movs	r0, #3
    ad98:	7138      	strb	r0, [r7, #4]
    ad9a:	2000      	movs	r0, #0
    ad9c:	7178      	strb	r0, [r7, #5]
    ad9e:	71b8      	strb	r0, [r7, #6]
    ada0:	71f8      	strb	r0, [r7, #7]
    ada2:	6878      	ldr	r0, [r7, #4]
    ada4:	6108      	str	r0, [r1, #16]
    ada6:	2100      	movs	r1, #0
    ada8:	f36f 0100 	bfc	r1, #0, #1
    adac:	f36f 0141 	bfc	r1, #1, #1
    adb0:	f36f 0182 	bfc	r1, #2, #1
    adb4:	f36f 01c5 	bfc	r1, #3, #3
    adb8:	2002      	movs	r0, #2
    adba:	f360 1188 	bfi	r1, r0, #6, #3
    adbe:	f403 737b 	and.w	r3, r3, #1004	; 0x3ec
    adc2:	f363 2152 	bfi	r1, r3, #9, #10
    adc6:	f36f 41de 	bfc	r1, #19, #12
    adca:	f36f 71df 	bfc	r1, #31, #1
    adce:	2300      	movs	r3, #0
    add0:	4809      	ldr	r0, [pc, #36]	; (adf8 <l2cap_recv+0x1dc>)
    add2:	f7f7 fa39 	bl	2248 <z_impl_z_log_msg_static_create>
    add6:	46a5      	mov	sp, r4
		l2cap_send_reject(chan->conn, hdr->ident,
    add8:	7869      	ldrb	r1, [r5, #1]
    adda:	6830      	ldr	r0, [r6, #0]
    addc:	2200      	movs	r2, #0
    adde:	9200      	str	r2, [sp, #0]
    ade0:	4613      	mov	r3, r2
    ade2:	f00d fa94 	bl	1830e <l2cap_send_reject>
		break;
    ade6:	e787      	b.n	acf8 <l2cap_recv+0xdc>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
    ade8:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    adec:	e7c4      	b.n	ad78 <l2cap_recv+0x15c>
    adee:	f06f 031b 	mvn.w	r3, #27
    adf2:	e7cf      	b.n	ad94 <l2cap_recv+0x178>
    adf4:	0001ecbc 	.word	0x0001ecbc
    adf8:	0001d014 	.word	0x0001d014
    adfc:	0001ec9c 	.word	0x0001ec9c
    ae00:	0001ece0 	.word	0x0001ece0
    ae04:	0001ed04 	.word	0x0001ed04

0000ae08 <bt_l2cap_recv>:
{
    ae08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ae0c:	b088      	sub	sp, #32
    ae0e:	af00      	add	r7, sp, #0
    ae10:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
    ae12:	898b      	ldrh	r3, [r1, #12]
    ae14:	2b03      	cmp	r3, #3
    ae16:	d915      	bls.n	ae44 <bt_l2cap_recv+0x3c>
    ae18:	4606      	mov	r6, r0
    ae1a:	4615      	mov	r5, r2
    ae1c:	2104      	movs	r1, #4
    ae1e:	f104 0008 	add.w	r0, r4, #8
    ae22:	f00f fa24 	bl	1a26e <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
    ae26:	f8b0 8002 	ldrh.w	r8, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
    ae2a:	4641      	mov	r1, r8
    ae2c:	4630      	mov	r0, r6
    ae2e:	f00d fa9b 	bl	18368 <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    ae32:	b368      	cbz	r0, ae90 <bt_l2cap_recv+0x88>
	l2cap_chan_recv(chan, buf, complete);
    ae34:	462a      	mov	r2, r5
    ae36:	4621      	mov	r1, r4
    ae38:	f00d fa02 	bl	18240 <l2cap_chan_recv>
}
    ae3c:	3720      	adds	r7, #32
    ae3e:	46bd      	mov	sp, r7
    ae40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("Too small L2CAP PDU received");
    ae44:	4b32      	ldr	r3, [pc, #200]	; (af10 <bt_l2cap_recv+0x108>)
    ae46:	61fb      	str	r3, [r7, #28]
    ae48:	2302      	movs	r3, #2
    ae4a:	713b      	strb	r3, [r7, #4]
    ae4c:	2300      	movs	r3, #0
    ae4e:	717b      	strb	r3, [r7, #5]
    ae50:	71bb      	strb	r3, [r7, #6]
    ae52:	71fb      	strb	r3, [r7, #7]
    ae54:	687a      	ldr	r2, [r7, #4]
    ae56:	61ba      	str	r2, [r7, #24]
    ae58:	4619      	mov	r1, r3
    ae5a:	f363 0100 	bfi	r1, r3, #0, #1
    ae5e:	f363 0141 	bfi	r1, r3, #1, #1
    ae62:	f363 0182 	bfi	r1, r3, #2, #1
    ae66:	f363 01c5 	bfi	r1, r3, #3, #3
    ae6a:	2201      	movs	r2, #1
    ae6c:	f362 1188 	bfi	r1, r2, #6, #3
    ae70:	2208      	movs	r2, #8
    ae72:	f362 2152 	bfi	r1, r2, #9, #10
    ae76:	f363 41de 	bfi	r1, r3, #19, #12
    ae7a:	f363 71df 	bfi	r1, r3, #31, #1
    ae7e:	f107 0218 	add.w	r2, r7, #24
    ae82:	4824      	ldr	r0, [pc, #144]	; (af14 <bt_l2cap_recv+0x10c>)
    ae84:	f7f7 f9e0 	bl	2248 <z_impl_z_log_msg_static_create>
		net_buf_unref(buf);
    ae88:	4620      	mov	r0, r4
    ae8a:	f00f f96e 	bl	1a16a <net_buf_unref>
		return;
    ae8e:	e7d5      	b.n	ae3c <bt_l2cap_recv+0x34>
		BT_WARN("Ignoring data for unknown channel ID 0x%04x", cid);
    ae90:	466e      	mov	r6, sp
    ae92:	b088      	sub	sp, #32
    ae94:	466b      	mov	r3, sp
    ae96:	f113 0210 	adds.w	r2, r3, #16
    ae9a:	d033      	beq.n	af04 <bt_l2cap_recv+0xfc>
    ae9c:	210c      	movs	r1, #12
    ae9e:	b11a      	cbz	r2, aea8 <bt_l2cap_recv+0xa0>
    aea0:	2904      	cmp	r1, #4
    aea2:	dd01      	ble.n	aea8 <bt_l2cap_recv+0xa0>
    aea4:	481c      	ldr	r0, [pc, #112]	; (af18 <bt_l2cap_recv+0x110>)
    aea6:	6158      	str	r0, [r3, #20]
    aea8:	b11a      	cbz	r2, aeb2 <bt_l2cap_recv+0xaa>
    aeaa:	2908      	cmp	r1, #8
    aeac:	dd01      	ble.n	aeb2 <bt_l2cap_recv+0xaa>
    aeae:	f8c3 8018 	str.w	r8, [r3, #24]
    aeb2:	290b      	cmp	r1, #11
    aeb4:	dd29      	ble.n	af0a <bt_l2cap_recv+0x102>
    aeb6:	250c      	movs	r5, #12
    aeb8:	b13a      	cbz	r2, aeca <bt_l2cap_recv+0xc2>
    aeba:	2103      	movs	r1, #3
    aebc:	7139      	strb	r1, [r7, #4]
    aebe:	2100      	movs	r1, #0
    aec0:	7179      	strb	r1, [r7, #5]
    aec2:	71b9      	strb	r1, [r7, #6]
    aec4:	71f9      	strb	r1, [r7, #7]
    aec6:	6878      	ldr	r0, [r7, #4]
    aec8:	6118      	str	r0, [r3, #16]
    aeca:	2100      	movs	r1, #0
    aecc:	f36f 0100 	bfc	r1, #0, #1
    aed0:	f36f 0141 	bfc	r1, #1, #1
    aed4:	f36f 0182 	bfc	r1, #2, #1
    aed8:	f36f 01c5 	bfc	r1, #3, #3
    aedc:	2302      	movs	r3, #2
    aede:	f363 1188 	bfi	r1, r3, #6, #3
    aee2:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    aee6:	f365 2152 	bfi	r1, r5, #9, #10
    aeea:	f36f 41de 	bfc	r1, #19, #12
    aeee:	f36f 71df 	bfc	r1, #31, #1
    aef2:	2300      	movs	r3, #0
    aef4:	4807      	ldr	r0, [pc, #28]	; (af14 <bt_l2cap_recv+0x10c>)
    aef6:	f7f7 f9a7 	bl	2248 <z_impl_z_log_msg_static_create>
    aefa:	46b5      	mov	sp, r6
		net_buf_unref(buf);
    aefc:	4620      	mov	r0, r4
    aefe:	f00f f934 	bl	1a16a <net_buf_unref>
		return;
    af02:	e79b      	b.n	ae3c <bt_l2cap_recv+0x34>
		BT_WARN("Ignoring data for unknown channel ID 0x%04x", cid);
    af04:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    af08:	e7c9      	b.n	ae9e <bt_l2cap_recv+0x96>
    af0a:	f06f 051b 	mvn.w	r5, #27
    af0e:	e7d3      	b.n	aeb8 <bt_l2cap_recv+0xb0>
    af10:	0001ed24 	.word	0x0001ed24
    af14:	0001d014 	.word	0x0001d014
    af18:	0001ed44 	.word	0x0001ed44

0000af1c <att_cb>:

	chan_unknown(conn, user_data, err);
}

static bt_conn_tx_cb_t att_cb(const struct net_buf *buf)
{
    af1c:	b508      	push	{r3, lr}
	const att_type_t op_type = att_op_get_type(buf->data[0]);
    af1e:	6883      	ldr	r3, [r0, #8]
    af20:	7818      	ldrb	r0, [r3, #0]
    af22:	f00d faad 	bl	18480 <att_op_get_type>

	switch (op_type) {
    af26:	2805      	cmp	r0, #5
    af28:	d80a      	bhi.n	af40 <att_cb+0x24>
    af2a:	e8df f000 	tbb	[pc, r0]
    af2e:	0507      	.short	0x0507
    af30:	050b0703 	.word	0x050b0703
    af34:	4804      	ldr	r0, [pc, #16]	; (af48 <att_cb+0x2c>)
    af36:	e000      	b.n	af3a <att_cb+0x1e>
		return att_rsp_sent;
	case ATT_CONFIRMATION:
		return att_cfm_sent;
	case ATT_REQUEST:
	case ATT_INDICATION:
		return att_req_sent;
    af38:	4804      	ldr	r0, [pc, #16]	; (af4c <att_cb+0x30>)
	default:
		__ASSERT(false, "Unknown op type 0x%02X", op_type);
	}

	return att_unknown;
}
    af3a:	bd08      	pop	{r3, pc}
		return att_tx_complete;
    af3c:	4804      	ldr	r0, [pc, #16]	; (af50 <att_cb+0x34>)
    af3e:	e7fc      	b.n	af3a <att_cb+0x1e>
	return att_unknown;
    af40:	4804      	ldr	r0, [pc, #16]	; (af54 <att_cb+0x38>)
    af42:	e7fa      	b.n	af3a <att_cb+0x1e>
		return att_cfm_sent;
    af44:	4804      	ldr	r0, [pc, #16]	; (af58 <att_cb+0x3c>)
    af46:	e7f8      	b.n	af3a <att_cb+0x1e>
    af48:	00018c7d 	.word	0x00018c7d
    af4c:	00018c45 	.word	0x00018c45
    af50:	00018c29 	.word	0x00018c29
    af54:	00018c0d 	.word	0x00018c0d
    af58:	00018c61 	.word	0x00018c61

0000af5c <tx_meta_data_alloc>:
{
    af5c:	b508      	push	{r3, lr}
    af5e:	4602      	mov	r2, r0
    af60:	460b      	mov	r3, r1
	return z_impl_k_queue_get(queue, timeout);
    af62:	4802      	ldr	r0, [pc, #8]	; (af6c <tx_meta_data_alloc+0x10>)
    af64:	f008 fdda 	bl	13b1c <z_impl_k_queue_get>
}
    af68:	bd08      	pop	{r3, pc}
    af6a:	bf00      	nop
    af6c:	20000654 	.word	0x20000654

0000af70 <att_get>:

	return 0;
}

static struct bt_att *att_get(struct bt_conn *conn)
{
    af70:	b510      	push	{r4, lr}
    af72:	b08e      	sub	sp, #56	; 0x38
	struct bt_l2cap_chan *chan;
	struct bt_att_chan *att_chan;

	if (conn->state != BT_CONN_CONNECTED) {
    af74:	7a83      	ldrb	r3, [r0, #10]
    af76:	2b07      	cmp	r3, #7
    af78:	d109      	bne.n	af8e <att_get+0x1e>
		BT_WARN("Not connected");
		return NULL;
	}

	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
    af7a:	2104      	movs	r1, #4
    af7c:	f00d f9f4 	bl	18368 <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
    af80:	4604      	mov	r4, r0
    af82:	b350      	cbz	r0, afda <att_get+0x6a>

	att_chan = ATT_CHAN(chan);
	__ASSERT(atomic_test_bit(att_chan->flags, ATT_CONNECTED),
		 "ATT channel not connected");

	return att_chan->att;
    af84:	f850 4c04 	ldr.w	r4, [r0, #-4]
}
    af88:	4620      	mov	r0, r4
    af8a:	b00e      	add	sp, #56	; 0x38
    af8c:	bd10      	pop	{r4, pc}
		BT_WARN("Not connected");
    af8e:	4b26      	ldr	r3, [pc, #152]	; (b028 <att_get+0xb8>)
    af90:	930d      	str	r3, [sp, #52]	; 0x34
    af92:	2302      	movs	r3, #2
    af94:	f88d 3004 	strb.w	r3, [sp, #4]
    af98:	2400      	movs	r4, #0
    af9a:	f88d 4005 	strb.w	r4, [sp, #5]
    af9e:	f88d 4006 	strb.w	r4, [sp, #6]
    afa2:	f88d 4007 	strb.w	r4, [sp, #7]
    afa6:	9a01      	ldr	r2, [sp, #4]
    afa8:	920c      	str	r2, [sp, #48]	; 0x30
    afaa:	4621      	mov	r1, r4
    afac:	f364 0100 	bfi	r1, r4, #0, #1
    afb0:	f364 0141 	bfi	r1, r4, #1, #1
    afb4:	f364 0182 	bfi	r1, r4, #2, #1
    afb8:	f364 01c5 	bfi	r1, r4, #3, #3
    afbc:	f363 1188 	bfi	r1, r3, #6, #3
    afc0:	2308      	movs	r3, #8
    afc2:	f363 2152 	bfi	r1, r3, #9, #10
    afc6:	f364 41de 	bfi	r1, r4, #19, #12
    afca:	f364 71df 	bfi	r1, r4, #31, #1
    afce:	4623      	mov	r3, r4
    afd0:	aa0c      	add	r2, sp, #48	; 0x30
    afd2:	4816      	ldr	r0, [pc, #88]	; (b02c <att_get+0xbc>)
    afd4:	f7f7 f938 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    afd8:	e7d6      	b.n	af88 <att_get+0x18>
		BT_ERR("Unable to find ATT channel");
    afda:	4b15      	ldr	r3, [pc, #84]	; (b030 <att_get+0xc0>)
    afdc:	9307      	str	r3, [sp, #28]
    afde:	2302      	movs	r3, #2
    afe0:	f88d 3004 	strb.w	r3, [sp, #4]
    afe4:	2300      	movs	r3, #0
    afe6:	f88d 3005 	strb.w	r3, [sp, #5]
    afea:	f88d 3006 	strb.w	r3, [sp, #6]
    afee:	f88d 3007 	strb.w	r3, [sp, #7]
    aff2:	9a01      	ldr	r2, [sp, #4]
    aff4:	9206      	str	r2, [sp, #24]
    aff6:	4619      	mov	r1, r3
    aff8:	f363 0100 	bfi	r1, r3, #0, #1
    affc:	f363 0141 	bfi	r1, r3, #1, #1
    b000:	f363 0182 	bfi	r1, r3, #2, #1
    b004:	f363 01c5 	bfi	r1, r3, #3, #3
    b008:	2201      	movs	r2, #1
    b00a:	f362 1188 	bfi	r1, r2, #6, #3
    b00e:	2208      	movs	r2, #8
    b010:	f362 2152 	bfi	r1, r2, #9, #10
    b014:	f363 41de 	bfi	r1, r3, #19, #12
    b018:	f363 71df 	bfi	r1, r3, #31, #1
    b01c:	aa06      	add	r2, sp, #24
    b01e:	4803      	ldr	r0, [pc, #12]	; (b02c <att_get+0xbc>)
    b020:	f7f7 f912 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    b024:	e7b0      	b.n	af88 <att_get+0x18>
    b026:	bf00      	nop
    b028:	0001eda0 	.word	0x0001eda0
    b02c:	0001cfd4 	.word	0x0001cfd4
    b030:	0001edb0 	.word	0x0001edb0

0000b034 <att_chan_new>:
	att_chan_mtu_updated(att_chan);
}
#endif /* CONFIG_BT_EATT */

static struct bt_att_chan *att_chan_new(struct bt_att *att, atomic_val_t flags)
{
    b034:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    b038:	b082      	sub	sp, #8
    b03a:	af00      	add	r7, sp, #0
    b03c:	4606      	mov	r6, r0
    b03e:	4688      	mov	r8, r1
	return list->head;
    b040:	6a43      	ldr	r3, [r0, #36]	; 0x24
		.reconfigured = bt_att_reconfigured,
	#endif /* CONFIG_BT_EATT */
	};
	struct bt_att_chan *chan;

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
    b042:	b103      	cbz	r3, b046 <att_chan_new+0x12>
    b044:	3be0      	subs	r3, #224	; 0xe0
    b046:	607b      	str	r3, [r7, #4]
	int quota = 0;
    b048:	2500      	movs	r5, #0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
    b04a:	e03f      	b.n	b0cc <att_chan_new+0x98>
		if (chan->att == att) {
			quota++;
    b04c:	3501      	adds	r5, #1
    b04e:	e042      	b.n	b0d6 <att_chan_new+0xa2>
		}

		if (quota == ATT_CHAN_MAX) {
			BT_WARN("Maximum number of channels reached: %d", quota);
    b050:	466e      	mov	r6, sp
    b052:	b088      	sub	sp, #32
    b054:	466b      	mov	r3, sp
    b056:	f113 0210 	adds.w	r2, r3, #16
    b05a:	d030      	beq.n	b0be <att_chan_new+0x8a>
    b05c:	210c      	movs	r1, #12
    b05e:	b11a      	cbz	r2, b068 <att_chan_new+0x34>
    b060:	2904      	cmp	r1, #4
    b062:	dd01      	ble.n	b068 <att_chan_new+0x34>
    b064:	4853      	ldr	r0, [pc, #332]	; (b1b4 <att_chan_new+0x180>)
    b066:	6158      	str	r0, [r3, #20]
    b068:	b112      	cbz	r2, b070 <att_chan_new+0x3c>
    b06a:	2908      	cmp	r1, #8
    b06c:	dd00      	ble.n	b070 <att_chan_new+0x3c>
    b06e:	619d      	str	r5, [r3, #24]
    b070:	290b      	cmp	r1, #11
    b072:	dd27      	ble.n	b0c4 <att_chan_new+0x90>
    b074:	240c      	movs	r4, #12
    b076:	b13a      	cbz	r2, b088 <att_chan_new+0x54>
    b078:	2103      	movs	r1, #3
    b07a:	7039      	strb	r1, [r7, #0]
    b07c:	2100      	movs	r1, #0
    b07e:	7079      	strb	r1, [r7, #1]
    b080:	70b9      	strb	r1, [r7, #2]
    b082:	70f9      	strb	r1, [r7, #3]
    b084:	6838      	ldr	r0, [r7, #0]
    b086:	6118      	str	r0, [r3, #16]
    b088:	2100      	movs	r1, #0
    b08a:	f36f 0100 	bfc	r1, #0, #1
    b08e:	f36f 0141 	bfc	r1, #1, #1
    b092:	f36f 0182 	bfc	r1, #2, #1
    b096:	f36f 01c5 	bfc	r1, #3, #3
    b09a:	2302      	movs	r3, #2
    b09c:	f363 1188 	bfi	r1, r3, #6, #3
    b0a0:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    b0a4:	f364 2152 	bfi	r1, r4, #9, #10
    b0a8:	f36f 41de 	bfc	r1, #19, #12
    b0ac:	f36f 71df 	bfc	r1, #31, #1
    b0b0:	2300      	movs	r3, #0
    b0b2:	4841      	ldr	r0, [pc, #260]	; (b1b8 <att_chan_new+0x184>)
    b0b4:	f7f7 f8c8 	bl	2248 <z_impl_z_log_msg_static_create>
    b0b8:	46b5      	mov	sp, r6
			return NULL;
    b0ba:	2400      	movs	r4, #0
    b0bc:	e037      	b.n	b12e <att_chan_new+0xfa>
			BT_WARN("Maximum number of channels reached: %d", quota);
    b0be:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    b0c2:	e7cc      	b.n	b05e <att_chan_new+0x2a>
    b0c4:	f06f 041b 	mvn.w	r4, #27
    b0c8:	e7d5      	b.n	b076 <att_chan_new+0x42>
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
    b0ca:	607b      	str	r3, [r7, #4]
    b0cc:	687c      	ldr	r4, [r7, #4]
    b0ce:	b16c      	cbz	r4, b0ec <att_chan_new+0xb8>
		if (chan->att == att) {
    b0d0:	6823      	ldr	r3, [r4, #0]
    b0d2:	42b3      	cmp	r3, r6
    b0d4:	d0ba      	beq.n	b04c <att_chan_new+0x18>
		if (quota == ATT_CHAN_MAX) {
    b0d6:	2d01      	cmp	r5, #1
    b0d8:	d0ba      	beq.n	b050 <att_chan_new+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
    b0da:	f114 03e0 	adds.w	r3, r4, #224	; 0xe0
    b0de:	d0f4      	beq.n	b0ca <att_chan_new+0x96>
	return node->next;
    b0e0:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
    b0e4:	2b00      	cmp	r3, #0
    b0e6:	d0f0      	beq.n	b0ca <att_chan_new+0x96>
    b0e8:	3be0      	subs	r3, #224	; 0xe0
    b0ea:	e7ee      	b.n	b0ca <att_chan_new+0x96>
		}
	}

	if (k_mem_slab_alloc(&chan_slab, (void **)&chan, K_NO_WAIT)) {
    b0ec:	2200      	movs	r2, #0
    b0ee:	2300      	movs	r3, #0
    b0f0:	1d39      	adds	r1, r7, #4
    b0f2:	4832      	ldr	r0, [pc, #200]	; (b1bc <att_chan_new+0x188>)
    b0f4:	f008 fb0a 	bl	1370c <k_mem_slab_alloc>
    b0f8:	b9f0      	cbnz	r0, b138 <att_chan_new+0x104>
		BT_WARN("No available ATT channel for conn %p", att->conn);
		return NULL;
	}

	(void)memset(chan, 0, sizeof(*chan));
    b0fa:	22e8      	movs	r2, #232	; 0xe8
    b0fc:	2100      	movs	r1, #0
    b0fe:	6878      	ldr	r0, [r7, #4]
    b100:	f00c fb45 	bl	1778e <memset>
	chan->chan.chan.ops = &ops;
    b104:	6878      	ldr	r0, [r7, #4]
    b106:	4b2e      	ldr	r3, [pc, #184]	; (b1c0 <att_chan_new+0x18c>)
    b108:	6083      	str	r3, [r0, #8]
	k_fifo_init(&chan->tx_queue);
    b10a:	3098      	adds	r0, #152	; 0x98
	z_impl_k_queue_init(queue);
    b10c:	f011 f820 	bl	1c150 <z_impl_k_queue_init>
	atomic_set(chan->flags, flags);
    b110:	687b      	ldr	r3, [r7, #4]
    b112:	3390      	adds	r3, #144	; 0x90
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    b114:	e8d3 2fef 	ldaex	r2, [r3]
    b118:	e8c3 8fe1 	stlex	r1, r8, [r3]
    b11c:	2900      	cmp	r1, #0
    b11e:	d1f9      	bne.n	b114 <att_chan_new+0xe0>
	chan->att = att;
    b120:	687b      	ldr	r3, [r7, #4]
    b122:	601e      	str	r6, [r3, #0]
	att_chan_attach(att, chan);
    b124:	6879      	ldr	r1, [r7, #4]
    b126:	4630      	mov	r0, r6
    b128:	f00d fa2b 	bl	18582 <att_chan_attach>

	return chan;
    b12c:	687c      	ldr	r4, [r7, #4]
}
    b12e:	4620      	mov	r0, r4
    b130:	3708      	adds	r7, #8
    b132:	46bd      	mov	sp, r7
    b134:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_WARN("No available ATT channel for conn %p", att->conn);
    b138:	6830      	ldr	r0, [r6, #0]
    b13a:	466e      	mov	r6, sp
    b13c:	b088      	sub	sp, #32
    b13e:	466b      	mov	r3, sp
    b140:	f113 0210 	adds.w	r2, r3, #16
    b144:	d02f      	beq.n	b1a6 <att_chan_new+0x172>
    b146:	210c      	movs	r1, #12
    b148:	b11a      	cbz	r2, b152 <att_chan_new+0x11e>
    b14a:	2904      	cmp	r1, #4
    b14c:	dd01      	ble.n	b152 <att_chan_new+0x11e>
    b14e:	4d1d      	ldr	r5, [pc, #116]	; (b1c4 <att_chan_new+0x190>)
    b150:	615d      	str	r5, [r3, #20]
    b152:	b112      	cbz	r2, b15a <att_chan_new+0x126>
    b154:	2908      	cmp	r1, #8
    b156:	dd00      	ble.n	b15a <att_chan_new+0x126>
    b158:	6198      	str	r0, [r3, #24]
    b15a:	290b      	cmp	r1, #11
    b15c:	dd26      	ble.n	b1ac <att_chan_new+0x178>
    b15e:	250c      	movs	r5, #12
    b160:	b13a      	cbz	r2, b172 <att_chan_new+0x13e>
    b162:	2103      	movs	r1, #3
    b164:	7039      	strb	r1, [r7, #0]
    b166:	2100      	movs	r1, #0
    b168:	7079      	strb	r1, [r7, #1]
    b16a:	70b9      	strb	r1, [r7, #2]
    b16c:	70f9      	strb	r1, [r7, #3]
    b16e:	6838      	ldr	r0, [r7, #0]
    b170:	6118      	str	r0, [r3, #16]
    b172:	2100      	movs	r1, #0
    b174:	f36f 0100 	bfc	r1, #0, #1
    b178:	f36f 0141 	bfc	r1, #1, #1
    b17c:	f36f 0182 	bfc	r1, #2, #1
    b180:	f36f 01c5 	bfc	r1, #3, #3
    b184:	2302      	movs	r3, #2
    b186:	f363 1188 	bfi	r1, r3, #6, #3
    b18a:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    b18e:	f365 2152 	bfi	r1, r5, #9, #10
    b192:	f36f 41de 	bfc	r1, #19, #12
    b196:	f36f 71df 	bfc	r1, #31, #1
    b19a:	2300      	movs	r3, #0
    b19c:	4806      	ldr	r0, [pc, #24]	; (b1b8 <att_chan_new+0x184>)
    b19e:	f7f7 f853 	bl	2248 <z_impl_z_log_msg_static_create>
    b1a2:	46b5      	mov	sp, r6
		return NULL;
    b1a4:	e7c3      	b.n	b12e <att_chan_new+0xfa>
		BT_WARN("No available ATT channel for conn %p", att->conn);
    b1a6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    b1aa:	e7cd      	b.n	b148 <att_chan_new+0x114>
    b1ac:	f06f 051b 	mvn.w	r5, #27
    b1b0:	e7d6      	b.n	b160 <att_chan_new+0x12c>
    b1b2:	bf00      	nop
    b1b4:	0001edcc 	.word	0x0001edcc
    b1b8:	0001cfd4 	.word	0x0001cfd4
    b1bc:	20000588 	.word	0x20000588
    b1c0:	20000274 	.word	0x20000274
    b1c4:	0001edf4 	.word	0x0001edf4

0000b1c8 <bt_att_accept>:

}
#endif /* CONFIG_BT_EATT */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **ch)
{
    b1c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    b1ca:	b083      	sub	sp, #12
    b1cc:	af00      	add	r7, sp, #0
    b1ce:	4606      	mov	r6, r0
    b1d0:	460c      	mov	r4, r1
	struct bt_att *att;
	struct bt_att_chan *chan;

	BT_DBG("conn %p handle %u", conn, conn->handle);

	if (k_mem_slab_alloc(&att_slab, (void **)&att, K_NO_WAIT)) {
    b1d2:	2200      	movs	r2, #0
    b1d4:	2300      	movs	r3, #0
    b1d6:	1d39      	adds	r1, r7, #4
    b1d8:	4830      	ldr	r0, [pc, #192]	; (b29c <bt_att_accept+0xd4>)
    b1da:	f008 fa97 	bl	1370c <k_mem_slab_alloc>
    b1de:	b9e0      	cbnz	r0, b21a <bt_att_accept+0x52>
    b1e0:	4605      	mov	r5, r0
	return z_impl_z_current_get();
    b1e2:	f009 facd 	bl	14780 <z_impl_z_current_get>
		BT_ERR("No available ATT context for conn %p", conn);
		return -ENOMEM;
	}

	att_handle_rsp_thread = k_current_get();
    b1e6:	4b2e      	ldr	r3, [pc, #184]	; (b2a0 <bt_att_accept+0xd8>)
    b1e8:	6018      	str	r0, [r3, #0]

	(void)memset(att, 0, sizeof(*att));
    b1ea:	222c      	movs	r2, #44	; 0x2c
    b1ec:	2100      	movs	r1, #0
    b1ee:	6878      	ldr	r0, [r7, #4]
    b1f0:	f00c facd 	bl	1778e <memset>
	att->conn = conn;
    b1f4:	687b      	ldr	r3, [r7, #4]
    b1f6:	601e      	str	r6, [r3, #0]
	sys_slist_init(&att->reqs);
    b1f8:	6878      	ldr	r0, [r7, #4]
	list->head = NULL;
    b1fa:	2100      	movs	r1, #0
    b1fc:	6041      	str	r1, [r0, #4]
	list->tail = NULL;
    b1fe:	6081      	str	r1, [r0, #8]
	list->head = NULL;
    b200:	6241      	str	r1, [r0, #36]	; 0x24
	list->tail = NULL;
    b202:	6281      	str	r1, [r0, #40]	; 0x28
#if defined(CONFIG_BT_EATT)
	k_work_init_delayable(&att->eatt.connection_work,
			      att_enhanced_connection_work_handler);
#endif /* CONFIG_BT_EATT */

	chan = att_chan_new(att, 0);
    b204:	f7ff ff16 	bl	b034 <att_chan_new>
	if (!chan) {
    b208:	4603      	mov	r3, r0
    b20a:	2800      	cmp	r0, #0
    b20c:	d043      	beq.n	b296 <bt_att_accept+0xce>
		return -ENOMEM;
	}

	*ch = &chan->chan.chan;
    b20e:	3304      	adds	r3, #4
    b210:	6023      	str	r3, [r4, #0]

	return 0;
}
    b212:	4628      	mov	r0, r5
    b214:	370c      	adds	r7, #12
    b216:	46bd      	mov	sp, r7
    b218:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("No available ATT context for conn %p", conn);
    b21a:	466d      	mov	r5, sp
    b21c:	b088      	sub	sp, #32
    b21e:	466b      	mov	r3, sp
    b220:	f113 0210 	adds.w	r2, r3, #16
    b224:	d031      	beq.n	b28a <bt_att_accept+0xc2>
    b226:	210c      	movs	r1, #12
    b228:	b11a      	cbz	r2, b232 <bt_att_accept+0x6a>
    b22a:	2904      	cmp	r1, #4
    b22c:	dd01      	ble.n	b232 <bt_att_accept+0x6a>
    b22e:	481d      	ldr	r0, [pc, #116]	; (b2a4 <bt_att_accept+0xdc>)
    b230:	6158      	str	r0, [r3, #20]
    b232:	b112      	cbz	r2, b23a <bt_att_accept+0x72>
    b234:	2908      	cmp	r1, #8
    b236:	dd00      	ble.n	b23a <bt_att_accept+0x72>
    b238:	619e      	str	r6, [r3, #24]
    b23a:	290b      	cmp	r1, #11
    b23c:	dd28      	ble.n	b290 <bt_att_accept+0xc8>
    b23e:	240c      	movs	r4, #12
    b240:	b13a      	cbz	r2, b252 <bt_att_accept+0x8a>
    b242:	2103      	movs	r1, #3
    b244:	7039      	strb	r1, [r7, #0]
    b246:	2100      	movs	r1, #0
    b248:	7079      	strb	r1, [r7, #1]
    b24a:	70b9      	strb	r1, [r7, #2]
    b24c:	70f9      	strb	r1, [r7, #3]
    b24e:	6838      	ldr	r0, [r7, #0]
    b250:	6118      	str	r0, [r3, #16]
    b252:	2100      	movs	r1, #0
    b254:	f36f 0100 	bfc	r1, #0, #1
    b258:	f36f 0141 	bfc	r1, #1, #1
    b25c:	f36f 0182 	bfc	r1, #2, #1
    b260:	f36f 01c5 	bfc	r1, #3, #3
    b264:	2301      	movs	r3, #1
    b266:	f363 1188 	bfi	r1, r3, #6, #3
    b26a:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    b26e:	f364 2152 	bfi	r1, r4, #9, #10
    b272:	f36f 41de 	bfc	r1, #19, #12
    b276:	f36f 71df 	bfc	r1, #31, #1
    b27a:	2300      	movs	r3, #0
    b27c:	480a      	ldr	r0, [pc, #40]	; (b2a8 <bt_att_accept+0xe0>)
    b27e:	f7f6 ffe3 	bl	2248 <z_impl_z_log_msg_static_create>
    b282:	46ad      	mov	sp, r5
		return -ENOMEM;
    b284:	f06f 050b 	mvn.w	r5, #11
    b288:	e7c3      	b.n	b212 <bt_att_accept+0x4a>
		BT_ERR("No available ATT context for conn %p", conn);
    b28a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    b28e:	e7cb      	b.n	b228 <bt_att_accept+0x60>
    b290:	f06f 041b 	mvn.w	r4, #27
    b294:	e7d4      	b.n	b240 <bt_att_accept+0x78>
		return -ENOMEM;
    b296:	f06f 050b 	mvn.w	r5, #11
    b29a:	e7ba      	b.n	b212 <bt_att_accept+0x4a>
    b29c:	2000056c 	.word	0x2000056c
    b2a0:	2000238c 	.word	0x2000238c
    b2a4:	0001ee1c 	.word	0x0001ee1c
    b2a8:	0001cfd4 	.word	0x0001cfd4

0000b2ac <bt_att_released>:
{
    b2ac:	b500      	push	{lr}
    b2ae:	b083      	sub	sp, #12
	struct bt_att_chan *chan = ATT_CHAN(ch);
    b2b0:	3804      	subs	r0, #4
    b2b2:	9001      	str	r0, [sp, #4]
	k_mem_slab_free(&chan_slab, (void **)&chan);
    b2b4:	a901      	add	r1, sp, #4
    b2b6:	4803      	ldr	r0, [pc, #12]	; (b2c4 <bt_att_released+0x18>)
    b2b8:	f010 fe31 	bl	1bf1e <k_mem_slab_free>
}
    b2bc:	b003      	add	sp, #12
    b2be:	f85d fb04 	ldr.w	pc, [sp], #4
    b2c2:	bf00      	nop
    b2c4:	20000588 	.word	0x20000588

0000b2c8 <read_group_cb>:
{
    b2c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    b2ca:	b085      	sub	sp, #20
    b2cc:	4605      	mov	r5, r0
    b2ce:	460e      	mov	r6, r1
    b2d0:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
    b2d2:	6817      	ldr	r7, [r2, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    b2d4:	2300      	movs	r3, #0
    b2d6:	f88d 3008 	strb.w	r3, [sp, #8]
    b2da:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    b2de:	f8ad 300a 	strh.w	r3, [sp, #10]
    b2e2:	a902      	add	r1, sp, #8
    b2e4:	6800      	ldr	r0, [r0, #0]
    b2e6:	f00c fa8b 	bl	17800 <bt_uuid_cmp>
    b2ea:	b158      	cbz	r0, b304 <read_group_cb+0x3c>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    b2ec:	2300      	movs	r3, #0
    b2ee:	f88d 300c 	strb.w	r3, [sp, #12]
    b2f2:	f642 0301 	movw	r3, #10241	; 0x2801
    b2f6:	f8ad 300e 	strh.w	r3, [sp, #14]
    b2fa:	a903      	add	r1, sp, #12
    b2fc:	6828      	ldr	r0, [r5, #0]
    b2fe:	f00c fa7f 	bl	17800 <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
    b302:	bb28      	cbnz	r0, b350 <read_group_cb+0x88>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    b304:	6861      	ldr	r1, [r4, #4]
    b306:	6828      	ldr	r0, [r5, #0]
    b308:	f00c fa7a 	bl	17800 <bt_uuid_cmp>
    b30c:	bb40      	cbnz	r0, b360 <read_group_cb+0x98>
	if (data->rsp->len &&
    b30e:	68e3      	ldr	r3, [r4, #12]
    b310:	781a      	ldrb	r2, [r3, #0]
    b312:	b12a      	cbz	r2, b320 <read_group_cb+0x58>
	    chan->chan.tx.mtu - data->buf->len < data->rsp->len) {
    b314:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
    b316:	68a1      	ldr	r1, [r4, #8]
    b318:	8989      	ldrh	r1, [r1, #12]
    b31a:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
    b31c:	4293      	cmp	r3, r2
    b31e:	db24      	blt.n	b36a <read_group_cb+0xa2>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
    b320:	68a0      	ldr	r0, [r4, #8]
	return net_buf_simple_add(&buf->b, len);
    b322:	2104      	movs	r1, #4
    b324:	3008      	adds	r0, #8
    b326:	f00e ff6a 	bl	1a1fe <net_buf_simple_add>
    b32a:	6120      	str	r0, [r4, #16]
	data->group->start_handle = sys_cpu_to_le16(handle);
    b32c:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
    b32e:	6923      	ldr	r3, [r4, #16]
    b330:	805e      	strh	r6, [r3, #2]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_group_cb,
    b332:	9401      	str	r4, [sp, #4]
    b334:	4b10      	ldr	r3, [pc, #64]	; (b378 <read_group_cb+0xb0>)
    b336:	9300      	str	r3, [sp, #0]
    b338:	2300      	movs	r3, #0
    b33a:	68a2      	ldr	r2, [r4, #8]
    b33c:	4629      	mov	r1, r5
    b33e:	4638      	mov	r0, r7
    b340:	f00d f9c0 	bl	186c4 <att_chan_read>
	if (read < 0) {
    b344:	2800      	cmp	r0, #0
    b346:	db12      	blt.n	b36e <read_group_cb+0xa6>
	if (!data->group) {
    b348:	6923      	ldr	r3, [r4, #16]
    b34a:	b193      	cbz	r3, b372 <read_group_cb+0xaa>
	return BT_GATT_ITER_CONTINUE;
    b34c:	2001      	movs	r0, #1
    b34e:	e00a      	b.n	b366 <read_group_cb+0x9e>
		if (data->group &&
    b350:	6923      	ldr	r3, [r4, #16]
    b352:	b11b      	cbz	r3, b35c <read_group_cb+0x94>
		    handle > sys_le16_to_cpu(data->group->end_handle)) {
    b354:	885a      	ldrh	r2, [r3, #2]
		if (data->group &&
    b356:	42b2      	cmp	r2, r6
    b358:	d200      	bcs.n	b35c <read_group_cb+0x94>
			data->group->end_handle = sys_cpu_to_le16(handle);
    b35a:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
    b35c:	2001      	movs	r0, #1
    b35e:	e002      	b.n	b366 <read_group_cb+0x9e>
		data->group = NULL;
    b360:	2300      	movs	r3, #0
    b362:	6123      	str	r3, [r4, #16]
		return BT_GATT_ITER_CONTINUE;
    b364:	2001      	movs	r0, #1
}
    b366:	b005      	add	sp, #20
    b368:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ITER_STOP;
    b36a:	2000      	movs	r0, #0
    b36c:	e7fb      	b.n	b366 <read_group_cb+0x9e>
		return BT_GATT_ITER_STOP;
    b36e:	2000      	movs	r0, #0
    b370:	e7f9      	b.n	b366 <read_group_cb+0x9e>
		return BT_GATT_ITER_STOP;
    b372:	2000      	movs	r0, #0
    b374:	e7f7      	b.n	b366 <read_group_cb+0x9e>
    b376:	bf00      	nop
    b378:	00018453 	.word	0x00018453

0000b37c <read_type_cb>:
{
    b37c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b380:	b083      	sub	sp, #12
    b382:	4606      	mov	r6, r0
    b384:	4688      	mov	r8, r1
    b386:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
    b388:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
    b38a:	687d      	ldr	r5, [r7, #4]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
    b38c:	6851      	ldr	r1, [r2, #4]
    b38e:	6800      	ldr	r0, [r0, #0]
    b390:	f00c fa36 	bl	17800 <bt_uuid_cmp>
    b394:	b120      	cbz	r0, b3a0 <read_type_cb+0x24>
		return BT_GATT_ITER_CONTINUE;
    b396:	2501      	movs	r5, #1
}
    b398:	4628      	mov	r0, r5
    b39a:	b003      	add	sp, #12
    b39c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
    b3a0:	2295      	movs	r2, #149	; 0x95
    b3a2:	4631      	mov	r1, r6
    b3a4:	4628      	mov	r0, r5
    b3a6:	f00e fb67 	bl	19a78 <bt_gatt_check_perm>
    b3aa:	4605      	mov	r5, r0
    b3ac:	7520      	strb	r0, [r4, #20]
	if (data->err) {
    b3ae:	b130      	cbz	r0, b3be <read_type_cb+0x42>
		if (data->rsp->len) {
    b3b0:	68e3      	ldr	r3, [r4, #12]
    b3b2:	781b      	ldrb	r3, [r3, #0]
    b3b4:	b10b      	cbz	r3, b3ba <read_type_cb+0x3e>
			data->err = 0x00;
    b3b6:	2300      	movs	r3, #0
    b3b8:	7523      	strb	r3, [r4, #20]
		return BT_GATT_ITER_STOP;
    b3ba:	2500      	movs	r5, #0
    b3bc:	e7ec      	b.n	b398 <read_type_cb+0x1c>
	data->err = 0x00;
    b3be:	f04f 0900 	mov.w	r9, #0
    b3c2:	f884 9014 	strb.w	r9, [r4, #20]
	data->item = net_buf_add(net_buf_frag_last(data->buf),
    b3c6:	68a0      	ldr	r0, [r4, #8]
    b3c8:	f00e fef9 	bl	1a1be <net_buf_frag_last>
    b3cc:	2102      	movs	r1, #2
    b3ce:	3008      	adds	r0, #8
    b3d0:	f00e ff15 	bl	1a1fe <net_buf_simple_add>
    b3d4:	6120      	str	r0, [r4, #16]
	data->item->handle = sys_cpu_to_le16(handle);
    b3d6:	f8a0 8000 	strh.w	r8, [r0]
	read = att_chan_read(chan, attr, data->buf, 0, attr_read_type_cb, data);
    b3da:	9401      	str	r4, [sp, #4]
    b3dc:	4b10      	ldr	r3, [pc, #64]	; (b420 <read_type_cb+0xa4>)
    b3de:	9300      	str	r3, [sp, #0]
    b3e0:	464b      	mov	r3, r9
    b3e2:	68a2      	ldr	r2, [r4, #8]
    b3e4:	4631      	mov	r1, r6
    b3e6:	4638      	mov	r0, r7
    b3e8:	f00d f96c 	bl	186c4 <att_chan_read>
	if (read < 0) {
    b3ec:	2800      	cmp	r0, #0
    b3ee:	db06      	blt.n	b3fe <read_type_cb+0x82>
	if (!data->item) {
    b3f0:	6923      	ldr	r3, [r4, #16]
    b3f2:	2b00      	cmp	r3, #0
    b3f4:	d0d0      	beq.n	b398 <read_type_cb+0x1c>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
    b3f6:	8d7d      	ldrh	r5, [r7, #42]	; 0x2a
    b3f8:	68a3      	ldr	r3, [r4, #8]
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
    b3fa:	2200      	movs	r2, #0

	while (buf) {
    b3fc:	e006      	b.n	b40c <read_type_cb+0x90>
		data->err = err_to_att(read);
    b3fe:	f00d f80c 	bl	1841a <err_to_att>
    b402:	7520      	strb	r0, [r4, #20]
		return BT_GATT_ITER_STOP;
    b404:	e7c8      	b.n	b398 <read_type_cb+0x1c>
		bytes += buf->len;
    b406:	8999      	ldrh	r1, [r3, #12]
    b408:	440a      	add	r2, r1
		buf = buf->frags;
    b40a:	681b      	ldr	r3, [r3, #0]
	while (buf) {
    b40c:	2b00      	cmp	r3, #0
    b40e:	d1fa      	bne.n	b406 <read_type_cb+0x8a>
	return chan->chan.tx.mtu - net_buf_frags_len(data->buf) >
    b410:	1aaa      	subs	r2, r5, r2
	       data->rsp->len ? BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
    b412:	68e3      	ldr	r3, [r4, #12]
    b414:	781d      	ldrb	r5, [r3, #0]
    b416:	42aa      	cmp	r2, r5
    b418:	bf94      	ite	ls
    b41a:	2500      	movls	r5, #0
    b41c:	2501      	movhi	r5, #1
    b41e:	e7bb      	b.n	b398 <read_type_cb+0x1c>
    b420:	0001842b 	.word	0x0001842b

0000b424 <find_type_cb>:
{
    b424:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b428:	b097      	sub	sp, #92	; 0x5c
    b42a:	af02      	add	r7, sp, #8
    b42c:	4605      	mov	r5, r0
    b42e:	460e      	mov	r6, r1
    b430:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
    b432:	f8d2 8000 	ldr.w	r8, [r2]
	struct bt_conn *conn = chan->chan.chan.conn;
    b436:	f8d8 9004 	ldr.w	r9, [r8, #4]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
    b43a:	2300      	movs	r3, #0
    b43c:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
    b440:	f642 0301 	movw	r3, #10241	; 0x2801
    b444:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    b448:	f107 0148 	add.w	r1, r7, #72	; 0x48
    b44c:	6800      	ldr	r0, [r0, #0]
    b44e:	f00c f9d7 	bl	17800 <bt_uuid_cmp>
    b452:	b930      	cbnz	r0, b462 <find_type_cb+0x3e>
	data->group = NULL;
    b454:	2300      	movs	r3, #0
    b456:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
    b458:	2001      	movs	r0, #1
}
    b45a:	3754      	adds	r7, #84	; 0x54
    b45c:	46bd      	mov	sp, r7
    b45e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
    b462:	2300      	movs	r3, #0
    b464:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
    b468:	f44f 5320 	mov.w	r3, #10240	; 0x2800
    b46c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    b470:	f107 014c 	add.w	r1, r7, #76	; 0x4c
    b474:	6828      	ldr	r0, [r5, #0]
    b476:	f00c f9c3 	bl	17800 <bt_uuid_cmp>
    b47a:	b928      	cbnz	r0, b488 <find_type_cb+0x64>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
    b47c:	f8b8 c02a 	ldrh.w	ip, [r8, #42]	; 0x2a
    b480:	6860      	ldr	r0, [r4, #4]
    b482:	4603      	mov	r3, r0
	size_t bytes = 0;
    b484:	2200      	movs	r2, #0
	while (buf) {
    b486:	e00a      	b.n	b49e <find_type_cb+0x7a>
		if (data->group &&
    b488:	68a3      	ldr	r3, [r4, #8]
    b48a:	b11b      	cbz	r3, b494 <find_type_cb+0x70>
		    handle > sys_le16_to_cpu(data->group->end_handle)) {
    b48c:	885a      	ldrh	r2, [r3, #2]
		if (data->group &&
    b48e:	42b2      	cmp	r2, r6
    b490:	d200      	bcs.n	b494 <find_type_cb+0x70>
			data->group->end_handle = sys_cpu_to_le16(handle);
    b492:	805e      	strh	r6, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
    b494:	2001      	movs	r0, #1
    b496:	e7e0      	b.n	b45a <find_type_cb+0x36>
		bytes += buf->len;
    b498:	8999      	ldrh	r1, [r3, #12]
    b49a:	440a      	add	r2, r1
		buf = buf->frags;
    b49c:	681b      	ldr	r3, [r3, #0]
	while (buf) {
    b49e:	2b00      	cmp	r3, #0
    b4a0:	d1fa      	bne.n	b498 <find_type_cb+0x74>
	if (chan->chan.tx.mtu - net_buf_frags_len(data->buf) <
    b4a2:	ebac 0202 	sub.w	r2, ip, r2
    b4a6:	2a03      	cmp	r2, #3
    b4a8:	d801      	bhi.n	b4ae <find_type_cb+0x8a>
		return BT_GATT_ITER_STOP;
    b4aa:	2000      	movs	r0, #0
    b4ac:	e7d5      	b.n	b45a <find_type_cb+0x36>
	frag = net_buf_frag_last(data->buf);
    b4ae:	f00e fe86 	bl	1a1be <net_buf_frag_last>
    b4b2:	6078      	str	r0, [r7, #4]
	len = MIN(chan->chan.tx.mtu - net_buf_frags_len(data->buf),
    b4b4:	f8b8 a02a 	ldrh.w	sl, [r8, #42]	; 0x2a
    b4b8:	6863      	ldr	r3, [r4, #4]
	size_t bytes = 0;
    b4ba:	2200      	movs	r2, #0
	while (buf) {
    b4bc:	e002      	b.n	b4c4 <find_type_cb+0xa0>
		bytes += buf->len;
    b4be:	8999      	ldrh	r1, [r3, #12]
    b4c0:	440a      	add	r2, r1
		buf = buf->frags;
    b4c2:	681b      	ldr	r3, [r3, #0]
	while (buf) {
    b4c4:	2b00      	cmp	r3, #0
    b4c6:	d1fa      	bne.n	b4be <find_type_cb+0x9a>
    b4c8:	ebaa 0a02 	sub.w	sl, sl, r2
	return net_buf_simple_tailroom(&buf->b);
    b4cc:	687b      	ldr	r3, [r7, #4]
    b4ce:	f103 0b08 	add.w	fp, r3, #8
    b4d2:	4658      	mov	r0, fp
    b4d4:	f00e fedf 	bl	1a296 <net_buf_simple_tailroom>
    b4d8:	4582      	cmp	sl, r0
    b4da:	d25a      	bcs.n	b592 <find_type_cb+0x16e>
    b4dc:	f8b8 002a 	ldrh.w	r0, [r8, #42]	; 0x2a
    b4e0:	6863      	ldr	r3, [r4, #4]
	size_t bytes = 0;
    b4e2:	2200      	movs	r2, #0
	while (buf) {
    b4e4:	e002      	b.n	b4ec <find_type_cb+0xc8>
		bytes += buf->len;
    b4e6:	8999      	ldrh	r1, [r3, #12]
    b4e8:	440a      	add	r2, r1
		buf = buf->frags;
    b4ea:	681b      	ldr	r3, [r3, #0]
	while (buf) {
    b4ec:	2b00      	cmp	r3, #0
    b4ee:	d1fa      	bne.n	b4e6 <find_type_cb+0xc2>
    b4f0:	1a80      	subs	r0, r0, r2
	if (!len) {
    b4f2:	2800      	cmp	r0, #0
    b4f4:	d051      	beq.n	b59a <find_type_cb+0x176>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
    b4f6:	f8d5 8004 	ldr.w	r8, [r5, #4]
    b4fa:	2300      	movs	r3, #0
    b4fc:	9300      	str	r3, [sp, #0]
    b4fe:	2310      	movs	r3, #16
    b500:	f107 0238 	add.w	r2, r7, #56	; 0x38
    b504:	4629      	mov	r1, r5
    b506:	4648      	mov	r0, r9
    b508:	47c0      	blx	r8
	if (read < 0) {
    b50a:	1e05      	subs	r5, r0, #0
    b50c:	dba2      	blt.n	b454 <find_type_cb+0x30>
	if (read != data->value_len) {
    b50e:	7c22      	ldrb	r2, [r4, #16]
    b510:	4295      	cmp	r5, r2
    b512:	f000 80a6 	beq.w	b662 <find_type_cb+0x23e>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
    b516:	68e1      	ldr	r1, [r4, #12]
    b518:	f107 0024 	add.w	r0, r7, #36	; 0x24
    b51c:	f00c f98e 	bl	1783c <bt_uuid_create>
    b520:	2800      	cmp	r0, #0
    b522:	d151      	bne.n	b5c8 <find_type_cb+0x1a4>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
    b524:	7c20      	ldrb	r0, [r4, #16]
    b526:	466e      	mov	r6, sp
    b528:	b088      	sub	sp, #32
    b52a:	ab02      	add	r3, sp, #8
    b52c:	f113 0210 	adds.w	r2, r3, #16
    b530:	d044      	beq.n	b5bc <find_type_cb+0x198>
    b532:	210c      	movs	r1, #12
    b534:	b11a      	cbz	r2, b53e <find_type_cb+0x11a>
    b536:	2904      	cmp	r1, #4
    b538:	dd01      	ble.n	b53e <find_type_cb+0x11a>
    b53a:	4d55      	ldr	r5, [pc, #340]	; (b690 <find_type_cb+0x26c>)
    b53c:	615d      	str	r5, [r3, #20]
    b53e:	b112      	cbz	r2, b546 <find_type_cb+0x122>
    b540:	2908      	cmp	r1, #8
    b542:	dd00      	ble.n	b546 <find_type_cb+0x122>
    b544:	6198      	str	r0, [r3, #24]
    b546:	290b      	cmp	r1, #11
    b548:	dd3b      	ble.n	b5c2 <find_type_cb+0x19e>
    b54a:	250c      	movs	r5, #12
    b54c:	b13a      	cbz	r2, b55e <find_type_cb+0x13a>
    b54e:	2103      	movs	r1, #3
    b550:	7439      	strb	r1, [r7, #16]
    b552:	2100      	movs	r1, #0
    b554:	7479      	strb	r1, [r7, #17]
    b556:	74b9      	strb	r1, [r7, #18]
    b558:	74f9      	strb	r1, [r7, #19]
    b55a:	6938      	ldr	r0, [r7, #16]
    b55c:	6118      	str	r0, [r3, #16]
    b55e:	2100      	movs	r1, #0
    b560:	f36f 0100 	bfc	r1, #0, #1
    b564:	f36f 0141 	bfc	r1, #1, #1
    b568:	f36f 0182 	bfc	r1, #2, #1
    b56c:	f36f 01c5 	bfc	r1, #3, #3
    b570:	2302      	movs	r3, #2
    b572:	f363 1188 	bfi	r1, r3, #6, #3
    b576:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    b57a:	f365 2152 	bfi	r1, r5, #9, #10
    b57e:	f36f 41de 	bfc	r1, #19, #12
    b582:	f36f 71df 	bfc	r1, #31, #1
    b586:	2300      	movs	r3, #0
    b588:	4842      	ldr	r0, [pc, #264]	; (b694 <find_type_cb+0x270>)
    b58a:	f7f6 fe5d 	bl	2248 <z_impl_z_log_msg_static_create>
    b58e:	46b5      	mov	sp, r6
			goto skip;
    b590:	e760      	b.n	b454 <find_type_cb+0x30>
	return net_buf_simple_tailroom(&buf->b);
    b592:	4658      	mov	r0, fp
    b594:	f00e fe7f 	bl	1a296 <net_buf_simple_tailroom>
    b598:	e7ab      	b.n	b4f2 <find_type_cb+0xce>
		frag = net_buf_alloc(net_buf_pool_get(data->buf->pool_id),
    b59a:	6863      	ldr	r3, [r4, #4]
    b59c:	7998      	ldrb	r0, [r3, #6]
    b59e:	f002 fb67 	bl	dc70 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
    b5a2:	2200      	movs	r2, #0
    b5a4:	2300      	movs	r3, #0
    b5a6:	f00e fd4d 	bl	1a044 <net_buf_alloc_fixed>
		if (!frag) {
    b5aa:	6078      	str	r0, [r7, #4]
    b5ac:	2800      	cmp	r0, #0
    b5ae:	f43f af54 	beq.w	b45a <find_type_cb+0x36>
		net_buf_frag_add(data->buf, frag);
    b5b2:	6879      	ldr	r1, [r7, #4]
    b5b4:	6860      	ldr	r0, [r4, #4]
    b5b6:	f00e fe13 	bl	1a1e0 <net_buf_frag_add>
    b5ba:	e79c      	b.n	b4f6 <find_type_cb+0xd2>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
    b5bc:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    b5c0:	e7b8      	b.n	b534 <find_type_cb+0x110>
    b5c2:	f06f 051b 	mvn.w	r5, #27
    b5c6:	e7c1      	b.n	b54c <find_type_cb+0x128>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
    b5c8:	b2ea      	uxtb	r2, r5
    b5ca:	f107 0138 	add.w	r1, r7, #56	; 0x38
    b5ce:	f107 0010 	add.w	r0, r7, #16
    b5d2:	f00c f933 	bl	1783c <bt_uuid_create>
    b5d6:	2800      	cmp	r0, #0
    b5d8:	d13b      	bne.n	b652 <find_type_cb+0x22e>
			BT_WARN("Unable to create UUID: size %d", read);
    b5da:	466e      	mov	r6, sp
    b5dc:	b088      	sub	sp, #32
    b5de:	ab02      	add	r3, sp, #8
    b5e0:	f113 0210 	adds.w	r2, r3, #16
    b5e4:	d02f      	beq.n	b646 <find_type_cb+0x222>
    b5e6:	210c      	movs	r1, #12
    b5e8:	b11a      	cbz	r2, b5f2 <find_type_cb+0x1ce>
    b5ea:	2904      	cmp	r1, #4
    b5ec:	dd01      	ble.n	b5f2 <find_type_cb+0x1ce>
    b5ee:	482a      	ldr	r0, [pc, #168]	; (b698 <find_type_cb+0x274>)
    b5f0:	6158      	str	r0, [r3, #20]
    b5f2:	b112      	cbz	r2, b5fa <find_type_cb+0x1d6>
    b5f4:	2908      	cmp	r1, #8
    b5f6:	dd00      	ble.n	b5fa <find_type_cb+0x1d6>
    b5f8:	619d      	str	r5, [r3, #24]
    b5fa:	290b      	cmp	r1, #11
    b5fc:	dd26      	ble.n	b64c <find_type_cb+0x228>
    b5fe:	250c      	movs	r5, #12
    b600:	b13a      	cbz	r2, b612 <find_type_cb+0x1ee>
    b602:	2103      	movs	r1, #3
    b604:	7339      	strb	r1, [r7, #12]
    b606:	2100      	movs	r1, #0
    b608:	7379      	strb	r1, [r7, #13]
    b60a:	73b9      	strb	r1, [r7, #14]
    b60c:	73f9      	strb	r1, [r7, #15]
    b60e:	68f8      	ldr	r0, [r7, #12]
    b610:	6118      	str	r0, [r3, #16]
    b612:	2100      	movs	r1, #0
    b614:	f36f 0100 	bfc	r1, #0, #1
    b618:	f36f 0141 	bfc	r1, #1, #1
    b61c:	f36f 0182 	bfc	r1, #2, #1
    b620:	f36f 01c5 	bfc	r1, #3, #3
    b624:	2302      	movs	r3, #2
    b626:	f363 1188 	bfi	r1, r3, #6, #3
    b62a:	f405 737b 	and.w	r3, r5, #1004	; 0x3ec
    b62e:	f363 2152 	bfi	r1, r3, #9, #10
    b632:	f36f 41de 	bfc	r1, #19, #12
    b636:	f36f 71df 	bfc	r1, #31, #1
    b63a:	2300      	movs	r3, #0
    b63c:	4815      	ldr	r0, [pc, #84]	; (b694 <find_type_cb+0x270>)
    b63e:	f7f6 fe03 	bl	2248 <z_impl_z_log_msg_static_create>
    b642:	46b5      	mov	sp, r6
			goto skip;
    b644:	e706      	b.n	b454 <find_type_cb+0x30>
			BT_WARN("Unable to create UUID: size %d", read);
    b646:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    b64a:	e7cd      	b.n	b5e8 <find_type_cb+0x1c4>
    b64c:	f06f 051b 	mvn.w	r5, #27
    b650:	e7d6      	b.n	b600 <find_type_cb+0x1dc>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
    b652:	f107 0110 	add.w	r1, r7, #16
    b656:	f107 0024 	add.w	r0, r7, #36	; 0x24
    b65a:	f00c f8d1 	bl	17800 <bt_uuid_cmp>
    b65e:	b148      	cbz	r0, b674 <find_type_cb+0x250>
    b660:	e6f8      	b.n	b454 <find_type_cb+0x30>
	} else if (memcmp(data->value, uuid, read)) {
    b662:	462a      	mov	r2, r5
    b664:	f107 0138 	add.w	r1, r7, #56	; 0x38
    b668:	68e0      	ldr	r0, [r4, #12]
    b66a:	f00c f84f 	bl	1770c <memcmp>
    b66e:	2800      	cmp	r0, #0
    b670:	f47f aef0 	bne.w	b454 <find_type_cb+0x30>
	data->err = 0x00;
    b674:	2300      	movs	r3, #0
    b676:	7463      	strb	r3, [r4, #17]
	return net_buf_simple_add(&buf->b, len);
    b678:	2104      	movs	r1, #4
    b67a:	6878      	ldr	r0, [r7, #4]
    b67c:	3008      	adds	r0, #8
    b67e:	f00e fdbe 	bl	1a1fe <net_buf_simple_add>
	data->group = net_buf_add(frag, sizeof(*data->group));
    b682:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(handle);
    b684:	8006      	strh	r6, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(handle);
    b686:	68a3      	ldr	r3, [r4, #8]
    b688:	805e      	strh	r6, [r3, #2]
	return BT_GATT_ITER_CONTINUE;
    b68a:	2001      	movs	r0, #1
    b68c:	e6e5      	b.n	b45a <find_type_cb+0x36>
    b68e:	bf00      	nop
    b690:	0001ee44 	.word	0x0001ee44
    b694:	0001cfd4 	.word	0x0001cfd4
    b698:	0001ee64 	.word	0x0001ee64

0000b69c <bt_att_connected>:
{
    b69c:	b510      	push	{r4, lr}
    b69e:	4604      	mov	r4, r0
	struct bt_att_chan *att_chan = ATT_CHAN(chan);
    b6a0:	3804      	subs	r0, #4
	atomic_set_bit(att_chan->flags, ATT_CONNECTED);
    b6a2:	f104 038c 	add.w	r3, r4, #140	; 0x8c
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    b6a6:	e8d3 2fef 	ldaex	r2, [r3]
    b6aa:	f042 0204 	orr.w	r2, r2, #4
    b6ae:	e8c3 2fe1 	stlex	r1, r2, [r3]
    b6b2:	2900      	cmp	r1, #0
    b6b4:	d1f7      	bne.n	b6a6 <bt_att_connected+0xa>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b6b6:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(att_chan->flags, ATT_ENHANCED)) {
    b6ba:	f013 0f08 	tst.w	r3, #8
    b6be:	d102      	bne.n	b6c6 <bt_att_connected+0x2a>
		le_chan->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
    b6c0:	2317      	movs	r3, #23
    b6c2:	84e3      	strh	r3, [r4, #38]	; 0x26
		le_chan->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
    b6c4:	82e3      	strh	r3, [r4, #22]
	att_chan_mtu_updated(att_chan);
    b6c6:	f00c ff8f 	bl	185e8 <att_chan_mtu_updated>
	k_work_init_delayable(&att_chan->timeout_work, att_timeout);
    b6ca:	4904      	ldr	r1, [pc, #16]	; (b6dc <bt_att_connected+0x40>)
    b6cc:	f104 00ac 	add.w	r0, r4, #172	; 0xac
    b6d0:	f010 fe54 	bl	1c37c <k_work_init_delayable>
	bt_gatt_connected(le_chan->chan.conn);
    b6d4:	6820      	ldr	r0, [r4, #0]
    b6d6:	f002 fa11 	bl	dafc <bt_gatt_connected>
}
    b6da:	bd10      	pop	{r4, pc}
    b6dc:	0000c6f1 	.word	0x0000c6f1

0000b6e0 <chan_unknown>:
{
    b6e0:	b510      	push	{r4, lr}
    b6e2:	460c      	mov	r4, r1
	(void)memset(data, 0, sizeof(*data));
    b6e4:	2214      	movs	r2, #20
    b6e6:	2100      	movs	r1, #0
    b6e8:	4620      	mov	r0, r4
    b6ea:	f00c f850 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    b6ee:	4621      	mov	r1, r4
    b6f0:	4801      	ldr	r0, [pc, #4]	; (b6f8 <chan_unknown+0x18>)
    b6f2:	f010 fd39 	bl	1c168 <k_queue_append>
}
    b6f6:	bd10      	pop	{r4, pc}
    b6f8:	20000654 	.word	0x20000654

0000b6fc <chan_cfm_sent>:
{
    b6fc:	b510      	push	{r4, lr}
    b6fe:	460c      	mov	r4, r1
	struct bt_att_chan *chan = data->att_chan;
    b700:	680b      	ldr	r3, [r1, #0]
		atomic_clear_bit(chan->flags, ATT_PENDING_CFM);
    b702:	3390      	adds	r3, #144	; 0x90
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    b704:	e8d3 2fef 	ldaex	r2, [r3]
    b708:	f022 0202 	bic.w	r2, r2, #2
    b70c:	e8c3 2fe1 	stlex	r1, r2, [r3]
    b710:	2900      	cmp	r1, #0
    b712:	d1f7      	bne.n	b704 <chan_cfm_sent+0x8>
	(void)memset(data, 0, sizeof(*data));
    b714:	2214      	movs	r2, #20
    b716:	2100      	movs	r1, #0
    b718:	4620      	mov	r0, r4
    b71a:	f00c f838 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    b71e:	4621      	mov	r1, r4
    b720:	4801      	ldr	r0, [pc, #4]	; (b728 <chan_cfm_sent+0x2c>)
    b722:	f010 fd21 	bl	1c168 <k_queue_append>
}
    b726:	bd10      	pop	{r4, pc}
    b728:	20000654 	.word	0x20000654

0000b72c <chan_rsp_sent>:
{
    b72c:	b510      	push	{r4, lr}
    b72e:	460c      	mov	r4, r1
	struct bt_att_chan *chan = data->att_chan;
    b730:	680b      	ldr	r3, [r1, #0]
		atomic_clear_bit(chan->flags, ATT_PENDING_RSP);
    b732:	3390      	adds	r3, #144	; 0x90
    b734:	e8d3 2fef 	ldaex	r2, [r3]
    b738:	f022 0201 	bic.w	r2, r2, #1
    b73c:	e8c3 2fe1 	stlex	r1, r2, [r3]
    b740:	2900      	cmp	r1, #0
    b742:	d1f7      	bne.n	b734 <chan_rsp_sent+0x8>
	(void)memset(data, 0, sizeof(*data));
    b744:	2214      	movs	r2, #20
    b746:	2100      	movs	r1, #0
    b748:	4620      	mov	r0, r4
    b74a:	f00c f820 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    b74e:	4621      	mov	r1, r4
    b750:	4801      	ldr	r0, [pc, #4]	; (b758 <chan_rsp_sent+0x2c>)
    b752:	f010 fd09 	bl	1c168 <k_queue_append>
}
    b756:	bd10      	pop	{r4, pc}
    b758:	20000654 	.word	0x20000654

0000b75c <chan_req_sent>:
{
    b75c:	b510      	push	{r4, lr}
    b75e:	460c      	mov	r4, r1
	struct bt_att_chan *chan = data->att_chan;
    b760:	6808      	ldr	r0, [r1, #0]
	if (chan->req) {
    b762:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    b766:	b12b      	cbz	r3, b774 <chan_req_sent+0x18>
		k_work_reschedule(&chan->timeout_work, BT_ATT_TIMEOUT);
    b768:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
    b76c:	2300      	movs	r3, #0
    b76e:	30b0      	adds	r0, #176	; 0xb0
    b770:	f008 fc24 	bl	13fbc <k_work_reschedule>
	(void)memset(data, 0, sizeof(*data));
    b774:	2214      	movs	r2, #20
    b776:	2100      	movs	r1, #0
    b778:	4620      	mov	r0, r4
    b77a:	f00c f808 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    b77e:	4621      	mov	r1, r4
    b780:	4801      	ldr	r0, [pc, #4]	; (b788 <chan_req_sent+0x2c>)
    b782:	f010 fcf1 	bl	1c168 <k_queue_append>
}
    b786:	bd10      	pop	{r4, pc}
    b788:	20000654 	.word	0x20000654

0000b78c <chan_tx_complete>:
{
    b78c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    b790:	4605      	mov	r5, r0
    b792:	460c      	mov	r4, r1
    b794:	4690      	mov	r8, r2
	bt_gatt_complete_func_t func = data->func;
    b796:	688e      	ldr	r6, [r1, #8]
	uint16_t attr_count = data->attr_count;
    b798:	888f      	ldrh	r7, [r1, #4]
	void *ud = data->user_data;
    b79a:	f8d1 900c 	ldr.w	r9, [r1, #12]
	(void)memset(data, 0, sizeof(*data));
    b79e:	2214      	movs	r2, #20
    b7a0:	2100      	movs	r1, #0
    b7a2:	4620      	mov	r0, r4
    b7a4:	f00b fff3 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    b7a8:	4621      	mov	r1, r4
    b7aa:	4809      	ldr	r0, [pc, #36]	; (b7d0 <chan_tx_complete+0x44>)
    b7ac:	f010 fcdc 	bl	1c168 <k_queue_append>
	if (!err && func) {
    b7b0:	f1b8 0f00 	cmp.w	r8, #0
    b7b4:	d109      	bne.n	b7ca <chan_tx_complete+0x3e>
    b7b6:	b146      	cbz	r6, b7ca <chan_tx_complete+0x3e>
		for (uint16_t i = 0; i < attr_count; i++) {
    b7b8:	2400      	movs	r4, #0
    b7ba:	e004      	b.n	b7c6 <chan_tx_complete+0x3a>
			func(conn, ud);
    b7bc:	4649      	mov	r1, r9
    b7be:	4628      	mov	r0, r5
    b7c0:	47b0      	blx	r6
		for (uint16_t i = 0; i < attr_count; i++) {
    b7c2:	3401      	adds	r4, #1
    b7c4:	b2a4      	uxth	r4, r4
    b7c6:	42a7      	cmp	r7, r4
    b7c8:	d8f8      	bhi.n	b7bc <chan_tx_complete+0x30>
}
    b7ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    b7ce:	bf00      	nop
    b7d0:	20000654 	.word	0x20000654

0000b7d4 <chan_send>:
{
    b7d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b7d8:	b08b      	sub	sp, #44	; 0x2c
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
    b7da:	694f      	ldr	r7, [r1, #20]
	hdr = (void *)buf->data;
    b7dc:	688a      	ldr	r2, [r1, #8]
	if (!atomic_test_bit(chan->flags, ATT_CONNECTED)) {
    b7de:	f100 0390 	add.w	r3, r0, #144	; 0x90
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    b7e2:	e8d3 3faf 	lda	r3, [r3]
    b7e6:	f013 0f04 	tst.w	r3, #4
    b7ea:	d061      	beq.n	b8b0 <chan_send+0xdc>
    b7ec:	4605      	mov	r5, r0
    b7ee:	460c      	mov	r4, r1
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
    b7f0:	7813      	ldrb	r3, [r2, #0]
    b7f2:	2bd2      	cmp	r3, #210	; 0xd2
    b7f4:	d021      	beq.n	b83a <chan_send+0x66>
	state->offset = net_buf_simple_headroom(buf);
    b7f6:	f104 0008 	add.w	r0, r4, #8
    b7fa:	f00e fd48 	bl	1a28e <net_buf_simple_headroom>
    b7fe:	b286      	uxth	r6, r0
    b800:	f8ad 600c 	strh.w	r6, [sp, #12]
	state->len = buf->len;
    b804:	f8b4 800c 	ldrh.w	r8, [r4, #12]
    b808:	f8ad 800e 	strh.w	r8, [sp, #14]
	data->att_chan = chan;
    b80c:	603d      	str	r5, [r7, #0]
	err = bt_l2cap_send_cb(chan->att->conn, BT_L2CAP_CID_ATT,
    b80e:	682d      	ldr	r5, [r5, #0]
    b810:	4620      	mov	r0, r4
    b812:	f7ff fb83 	bl	af1c <att_cb>
    b816:	4603      	mov	r3, r0
    b818:	6828      	ldr	r0, [r5, #0]
    b81a:	9700      	str	r7, [sp, #0]
    b81c:	4622      	mov	r2, r4
    b81e:	2104      	movs	r1, #4
    b820:	f00c fd60 	bl	182e4 <bt_l2cap_send_cb>
	if (err) {
    b824:	4681      	mov	r9, r0
    b826:	b120      	cbz	r0, b832 <chan_send+0x5e>
	buf->data = buf->__buf + state->offset;
    b828:	6920      	ldr	r0, [r4, #16]
    b82a:	4430      	add	r0, r6
    b82c:	60a0      	str	r0, [r4, #8]
	buf->len = state->len;
    b82e:	f8a4 800c 	strh.w	r8, [r4, #12]
}
    b832:	4648      	mov	r0, r9
    b834:	b00b      	add	sp, #44	; 0x2c
    b836:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = bt_smp_sign(chan->att->conn, buf);
    b83a:	6803      	ldr	r3, [r0, #0]
    b83c:	6818      	ldr	r0, [r3, #0]
    b83e:	f00e fb2a 	bl	19e96 <bt_smp_sign>
		if (err) {
    b842:	4681      	mov	r9, r0
    b844:	2800      	cmp	r0, #0
    b846:	d0d6      	beq.n	b7f6 <chan_send+0x22>
			BT_ERR("Error signing data");
    b848:	4b1b      	ldr	r3, [pc, #108]	; (b8b8 <chan_send+0xe4>)
    b84a:	9309      	str	r3, [sp, #36]	; 0x24
    b84c:	2302      	movs	r3, #2
    b84e:	f88d 3008 	strb.w	r3, [sp, #8]
    b852:	2500      	movs	r5, #0
    b854:	f88d 5009 	strb.w	r5, [sp, #9]
    b858:	f88d 500a 	strb.w	r5, [sp, #10]
    b85c:	f88d 500b 	strb.w	r5, [sp, #11]
    b860:	9b02      	ldr	r3, [sp, #8]
    b862:	9308      	str	r3, [sp, #32]
    b864:	4629      	mov	r1, r5
    b866:	f365 0100 	bfi	r1, r5, #0, #1
    b86a:	f365 0141 	bfi	r1, r5, #1, #1
    b86e:	f365 0182 	bfi	r1, r5, #2, #1
    b872:	f365 01c5 	bfi	r1, r5, #3, #3
    b876:	2301      	movs	r3, #1
    b878:	f363 1188 	bfi	r1, r3, #6, #3
    b87c:	2308      	movs	r3, #8
    b87e:	f363 2152 	bfi	r1, r3, #9, #10
    b882:	f365 41de 	bfi	r1, r5, #19, #12
    b886:	f365 71df 	bfi	r1, r5, #31, #1
    b88a:	462b      	mov	r3, r5
    b88c:	aa08      	add	r2, sp, #32
    b88e:	480b      	ldr	r0, [pc, #44]	; (b8bc <chan_send+0xe8>)
    b890:	f7f6 fcda 	bl	2248 <z_impl_z_log_msg_static_create>
			tx_meta_data_free(bt_att_tx_meta_data(buf));
    b894:	6966      	ldr	r6, [r4, #20]
	(void)memset(data, 0, sizeof(*data));
    b896:	2214      	movs	r2, #20
    b898:	4629      	mov	r1, r5
    b89a:	4630      	mov	r0, r6
    b89c:	f00b ff77 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    b8a0:	4631      	mov	r1, r6
    b8a2:	4807      	ldr	r0, [pc, #28]	; (b8c0 <chan_send+0xec>)
    b8a4:	f010 fc60 	bl	1c168 <k_queue_append>
			net_buf_unref(buf);
    b8a8:	4620      	mov	r0, r4
    b8aa:	f00e fc5e 	bl	1a16a <net_buf_unref>
			return err;
    b8ae:	e7c0      	b.n	b832 <chan_send+0x5e>
		return -EINVAL;
    b8b0:	f06f 0915 	mvn.w	r9, #21
    b8b4:	e7bd      	b.n	b832 <chan_send+0x5e>
    b8b6:	bf00      	nop
    b8b8:	0001ee84 	.word	0x0001ee84
    b8bc:	0001cfd4 	.word	0x0001cfd4
    b8c0:	20000654 	.word	0x20000654

0000b8c4 <bt_att_chan_create_pdu>:
{
    b8c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    b8c8:	b089      	sub	sp, #36	; 0x24
    b8ca:	af00      	add	r7, sp, #0
    b8cc:	460c      	mov	r4, r1
	if (len + sizeof(op) > chan->chan.tx.mtu) {
    b8ce:	1c53      	adds	r3, r2, #1
    b8d0:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
    b8d2:	428b      	cmp	r3, r1
    b8d4:	d80b      	bhi.n	b8ee <bt_att_chan_create_pdu+0x2a>
	switch (att_op_get_type(op)) {
    b8d6:	4620      	mov	r0, r4
    b8d8:	f00c fdd2 	bl	18480 <att_op_get_type>
    b8dc:	2802      	cmp	r0, #2
    b8de:	d047      	beq.n	b970 <bt_att_chan_create_pdu+0xac>
    b8e0:	2804      	cmp	r0, #4
    b8e2:	d045      	beq.n	b970 <bt_att_chan_create_pdu+0xac>
		timeout = K_FOREVER;
    b8e4:	f04f 38ff 	mov.w	r8, #4294967295
    b8e8:	f04f 39ff 	mov.w	r9, #4294967295
    b8ec:	e044      	b.n	b978 <bt_att_chan_create_pdu+0xb4>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
    b8ee:	466d      	mov	r5, sp
    b8f0:	b088      	sub	sp, #32
    b8f2:	466c      	mov	r4, sp
    b8f4:	f114 0210 	adds.w	r2, r4, #16
    b8f8:	d034      	beq.n	b964 <bt_att_chan_create_pdu+0xa0>
    b8fa:	2010      	movs	r0, #16
    b8fc:	b11a      	cbz	r2, b906 <bt_att_chan_create_pdu+0x42>
    b8fe:	2804      	cmp	r0, #4
    b900:	dd01      	ble.n	b906 <bt_att_chan_create_pdu+0x42>
    b902:	4e5c      	ldr	r6, [pc, #368]	; (ba74 <bt_att_chan_create_pdu+0x1b0>)
    b904:	6166      	str	r6, [r4, #20]
    b906:	b112      	cbz	r2, b90e <bt_att_chan_create_pdu+0x4a>
    b908:	2808      	cmp	r0, #8
    b90a:	dd00      	ble.n	b90e <bt_att_chan_create_pdu+0x4a>
    b90c:	61a1      	str	r1, [r4, #24]
    b90e:	b112      	cbz	r2, b916 <bt_att_chan_create_pdu+0x52>
    b910:	280c      	cmp	r0, #12
    b912:	dd00      	ble.n	b916 <bt_att_chan_create_pdu+0x52>
    b914:	61e3      	str	r3, [r4, #28]
    b916:	280f      	cmp	r0, #15
    b918:	dd27      	ble.n	b96a <bt_att_chan_create_pdu+0xa6>
    b91a:	2310      	movs	r3, #16
    b91c:	b13a      	cbz	r2, b92e <bt_att_chan_create_pdu+0x6a>
    b91e:	2104      	movs	r1, #4
    b920:	7139      	strb	r1, [r7, #4]
    b922:	2100      	movs	r1, #0
    b924:	7179      	strb	r1, [r7, #5]
    b926:	71b9      	strb	r1, [r7, #6]
    b928:	71f9      	strb	r1, [r7, #7]
    b92a:	6878      	ldr	r0, [r7, #4]
    b92c:	6120      	str	r0, [r4, #16]
    b92e:	2100      	movs	r1, #0
    b930:	f36f 0100 	bfc	r1, #0, #1
    b934:	f36f 0141 	bfc	r1, #1, #1
    b938:	f36f 0182 	bfc	r1, #2, #1
    b93c:	f36f 01c5 	bfc	r1, #3, #3
    b940:	2002      	movs	r0, #2
    b942:	f360 1188 	bfi	r1, r0, #6, #3
    b946:	f403 737d 	and.w	r3, r3, #1012	; 0x3f4
    b94a:	f363 2152 	bfi	r1, r3, #9, #10
    b94e:	f36f 41de 	bfc	r1, #19, #12
    b952:	f36f 71df 	bfc	r1, #31, #1
    b956:	2300      	movs	r3, #0
    b958:	4847      	ldr	r0, [pc, #284]	; (ba78 <bt_att_chan_create_pdu+0x1b4>)
    b95a:	f7f6 fc75 	bl	2248 <z_impl_z_log_msg_static_create>
    b95e:	46ad      	mov	sp, r5
		return NULL;
    b960:	2500      	movs	r5, #0
    b962:	e01f      	b.n	b9a4 <bt_att_chan_create_pdu+0xe0>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
    b964:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    b968:	e7c8      	b.n	b8fc <bt_att_chan_create_pdu+0x38>
    b96a:	f06f 031b 	mvn.w	r3, #27
    b96e:	e7d5      	b.n	b91c <bt_att_chan_create_pdu+0x58>
		timeout = BT_ATT_TIMEOUT;
    b970:	f44f 2870 	mov.w	r8, #983040	; 0xf0000
    b974:	f04f 0900 	mov.w	r9, #0
	buf = bt_l2cap_create_pdu_timeout(NULL, 0, timeout);
    b978:	4642      	mov	r2, r8
    b97a:	464b      	mov	r3, r9
    b97c:	2100      	movs	r1, #0
    b97e:	4608      	mov	r0, r1
    b980:	f00c fcab 	bl	182da <bt_l2cap_create_pdu_timeout>
	if (!buf) {
    b984:	4605      	mov	r5, r0
    b986:	b190      	cbz	r0, b9ae <bt_att_chan_create_pdu+0xea>
	data = tx_meta_data_alloc(timeout);
    b988:	4640      	mov	r0, r8
    b98a:	4649      	mov	r1, r9
    b98c:	f7ff fae6 	bl	af5c <tx_meta_data_alloc>
	if (!data) {
    b990:	4606      	mov	r6, r0
    b992:	2800      	cmp	r0, #0
    b994:	d047      	beq.n	ba26 <bt_att_chan_create_pdu+0x162>
	bt_att_tx_meta_data(buf) = data;
    b996:	6168      	str	r0, [r5, #20]
	return net_buf_simple_add(&buf->b, len);
    b998:	2101      	movs	r1, #1
    b99a:	f105 0008 	add.w	r0, r5, #8
    b99e:	f00e fc2e 	bl	1a1fe <net_buf_simple_add>
	hdr->code = op;
    b9a2:	7004      	strb	r4, [r0, #0]
}
    b9a4:	4628      	mov	r0, r5
    b9a6:	3724      	adds	r7, #36	; 0x24
    b9a8:	46bd      	mov	sp, r7
    b9aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
    b9ae:	466e      	mov	r6, sp
    b9b0:	b088      	sub	sp, #32
    b9b2:	466b      	mov	r3, sp
    b9b4:	f113 0210 	adds.w	r2, r3, #16
    b9b8:	d02f      	beq.n	ba1a <bt_att_chan_create_pdu+0x156>
    b9ba:	210c      	movs	r1, #12
    b9bc:	b11a      	cbz	r2, b9c6 <bt_att_chan_create_pdu+0x102>
    b9be:	2904      	cmp	r1, #4
    b9c0:	dd01      	ble.n	b9c6 <bt_att_chan_create_pdu+0x102>
    b9c2:	482e      	ldr	r0, [pc, #184]	; (ba7c <bt_att_chan_create_pdu+0x1b8>)
    b9c4:	6158      	str	r0, [r3, #20]
    b9c6:	b112      	cbz	r2, b9ce <bt_att_chan_create_pdu+0x10a>
    b9c8:	2908      	cmp	r1, #8
    b9ca:	dd00      	ble.n	b9ce <bt_att_chan_create_pdu+0x10a>
    b9cc:	619c      	str	r4, [r3, #24]
    b9ce:	290b      	cmp	r1, #11
    b9d0:	dd26      	ble.n	ba20 <bt_att_chan_create_pdu+0x15c>
    b9d2:	240c      	movs	r4, #12
    b9d4:	b13a      	cbz	r2, b9e6 <bt_att_chan_create_pdu+0x122>
    b9d6:	2103      	movs	r1, #3
    b9d8:	7139      	strb	r1, [r7, #4]
    b9da:	2100      	movs	r1, #0
    b9dc:	7179      	strb	r1, [r7, #5]
    b9de:	71b9      	strb	r1, [r7, #6]
    b9e0:	71f9      	strb	r1, [r7, #7]
    b9e2:	6878      	ldr	r0, [r7, #4]
    b9e4:	6118      	str	r0, [r3, #16]
    b9e6:	2100      	movs	r1, #0
    b9e8:	f36f 0100 	bfc	r1, #0, #1
    b9ec:	f36f 0141 	bfc	r1, #1, #1
    b9f0:	f36f 0182 	bfc	r1, #2, #1
    b9f4:	f36f 01c5 	bfc	r1, #3, #3
    b9f8:	2301      	movs	r3, #1
    b9fa:	f363 1188 	bfi	r1, r3, #6, #3
    b9fe:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    ba02:	f363 2152 	bfi	r1, r3, #9, #10
    ba06:	f36f 41de 	bfc	r1, #19, #12
    ba0a:	f36f 71df 	bfc	r1, #31, #1
    ba0e:	2300      	movs	r3, #0
    ba10:	4819      	ldr	r0, [pc, #100]	; (ba78 <bt_att_chan_create_pdu+0x1b4>)
    ba12:	f7f6 fc19 	bl	2248 <z_impl_z_log_msg_static_create>
    ba16:	46b5      	mov	sp, r6
		return NULL;
    ba18:	e7c4      	b.n	b9a4 <bt_att_chan_create_pdu+0xe0>
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
    ba1a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    ba1e:	e7cd      	b.n	b9bc <bt_att_chan_create_pdu+0xf8>
    ba20:	f06f 041b 	mvn.w	r4, #27
    ba24:	e7d6      	b.n	b9d4 <bt_att_chan_create_pdu+0x110>
		BT_WARN("Unable to allocate ATT TX meta");
    ba26:	4b16      	ldr	r3, [pc, #88]	; (ba80 <bt_att_chan_create_pdu+0x1bc>)
    ba28:	61fb      	str	r3, [r7, #28]
    ba2a:	2202      	movs	r2, #2
    ba2c:	713a      	strb	r2, [r7, #4]
    ba2e:	2300      	movs	r3, #0
    ba30:	717b      	strb	r3, [r7, #5]
    ba32:	71bb      	strb	r3, [r7, #6]
    ba34:	71fb      	strb	r3, [r7, #7]
    ba36:	6879      	ldr	r1, [r7, #4]
    ba38:	61b9      	str	r1, [r7, #24]
    ba3a:	4619      	mov	r1, r3
    ba3c:	f363 0100 	bfi	r1, r3, #0, #1
    ba40:	f363 0141 	bfi	r1, r3, #1, #1
    ba44:	f363 0182 	bfi	r1, r3, #2, #1
    ba48:	f363 01c5 	bfi	r1, r3, #3, #3
    ba4c:	f362 1188 	bfi	r1, r2, #6, #3
    ba50:	2208      	movs	r2, #8
    ba52:	f362 2152 	bfi	r1, r2, #9, #10
    ba56:	f363 41de 	bfi	r1, r3, #19, #12
    ba5a:	f363 71df 	bfi	r1, r3, #31, #1
    ba5e:	f107 0218 	add.w	r2, r7, #24
    ba62:	4805      	ldr	r0, [pc, #20]	; (ba78 <bt_att_chan_create_pdu+0x1b4>)
    ba64:	f7f6 fbf0 	bl	2248 <z_impl_z_log_msg_static_create>
		net_buf_unref(buf);
    ba68:	4628      	mov	r0, r5
    ba6a:	f00e fb7e 	bl	1a16a <net_buf_unref>
		return NULL;
    ba6e:	4635      	mov	r5, r6
    ba70:	e798      	b.n	b9a4 <bt_att_chan_create_pdu+0xe0>
    ba72:	bf00      	nop
    ba74:	0001ee98 	.word	0x0001ee98
    ba78:	0001cfd4 	.word	0x0001cfd4
    ba7c:	0001ec74 	.word	0x0001ec74
    ba80:	0001eec0 	.word	0x0001eec0

0000ba84 <bt_att_recv>:
{
    ba84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ba88:	b095      	sub	sp, #84	; 0x54
    ba8a:	af00      	add	r7, sp, #0
	if (buf->len < sizeof(*hdr)) {
    ba8c:	898b      	ldrh	r3, [r1, #12]
    ba8e:	b173      	cbz	r3, baae <bt_att_recv+0x2a>
    ba90:	4606      	mov	r6, r0
    ba92:	460d      	mov	r5, r1
    ba94:	f1a0 0804 	sub.w	r8, r0, #4
	return net_buf_simple_pull_mem(&buf->b, len);
    ba98:	2101      	movs	r1, #1
    ba9a:	f105 0008 	add.w	r0, r5, #8
    ba9e:	f00e fbe6 	bl	1a26e <net_buf_simple_pull_mem>
    baa2:	4604      	mov	r4, r0
	if (!att_chan->att) {
    baa4:	f856 3c04 	ldr.w	r3, [r6, #-4]
    baa8:	b31b      	cbz	r3, baf2 <bt_att_recv+0x6e>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    baaa:	2300      	movs	r3, #0
    baac:	e027      	b.n	bafe <bt_att_recv+0x7a>
		BT_ERR("Too small ATT PDU received");
    baae:	4ba7      	ldr	r3, [pc, #668]	; (bd4c <bt_att_recv+0x2c8>)
    bab0:	64fb      	str	r3, [r7, #76]	; 0x4c
    bab2:	2302      	movs	r3, #2
    bab4:	713b      	strb	r3, [r7, #4]
    bab6:	2300      	movs	r3, #0
    bab8:	717b      	strb	r3, [r7, #5]
    baba:	71bb      	strb	r3, [r7, #6]
    babc:	71fb      	strb	r3, [r7, #7]
    babe:	687a      	ldr	r2, [r7, #4]
    bac0:	64ba      	str	r2, [r7, #72]	; 0x48
    bac2:	4619      	mov	r1, r3
    bac4:	f363 0100 	bfi	r1, r3, #0, #1
    bac8:	f363 0141 	bfi	r1, r3, #1, #1
    bacc:	f363 0182 	bfi	r1, r3, #2, #1
    bad0:	f363 01c5 	bfi	r1, r3, #3, #3
    bad4:	2201      	movs	r2, #1
    bad6:	f362 1188 	bfi	r1, r2, #6, #3
    bada:	2208      	movs	r2, #8
    badc:	f362 2152 	bfi	r1, r2, #9, #10
    bae0:	f363 41de 	bfi	r1, r3, #19, #12
    bae4:	f363 71df 	bfi	r1, r3, #31, #1
    bae8:	f107 0248 	add.w	r2, r7, #72	; 0x48
    baec:	4898      	ldr	r0, [pc, #608]	; (bd50 <bt_att_recv+0x2cc>)
    baee:	f7f6 fbab 	bl	2248 <z_impl_z_log_msg_static_create>
}
    baf2:	2000      	movs	r0, #0
    baf4:	3754      	adds	r7, #84	; 0x54
    baf6:	46bd      	mov	sp, r7
    baf8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    bafc:	3301      	adds	r3, #1
    bafe:	2b1d      	cmp	r3, #29
    bb00:	d868      	bhi.n	bbd4 <bt_att_recv+0x150>
		if (hdr->code == handlers[i].op) {
    bb02:	f894 c000 	ldrb.w	ip, [r4]
    bb06:	4a93      	ldr	r2, [pc, #588]	; (bd54 <bt_att_recv+0x2d0>)
    bb08:	f812 2033 	ldrb.w	r2, [r2, r3, lsl #3]
    bb0c:	4594      	cmp	ip, r2
    bb0e:	d1f5      	bne.n	bafc <bt_att_recv+0x78>
			handler = &handlers[i];
    bb10:	4a90      	ldr	r2, [pc, #576]	; (bd54 <bt_att_recv+0x2d0>)
    bb12:	eb02 09c3 	add.w	r9, r2, r3, lsl #3
	if (!handler) {
    bb16:	f1b9 0f00 	cmp.w	r9, #0
    bb1a:	d05e      	beq.n	bbda <bt_att_recv+0x156>
		if (handler->type == ATT_REQUEST &&
    bb1c:	f899 3002 	ldrb.w	r3, [r9, #2]
    bb20:	2b01      	cmp	r3, #1
    bb22:	f000 80a7 	beq.w	bc74 <bt_att_recv+0x1f0>
		} else if (handler->type == ATT_INDICATION &&
    bb26:	f899 3002 	ldrb.w	r3, [r9, #2]
    bb2a:	2b05      	cmp	r3, #5
    bb2c:	f000 80d2 	beq.w	bcd4 <bt_att_recv+0x250>
	if (buf->len < handler->expect_len) {
    bb30:	89a9      	ldrh	r1, [r5, #12]
    bb32:	f899 3001 	ldrb.w	r3, [r9, #1]
    bb36:	4299      	cmp	r1, r3
    bb38:	f080 8101 	bcs.w	bd3e <bt_att_recv+0x2ba>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    bb3c:	7826      	ldrb	r6, [r4, #0]
    bb3e:	466d      	mov	r5, sp
    bb40:	b088      	sub	sp, #32
    bb42:	466b      	mov	r3, sp
    bb44:	f113 0210 	adds.w	r2, r3, #16
    bb48:	f000 80f3 	beq.w	bd32 <bt_att_recv+0x2ae>
    bb4c:	2010      	movs	r0, #16
    bb4e:	b12a      	cbz	r2, bb5c <bt_att_recv+0xd8>
    bb50:	2804      	cmp	r0, #4
    bb52:	dd03      	ble.n	bb5c <bt_att_recv+0xd8>
    bb54:	f8df c200 	ldr.w	ip, [pc, #512]	; bd58 <bt_att_recv+0x2d4>
    bb58:	f8c3 c014 	str.w	ip, [r3, #20]
    bb5c:	b112      	cbz	r2, bb64 <bt_att_recv+0xe0>
    bb5e:	2808      	cmp	r0, #8
    bb60:	dd00      	ble.n	bb64 <bt_att_recv+0xe0>
    bb62:	6199      	str	r1, [r3, #24]
    bb64:	b112      	cbz	r2, bb6c <bt_att_recv+0xe8>
    bb66:	280c      	cmp	r0, #12
    bb68:	dd00      	ble.n	bb6c <bt_att_recv+0xe8>
    bb6a:	61de      	str	r6, [r3, #28]
    bb6c:	280f      	cmp	r0, #15
    bb6e:	f340 80e3 	ble.w	bd38 <bt_att_recv+0x2b4>
    bb72:	2610      	movs	r6, #16
    bb74:	b13a      	cbz	r2, bb86 <bt_att_recv+0x102>
    bb76:	2104      	movs	r1, #4
    bb78:	7139      	strb	r1, [r7, #4]
    bb7a:	2100      	movs	r1, #0
    bb7c:	7179      	strb	r1, [r7, #5]
    bb7e:	71b9      	strb	r1, [r7, #6]
    bb80:	71f9      	strb	r1, [r7, #7]
    bb82:	6878      	ldr	r0, [r7, #4]
    bb84:	6118      	str	r0, [r3, #16]
    bb86:	2100      	movs	r1, #0
    bb88:	f36f 0100 	bfc	r1, #0, #1
    bb8c:	f36f 0141 	bfc	r1, #1, #1
    bb90:	f36f 0182 	bfc	r1, #2, #1
    bb94:	f36f 01c5 	bfc	r1, #3, #3
    bb98:	2301      	movs	r3, #1
    bb9a:	f363 1188 	bfi	r1, r3, #6, #3
    bb9e:	f406 767d 	and.w	r6, r6, #1012	; 0x3f4
    bba2:	f366 2152 	bfi	r1, r6, #9, #10
    bba6:	f36f 41de 	bfc	r1, #19, #12
    bbaa:	f36f 71df 	bfc	r1, #31, #1
    bbae:	2300      	movs	r3, #0
    bbb0:	4867      	ldr	r0, [pc, #412]	; (bd50 <bt_att_recv+0x2cc>)
    bbb2:	f7f6 fb49 	bl	2248 <z_impl_z_log_msg_static_create>
    bbb6:	46ad      	mov	sp, r5
		err = BT_ATT_ERR_INVALID_PDU;
    bbb8:	2004      	movs	r0, #4
	if (handler->type == ATT_REQUEST && err) {
    bbba:	f899 3002 	ldrb.w	r3, [r9, #2]
    bbbe:	2b01      	cmp	r3, #1
    bbc0:	d197      	bne.n	baf2 <bt_att_recv+0x6e>
    bbc2:	2800      	cmp	r0, #0
    bbc4:	d095      	beq.n	baf2 <bt_att_recv+0x6e>
		send_err_rsp(att_chan, hdr->code, 0, err);
    bbc6:	4603      	mov	r3, r0
    bbc8:	2200      	movs	r2, #0
    bbca:	7821      	ldrb	r1, [r4, #0]
    bbcc:	4640      	mov	r0, r8
    bbce:	f00d f87d 	bl	18ccc <send_err_rsp>
    bbd2:	e78e      	b.n	baf2 <bt_att_recv+0x6e>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
    bbd4:	f04f 0900 	mov.w	r9, #0
    bbd8:	e79d      	b.n	bb16 <bt_att_recv+0x92>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
    bbda:	7820      	ldrb	r0, [r4, #0]
    bbdc:	466d      	mov	r5, sp
    bbde:	b088      	sub	sp, #32
    bbe0:	466b      	mov	r3, sp
    bbe2:	f113 0210 	adds.w	r2, r3, #16
    bbe6:	d03f      	beq.n	bc68 <bt_att_recv+0x1e4>
    bbe8:	210c      	movs	r1, #12
    bbea:	b11a      	cbz	r2, bbf4 <bt_att_recv+0x170>
    bbec:	2904      	cmp	r1, #4
    bbee:	dd01      	ble.n	bbf4 <bt_att_recv+0x170>
    bbf0:	4e5a      	ldr	r6, [pc, #360]	; (bd5c <bt_att_recv+0x2d8>)
    bbf2:	615e      	str	r6, [r3, #20]
    bbf4:	b112      	cbz	r2, bbfc <bt_att_recv+0x178>
    bbf6:	2908      	cmp	r1, #8
    bbf8:	dd00      	ble.n	bbfc <bt_att_recv+0x178>
    bbfa:	6198      	str	r0, [r3, #24]
    bbfc:	290b      	cmp	r1, #11
    bbfe:	dd36      	ble.n	bc6e <bt_att_recv+0x1ea>
    bc00:	260c      	movs	r6, #12
    bc02:	b13a      	cbz	r2, bc14 <bt_att_recv+0x190>
    bc04:	2103      	movs	r1, #3
    bc06:	7139      	strb	r1, [r7, #4]
    bc08:	2100      	movs	r1, #0
    bc0a:	7179      	strb	r1, [r7, #5]
    bc0c:	71b9      	strb	r1, [r7, #6]
    bc0e:	71f9      	strb	r1, [r7, #7]
    bc10:	6878      	ldr	r0, [r7, #4]
    bc12:	6118      	str	r0, [r3, #16]
    bc14:	2100      	movs	r1, #0
    bc16:	f36f 0100 	bfc	r1, #0, #1
    bc1a:	f36f 0141 	bfc	r1, #1, #1
    bc1e:	f36f 0182 	bfc	r1, #2, #1
    bc22:	f36f 01c5 	bfc	r1, #3, #3
    bc26:	2302      	movs	r3, #2
    bc28:	f363 1188 	bfi	r1, r3, #6, #3
    bc2c:	f406 737b 	and.w	r3, r6, #1004	; 0x3ec
    bc30:	f363 2152 	bfi	r1, r3, #9, #10
    bc34:	f36f 41de 	bfc	r1, #19, #12
    bc38:	f36f 71df 	bfc	r1, #31, #1
    bc3c:	2300      	movs	r3, #0
    bc3e:	4844      	ldr	r0, [pc, #272]	; (bd50 <bt_att_recv+0x2cc>)
    bc40:	f7f6 fb02 	bl	2248 <z_impl_z_log_msg_static_create>
    bc44:	46ad      	mov	sp, r5
		if (att_op_get_type(hdr->code) != ATT_COMMAND &&
    bc46:	7824      	ldrb	r4, [r4, #0]
    bc48:	4620      	mov	r0, r4
    bc4a:	f00c fc19 	bl	18480 <att_op_get_type>
    bc4e:	2800      	cmp	r0, #0
    bc50:	f43f af4f 	beq.w	baf2 <bt_att_recv+0x6e>
    bc54:	2805      	cmp	r0, #5
    bc56:	f43f af4c 	beq.w	baf2 <bt_att_recv+0x6e>
			send_err_rsp(att_chan, hdr->code, 0,
    bc5a:	2306      	movs	r3, #6
    bc5c:	2200      	movs	r2, #0
    bc5e:	4621      	mov	r1, r4
    bc60:	4640      	mov	r0, r8
    bc62:	f00d f833 	bl	18ccc <send_err_rsp>
		return 0;
    bc66:	e744      	b.n	baf2 <bt_att_recv+0x6e>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
    bc68:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    bc6c:	e7bd      	b.n	bbea <bt_att_recv+0x166>
    bc6e:	f06f 061b 	mvn.w	r6, #27
    bc72:	e7c6      	b.n	bc02 <bt_att_recv+0x17e>
		    atomic_test_and_set_bit(att_chan->flags, ATT_PENDING_RSP)) {
    bc74:	f106 038c 	add.w	r3, r6, #140	; 0x8c
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    bc78:	e8d3 2fef 	ldaex	r2, [r3]
    bc7c:	f042 0101 	orr.w	r1, r2, #1
    bc80:	e8c3 1fe0 	stlex	r0, r1, [r3]
    bc84:	2800      	cmp	r0, #0
    bc86:	d1f7      	bne.n	bc78 <bt_att_recv+0x1f4>
		if (handler->type == ATT_REQUEST &&
    bc88:	f012 0f01 	tst.w	r2, #1
    bc8c:	f43f af4b 	beq.w	bb26 <bt_att_recv+0xa2>
			BT_WARN("Ignoring unexpected request");
    bc90:	4b33      	ldr	r3, [pc, #204]	; (bd60 <bt_att_recv+0x2dc>)
    bc92:	61fb      	str	r3, [r7, #28]
    bc94:	2202      	movs	r2, #2
    bc96:	713a      	strb	r2, [r7, #4]
    bc98:	2300      	movs	r3, #0
    bc9a:	717b      	strb	r3, [r7, #5]
    bc9c:	71bb      	strb	r3, [r7, #6]
    bc9e:	71fb      	strb	r3, [r7, #7]
    bca0:	6879      	ldr	r1, [r7, #4]
    bca2:	61b9      	str	r1, [r7, #24]
    bca4:	4619      	mov	r1, r3
    bca6:	f363 0100 	bfi	r1, r3, #0, #1
    bcaa:	f363 0141 	bfi	r1, r3, #1, #1
    bcae:	f363 0182 	bfi	r1, r3, #2, #1
    bcb2:	f363 01c5 	bfi	r1, r3, #3, #3
    bcb6:	f362 1188 	bfi	r1, r2, #6, #3
    bcba:	2208      	movs	r2, #8
    bcbc:	f362 2152 	bfi	r1, r2, #9, #10
    bcc0:	f363 41de 	bfi	r1, r3, #19, #12
    bcc4:	f363 71df 	bfi	r1, r3, #31, #1
    bcc8:	f107 0218 	add.w	r2, r7, #24
    bccc:	4820      	ldr	r0, [pc, #128]	; (bd50 <bt_att_recv+0x2cc>)
    bcce:	f7f6 fabb 	bl	2248 <z_impl_z_log_msg_static_create>
			return 0;
    bcd2:	e70e      	b.n	baf2 <bt_att_recv+0x6e>
			   atomic_test_and_set_bit(att_chan->flags,
    bcd4:	368c      	adds	r6, #140	; 0x8c
    bcd6:	e8d6 3fef 	ldaex	r3, [r6]
    bcda:	f043 0202 	orr.w	r2, r3, #2
    bcde:	e8c6 2fe1 	stlex	r1, r2, [r6]
    bce2:	2900      	cmp	r1, #0
    bce4:	d1f7      	bne.n	bcd6 <bt_att_recv+0x252>
		} else if (handler->type == ATT_INDICATION &&
    bce6:	f013 0f02 	tst.w	r3, #2
    bcea:	f43f af21 	beq.w	bb30 <bt_att_recv+0xac>
			BT_WARN("Ignoring unexpected indication");
    bcee:	4b1d      	ldr	r3, [pc, #116]	; (bd64 <bt_att_recv+0x2e0>)
    bcf0:	637b      	str	r3, [r7, #52]	; 0x34
    bcf2:	2202      	movs	r2, #2
    bcf4:	713a      	strb	r2, [r7, #4]
    bcf6:	2300      	movs	r3, #0
    bcf8:	717b      	strb	r3, [r7, #5]
    bcfa:	71bb      	strb	r3, [r7, #6]
    bcfc:	71fb      	strb	r3, [r7, #7]
    bcfe:	6879      	ldr	r1, [r7, #4]
    bd00:	6339      	str	r1, [r7, #48]	; 0x30
    bd02:	4619      	mov	r1, r3
    bd04:	f363 0100 	bfi	r1, r3, #0, #1
    bd08:	f363 0141 	bfi	r1, r3, #1, #1
    bd0c:	f363 0182 	bfi	r1, r3, #2, #1
    bd10:	f363 01c5 	bfi	r1, r3, #3, #3
    bd14:	f362 1188 	bfi	r1, r2, #6, #3
    bd18:	2208      	movs	r2, #8
    bd1a:	f362 2152 	bfi	r1, r2, #9, #10
    bd1e:	f363 41de 	bfi	r1, r3, #19, #12
    bd22:	f363 71df 	bfi	r1, r3, #31, #1
    bd26:	f107 0230 	add.w	r2, r7, #48	; 0x30
    bd2a:	4809      	ldr	r0, [pc, #36]	; (bd50 <bt_att_recv+0x2cc>)
    bd2c:	f7f6 fa8c 	bl	2248 <z_impl_z_log_msg_static_create>
			return 0;
    bd30:	e6df      	b.n	baf2 <bt_att_recv+0x6e>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
    bd32:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    bd36:	e70a      	b.n	bb4e <bt_att_recv+0xca>
    bd38:	f06f 061b 	mvn.w	r6, #27
    bd3c:	e71a      	b.n	bb74 <bt_att_recv+0xf0>
		err = handler->func(att_chan, buf);
    bd3e:	f8d9 3004 	ldr.w	r3, [r9, #4]
    bd42:	4629      	mov	r1, r5
    bd44:	4640      	mov	r0, r8
    bd46:	4798      	blx	r3
    bd48:	e737      	b.n	bbba <bt_att_recv+0x136>
    bd4a:	bf00      	nop
    bd4c:	0001eee0 	.word	0x0001eee0
    bd50:	0001cfd4 	.word	0x0001cfd4
    bd54:	0001efbc 	.word	0x0001efbc
    bd58:	0001ef54 	.word	0x0001ef54
    bd5c:	0001eefc 	.word	0x0001eefc
    bd60:	0001ef18 	.word	0x0001ef18
    bd64:	0001ef34 	.word	0x0001ef34

0000bd68 <att_write_rsp>:
{
    bd68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bd6c:	b08a      	sub	sp, #40	; 0x28
    bd6e:	4604      	mov	r4, r0
    bd70:	4617      	mov	r7, r2
    bd72:	461d      	mov	r5, r3
	if (!bt_gatt_change_aware(chan->att->conn, req ? true : false)) {
    bd74:	6803      	ldr	r3, [r0, #0]
    bd76:	4688      	mov	r8, r1
    bd78:	3900      	subs	r1, #0
    bd7a:	bf18      	it	ne
    bd7c:	2101      	movne	r1, #1
    bd7e:	6818      	ldr	r0, [r3, #0]
    bd80:	f00e f80e 	bl	19da0 <bt_gatt_change_aware>
    bd84:	b128      	cbz	r0, bd92 <att_write_rsp+0x2a>
	if (!handle) {
    bd86:	b9a5      	cbnz	r5, bdb2 <att_write_rsp+0x4a>
		return BT_ATT_ERR_INVALID_HANDLE;
    bd88:	2601      	movs	r6, #1
}
    bd8a:	4630      	mov	r0, r6
    bd8c:	b00a      	add	sp, #40	; 0x28
    bd8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
    bd92:	3490      	adds	r4, #144	; 0x90
    bd94:	e8d4 3fef 	ldaex	r3, [r4]
    bd98:	f043 0220 	orr.w	r2, r3, #32
    bd9c:	e8c4 2fe1 	stlex	r1, r2, [r4]
    bda0:	2900      	cmp	r1, #0
    bda2:	d1f7      	bne.n	bd94 <att_write_rsp+0x2c>
    bda4:	f013 0f20 	tst.w	r3, #32
    bda8:	d001      	beq.n	bdae <att_write_rsp+0x46>
			return 0;
    bdaa:	2600      	movs	r6, #0
    bdac:	e7ed      	b.n	bd8a <att_write_rsp+0x22>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
    bdae:	2612      	movs	r6, #18
    bdb0:	e7eb      	b.n	bd8a <att_write_rsp+0x22>
	(void)memset(&data, 0, sizeof(data));
    bdb2:	2218      	movs	r2, #24
    bdb4:	2100      	movs	r1, #0
    bdb6:	a804      	add	r0, sp, #16
    bdb8:	f00b fce9 	bl	1778e <memset>
	if (rsp) {
    bdbc:	b13f      	cbz	r7, bdce <att_write_rsp+0x66>
		data.buf = bt_att_chan_create_pdu(chan, rsp, 0);
    bdbe:	2200      	movs	r2, #0
    bdc0:	4639      	mov	r1, r7
    bdc2:	4620      	mov	r0, r4
    bdc4:	f7ff fd7e 	bl	b8c4 <bt_att_chan_create_pdu>
    bdc8:	9005      	str	r0, [sp, #20]
		if (!data.buf) {
    bdca:	2800      	cmp	r0, #0
    bdcc:	d045      	beq.n	be5a <att_write_rsp+0xf2>
	data.conn = chan->att->conn;
    bdce:	6823      	ldr	r3, [r4, #0]
    bdd0:	681b      	ldr	r3, [r3, #0]
    bdd2:	9304      	str	r3, [sp, #16]
	data.req = req;
    bdd4:	f88d 8018 	strb.w	r8, [sp, #24]
	data.offset = offset;
    bdd8:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
    bddc:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
	data.value = value;
    bde0:	9b11      	ldr	r3, [sp, #68]	; 0x44
    bde2:	9307      	str	r3, [sp, #28]
	data.len = len;
    bde4:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
    bde8:	f8ad 3020 	strh.w	r3, [sp, #32]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    bdec:	2301      	movs	r3, #1
    bdee:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 */
static inline void bt_gatt_foreach_attr(uint16_t start_handle, uint16_t end_handle,
					bt_gatt_attr_func_t func,
					void *user_data)
{
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
    bdf2:	ab04      	add	r3, sp, #16
    bdf4:	9302      	str	r3, [sp, #8]
    bdf6:	4b1a      	ldr	r3, [pc, #104]	; (be60 <att_write_rsp+0xf8>)
    bdf8:	9301      	str	r3, [sp, #4]
    bdfa:	2200      	movs	r2, #0
    bdfc:	9200      	str	r2, [sp, #0]
    bdfe:	4613      	mov	r3, r2
    be00:	4629      	mov	r1, r5
    be02:	4628      	mov	r0, r5
    be04:	f001 f88e 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (data.err) {
    be08:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
    be0c:	b936      	cbnz	r6, be1c <att_write_rsp+0xb4>
	if (data.buf) {
    be0e:	9905      	ldr	r1, [sp, #20]
    be10:	2900      	cmp	r1, #0
    be12:	d0ba      	beq.n	bd8a <att_write_rsp+0x22>
		bt_att_chan_send_rsp(chan, data.buf);
    be14:	4620      	mov	r0, r4
    be16:	f00c fee4 	bl	18be2 <bt_att_chan_send_rsp>
    be1a:	e7b6      	b.n	bd8a <att_write_rsp+0x22>
		if (rsp) {
    be1c:	b927      	cbnz	r7, be28 <att_write_rsp+0xc0>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    be1e:	f1b8 0f18 	cmp.w	r8, #24
    be22:	d017      	beq.n	be54 <att_write_rsp+0xec>
    be24:	2600      	movs	r6, #0
    be26:	e7b0      	b.n	bd8a <att_write_rsp+0x22>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    be28:	9b05      	ldr	r3, [sp, #20]
    be2a:	695e      	ldr	r6, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    be2c:	2214      	movs	r2, #20
    be2e:	2100      	movs	r1, #0
    be30:	4630      	mov	r0, r6
    be32:	f00b fcac 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    be36:	4631      	mov	r1, r6
    be38:	480a      	ldr	r0, [pc, #40]	; (be64 <att_write_rsp+0xfc>)
    be3a:	f010 f995 	bl	1c168 <k_queue_append>
			net_buf_unref(data.buf);
    be3e:	9805      	ldr	r0, [sp, #20]
    be40:	f00e f993 	bl	1a16a <net_buf_unref>
			send_err_rsp(chan, req, handle, data.err);
    be44:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    be48:	462a      	mov	r2, r5
    be4a:	4641      	mov	r1, r8
    be4c:	4620      	mov	r0, r4
    be4e:	f00c ff3d 	bl	18ccc <send_err_rsp>
    be52:	e7e4      	b.n	be1e <att_write_rsp+0xb6>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
    be54:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
    be58:	e797      	b.n	bd8a <att_write_rsp+0x22>
			return BT_ATT_ERR_UNLIKELY;
    be5a:	260e      	movs	r6, #14
    be5c:	e795      	b.n	bd8a <att_write_rsp+0x22>
    be5e:	bf00      	nop
    be60:	00018665 	.word	0x00018665
    be64:	20000654 	.word	0x20000654

0000be68 <bt_att_create_pdu>:
{
    be68:	b5f0      	push	{r4, r5, r6, r7, lr}
    be6a:	b083      	sub	sp, #12
    be6c:	af00      	add	r7, sp, #0
    be6e:	460e      	mov	r6, r1
    be70:	4615      	mov	r5, r2
	att = att_get(conn);
    be72:	f7ff f87d 	bl	af70 <att_get>
	if (!att) {
    be76:	4604      	mov	r4, r0
    be78:	b320      	cbz	r0, bec4 <bt_att_create_pdu+0x5c>
	return list->head;
    be7a:	6a44      	ldr	r4, [r0, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    be7c:	b334      	cbz	r4, becc <bt_att_create_pdu+0x64>
    be7e:	3ce0      	subs	r4, #224	; 0xe0
    be80:	d026      	beq.n	bed0 <bt_att_create_pdu+0x68>
Z_GENLIST_PEEK_NEXT(slist, snode)
    be82:	f114 00e0 	adds.w	r0, r4, #224	; 0xe0
    be86:	d007      	beq.n	be98 <bt_att_create_pdu+0x30>
	return node->next;
    be88:	f8d4 00e0 	ldr.w	r0, [r4, #224]	; 0xe0
    be8c:	b120      	cbz	r0, be98 <bt_att_create_pdu+0x30>
    be8e:	38e0      	subs	r0, #224	; 0xe0
    be90:	e002      	b.n	be98 <bt_att_create_pdu+0x30>
    be92:	4603      	mov	r3, r0
    be94:	4604      	mov	r4, r0
    be96:	4618      	mov	r0, r3
    be98:	b1e4      	cbz	r4, bed4 <bt_att_create_pdu+0x6c>
		if (len + sizeof(op) > chan->chan.tx.mtu) {
    be9a:	1c6b      	adds	r3, r5, #1
    be9c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    be9e:	4293      	cmp	r3, r2
    bea0:	d90a      	bls.n	beb8 <bt_att_create_pdu+0x50>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    bea2:	2800      	cmp	r0, #0
    bea4:	d0f5      	beq.n	be92 <bt_att_create_pdu+0x2a>
Z_GENLIST_PEEK_NEXT(slist, snode)
    bea6:	f110 03e0 	adds.w	r3, r0, #224	; 0xe0
    beaa:	d0f3      	beq.n	be94 <bt_att_create_pdu+0x2c>
	return node->next;
    beac:	f8d0 30e0 	ldr.w	r3, [r0, #224]	; 0xe0
    beb0:	2b00      	cmp	r3, #0
    beb2:	d0ef      	beq.n	be94 <bt_att_create_pdu+0x2c>
    beb4:	3be0      	subs	r3, #224	; 0xe0
    beb6:	e7ed      	b.n	be94 <bt_att_create_pdu+0x2c>
		return bt_att_chan_create_pdu(chan, op, len);
    beb8:	462a      	mov	r2, r5
    beba:	4631      	mov	r1, r6
    bebc:	4620      	mov	r0, r4
    bebe:	f7ff fd01 	bl	b8c4 <bt_att_chan_create_pdu>
    bec2:	4604      	mov	r4, r0
}
    bec4:	4620      	mov	r0, r4
    bec6:	370c      	adds	r7, #12
    bec8:	46bd      	mov	sp, r7
    beca:	bdf0      	pop	{r4, r5, r6, r7, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
    becc:	4620      	mov	r0, r4
    bece:	e7e3      	b.n	be98 <bt_att_create_pdu+0x30>
    bed0:	4620      	mov	r0, r4
    bed2:	e7e1      	b.n	be98 <bt_att_create_pdu+0x30>
	BT_WARN("No ATT channel for MTU %zu", len + sizeof(op));
    bed4:	3501      	adds	r5, #1
    bed6:	466e      	mov	r6, sp
    bed8:	b088      	sub	sp, #32
    beda:	466b      	mov	r3, sp
    bedc:	f113 0210 	adds.w	r2, r3, #16
    bee0:	d02f      	beq.n	bf42 <bt_att_create_pdu+0xda>
    bee2:	210c      	movs	r1, #12
    bee4:	b11a      	cbz	r2, beee <bt_att_create_pdu+0x86>
    bee6:	2904      	cmp	r1, #4
    bee8:	dd01      	ble.n	beee <bt_att_create_pdu+0x86>
    beea:	4819      	ldr	r0, [pc, #100]	; (bf50 <bt_att_create_pdu+0xe8>)
    beec:	6158      	str	r0, [r3, #20]
    beee:	b112      	cbz	r2, bef6 <bt_att_create_pdu+0x8e>
    bef0:	2908      	cmp	r1, #8
    bef2:	dd00      	ble.n	bef6 <bt_att_create_pdu+0x8e>
    bef4:	619d      	str	r5, [r3, #24]
    bef6:	290b      	cmp	r1, #11
    bef8:	dd26      	ble.n	bf48 <bt_att_create_pdu+0xe0>
    befa:	250c      	movs	r5, #12
    befc:	b13a      	cbz	r2, bf0e <bt_att_create_pdu+0xa6>
    befe:	2103      	movs	r1, #3
    bf00:	7139      	strb	r1, [r7, #4]
    bf02:	2100      	movs	r1, #0
    bf04:	7179      	strb	r1, [r7, #5]
    bf06:	71b9      	strb	r1, [r7, #6]
    bf08:	71f9      	strb	r1, [r7, #7]
    bf0a:	6878      	ldr	r0, [r7, #4]
    bf0c:	6118      	str	r0, [r3, #16]
    bf0e:	2100      	movs	r1, #0
    bf10:	f36f 0100 	bfc	r1, #0, #1
    bf14:	f36f 0141 	bfc	r1, #1, #1
    bf18:	f36f 0182 	bfc	r1, #2, #1
    bf1c:	f36f 01c5 	bfc	r1, #3, #3
    bf20:	2302      	movs	r3, #2
    bf22:	f363 1188 	bfi	r1, r3, #6, #3
    bf26:	f405 737b 	and.w	r3, r5, #1004	; 0x3ec
    bf2a:	f363 2152 	bfi	r1, r3, #9, #10
    bf2e:	f36f 41de 	bfc	r1, #19, #12
    bf32:	f36f 71df 	bfc	r1, #31, #1
    bf36:	2300      	movs	r3, #0
    bf38:	4806      	ldr	r0, [pc, #24]	; (bf54 <bt_att_create_pdu+0xec>)
    bf3a:	f7f6 f985 	bl	2248 <z_impl_z_log_msg_static_create>
    bf3e:	46b5      	mov	sp, r6
	return NULL;
    bf40:	e7c0      	b.n	bec4 <bt_att_create_pdu+0x5c>
	BT_WARN("No ATT channel for MTU %zu", len + sizeof(op));
    bf42:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    bf46:	e7cd      	b.n	bee4 <bt_att_create_pdu+0x7c>
    bf48:	f06f 051b 	mvn.w	r5, #27
    bf4c:	e7d6      	b.n	befc <bt_att_create_pdu+0x94>
    bf4e:	bf00      	nop
    bf50:	0001ef74 	.word	0x0001ef74
    bf54:	0001cfd4 	.word	0x0001cfd4

0000bf58 <att_read_group_rsp>:
{
    bf58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    bf5c:	b08a      	sub	sp, #40	; 0x28
    bf5e:	4604      	mov	r4, r0
    bf60:	460f      	mov	r7, r1
    bf62:	4615      	mov	r5, r2
    bf64:	461e      	mov	r6, r3
	struct bt_conn *conn = chan->chan.chan.conn;
    bf66:	f8d0 8004 	ldr.w	r8, [r0, #4]
	(void)memset(&data, 0, sizeof(data));
    bf6a:	2214      	movs	r2, #20
    bf6c:	2100      	movs	r1, #0
    bf6e:	eb0d 0002 	add.w	r0, sp, r2
    bf72:	f00b fc0c 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
    bf76:	2201      	movs	r2, #1
    bf78:	2111      	movs	r1, #17
    bf7a:	4640      	mov	r0, r8
    bf7c:	f7ff ff74 	bl	be68 <bt_att_create_pdu>
    bf80:	9007      	str	r0, [sp, #28]
	if (!data.buf) {
    bf82:	2800      	cmp	r0, #0
    bf84:	d034      	beq.n	bff0 <att_read_group_rsp+0x98>
	data.chan = chan;
    bf86:	9405      	str	r4, [sp, #20]
	data.uuid = uuid;
    bf88:	9706      	str	r7, [sp, #24]
	return net_buf_simple_add(&buf->b, len);
    bf8a:	2101      	movs	r1, #1
    bf8c:	3008      	adds	r0, #8
    bf8e:	f00e f936 	bl	1a1fe <net_buf_simple_add>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    bf92:	9008      	str	r0, [sp, #32]
	data.rsp->len = 0U;
    bf94:	2200      	movs	r2, #0
    bf96:	7002      	strb	r2, [r0, #0]
	data.group = NULL;
    bf98:	9209      	str	r2, [sp, #36]	; 0x24
    bf9a:	ab05      	add	r3, sp, #20
    bf9c:	9302      	str	r3, [sp, #8]
    bf9e:	4b15      	ldr	r3, [pc, #84]	; (bff4 <att_read_group_rsp+0x9c>)
    bfa0:	9301      	str	r3, [sp, #4]
    bfa2:	9200      	str	r2, [sp, #0]
    bfa4:	4613      	mov	r3, r2
    bfa6:	4631      	mov	r1, r6
    bfa8:	4628      	mov	r0, r5
    bfaa:	f000 ffbb 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (!data.rsp->len) {
    bfae:	9b08      	ldr	r3, [sp, #32]
    bfb0:	781e      	ldrb	r6, [r3, #0]
    bfb2:	b146      	cbz	r6, bfc6 <att_read_group_rsp+0x6e>
	bt_att_chan_send_rsp(chan, data.buf);
    bfb4:	9907      	ldr	r1, [sp, #28]
    bfb6:	4620      	mov	r0, r4
    bfb8:	f00c fe13 	bl	18be2 <bt_att_chan_send_rsp>
	return 0;
    bfbc:	2600      	movs	r6, #0
}
    bfbe:	4630      	mov	r0, r6
    bfc0:	b00a      	add	sp, #40	; 0x28
    bfc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    bfc6:	9b07      	ldr	r3, [sp, #28]
    bfc8:	695f      	ldr	r7, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    bfca:	2214      	movs	r2, #20
    bfcc:	2100      	movs	r1, #0
    bfce:	4638      	mov	r0, r7
    bfd0:	f00b fbdd 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    bfd4:	4639      	mov	r1, r7
    bfd6:	4808      	ldr	r0, [pc, #32]	; (bff8 <att_read_group_rsp+0xa0>)
    bfd8:	f010 f8c6 	bl	1c168 <k_queue_append>
		net_buf_unref(data.buf);
    bfdc:	9807      	ldr	r0, [sp, #28]
    bfde:	f00e f8c4 	bl	1a16a <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, start_handle,
    bfe2:	230a      	movs	r3, #10
    bfe4:	462a      	mov	r2, r5
    bfe6:	2110      	movs	r1, #16
    bfe8:	4620      	mov	r0, r4
    bfea:	f00c fe6f 	bl	18ccc <send_err_rsp>
		return 0;
    bfee:	e7e6      	b.n	bfbe <att_read_group_rsp+0x66>
		return BT_ATT_ERR_UNLIKELY;
    bff0:	260e      	movs	r6, #14
    bff2:	e7e4      	b.n	bfbe <att_read_group_rsp+0x66>
    bff4:	0000b2c9 	.word	0x0000b2c9
    bff8:	20000654 	.word	0x20000654

0000bffc <att_read_mult_vl_req>:
{
    bffc:	b570      	push	{r4, r5, r6, lr}
    bffe:	b088      	sub	sp, #32
    c000:	4606      	mov	r6, r0
    c002:	460d      	mov	r5, r1
	struct bt_conn *conn = chan->chan.chan.conn;
    c004:	6844      	ldr	r4, [r0, #4]
	if (!bt_gatt_change_aware(conn, true)) {
    c006:	2101      	movs	r1, #1
    c008:	4620      	mov	r0, r4
    c00a:	f00d fec9 	bl	19da0 <bt_gatt_change_aware>
    c00e:	b980      	cbnz	r0, c032 <att_read_mult_vl_req+0x36>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
    c010:	3690      	adds	r6, #144	; 0x90
    c012:	e8d6 3fef 	ldaex	r3, [r6]
    c016:	f043 0220 	orr.w	r2, r3, #32
    c01a:	e8c6 2fe1 	stlex	r1, r2, [r6]
    c01e:	2900      	cmp	r1, #0
    c020:	d1f7      	bne.n	c012 <att_read_mult_vl_req+0x16>
    c022:	f013 0f20 	tst.w	r3, #32
    c026:	d002      	beq.n	c02e <att_read_mult_vl_req+0x32>
			return 0;
    c028:	2000      	movs	r0, #0
}
    c02a:	b008      	add	sp, #32
    c02c:	bd70      	pop	{r4, r5, r6, pc}
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
    c02e:	2012      	movs	r0, #18
    c030:	e7fb      	b.n	c02a <att_read_mult_vl_req+0x2e>
	(void)memset(&data, 0, sizeof(data));
    c032:	2210      	movs	r2, #16
    c034:	2100      	movs	r1, #0
    c036:	eb0d 0002 	add.w	r0, sp, r2
    c03a:	f00b fba8 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_VL_RSP, 0);
    c03e:	2200      	movs	r2, #0
    c040:	2121      	movs	r1, #33	; 0x21
    c042:	4620      	mov	r0, r4
    c044:	f7ff ff10 	bl	be68 <bt_att_create_pdu>
    c048:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    c04a:	2800      	cmp	r0, #0
    c04c:	d036      	beq.n	c0bc <att_read_mult_vl_req+0xc0>
	data.chan = chan;
    c04e:	9604      	str	r6, [sp, #16]
	while (buf->len >= sizeof(uint16_t)) {
    c050:	89ab      	ldrh	r3, [r5, #12]
    c052:	2b01      	cmp	r3, #1
    c054:	d92c      	bls.n	c0b0 <att_read_mult_vl_req+0xb4>
	return net_buf_simple_pull_le16(&buf->b);
    c056:	f105 0008 	add.w	r0, r5, #8
    c05a:	f00e f910 	bl	1a27e <net_buf_simple_pull_le16>
    c05e:	4604      	mov	r4, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    c060:	2301      	movs	r3, #1
    c062:	f88d 301c 	strb.w	r3, [sp, #28]
    c066:	ab04      	add	r3, sp, #16
    c068:	9302      	str	r3, [sp, #8]
    c06a:	4b15      	ldr	r3, [pc, #84]	; (c0c0 <att_read_mult_vl_req+0xc4>)
    c06c:	9301      	str	r3, [sp, #4]
    c06e:	2200      	movs	r2, #0
    c070:	9200      	str	r2, [sp, #0]
    c072:	4613      	mov	r3, r2
    c074:	4601      	mov	r1, r0
    c076:	f000 ff55 	bl	cf24 <bt_gatt_foreach_attr_type>
		if (data.err) {
    c07a:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c07e:	2b00      	cmp	r3, #0
    c080:	d0e6      	beq.n	c050 <att_read_mult_vl_req+0x54>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    c082:	9b06      	ldr	r3, [sp, #24]
    c084:	695d      	ldr	r5, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c086:	2214      	movs	r2, #20
    c088:	2100      	movs	r1, #0
    c08a:	4628      	mov	r0, r5
    c08c:	f00b fb7f 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c090:	4629      	mov	r1, r5
    c092:	480c      	ldr	r0, [pc, #48]	; (c0c4 <att_read_mult_vl_req+0xc8>)
    c094:	f010 f868 	bl	1c168 <k_queue_append>
			net_buf_unref(data.buf);
    c098:	9806      	ldr	r0, [sp, #24]
    c09a:	f00e f866 	bl	1a16a <net_buf_unref>
			send_err_rsp(chan, BT_ATT_OP_READ_MULT_VL_REQ, handle,
    c09e:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c0a2:	4622      	mov	r2, r4
    c0a4:	2120      	movs	r1, #32
    c0a6:	4630      	mov	r0, r6
    c0a8:	f00c fe10 	bl	18ccc <send_err_rsp>
			return 0;
    c0ac:	2000      	movs	r0, #0
    c0ae:	e7bc      	b.n	c02a <att_read_mult_vl_req+0x2e>
	bt_att_chan_send_rsp(chan, data.buf);
    c0b0:	9906      	ldr	r1, [sp, #24]
    c0b2:	4630      	mov	r0, r6
    c0b4:	f00c fd95 	bl	18be2 <bt_att_chan_send_rsp>
	return 0;
    c0b8:	2000      	movs	r0, #0
    c0ba:	e7b6      	b.n	c02a <att_read_mult_vl_req+0x2e>
		return BT_ATT_ERR_UNLIKELY;
    c0bc:	200e      	movs	r0, #14
    c0be:	e7b4      	b.n	c02a <att_read_mult_vl_req+0x2e>
    c0c0:	00018819 	.word	0x00018819
    c0c4:	20000654 	.word	0x20000654

0000c0c8 <att_read_mult_req>:
{
    c0c8:	b570      	push	{r4, r5, r6, lr}
    c0ca:	b088      	sub	sp, #32
    c0cc:	4606      	mov	r6, r0
    c0ce:	460d      	mov	r5, r1
	struct bt_conn *conn = chan->chan.chan.conn;
    c0d0:	6844      	ldr	r4, [r0, #4]
	if (!bt_gatt_change_aware(conn, true)) {
    c0d2:	2101      	movs	r1, #1
    c0d4:	4620      	mov	r0, r4
    c0d6:	f00d fe63 	bl	19da0 <bt_gatt_change_aware>
    c0da:	b980      	cbnz	r0, c0fe <att_read_mult_req+0x36>
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
    c0dc:	3690      	adds	r6, #144	; 0x90
    c0de:	e8d6 3fef 	ldaex	r3, [r6]
    c0e2:	f043 0220 	orr.w	r2, r3, #32
    c0e6:	e8c6 2fe1 	stlex	r1, r2, [r6]
    c0ea:	2900      	cmp	r1, #0
    c0ec:	d1f7      	bne.n	c0de <att_read_mult_req+0x16>
    c0ee:	f013 0f20 	tst.w	r3, #32
    c0f2:	d002      	beq.n	c0fa <att_read_mult_req+0x32>
			return 0;
    c0f4:	2000      	movs	r0, #0
}
    c0f6:	b008      	add	sp, #32
    c0f8:	bd70      	pop	{r4, r5, r6, pc}
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
    c0fa:	2012      	movs	r0, #18
    c0fc:	e7fb      	b.n	c0f6 <att_read_mult_req+0x2e>
	(void)memset(&data, 0, sizeof(data));
    c0fe:	2210      	movs	r2, #16
    c100:	2100      	movs	r1, #0
    c102:	eb0d 0002 	add.w	r0, sp, r2
    c106:	f00b fb42 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
    c10a:	2200      	movs	r2, #0
    c10c:	210f      	movs	r1, #15
    c10e:	4620      	mov	r0, r4
    c110:	f7ff feaa 	bl	be68 <bt_att_create_pdu>
    c114:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    c116:	2800      	cmp	r0, #0
    c118:	d036      	beq.n	c188 <att_read_mult_req+0xc0>
	data.chan = chan;
    c11a:	9604      	str	r6, [sp, #16]
	while (buf->len >= sizeof(uint16_t)) {
    c11c:	89ab      	ldrh	r3, [r5, #12]
    c11e:	2b01      	cmp	r3, #1
    c120:	d92c      	bls.n	c17c <att_read_mult_req+0xb4>
    c122:	f105 0008 	add.w	r0, r5, #8
    c126:	f00e f8aa 	bl	1a27e <net_buf_simple_pull_le16>
    c12a:	4604      	mov	r4, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
    c12c:	2301      	movs	r3, #1
    c12e:	f88d 301c 	strb.w	r3, [sp, #28]
    c132:	ab04      	add	r3, sp, #16
    c134:	9302      	str	r3, [sp, #8]
    c136:	4b15      	ldr	r3, [pc, #84]	; (c18c <att_read_mult_req+0xc4>)
    c138:	9301      	str	r3, [sp, #4]
    c13a:	2200      	movs	r2, #0
    c13c:	9200      	str	r2, [sp, #0]
    c13e:	4613      	mov	r3, r2
    c140:	4601      	mov	r1, r0
    c142:	f000 feef 	bl	cf24 <bt_gatt_foreach_attr_type>
		if (data.err) {
    c146:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c14a:	2b00      	cmp	r3, #0
    c14c:	d0e6      	beq.n	c11c <att_read_mult_req+0x54>
			tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    c14e:	9b06      	ldr	r3, [sp, #24]
    c150:	695d      	ldr	r5, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c152:	2214      	movs	r2, #20
    c154:	2100      	movs	r1, #0
    c156:	4628      	mov	r0, r5
    c158:	f00b fb19 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c15c:	4629      	mov	r1, r5
    c15e:	480c      	ldr	r0, [pc, #48]	; (c190 <att_read_mult_req+0xc8>)
    c160:	f010 f802 	bl	1c168 <k_queue_append>
			net_buf_unref(data.buf);
    c164:	9806      	ldr	r0, [sp, #24]
    c166:	f00e f800 	bl	1a16a <net_buf_unref>
			send_err_rsp(chan, BT_ATT_OP_READ_MULT_REQ, handle,
    c16a:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c16e:	4622      	mov	r2, r4
    c170:	210e      	movs	r1, #14
    c172:	4630      	mov	r0, r6
    c174:	f00c fdaa 	bl	18ccc <send_err_rsp>
			return 0;
    c178:	2000      	movs	r0, #0
    c17a:	e7bc      	b.n	c0f6 <att_read_mult_req+0x2e>
	bt_att_chan_send_rsp(chan, data.buf);
    c17c:	9906      	ldr	r1, [sp, #24]
    c17e:	4630      	mov	r0, r6
    c180:	f00c fd2f 	bl	18be2 <bt_att_chan_send_rsp>
	return 0;
    c184:	2000      	movs	r0, #0
    c186:	e7b6      	b.n	c0f6 <att_read_mult_req+0x2e>
		return BT_ATT_ERR_UNLIKELY;
    c188:	200e      	movs	r0, #14
    c18a:	e7b4      	b.n	c0f6 <att_read_mult_req+0x2e>
    c18c:	0001887f 	.word	0x0001887f
    c190:	20000654 	.word	0x20000654

0000c194 <att_read_rsp>:
{
    c194:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c198:	b088      	sub	sp, #32
    c19a:	4604      	mov	r4, r0
    c19c:	4688      	mov	r8, r1
    c19e:	4616      	mov	r6, r2
    c1a0:	461d      	mov	r5, r3
	struct bt_conn *conn = chan->chan.chan.conn;
    c1a2:	6847      	ldr	r7, [r0, #4]
	if (!bt_gatt_change_aware(conn, true)) {
    c1a4:	2101      	movs	r1, #1
    c1a6:	4638      	mov	r0, r7
    c1a8:	f00d fdfa 	bl	19da0 <bt_gatt_change_aware>
    c1ac:	b128      	cbz	r0, c1ba <att_read_rsp+0x26>
	if (!handle) {
    c1ae:	b9a5      	cbnz	r5, c1da <att_read_rsp+0x46>
		return BT_ATT_ERR_INVALID_HANDLE;
    c1b0:	2601      	movs	r6, #1
}
    c1b2:	4630      	mov	r0, r6
    c1b4:	b008      	add	sp, #32
    c1b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {
    c1ba:	3490      	adds	r4, #144	; 0x90
    c1bc:	e8d4 3fef 	ldaex	r3, [r4]
    c1c0:	f043 0220 	orr.w	r2, r3, #32
    c1c4:	e8c4 2fe1 	stlex	r1, r2, [r4]
    c1c8:	2900      	cmp	r1, #0
    c1ca:	d1f7      	bne.n	c1bc <att_read_rsp+0x28>
    c1cc:	f013 0f20 	tst.w	r3, #32
    c1d0:	d001      	beq.n	c1d6 <att_read_rsp+0x42>
			return 0;
    c1d2:	2600      	movs	r6, #0
    c1d4:	e7ed      	b.n	c1b2 <att_read_rsp+0x1e>
			return BT_ATT_ERR_DB_OUT_OF_SYNC;
    c1d6:	2612      	movs	r6, #18
    c1d8:	e7eb      	b.n	c1b2 <att_read_rsp+0x1e>
	(void)memset(&data, 0, sizeof(data));
    c1da:	2210      	movs	r2, #16
    c1dc:	2100      	movs	r1, #0
    c1de:	eb0d 0002 	add.w	r0, sp, r2
    c1e2:	f00b fad4 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
    c1e6:	2200      	movs	r2, #0
    c1e8:	4631      	mov	r1, r6
    c1ea:	4638      	mov	r0, r7
    c1ec:	f7ff fe3c 	bl	be68 <bt_att_create_pdu>
    c1f0:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    c1f2:	b388      	cbz	r0, c258 <att_read_rsp+0xc4>
	data.chan = chan;
    c1f4:	9404      	str	r4, [sp, #16]
	data.offset = offset;
    c1f6:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
    c1fa:	f8ad 3014 	strh.w	r3, [sp, #20]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
    c1fe:	2301      	movs	r3, #1
    c200:	f88d 301c 	strb.w	r3, [sp, #28]
    c204:	ab04      	add	r3, sp, #16
    c206:	9302      	str	r3, [sp, #8]
    c208:	4b14      	ldr	r3, [pc, #80]	; (c25c <att_read_rsp+0xc8>)
    c20a:	9301      	str	r3, [sp, #4]
    c20c:	2200      	movs	r2, #0
    c20e:	9200      	str	r2, [sp, #0]
    c210:	4613      	mov	r3, r2
    c212:	4629      	mov	r1, r5
    c214:	4628      	mov	r0, r5
    c216:	f000 fe85 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (data.err) {
    c21a:	f89d 601c 	ldrb.w	r6, [sp, #28]
    c21e:	b926      	cbnz	r6, c22a <att_read_rsp+0x96>
	bt_att_chan_send_rsp(chan, data.buf);
    c220:	9906      	ldr	r1, [sp, #24]
    c222:	4620      	mov	r0, r4
    c224:	f00c fcdd 	bl	18be2 <bt_att_chan_send_rsp>
	return 0;
    c228:	e7c3      	b.n	c1b2 <att_read_rsp+0x1e>
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    c22a:	9b06      	ldr	r3, [sp, #24]
    c22c:	695e      	ldr	r6, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c22e:	2214      	movs	r2, #20
    c230:	2100      	movs	r1, #0
    c232:	4630      	mov	r0, r6
    c234:	f00b faab 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c238:	4631      	mov	r1, r6
    c23a:	4809      	ldr	r0, [pc, #36]	; (c260 <att_read_rsp+0xcc>)
    c23c:	f00f ff94 	bl	1c168 <k_queue_append>
		net_buf_unref(data.buf);
    c240:	9806      	ldr	r0, [sp, #24]
    c242:	f00d ff92 	bl	1a16a <net_buf_unref>
		send_err_rsp(chan, op, handle, data.err);
    c246:	f89d 301c 	ldrb.w	r3, [sp, #28]
    c24a:	462a      	mov	r2, r5
    c24c:	4641      	mov	r1, r8
    c24e:	4620      	mov	r0, r4
    c250:	f00c fd3c 	bl	18ccc <send_err_rsp>
		return 0;
    c254:	2600      	movs	r6, #0
    c256:	e7ac      	b.n	c1b2 <att_read_rsp+0x1e>
		return BT_ATT_ERR_UNLIKELY;
    c258:	260e      	movs	r6, #14
    c25a:	e7aa      	b.n	c1b2 <att_read_rsp+0x1e>
    c25c:	0001887f 	.word	0x0001887f
    c260:	20000654 	.word	0x20000654

0000c264 <att_read_type_rsp>:
{
    c264:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c268:	b08a      	sub	sp, #40	; 0x28
    c26a:	4604      	mov	r4, r0
    c26c:	460f      	mov	r7, r1
    c26e:	4615      	mov	r5, r2
    c270:	461e      	mov	r6, r3
	struct bt_conn *conn = chan->chan.chan.conn;
    c272:	f8d0 8004 	ldr.w	r8, [r0, #4]
	(void)memset(&data, 0, sizeof(data));
    c276:	2218      	movs	r2, #24
    c278:	2100      	movs	r1, #0
    c27a:	a804      	add	r0, sp, #16
    c27c:	f00b fa87 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
    c280:	2201      	movs	r2, #1
    c282:	2109      	movs	r1, #9
    c284:	4640      	mov	r0, r8
    c286:	f7ff fdef 	bl	be68 <bt_att_create_pdu>
    c28a:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    c28c:	2800      	cmp	r0, #0
    c28e:	d037      	beq.n	c300 <att_read_type_rsp+0x9c>
	data.chan = chan;
    c290:	9404      	str	r4, [sp, #16]
	data.uuid = uuid;
    c292:	9705      	str	r7, [sp, #20]
	return net_buf_simple_add(&buf->b, len);
    c294:	2101      	movs	r1, #1
    c296:	3008      	adds	r0, #8
    c298:	f00d ffb1 	bl	1a1fe <net_buf_simple_add>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
    c29c:	9007      	str	r0, [sp, #28]
	data.rsp->len = 0U;
    c29e:	2200      	movs	r2, #0
    c2a0:	7002      	strb	r2, [r0, #0]
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    c2a2:	230a      	movs	r3, #10
    c2a4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    c2a8:	ab04      	add	r3, sp, #16
    c2aa:	9302      	str	r3, [sp, #8]
    c2ac:	4b15      	ldr	r3, [pc, #84]	; (c304 <att_read_type_rsp+0xa0>)
    c2ae:	9301      	str	r3, [sp, #4]
    c2b0:	9200      	str	r2, [sp, #0]
    c2b2:	4613      	mov	r3, r2
    c2b4:	4631      	mov	r1, r6
    c2b6:	4628      	mov	r0, r5
    c2b8:	f000 fe34 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (data.err) {
    c2bc:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
    c2c0:	b93e      	cbnz	r6, c2d2 <att_read_type_rsp+0x6e>
	bt_att_chan_send_rsp(chan, data.buf);
    c2c2:	9906      	ldr	r1, [sp, #24]
    c2c4:	4620      	mov	r0, r4
    c2c6:	f00c fc8c 	bl	18be2 <bt_att_chan_send_rsp>
}
    c2ca:	4630      	mov	r0, r6
    c2cc:	b00a      	add	sp, #40	; 0x28
    c2ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    c2d2:	9b06      	ldr	r3, [sp, #24]
    c2d4:	695e      	ldr	r6, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c2d6:	2214      	movs	r2, #20
    c2d8:	2100      	movs	r1, #0
    c2da:	4630      	mov	r0, r6
    c2dc:	f00b fa57 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c2e0:	4631      	mov	r1, r6
    c2e2:	4809      	ldr	r0, [pc, #36]	; (c308 <att_read_type_rsp+0xa4>)
    c2e4:	f00f ff40 	bl	1c168 <k_queue_append>
		net_buf_unref(data.buf);
    c2e8:	9806      	ldr	r0, [sp, #24]
    c2ea:	f00d ff3e 	bl	1a16a <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, start_handle,
    c2ee:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    c2f2:	462a      	mov	r2, r5
    c2f4:	2108      	movs	r1, #8
    c2f6:	4620      	mov	r0, r4
    c2f8:	f00c fce8 	bl	18ccc <send_err_rsp>
		return 0;
    c2fc:	2600      	movs	r6, #0
    c2fe:	e7e4      	b.n	c2ca <att_read_type_rsp+0x66>
		return BT_ATT_ERR_UNLIKELY;
    c300:	260e      	movs	r6, #14
    c302:	e7e2      	b.n	c2ca <att_read_type_rsp+0x66>
    c304:	0000b37d 	.word	0x0000b37d
    c308:	20000654 	.word	0x20000654

0000c30c <att_find_type_rsp>:
{
    c30c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c310:	b08a      	sub	sp, #40	; 0x28
    c312:	4604      	mov	r4, r0
    c314:	460d      	mov	r5, r1
    c316:	4616      	mov	r6, r2
    c318:	461f      	mov	r7, r3
	struct bt_conn *conn = chan->chan.chan.conn;
    c31a:	f8d0 8004 	ldr.w	r8, [r0, #4]
	(void)memset(&data, 0, sizeof(data));
    c31e:	2214      	movs	r2, #20
    c320:	2100      	movs	r1, #0
    c322:	eb0d 0002 	add.w	r0, sp, r2
    c326:	f00b fa32 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
    c32a:	2200      	movs	r2, #0
    c32c:	2107      	movs	r1, #7
    c32e:	4640      	mov	r0, r8
    c330:	f7ff fd9a 	bl	be68 <bt_att_create_pdu>
    c334:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
    c336:	2800      	cmp	r0, #0
    c338:	d036      	beq.n	c3a8 <att_find_type_rsp+0x9c>
	data.chan = chan;
    c33a:	9405      	str	r4, [sp, #20]
	data.group = NULL;
    c33c:	2200      	movs	r2, #0
    c33e:	9207      	str	r2, [sp, #28]
	data.value = value;
    c340:	9708      	str	r7, [sp, #32]
	data.value_len = value_len;
    c342:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
    c346:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
    c34a:	230a      	movs	r3, #10
    c34c:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    c350:	ab05      	add	r3, sp, #20
    c352:	9302      	str	r3, [sp, #8]
    c354:	4b15      	ldr	r3, [pc, #84]	; (c3ac <att_find_type_rsp+0xa0>)
    c356:	9301      	str	r3, [sp, #4]
    c358:	9200      	str	r2, [sp, #0]
    c35a:	4613      	mov	r3, r2
    c35c:	4631      	mov	r1, r6
    c35e:	4628      	mov	r0, r5
    c360:	f000 fde0 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (data.err) {
    c364:	f89d 6025 	ldrb.w	r6, [sp, #37]	; 0x25
    c368:	b93e      	cbnz	r6, c37a <att_find_type_rsp+0x6e>
	bt_att_chan_send_rsp(chan, data.buf);
    c36a:	9906      	ldr	r1, [sp, #24]
    c36c:	4620      	mov	r0, r4
    c36e:	f00c fc38 	bl	18be2 <bt_att_chan_send_rsp>
}
    c372:	4630      	mov	r0, r6
    c374:	b00a      	add	sp, #40	; 0x28
    c376:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    c37a:	9b06      	ldr	r3, [sp, #24]
    c37c:	695e      	ldr	r6, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c37e:	2214      	movs	r2, #20
    c380:	2100      	movs	r1, #0
    c382:	4630      	mov	r0, r6
    c384:	f00b fa03 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c388:	4631      	mov	r1, r6
    c38a:	4809      	ldr	r0, [pc, #36]	; (c3b0 <att_find_type_rsp+0xa4>)
    c38c:	f00f feec 	bl	1c168 <k_queue_append>
		net_buf_unref(data.buf);
    c390:	9806      	ldr	r0, [sp, #24]
    c392:	f00d feea 	bl	1a16a <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle,
    c396:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
    c39a:	462a      	mov	r2, r5
    c39c:	2106      	movs	r1, #6
    c39e:	4620      	mov	r0, r4
    c3a0:	f00c fc94 	bl	18ccc <send_err_rsp>
		return 0;
    c3a4:	2600      	movs	r6, #0
    c3a6:	e7e4      	b.n	c372 <att_find_type_rsp+0x66>
		return BT_ATT_ERR_UNLIKELY;
    c3a8:	260e      	movs	r6, #14
    c3aa:	e7e2      	b.n	c372 <att_find_type_rsp+0x66>
    c3ac:	0000b425 	.word	0x0000b425
    c3b0:	20000654 	.word	0x20000654

0000c3b4 <att_find_info_rsp>:
{
    c3b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    c3b6:	b089      	sub	sp, #36	; 0x24
    c3b8:	4604      	mov	r4, r0
    c3ba:	460f      	mov	r7, r1
    c3bc:	4616      	mov	r6, r2
	struct bt_conn *conn = chan->chan.chan.conn;
    c3be:	6845      	ldr	r5, [r0, #4]
	(void)memset(&data, 0, sizeof(data));
    c3c0:	2210      	movs	r2, #16
    c3c2:	2100      	movs	r1, #0
    c3c4:	eb0d 0002 	add.w	r0, sp, r2
    c3c8:	f00b f9e1 	bl	1778e <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
    c3cc:	2200      	movs	r2, #0
    c3ce:	2105      	movs	r1, #5
    c3d0:	4628      	mov	r0, r5
    c3d2:	f7ff fd49 	bl	be68 <bt_att_create_pdu>
    c3d6:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
    c3d8:	b350      	cbz	r0, c430 <att_find_info_rsp+0x7c>
	data.chan = chan;
    c3da:	9404      	str	r4, [sp, #16]
    c3dc:	ab04      	add	r3, sp, #16
    c3de:	9302      	str	r3, [sp, #8]
    c3e0:	4b14      	ldr	r3, [pc, #80]	; (c434 <att_find_info_rsp+0x80>)
    c3e2:	9301      	str	r3, [sp, #4]
    c3e4:	2200      	movs	r2, #0
    c3e6:	9200      	str	r2, [sp, #0]
    c3e8:	4613      	mov	r3, r2
    c3ea:	4631      	mov	r1, r6
    c3ec:	4638      	mov	r0, r7
    c3ee:	f000 fd99 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (!data.rsp) {
    c3f2:	9b06      	ldr	r3, [sp, #24]
    c3f4:	b133      	cbz	r3, c404 <att_find_info_rsp+0x50>
	bt_att_chan_send_rsp(chan, data.buf);
    c3f6:	9905      	ldr	r1, [sp, #20]
    c3f8:	4620      	mov	r0, r4
    c3fa:	f00c fbf2 	bl	18be2 <bt_att_chan_send_rsp>
	return 0;
    c3fe:	2000      	movs	r0, #0
}
    c400:	b009      	add	sp, #36	; 0x24
    c402:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tx_meta_data_free(bt_att_tx_meta_data(data.buf));
    c404:	9b05      	ldr	r3, [sp, #20]
    c406:	695d      	ldr	r5, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c408:	2214      	movs	r2, #20
    c40a:	2100      	movs	r1, #0
    c40c:	4628      	mov	r0, r5
    c40e:	f00b f9be 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c412:	4629      	mov	r1, r5
    c414:	4808      	ldr	r0, [pc, #32]	; (c438 <att_find_info_rsp+0x84>)
    c416:	f00f fea7 	bl	1c168 <k_queue_append>
		net_buf_unref(data.buf);
    c41a:	9805      	ldr	r0, [sp, #20]
    c41c:	f00d fea5 	bl	1a16a <net_buf_unref>
		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, start_handle,
    c420:	230a      	movs	r3, #10
    c422:	463a      	mov	r2, r7
    c424:	2104      	movs	r1, #4
    c426:	4620      	mov	r0, r4
    c428:	f00c fc50 	bl	18ccc <send_err_rsp>
		return 0;
    c42c:	2000      	movs	r0, #0
    c42e:	e7e7      	b.n	c400 <att_find_info_rsp+0x4c>
		return BT_ATT_ERR_UNLIKELY;
    c430:	200e      	movs	r0, #14
    c432:	e7e5      	b.n	c400 <att_find_info_rsp+0x4c>
    c434:	000188c7 	.word	0x000188c7
    c438:	20000654 	.word	0x20000654

0000c43c <bt_att_init>:
	bt_l2cap_register_ecred_cb(&cb);
#endif /* CONFIG_BT_EATT */
}

void bt_att_init(void)
{
    c43c:	b510      	push	{r4, lr}
	for (size_t i = 0; i < ARRAY_SIZE(tx_meta_data); i++) {
    c43e:	2400      	movs	r4, #0
    c440:	e008      	b.n	c454 <bt_att_init+0x18>
		k_fifo_put(&free_att_tx_meta_data, &tx_meta_data[i]);
    c442:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    c446:	0093      	lsls	r3, r2, #2
    c448:	4905      	ldr	r1, [pc, #20]	; (c460 <bt_att_init+0x24>)
    c44a:	4419      	add	r1, r3
    c44c:	4805      	ldr	r0, [pc, #20]	; (c464 <bt_att_init+0x28>)
    c44e:	f00f fe8b 	bl	1c168 <k_queue_append>
	for (size_t i = 0; i < ARRAY_SIZE(tx_meta_data); i++) {
    c452:	3401      	adds	r4, #1
    c454:	2c02      	cmp	r4, #2
    c456:	d9f4      	bls.n	c442 <bt_att_init+0x6>
	}

	bt_gatt_init();
    c458:	f000 fd02 	bl	ce60 <bt_gatt_init>

	if (IS_ENABLED(CONFIG_BT_EATT)) {
		bt_eatt_init();
	}
}
    c45c:	bd10      	pop	{r4, pc}
    c45e:	bf00      	nop
    c460:	200023a0 	.word	0x200023a0
    c464:	20000654 	.word	0x20000654

0000c468 <bt_att_req_alloc>:
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
	}
}

struct bt_att_req *bt_att_req_alloc(k_timeout_t timeout)
{
    c468:	b530      	push	{r4, r5, lr}
    c46a:	b083      	sub	sp, #12
    c46c:	4605      	mov	r5, r0
    c46e:	460c      	mov	r4, r1
	struct bt_att_req *req = NULL;
    c470:	2300      	movs	r3, #0
    c472:	9301      	str	r3, [sp, #4]
    c474:	f008 f984 	bl	14780 <z_impl_z_current_get>

	if (k_current_get() == att_handle_rsp_thread) {
    c478:	4b0b      	ldr	r3, [pc, #44]	; (c4a8 <bt_att_req_alloc+0x40>)
    c47a:	681b      	ldr	r3, [r3, #0]
    c47c:	4283      	cmp	r3, r0
    c47e:	d00e      	beq.n	c49e <bt_att_req_alloc+0x36>
		 */
		timeout = K_NO_WAIT;
	}

	/* Reserve space for request */
	if (k_mem_slab_alloc(&req_slab, (void **)&req, timeout)) {
    c480:	462a      	mov	r2, r5
    c482:	4623      	mov	r3, r4
    c484:	a901      	add	r1, sp, #4
    c486:	4809      	ldr	r0, [pc, #36]	; (c4ac <bt_att_req_alloc+0x44>)
    c488:	f007 f940 	bl	1370c <k_mem_slab_alloc>
    c48c:	b950      	cbnz	r0, c4a4 <bt_att_req_alloc+0x3c>
		return NULL;
	}

	BT_DBG("req %p", req);

	memset(req, 0, sizeof(*req));
    c48e:	2210      	movs	r2, #16
    c490:	2100      	movs	r1, #0
    c492:	9801      	ldr	r0, [sp, #4]
    c494:	f00b f97b 	bl	1778e <memset>

	return req;
    c498:	9801      	ldr	r0, [sp, #4]
}
    c49a:	b003      	add	sp, #12
    c49c:	bd30      	pop	{r4, r5, pc}
		timeout = K_NO_WAIT;
    c49e:	2500      	movs	r5, #0
    c4a0:	462c      	mov	r4, r5
    c4a2:	e7ed      	b.n	c480 <bt_att_req_alloc+0x18>
		return NULL;
    c4a4:	2000      	movs	r0, #0
    c4a6:	e7f8      	b.n	c49a <bt_att_req_alloc+0x32>
    c4a8:	2000238c 	.word	0x2000238c
    c4ac:	200005a4 	.word	0x200005a4

0000c4b0 <bt_att_req_free>:

void bt_att_req_free(struct bt_att_req *req)
{
    c4b0:	b510      	push	{r4, lr}
    c4b2:	b082      	sub	sp, #8
    c4b4:	9001      	str	r0, [sp, #4]
	BT_DBG("req %p", req);

	if (req->buf) {
    c4b6:	6883      	ldr	r3, [r0, #8]
    c4b8:	b183      	cbz	r3, c4dc <bt_att_req_free+0x2c>
		tx_meta_data_free(bt_att_tx_meta_data(req->buf));
    c4ba:	695c      	ldr	r4, [r3, #20]
	(void)memset(data, 0, sizeof(*data));
    c4bc:	2214      	movs	r2, #20
    c4be:	2100      	movs	r1, #0
    c4c0:	4620      	mov	r0, r4
    c4c2:	f00b f964 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c4c6:	4621      	mov	r1, r4
    c4c8:	4807      	ldr	r0, [pc, #28]	; (c4e8 <bt_att_req_free+0x38>)
    c4ca:	f00f fe4d 	bl	1c168 <k_queue_append>
		net_buf_unref(req->buf);
    c4ce:	9b01      	ldr	r3, [sp, #4]
    c4d0:	6898      	ldr	r0, [r3, #8]
    c4d2:	f00d fe4a 	bl	1a16a <net_buf_unref>
		req->buf = NULL;
    c4d6:	9b01      	ldr	r3, [sp, #4]
    c4d8:	2200      	movs	r2, #0
    c4da:	609a      	str	r2, [r3, #8]
	}

	k_mem_slab_free(&req_slab, (void **)&req);
    c4dc:	a901      	add	r1, sp, #4
    c4de:	4803      	ldr	r0, [pc, #12]	; (c4ec <bt_att_req_free+0x3c>)
    c4e0:	f00f fd1d 	bl	1bf1e <k_mem_slab_free>
}
    c4e4:	b002      	add	sp, #8
    c4e6:	bd10      	pop	{r4, pc}
    c4e8:	20000654 	.word	0x20000654
    c4ec:	200005a4 	.word	0x200005a4

0000c4f0 <att_handle_rsp>:
{
    c4f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c4f4:	b08a      	sub	sp, #40	; 0x28
    c4f6:	4604      	mov	r4, r0
    c4f8:	460f      	mov	r7, r1
    c4fa:	4691      	mov	r9, r2
    c4fc:	461e      	mov	r6, r3
	k_work_cancel_delayable(&chan->timeout_work);
    c4fe:	30b0      	adds	r0, #176	; 0xb0
    c500:	f00f ff98 	bl	1c434 <k_work_cancel_delayable>
	if (!chan->req) {
    c504:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
    c508:	b1f8      	cbz	r0, c54a <att_handle_rsp+0x5a>
	if (chan->req == &cancel) {
    c50a:	4b25      	ldr	r3, [pc, #148]	; (c5a0 <att_handle_rsp+0xb0>)
    c50c:	4298      	cmp	r0, r3
    c50e:	d042      	beq.n	c596 <att_handle_rsp+0xa6>
	func = chan->req->func;
    c510:	6845      	ldr	r5, [r0, #4]
	chan->req->func = NULL;
    c512:	f04f 0a00 	mov.w	sl, #0
    c516:	f8c0 a004 	str.w	sl, [r0, #4]
	params = chan->req->user_data;
    c51a:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
    c51e:	f8d0 800c 	ldr.w	r8, [r0, #12]
	bt_att_req_free(chan->req);
    c522:	f7ff ffc5 	bl	c4b0 <bt_att_req_free>
	chan->req = NULL;
    c526:	f8c4 a094 	str.w	sl, [r4, #148]	; 0x94
	att_req_send_process(chan->att);
    c52a:	6820      	ldr	r0, [r4, #0]
    c52c:	f00c fa77 	bl	18a1e <att_req_send_process>
	if (func) {
    c530:	b13d      	cbz	r5, c542 <att_handle_rsp+0x52>
		func(chan->att->conn, err, pdu, len, params);
    c532:	6823      	ldr	r3, [r4, #0]
    c534:	6818      	ldr	r0, [r3, #0]
    c536:	f8cd 8000 	str.w	r8, [sp]
    c53a:	464b      	mov	r3, r9
    c53c:	463a      	mov	r2, r7
    c53e:	4631      	mov	r1, r6
    c540:	47a8      	blx	r5
}
    c542:	2000      	movs	r0, #0
    c544:	b00a      	add	sp, #40	; 0x28
    c546:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		BT_WARN("No pending ATT request");
    c54a:	4b16      	ldr	r3, [pc, #88]	; (c5a4 <att_handle_rsp+0xb4>)
    c54c:	9309      	str	r3, [sp, #36]	; 0x24
    c54e:	2302      	movs	r3, #2
    c550:	f88d 300c 	strb.w	r3, [sp, #12]
    c554:	2500      	movs	r5, #0
    c556:	f88d 500d 	strb.w	r5, [sp, #13]
    c55a:	f88d 500e 	strb.w	r5, [sp, #14]
    c55e:	f88d 500f 	strb.w	r5, [sp, #15]
    c562:	9a03      	ldr	r2, [sp, #12]
    c564:	9208      	str	r2, [sp, #32]
    c566:	4629      	mov	r1, r5
    c568:	f365 0100 	bfi	r1, r5, #0, #1
    c56c:	f365 0141 	bfi	r1, r5, #1, #1
    c570:	f365 0182 	bfi	r1, r5, #2, #1
    c574:	f365 01c5 	bfi	r1, r5, #3, #3
    c578:	f363 1188 	bfi	r1, r3, #6, #3
    c57c:	2308      	movs	r3, #8
    c57e:	f363 2152 	bfi	r1, r3, #9, #10
    c582:	f365 41de 	bfi	r1, r5, #19, #12
    c586:	f365 71df 	bfi	r1, r5, #31, #1
    c58a:	462b      	mov	r3, r5
    c58c:	aa08      	add	r2, sp, #32
    c58e:	4806      	ldr	r0, [pc, #24]	; (c5a8 <att_handle_rsp+0xb8>)
    c590:	f7f5 fe5a 	bl	2248 <z_impl_z_log_msg_static_create>
		goto process;
    c594:	e7c9      	b.n	c52a <att_handle_rsp+0x3a>
		chan->req = NULL;
    c596:	2500      	movs	r5, #0
    c598:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
		goto process;
    c59c:	e7c5      	b.n	c52a <att_handle_rsp+0x3a>
    c59e:	bf00      	nop
    c5a0:	20002390 	.word	0x20002390
    c5a4:	0001ef90 	.word	0x0001ef90
    c5a8:	0001cfd4 	.word	0x0001cfd4

0000c5ac <att_error_rsp>:
{
    c5ac:	b508      	push	{r3, lr}
	rsp = (void *)buf->data;
    c5ae:	688a      	ldr	r2, [r1, #8]
	if (!chan->req || chan->req == &cancel || !rsp->error) {
    c5b0:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    c5b4:	b14b      	cbz	r3, c5ca <att_error_rsp+0x1e>
    c5b6:	4908      	ldr	r1, [pc, #32]	; (c5d8 <att_error_rsp+0x2c>)
    c5b8:	428b      	cmp	r3, r1
    c5ba:	d008      	beq.n	c5ce <att_error_rsp+0x22>
    c5bc:	78d3      	ldrb	r3, [r2, #3]
    c5be:	b143      	cbz	r3, c5d2 <att_error_rsp+0x26>
	return att_handle_rsp(chan, NULL, 0, err);
    c5c0:	2200      	movs	r2, #0
    c5c2:	4611      	mov	r1, r2
    c5c4:	f7ff ff94 	bl	c4f0 <att_handle_rsp>
}
    c5c8:	bd08      	pop	{r3, pc}
		err = BT_ATT_ERR_UNLIKELY;
    c5ca:	230e      	movs	r3, #14
    c5cc:	e7f8      	b.n	c5c0 <att_error_rsp+0x14>
    c5ce:	230e      	movs	r3, #14
    c5d0:	e7f6      	b.n	c5c0 <att_error_rsp+0x14>
    c5d2:	230e      	movs	r3, #14
    c5d4:	e7f4      	b.n	c5c0 <att_error_rsp+0x14>
    c5d6:	bf00      	nop
    c5d8:	20002390 	.word	0x20002390

0000c5dc <att_chan_detach>:
{
    c5dc:	b570      	push	{r4, r5, r6, lr}
    c5de:	4606      	mov	r6, r0
	sys_slist_find_and_remove(&chan->att->chans, &chan->node);
    c5e0:	4602      	mov	r2, r0
    c5e2:	f852 0be0 	ldr.w	r0, [r2], #224
    c5e6:	f100 0424 	add.w	r4, r0, #36	; 0x24
	return list->head;
    c5ea:	6a43      	ldr	r3, [r0, #36]	; 0x24
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    c5ec:	2100      	movs	r1, #0
    c5ee:	e00b      	b.n	c608 <att_chan_detach+0x2c>
	return node->next;
    c5f0:	f8d6 30e0 	ldr.w	r3, [r6, #224]	; 0xe0
	list->head = node;
    c5f4:	6243      	str	r3, [r0, #36]	; 0x24
	return list->tail;
    c5f6:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_REMOVE(slist, snode)
    c5f8:	428a      	cmp	r2, r1
    c5fa:	d110      	bne.n	c61e <att_chan_detach+0x42>
	list->tail = node;
    c5fc:	6063      	str	r3, [r4, #4]
}
    c5fe:	e00e      	b.n	c61e <att_chan_detach+0x42>
	list->tail = node;
    c600:	6061      	str	r1, [r4, #4]
}
    c602:	e00c      	b.n	c61e <att_chan_detach+0x42>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    c604:	4619      	mov	r1, r3
    c606:	681b      	ldr	r3, [r3, #0]
    c608:	b1d3      	cbz	r3, c640 <att_chan_detach+0x64>
    c60a:	429a      	cmp	r2, r3
    c60c:	d1fa      	bne.n	c604 <att_chan_detach+0x28>
Z_GENLIST_REMOVE(slist, snode)
    c60e:	2900      	cmp	r1, #0
    c610:	d0ee      	beq.n	c5f0 <att_chan_detach+0x14>
	return node->next;
    c612:	f8d6 30e0 	ldr.w	r3, [r6, #224]	; 0xe0
	parent->next = child;
    c616:	600b      	str	r3, [r1, #0]
	return list->tail;
    c618:	6863      	ldr	r3, [r4, #4]
Z_GENLIST_REMOVE(slist, snode)
    c61a:	429a      	cmp	r2, r3
    c61c:	d0f0      	beq.n	c600 <att_chan_detach+0x24>
	parent->next = child;
    c61e:	2300      	movs	r3, #0
    c620:	f8c6 30e0 	str.w	r3, [r6, #224]	; 0xe0
Z_GENLIST_REMOVE(slist, snode)
    c624:	e00c      	b.n	c640 <att_chan_detach+0x64>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
    c626:	6965      	ldr	r5, [r4, #20]
	(void)memset(data, 0, sizeof(*data));
    c628:	2214      	movs	r2, #20
    c62a:	2100      	movs	r1, #0
    c62c:	4628      	mov	r0, r5
    c62e:	f00b f8ae 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c632:	4629      	mov	r1, r5
    c634:	480d      	ldr	r0, [pc, #52]	; (c66c <att_chan_detach+0x90>)
    c636:	f00f fd97 	bl	1c168 <k_queue_append>
		net_buf_unref(buf);
    c63a:	4620      	mov	r0, r4
    c63c:	f00d fd95 	bl	1a16a <net_buf_unref>
	while ((buf = net_buf_get(&chan->tx_queue, K_NO_WAIT))) {
    c640:	2200      	movs	r2, #0
    c642:	2300      	movs	r3, #0
    c644:	f106 0098 	add.w	r0, r6, #152	; 0x98
    c648:	f00d fd03 	bl	1a052 <net_buf_get>
    c64c:	4604      	mov	r4, r0
    c64e:	2800      	cmp	r0, #0
    c650:	d1e9      	bne.n	c626 <att_chan_detach+0x4a>
	if (chan->req) {
    c652:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
    c656:	b12b      	cbz	r3, c664 <att_chan_detach+0x88>
		att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_UNLIKELY);
    c658:	230e      	movs	r3, #14
    c65a:	2200      	movs	r2, #0
    c65c:	4611      	mov	r1, r2
    c65e:	4630      	mov	r0, r6
    c660:	f7ff ff46 	bl	c4f0 <att_handle_rsp>
	chan->att = NULL;
    c664:	2300      	movs	r3, #0
    c666:	6033      	str	r3, [r6, #0]
}
    c668:	bd70      	pop	{r4, r5, r6, pc}
    c66a:	bf00      	nop
    c66c:	20000654 	.word	0x20000654

0000c670 <att_reset>:
{
    c670:	b530      	push	{r4, r5, lr}
    c672:	b085      	sub	sp, #20
    c674:	9003      	str	r0, [sp, #12]
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
    c676:	e00c      	b.n	c692 <att_reset+0x22>
		tx_meta_data_free(bt_att_tx_meta_data(buf));
    c678:	6965      	ldr	r5, [r4, #20]
	(void)memset(data, 0, sizeof(*data));
    c67a:	2214      	movs	r2, #20
    c67c:	2100      	movs	r1, #0
    c67e:	4628      	mov	r0, r5
    c680:	f00b f885 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c684:	4629      	mov	r1, r5
    c686:	4818      	ldr	r0, [pc, #96]	; (c6e8 <att_reset+0x78>)
    c688:	f00f fd6e 	bl	1c168 <k_queue_append>
		net_buf_unref(buf);
    c68c:	4620      	mov	r0, r4
    c68e:	f00d fd6c 	bl	1a16a <net_buf_unref>
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
    c692:	2200      	movs	r2, #0
    c694:	2300      	movs	r3, #0
    c696:	9803      	ldr	r0, [sp, #12]
    c698:	300c      	adds	r0, #12
    c69a:	f00d fcda 	bl	1a052 <net_buf_get>
    c69e:	4604      	mov	r4, r0
    c6a0:	2800      	cmp	r0, #0
    c6a2:	d1e9      	bne.n	c678 <att_reset+0x8>
    c6a4:	e00b      	b.n	c6be <att_reset+0x4e>
	list->tail = node;
    c6a6:	609a      	str	r2, [r3, #8]
}
    c6a8:	e011      	b.n	c6ce <att_reset+0x5e>
			req->func(att->conn, BT_ATT_ERR_UNLIKELY, NULL, 0,
    c6aa:	6818      	ldr	r0, [r3, #0]
    c6ac:	68e3      	ldr	r3, [r4, #12]
    c6ae:	9300      	str	r3, [sp, #0]
    c6b0:	2300      	movs	r3, #0
    c6b2:	461a      	mov	r2, r3
    c6b4:	210e      	movs	r1, #14
    c6b6:	47a8      	blx	r5
		bt_att_req_free(req);
    c6b8:	4620      	mov	r0, r4
    c6ba:	f7ff fef9 	bl	c4b0 <bt_att_req_free>
	while (!sys_slist_is_empty(&att->reqs)) {
    c6be:	9b03      	ldr	r3, [sp, #12]
	return list->head;
    c6c0:	685c      	ldr	r4, [r3, #4]
    c6c2:	b144      	cbz	r4, c6d6 <att_reset+0x66>
	return node->next;
    c6c4:	6822      	ldr	r2, [r4, #0]
	list->head = node;
    c6c6:	605a      	str	r2, [r3, #4]
	return list->tail;
    c6c8:	6899      	ldr	r1, [r3, #8]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    c6ca:	42a1      	cmp	r1, r4
    c6cc:	d0eb      	beq.n	c6a6 <att_reset+0x36>
		if (req->func) {
    c6ce:	6865      	ldr	r5, [r4, #4]
    c6d0:	2d00      	cmp	r5, #0
    c6d2:	d1ea      	bne.n	c6aa <att_reset+0x3a>
    c6d4:	e7f0      	b.n	c6b8 <att_reset+0x48>
	att->conn = NULL;
    c6d6:	2200      	movs	r2, #0
    c6d8:	601a      	str	r2, [r3, #0]
	k_mem_slab_free(&att_slab, (void **)&att);
    c6da:	a903      	add	r1, sp, #12
    c6dc:	4803      	ldr	r0, [pc, #12]	; (c6ec <att_reset+0x7c>)
    c6de:	f00f fc1e 	bl	1bf1e <k_mem_slab_free>
}
    c6e2:	b005      	add	sp, #20
    c6e4:	bd30      	pop	{r4, r5, pc}
    c6e6:	bf00      	nop
    c6e8:	20000654 	.word	0x20000654
    c6ec:	2000056c 	.word	0x2000056c

0000c6f0 <att_timeout>:
{
    c6f0:	b510      	push	{r4, lr}
    c6f2:	b088      	sub	sp, #32
    c6f4:	4604      	mov	r4, r0
	BT_ERR("ATT Timeout");
    c6f6:	4b15      	ldr	r3, [pc, #84]	; (c74c <att_timeout+0x5c>)
    c6f8:	9307      	str	r3, [sp, #28]
    c6fa:	2302      	movs	r3, #2
    c6fc:	f88d 3004 	strb.w	r3, [sp, #4]
    c700:	2300      	movs	r3, #0
    c702:	f88d 3005 	strb.w	r3, [sp, #5]
    c706:	f88d 3006 	strb.w	r3, [sp, #6]
    c70a:	f88d 3007 	strb.w	r3, [sp, #7]
    c70e:	9a01      	ldr	r2, [sp, #4]
    c710:	9206      	str	r2, [sp, #24]
    c712:	4619      	mov	r1, r3
    c714:	f363 0100 	bfi	r1, r3, #0, #1
    c718:	f363 0141 	bfi	r1, r3, #1, #1
    c71c:	f363 0182 	bfi	r1, r3, #2, #1
    c720:	f363 01c5 	bfi	r1, r3, #3, #3
    c724:	2201      	movs	r2, #1
    c726:	f362 1188 	bfi	r1, r2, #6, #3
    c72a:	2208      	movs	r2, #8
    c72c:	f362 2152 	bfi	r1, r2, #9, #10
    c730:	f363 41de 	bfi	r1, r3, #19, #12
    c734:	f363 71df 	bfi	r1, r3, #31, #1
    c738:	aa06      	add	r2, sp, #24
    c73a:	4805      	ldr	r0, [pc, #20]	; (c750 <att_timeout+0x60>)
    c73c:	f7f5 fd84 	bl	2248 <z_impl_z_log_msg_static_create>
	bt_att_disconnected(&chan->chan.chan);
    c740:	f1a4 00ac 	sub.w	r0, r4, #172	; 0xac
    c744:	f00c fcb5 	bl	190b2 <bt_att_disconnected>
}
    c748:	b008      	add	sp, #32
    c74a:	bd10      	pop	{r4, pc}
    c74c:	0001efa8 	.word	0x0001efa8
    c750:	0001cfd4 	.word	0x0001cfd4

0000c754 <bt_att_chan_req_cancel>:
	return 0;
}

static bool bt_att_chan_req_cancel(struct bt_att_chan *chan,
				   struct bt_att_req *req)
{
    c754:	b508      	push	{r3, lr}
	if (chan->req != req) {
    c756:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
    c75a:	428b      	cmp	r3, r1
    c75c:	d001      	beq.n	c762 <bt_att_chan_req_cancel+0xe>
		return false;
    c75e:	2000      	movs	r0, #0
	chan->req = &cancel;

	bt_att_req_free(req);

	return true;
}
    c760:	bd08      	pop	{r3, pc}
	chan->req = &cancel;
    c762:	4b04      	ldr	r3, [pc, #16]	; (c774 <bt_att_chan_req_cancel+0x20>)
    c764:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
	bt_att_req_free(req);
    c768:	4608      	mov	r0, r1
    c76a:	f7ff fea1 	bl	c4b0 <bt_att_req_free>
	return true;
    c76e:	2001      	movs	r0, #1
    c770:	e7f6      	b.n	c760 <bt_att_chan_req_cancel+0xc>
    c772:	bf00      	nop
    c774:	20002390 	.word	0x20002390

0000c778 <bt_att_send>:
{
    c778:	b538      	push	{r3, r4, r5, lr}
    c77a:	460c      	mov	r4, r1
	att = att_get(conn);
    c77c:	f7fe fbf8 	bl	af70 <att_get>
	if (!att) {
    c780:	b148      	cbz	r0, c796 <bt_att_send+0x1e>
    c782:	4605      	mov	r5, r0
	net_buf_put(&att->tx_queue, buf);
    c784:	4621      	mov	r1, r4
    c786:	300c      	adds	r0, #12
    c788:	f00d fce1 	bl	1a14e <net_buf_put>
	att_send_process(att);
    c78c:	4628      	mov	r0, r5
    c78e:	f00c f9e9 	bl	18b64 <att_send_process>
	return 0;
    c792:	2000      	movs	r0, #0
}
    c794:	bd38      	pop	{r3, r4, r5, pc}
		tx_meta_data_free(bt_att_tx_meta_data(buf));
    c796:	6965      	ldr	r5, [r4, #20]
	(void)memset(data, 0, sizeof(*data));
    c798:	2214      	movs	r2, #20
    c79a:	2100      	movs	r1, #0
    c79c:	4628      	mov	r0, r5
    c79e:	f00a fff6 	bl	1778e <memset>
	k_fifo_put(&free_att_tx_meta_data, data);
    c7a2:	4629      	mov	r1, r5
    c7a4:	4804      	ldr	r0, [pc, #16]	; (c7b8 <bt_att_send+0x40>)
    c7a6:	f00f fcdf 	bl	1c168 <k_queue_append>
		net_buf_unref(buf);
    c7aa:	4620      	mov	r0, r4
    c7ac:	f00d fcdd 	bl	1a16a <net_buf_unref>
		return -ENOTCONN;
    c7b0:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    c7b4:	e7ee      	b.n	c794 <bt_att_send+0x1c>
    c7b6:	bf00      	nop
    c7b8:	20000654 	.word	0x20000654

0000c7bc <bt_gatt_service_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    c7bc:	4b0b      	ldr	r3, [pc, #44]	; (c7ec <bt_gatt_service_init+0x30>)
    c7be:	2201      	movs	r2, #1
    c7c0:	e8d3 1fef 	ldaex	r1, [r3]
    c7c4:	2900      	cmp	r1, #0
    c7c6:	d103      	bne.n	c7d0 <bt_gatt_service_init+0x14>
    c7c8:	e8c3 2fe0 	stlex	r0, r2, [r3]
    c7cc:	2800      	cmp	r0, #0
    c7ce:	d1f7      	bne.n	c7c0 <bt_gatt_service_init+0x4>
}
#endif

static void bt_gatt_service_init(void)
{
	if (!atomic_cas(&service_init, 0, 1)) {
    c7d0:	d101      	bne.n	c7d6 <bt_gatt_service_init+0x1a>
		return;
	}

	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    c7d2:	4b07      	ldr	r3, [pc, #28]	; (c7f0 <bt_gatt_service_init+0x34>)
    c7d4:	e006      	b.n	c7e4 <bt_gatt_service_init+0x28>
    c7d6:	4770      	bx	lr
		last_static_handle += svc->attr_count;
    c7d8:	685a      	ldr	r2, [r3, #4]
    c7da:	4906      	ldr	r1, [pc, #24]	; (c7f4 <bt_gatt_service_init+0x38>)
    c7dc:	8808      	ldrh	r0, [r1, #0]
    c7de:	4402      	add	r2, r0
    c7e0:	800a      	strh	r2, [r1, #0]
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
    c7e2:	3308      	adds	r3, #8
    c7e4:	4a04      	ldr	r2, [pc, #16]	; (c7f8 <bt_gatt_service_init+0x3c>)
    c7e6:	4293      	cmp	r3, r2
    c7e8:	d3f6      	bcc.n	c7d8 <bt_gatt_service_init+0x1c>
	}
}
    c7ea:	4770      	bx	lr
    c7ec:	2000241c 	.word	0x2000241c
    c7f0:	0001cfb4 	.word	0x0001cfb4
    c7f4:	200028f4 	.word	0x200028f4
    c7f8:	0001cfcc 	.word	0x0001cfcc

0000c7fc <find_cf_cfg>:
{
    c7fc:	b570      	push	{r4, r5, r6, lr}
    c7fe:	b082      	sub	sp, #8
    c800:	4606      	mov	r6, r0
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    c802:	2400      	movs	r4, #0
    c804:	b11c      	cbz	r4, c80e <find_cf_cfg+0x12>
	return NULL;
    c806:	2500      	movs	r5, #0
}
    c808:	4628      	mov	r0, r5
    c80a:	b002      	add	sp, #8
    c80c:	bd70      	pop	{r4, r5, r6, pc}
		struct gatt_cf_cfg *cfg = &cf_cfg[i];
    c80e:	4d0f      	ldr	r5, [pc, #60]	; (c84c <find_cf_cfg+0x50>)
    c810:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (!conn) {
    c814:	b166      	cbz	r6, c830 <find_cf_cfg+0x34>
		} else if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    c816:	490d      	ldr	r1, [pc, #52]	; (c84c <find_cf_cfg+0x50>)
    c818:	0123      	lsls	r3, r4, #4
    c81a:	eb01 1204 	add.w	r2, r1, r4, lsl #4
    c81e:	3201      	adds	r2, #1
    c820:	5cc9      	ldrb	r1, [r1, r3]
    c822:	4630      	mov	r0, r6
    c824:	f00b fcbc 	bl	181a0 <bt_conn_is_peer_addr_le>
    c828:	2800      	cmp	r0, #0
    c82a:	d1ed      	bne.n	c808 <find_cf_cfg+0xc>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
    c82c:	3401      	adds	r4, #1
    c82e:	e7e9      	b.n	c804 <find_cf_cfg+0x8>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    c830:	4628      	mov	r0, r5
    c832:	2300      	movs	r3, #0
    c834:	9300      	str	r3, [sp, #0]
    c836:	f8cd 3003 	str.w	r3, [sp, #3]
	return memcmp(a, b, sizeof(*a));
    c83a:	2207      	movs	r2, #7
    c83c:	4669      	mov	r1, sp
    c83e:	3001      	adds	r0, #1
    c840:	f00a ff64 	bl	1770c <memcmp>
    c844:	2800      	cmp	r0, #0
    c846:	d1f1      	bne.n	c82c <find_cf_cfg+0x30>
    c848:	e7de      	b.n	c808 <find_cf_cfg+0xc>
    c84a:	bf00      	nop
    c84c:	200023e4 	.word	0x200023e4

0000c850 <find_sc_cfg>:
{
    c850:	b570      	push	{r4, r5, r6, lr}
    c852:	4606      	mov	r6, r0
    c854:	460d      	mov	r5, r1
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    c856:	2400      	movs	r4, #0
    c858:	b10c      	cbz	r4, c85e <find_sc_cfg+0xe>
	return NULL;
    c85a:	2000      	movs	r0, #0
}
    c85c:	bd70      	pop	{r4, r5, r6, pc}
		if (id == sc_cfg[i].id &&
    c85e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    c862:	4a0c      	ldr	r2, [pc, #48]	; (c894 <find_sc_cfg+0x44>)
    c864:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    c868:	429e      	cmp	r6, r3
    c86a:	d001      	beq.n	c870 <find_sc_cfg+0x20>
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    c86c:	3401      	adds	r4, #1
    c86e:	e7f3      	b.n	c858 <find_sc_cfg+0x8>
		    !bt_addr_le_cmp(&sc_cfg[i].peer, addr)) {
    c870:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    c874:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    c878:	2207      	movs	r2, #7
    c87a:	4629      	mov	r1, r5
    c87c:	3001      	adds	r0, #1
    c87e:	f00a ff45 	bl	1770c <memcmp>
		if (id == sc_cfg[i].id &&
    c882:	2800      	cmp	r0, #0
    c884:	d1f2      	bne.n	c86c <find_sc_cfg+0x1c>
			return &sc_cfg[i];
    c886:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    c88a:	4802      	ldr	r0, [pc, #8]	; (c894 <find_sc_cfg+0x44>)
    c88c:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    c890:	e7e4      	b.n	c85c <find_sc_cfg+0xc>
    c892:	bf00      	nop
    c894:	200023f8 	.word	0x200023f8

0000c898 <gatt_sub_find>:
	}
}

#if defined(CONFIG_BT_GATT_CLIENT)
static struct gatt_sub *gatt_sub_find(struct bt_conn *conn)
{
    c898:	b570      	push	{r4, r5, r6, lr}
    c89a:	b082      	sub	sp, #8
    c89c:	4606      	mov	r6, r0
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
    c89e:	2400      	movs	r4, #0
    c8a0:	b11c      	cbz	r4, c8aa <gatt_sub_find+0x12>
		} else if (bt_conn_is_peer_addr_le(conn, sub->id, &sub->peer)) {
			return sub;
		}
	}

	return NULL;
    c8a2:	2500      	movs	r5, #0
}
    c8a4:	4628      	mov	r0, r5
    c8a6:	b002      	add	sp, #8
    c8a8:	bd70      	pop	{r4, r5, r6, pc}
		struct gatt_sub *sub = &subscriptions[i];
    c8aa:	4d0f      	ldr	r5, [pc, #60]	; (c8e8 <gatt_sub_find+0x50>)
    c8ac:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (!conn) {
    c8b0:	b166      	cbz	r6, c8cc <gatt_sub_find+0x34>
		} else if (bt_conn_is_peer_addr_le(conn, sub->id, &sub->peer)) {
    c8b2:	490d      	ldr	r1, [pc, #52]	; (c8e8 <gatt_sub_find+0x50>)
    c8b4:	0123      	lsls	r3, r4, #4
    c8b6:	eb01 1204 	add.w	r2, r1, r4, lsl #4
    c8ba:	3201      	adds	r2, #1
    c8bc:	5cc9      	ldrb	r1, [r1, r3]
    c8be:	4630      	mov	r0, r6
    c8c0:	f00b fc6e 	bl	181a0 <bt_conn_is_peer_addr_le>
    c8c4:	2800      	cmp	r0, #0
    c8c6:	d1ed      	bne.n	c8a4 <gatt_sub_find+0xc>
	for (int i = 0; i < ARRAY_SIZE(subscriptions); i++) {
    c8c8:	3401      	adds	r4, #1
    c8ca:	e7e9      	b.n	c8a0 <gatt_sub_find+0x8>
			if (!bt_addr_le_cmp(&sub->peer, BT_ADDR_LE_ANY)) {
    c8cc:	4628      	mov	r0, r5
    c8ce:	2300      	movs	r3, #0
    c8d0:	9300      	str	r3, [sp, #0]
    c8d2:	f8cd 3003 	str.w	r3, [sp, #3]
    c8d6:	2207      	movs	r2, #7
    c8d8:	4669      	mov	r1, sp
    c8da:	3001      	adds	r0, #1
    c8dc:	f00a ff16 	bl	1770c <memcmp>
    c8e0:	2800      	cmp	r0, #0
    c8e2:	d1f1      	bne.n	c8c8 <gatt_sub_find+0x30>
    c8e4:	e7de      	b.n	c8a4 <gatt_sub_find+0xc>
    c8e6:	bf00      	nop
    c8e8:	20002420 	.word	0x20002420

0000c8ec <cf_write>:
{
    c8ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c8f0:	b088      	sub	sp, #32
    c8f2:	461d      	mov	r5, r3
    c8f4:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
	if (offset > sizeof(cfg->data)) {
    c8f8:	2b01      	cmp	r3, #1
    c8fa:	d851      	bhi.n	c9a0 <cf_write+0xb4>
    c8fc:	4606      	mov	r6, r0
    c8fe:	4690      	mov	r8, r2
	if (offset + len > sizeof(cfg->data)) {
    c900:	462f      	mov	r7, r5
    c902:	442b      	add	r3, r5
    c904:	2b01      	cmp	r3, #1
    c906:	d84e      	bhi.n	c9a6 <cf_write+0xba>
	cfg = find_cf_cfg(conn);
    c908:	f7ff ff78 	bl	c7fc <find_cf_cfg>
	if (!cfg) {
    c90c:	4604      	mov	r4, r0
    c90e:	b1e0      	cbz	r0, c94a <cf_write+0x5e>
	if (!cfg) {
    c910:	b1fc      	cbz	r4, c952 <cf_write+0x66>
	if (!cf_set_value(cfg, value, len)) {
    c912:	462a      	mov	r2, r5
    c914:	4641      	mov	r1, r8
    c916:	4620      	mov	r0, r4
    c918:	f00c fcbf 	bl	1929a <cf_set_value>
    c91c:	2800      	cmp	r0, #0
    c91e:	d045      	beq.n	c9ac <cf_write+0xc0>
	memcpy(dst, src, sizeof(*dst));
    c920:	2207      	movs	r2, #7
    c922:	f106 0188 	add.w	r1, r6, #136	; 0x88
    c926:	1c60      	adds	r0, r4, #1
    c928:	f00a ff02 	bl	17730 <memcpy>
	cfg->id = conn->id;
    c92c:	7a33      	ldrb	r3, [r6, #8]
    c92e:	f804 3b0c 	strb.w	r3, [r4], #12
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    c932:	e8d4 3fef 	ldaex	r3, [r4]
    c936:	f043 0301 	orr.w	r3, r3, #1
    c93a:	e8c4 3fe2 	stlex	r2, r3, [r4]
    c93e:	2a00      	cmp	r2, #0
    c940:	d1f7      	bne.n	c932 <cf_write+0x46>
}
    c942:	4638      	mov	r0, r7
    c944:	b008      	add	sp, #32
    c946:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg = find_cf_cfg(NULL);
    c94a:	f7ff ff57 	bl	c7fc <find_cf_cfg>
    c94e:	4604      	mov	r4, r0
    c950:	e7de      	b.n	c910 <cf_write+0x24>
		BT_WARN("No space to store Client Supported Features");
    c952:	4b18      	ldr	r3, [pc, #96]	; (c9b4 <cf_write+0xc8>)
    c954:	9307      	str	r3, [sp, #28]
    c956:	2202      	movs	r2, #2
    c958:	f88d 2004 	strb.w	r2, [sp, #4]
    c95c:	2300      	movs	r3, #0
    c95e:	f88d 3005 	strb.w	r3, [sp, #5]
    c962:	f88d 3006 	strb.w	r3, [sp, #6]
    c966:	f88d 3007 	strb.w	r3, [sp, #7]
    c96a:	9901      	ldr	r1, [sp, #4]
    c96c:	9106      	str	r1, [sp, #24]
    c96e:	4619      	mov	r1, r3
    c970:	f363 0100 	bfi	r1, r3, #0, #1
    c974:	f363 0141 	bfi	r1, r3, #1, #1
    c978:	f363 0182 	bfi	r1, r3, #2, #1
    c97c:	f363 01c5 	bfi	r1, r3, #3, #3
    c980:	f362 1188 	bfi	r1, r2, #6, #3
    c984:	2208      	movs	r2, #8
    c986:	f362 2152 	bfi	r1, r2, #9, #10
    c98a:	f363 41de 	bfi	r1, r3, #19, #12
    c98e:	f363 71df 	bfi	r1, r3, #31, #1
    c992:	aa06      	add	r2, sp, #24
    c994:	4808      	ldr	r0, [pc, #32]	; (c9b8 <cf_write+0xcc>)
    c996:	f7f5 fc57 	bl	2248 <z_impl_z_log_msg_static_create>
		return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    c99a:	f06f 0710 	mvn.w	r7, #16
    c99e:	e7d0      	b.n	c942 <cf_write+0x56>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    c9a0:	f06f 0706 	mvn.w	r7, #6
    c9a4:	e7cd      	b.n	c942 <cf_write+0x56>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    c9a6:	f06f 070c 	mvn.w	r7, #12
    c9aa:	e7ca      	b.n	c942 <cf_write+0x56>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
    c9ac:	f06f 0712 	mvn.w	r7, #18
    c9b0:	e7c7      	b.n	c942 <cf_write+0x56>
    c9b2:	bf00      	nop
    c9b4:	0001f0ac 	.word	0x0001f0ac
    c9b8:	0001cff4 	.word	0x0001cff4

0000c9bc <sc_save>:
{
    c9bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c9c0:	b08a      	sub	sp, #40	; 0x28
    c9c2:	4607      	mov	r7, r0
    c9c4:	4688      	mov	r8, r1
    c9c6:	4616      	mov	r6, r2
    c9c8:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
    c9ca:	f7ff ff41 	bl	c850 <find_sc_cfg>
	if (!cfg) {
    c9ce:	4604      	mov	r4, r0
    c9d0:	b178      	cbz	r0, c9f2 <sc_save+0x36>
	if (!(cfg->data.start || cfg->data.end)) {
    c9d2:	8923      	ldrh	r3, [r4, #8]
    c9d4:	b913      	cbnz	r3, c9dc <sc_save+0x20>
    c9d6:	8963      	ldrh	r3, [r4, #10]
    c9d8:	2b00      	cmp	r3, #0
    c9da:	d03f      	beq.n	ca5c <sc_save+0xa0>
	modified = update_range(&cfg->data.start, &cfg->data.end, start, end);
    c9dc:	462b      	mov	r3, r5
    c9de:	4632      	mov	r2, r6
    c9e0:	f104 010a 	add.w	r1, r4, #10
    c9e4:	f104 0008 	add.w	r0, r4, #8
    c9e8:	f00c fc35 	bl	19256 <update_range>
}
    c9ec:	b00a      	add	sp, #40	; 0x28
    c9ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
    c9f2:	9002      	str	r0, [sp, #8]
    c9f4:	f8cd 000b 	str.w	r0, [sp, #11]
    c9f8:	a902      	add	r1, sp, #8
    c9fa:	f7ff ff29 	bl	c850 <find_sc_cfg>
		if (!cfg) {
    c9fe:	4604      	mov	r4, r0
    ca00:	b130      	cbz	r0, ca10 <sc_save+0x54>
		cfg->id = id;
    ca02:	f800 7b01 	strb.w	r7, [r0], #1
    ca06:	2207      	movs	r2, #7
    ca08:	4641      	mov	r1, r8
    ca0a:	f00a fe91 	bl	17730 <memcpy>
    ca0e:	e7e0      	b.n	c9d2 <sc_save+0x16>
			BT_ERR("unable to save SC: no cfg left");
    ca10:	4b14      	ldr	r3, [pc, #80]	; (ca64 <sc_save+0xa8>)
    ca12:	9309      	str	r3, [sp, #36]	; 0x24
    ca14:	2302      	movs	r3, #2
    ca16:	f88d 3004 	strb.w	r3, [sp, #4]
    ca1a:	2300      	movs	r3, #0
    ca1c:	f88d 3005 	strb.w	r3, [sp, #5]
    ca20:	f88d 3006 	strb.w	r3, [sp, #6]
    ca24:	f88d 3007 	strb.w	r3, [sp, #7]
    ca28:	9a01      	ldr	r2, [sp, #4]
    ca2a:	9208      	str	r2, [sp, #32]
    ca2c:	4619      	mov	r1, r3
    ca2e:	f363 0100 	bfi	r1, r3, #0, #1
    ca32:	f363 0141 	bfi	r1, r3, #1, #1
    ca36:	f363 0182 	bfi	r1, r3, #2, #1
    ca3a:	f363 01c5 	bfi	r1, r3, #3, #3
    ca3e:	2201      	movs	r2, #1
    ca40:	f362 1188 	bfi	r1, r2, #6, #3
    ca44:	2208      	movs	r2, #8
    ca46:	f362 2152 	bfi	r1, r2, #9, #10
    ca4a:	f363 41de 	bfi	r1, r3, #19, #12
    ca4e:	f363 71df 	bfi	r1, r3, #31, #1
    ca52:	aa08      	add	r2, sp, #32
    ca54:	4804      	ldr	r0, [pc, #16]	; (ca68 <sc_save+0xac>)
    ca56:	f7f5 fbf7 	bl	2248 <z_impl_z_log_msg_static_create>
			return;
    ca5a:	e7c7      	b.n	c9ec <sc_save+0x30>
		cfg->data.start = start;
    ca5c:	8126      	strh	r6, [r4, #8]
		cfg->data.end = end;
    ca5e:	8165      	strh	r5, [r4, #10]
		goto done;
    ca60:	e7c4      	b.n	c9ec <sc_save+0x30>
    ca62:	bf00      	nop
    ca64:	0001f0d8 	.word	0x0001f0d8
    ca68:	0001cff4 	.word	0x0001cff4

0000ca6c <bt_gatt_attr_write_ccc>:
{
    ca6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ca70:	b089      	sub	sp, #36	; 0x24
    ca72:	461c      	mov	r4, r3
    ca74:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
	struct _bt_gatt_ccc *ccc = attr->user_data;
    ca78:	68cf      	ldr	r7, [r1, #12]
	if (offset) {
    ca7a:	2b00      	cmp	r3, #0
    ca7c:	d16d      	bne.n	cb5a <bt_gatt_attr_write_ccc+0xee>
    ca7e:	4681      	mov	r9, r0
    ca80:	460e      	mov	r6, r1
	if (!len || len > sizeof(uint16_t)) {
    ca82:	1e63      	subs	r3, r4, #1
    ca84:	b29b      	uxth	r3, r3
    ca86:	2b01      	cmp	r3, #1
    ca88:	d86a      	bhi.n	cb60 <bt_gatt_attr_write_ccc+0xf4>
	if (len < sizeof(uint16_t)) {
    ca8a:	2c01      	cmp	r4, #1
    ca8c:	d91f      	bls.n	cace <bt_gatt_attr_write_ccc+0x62>
    ca8e:	7853      	ldrb	r3, [r2, #1]
    ca90:	7815      	ldrb	r5, [r2, #0]
    ca92:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
    ca96:	4639      	mov	r1, r7
    ca98:	4648      	mov	r0, r9
    ca9a:	f00c fcdc 	bl	19456 <find_ccc_cfg>
	if (!cfg) {
    ca9e:	4680      	mov	r8, r0
    caa0:	b1b8      	cbz	r0, cad2 <bt_gatt_attr_write_ccc+0x66>
	if (ccc->cfg_write) {
    caa2:	693b      	ldr	r3, [r7, #16]
    caa4:	b143      	cbz	r3, cab8 <bt_gatt_attr_write_ccc+0x4c>
		ssize_t write = ccc->cfg_write(conn, attr, value);
    caa6:	462a      	mov	r2, r5
    caa8:	4631      	mov	r1, r6
    caaa:	4648      	mov	r0, r9
    caac:	4798      	blx	r3
		if (write < 0) {
    caae:	2800      	cmp	r0, #0
    cab0:	db0a      	blt.n	cac8 <bt_gatt_attr_write_ccc+0x5c>
		if (write != sizeof(value) && write != 1) {
    cab2:	3801      	subs	r0, #1
    cab4:	2801      	cmp	r0, #1
    cab6:	d856      	bhi.n	cb66 <bt_gatt_attr_write_ccc+0xfa>
	cfg->value = value;
    cab8:	f8a8 5008 	strh.w	r5, [r8, #8]
	if (cfg->value != ccc->value) {
    cabc:	897b      	ldrh	r3, [r7, #10]
    cabe:	429d      	cmp	r5, r3
    cac0:	d142      	bne.n	cb48 <bt_gatt_attr_write_ccc+0xdc>
	if (!value) {
    cac2:	2d00      	cmp	r5, #0
    cac4:	d045      	beq.n	cb52 <bt_gatt_attr_write_ccc+0xe6>
	return len;
    cac6:	4620      	mov	r0, r4
}
    cac8:	b009      	add	sp, #36	; 0x24
    caca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		value = *(uint8_t *)buf;
    cace:	7815      	ldrb	r5, [r2, #0]
    cad0:	e7e1      	b.n	ca96 <bt_gatt_attr_write_ccc+0x2a>
		if (!value) {
    cad2:	b90d      	cbnz	r5, cad8 <bt_gatt_attr_write_ccc+0x6c>
			return len;
    cad4:	4620      	mov	r0, r4
    cad6:	e7f7      	b.n	cac8 <bt_gatt_attr_write_ccc+0x5c>
		cfg = find_ccc_cfg(NULL, ccc);
    cad8:	4639      	mov	r1, r7
    cada:	2000      	movs	r0, #0
    cadc:	f00c fcbb 	bl	19456 <find_ccc_cfg>
		if (!cfg) {
    cae0:	4680      	mov	r8, r0
    cae2:	b150      	cbz	r0, cafa <bt_gatt_attr_write_ccc+0x8e>
    cae4:	2207      	movs	r2, #7
    cae6:	f109 0188 	add.w	r1, r9, #136	; 0x88
    caea:	3001      	adds	r0, #1
    caec:	f00a fe20 	bl	17730 <memcpy>
		cfg->id = conn->id;
    caf0:	f899 3008 	ldrb.w	r3, [r9, #8]
    caf4:	f888 3000 	strb.w	r3, [r8]
    caf8:	e7d3      	b.n	caa2 <bt_gatt_attr_write_ccc+0x36>
			BT_WARN("No space to store CCC cfg");
    cafa:	4b1c      	ldr	r3, [pc, #112]	; (cb6c <bt_gatt_attr_write_ccc+0x100>)
    cafc:	9307      	str	r3, [sp, #28]
    cafe:	2202      	movs	r2, #2
    cb00:	f88d 2004 	strb.w	r2, [sp, #4]
    cb04:	2300      	movs	r3, #0
    cb06:	f88d 3005 	strb.w	r3, [sp, #5]
    cb0a:	f88d 3006 	strb.w	r3, [sp, #6]
    cb0e:	f88d 3007 	strb.w	r3, [sp, #7]
    cb12:	9901      	ldr	r1, [sp, #4]
    cb14:	9106      	str	r1, [sp, #24]
    cb16:	4619      	mov	r1, r3
    cb18:	f363 0100 	bfi	r1, r3, #0, #1
    cb1c:	f363 0141 	bfi	r1, r3, #1, #1
    cb20:	f363 0182 	bfi	r1, r3, #2, #1
    cb24:	f363 01c5 	bfi	r1, r3, #3, #3
    cb28:	f362 1188 	bfi	r1, r2, #6, #3
    cb2c:	2208      	movs	r2, #8
    cb2e:	f362 2152 	bfi	r1, r2, #9, #10
    cb32:	f363 41de 	bfi	r1, r3, #19, #12
    cb36:	f363 71df 	bfi	r1, r3, #31, #1
    cb3a:	aa06      	add	r2, sp, #24
    cb3c:	480c      	ldr	r0, [pc, #48]	; (cb70 <bt_gatt_attr_write_ccc+0x104>)
    cb3e:	f7f5 fb83 	bl	2248 <z_impl_z_log_msg_static_create>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
    cb42:	f06f 0010 	mvn.w	r0, #16
    cb46:	e7bf      	b.n	cac8 <bt_gatt_attr_write_ccc+0x5c>
		gatt_ccc_changed(attr, ccc);
    cb48:	4639      	mov	r1, r7
    cb4a:	4630      	mov	r0, r6
    cb4c:	f00c fbe0 	bl	19310 <gatt_ccc_changed>
    cb50:	e7b7      	b.n	cac2 <bt_gatt_attr_write_ccc+0x56>
		clear_ccc_cfg(cfg);
    cb52:	4640      	mov	r0, r8
    cb54:	f00c fcab 	bl	194ae <clear_ccc_cfg>
    cb58:	e7b5      	b.n	cac6 <bt_gatt_attr_write_ccc+0x5a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
    cb5a:	f06f 0006 	mvn.w	r0, #6
    cb5e:	e7b3      	b.n	cac8 <bt_gatt_attr_write_ccc+0x5c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    cb60:	f06f 000c 	mvn.w	r0, #12
    cb64:	e7b0      	b.n	cac8 <bt_gatt_attr_write_ccc+0x5c>
			return BT_GATT_ERR(BT_ATT_ERR_UNLIKELY);
    cb66:	f06f 000d 	mvn.w	r0, #13
    cb6a:	e7ad      	b.n	cac8 <bt_gatt_attr_write_ccc+0x5c>
    cb6c:	0001f0f8 	.word	0x0001f0f8
    cb70:	0001cff4 	.word	0x0001cff4

0000cb74 <sc_clear>:
{
    cb74:	b5b0      	push	{r4, r5, r7, lr}
    cb76:	b082      	sub	sp, #8
    cb78:	af00      	add	r7, sp, #0
    cb7a:	4604      	mov	r4, r0
	if (bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    cb7c:	f100 0588 	add.w	r5, r0, #136	; 0x88
    cb80:	4629      	mov	r1, r5
    cb82:	7a00      	ldrb	r0, [r0, #8]
    cb84:	f00a ffe4 	bl	17b50 <bt_addr_le_is_bonded>
    cb88:	2800      	cmp	r0, #0
    cb8a:	d042      	beq.n	cc12 <sc_clear+0x9e>
		err = bt_gatt_clear_sc(conn->id, &conn->le.dst);
    cb8c:	4629      	mov	r1, r5
    cb8e:	7a20      	ldrb	r0, [r4, #8]
    cb90:	f00c fce6 	bl	19560 <bt_gatt_clear_sc>
		if (err) {
    cb94:	4604      	mov	r4, r0
    cb96:	2800      	cmp	r0, #0
    cb98:	d042      	beq.n	cc20 <sc_clear+0xac>
			BT_ERR("Failed to clear SC %d", err);
    cb9a:	466d      	mov	r5, sp
    cb9c:	b088      	sub	sp, #32
    cb9e:	466b      	mov	r3, sp
    cba0:	f113 0210 	adds.w	r2, r3, #16
    cba4:	d02f      	beq.n	cc06 <sc_clear+0x92>
    cba6:	210c      	movs	r1, #12
    cba8:	b11a      	cbz	r2, cbb2 <sc_clear+0x3e>
    cbaa:	2904      	cmp	r1, #4
    cbac:	dd01      	ble.n	cbb2 <sc_clear+0x3e>
    cbae:	481e      	ldr	r0, [pc, #120]	; (cc28 <sc_clear+0xb4>)
    cbb0:	6158      	str	r0, [r3, #20]
    cbb2:	b112      	cbz	r2, cbba <sc_clear+0x46>
    cbb4:	2908      	cmp	r1, #8
    cbb6:	dd00      	ble.n	cbba <sc_clear+0x46>
    cbb8:	619c      	str	r4, [r3, #24]
    cbba:	290b      	cmp	r1, #11
    cbbc:	dd26      	ble.n	cc0c <sc_clear+0x98>
    cbbe:	240c      	movs	r4, #12
    cbc0:	b13a      	cbz	r2, cbd2 <sc_clear+0x5e>
    cbc2:	2103      	movs	r1, #3
    cbc4:	7139      	strb	r1, [r7, #4]
    cbc6:	2100      	movs	r1, #0
    cbc8:	7179      	strb	r1, [r7, #5]
    cbca:	71b9      	strb	r1, [r7, #6]
    cbcc:	71f9      	strb	r1, [r7, #7]
    cbce:	6878      	ldr	r0, [r7, #4]
    cbd0:	6118      	str	r0, [r3, #16]
    cbd2:	2100      	movs	r1, #0
    cbd4:	f36f 0100 	bfc	r1, #0, #1
    cbd8:	f36f 0141 	bfc	r1, #1, #1
    cbdc:	f36f 0182 	bfc	r1, #2, #1
    cbe0:	f36f 01c5 	bfc	r1, #3, #3
    cbe4:	2301      	movs	r3, #1
    cbe6:	f363 1188 	bfi	r1, r3, #6, #3
    cbea:	f404 747b 	and.w	r4, r4, #1004	; 0x3ec
    cbee:	f364 2152 	bfi	r1, r4, #9, #10
    cbf2:	f36f 41de 	bfc	r1, #19, #12
    cbf6:	f36f 71df 	bfc	r1, #31, #1
    cbfa:	2300      	movs	r3, #0
    cbfc:	480b      	ldr	r0, [pc, #44]	; (cc2c <sc_clear+0xb8>)
    cbfe:	f7f5 fb23 	bl	2248 <z_impl_z_log_msg_static_create>
    cc02:	46ad      	mov	sp, r5
    cc04:	e00c      	b.n	cc20 <sc_clear+0xac>
    cc06:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    cc0a:	e7cd      	b.n	cba8 <sc_clear+0x34>
    cc0c:	f06f 041b 	mvn.w	r4, #27
    cc10:	e7d6      	b.n	cbc0 <sc_clear+0x4c>
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
    cc12:	4629      	mov	r1, r5
    cc14:	7a20      	ldrb	r0, [r4, #8]
    cc16:	f7ff fe1b 	bl	c850 <find_sc_cfg>
		if (cfg) {
    cc1a:	b108      	cbz	r0, cc20 <sc_clear+0xac>
			clear_sc_cfg(cfg);
    cc1c:	f00c fc9a 	bl	19554 <clear_sc_cfg>
}
    cc20:	3708      	adds	r7, #8
    cc22:	46bd      	mov	sp, r7
    cc24:	bdb0      	pop	{r4, r5, r7, pc}
    cc26:	bf00      	nop
    cc28:	0001f114 	.word	0x0001f114
    cc2c:	0001cff4 	.word	0x0001cff4

0000cc30 <sc_indicate_rsp>:
{
    cc30:	b510      	push	{r4, lr}
    cc32:	4604      	mov	r4, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    cc34:	4b16      	ldr	r3, [pc, #88]	; (cc90 <sc_indicate_rsp+0x60>)
    cc36:	e8d3 2fef 	ldaex	r2, [r3]
    cc3a:	f022 0202 	bic.w	r2, r2, #2
    cc3e:	e8c3 2fe1 	stlex	r1, r2, [r3]
    cc42:	2900      	cmp	r1, #0
    cc44:	d1f7      	bne.n	cc36 <sc_indicate_rsp+0x6>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    cc46:	e8d3 3faf 	lda	r3, [r3]
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
    cc4a:	f013 0f01 	tst.w	r3, #1
    cc4e:	d104      	bne.n	cc5a <sc_indicate_rsp+0x2a>
	if (bt_att_fixed_chan_only(conn)) {
    cc50:	4620      	mov	r0, r4
    cc52:	f00c facc 	bl	191ee <bt_att_fixed_chan_only>
    cc56:	b930      	cbnz	r0, cc66 <sc_indicate_rsp+0x36>
}
    cc58:	bd10      	pop	{r4, pc}
	k_work_reschedule(&gatt_sc.work, timeout);
    cc5a:	2200      	movs	r2, #0
    cc5c:	2300      	movs	r3, #0
    cc5e:	480d      	ldr	r0, [pc, #52]	; (cc94 <sc_indicate_rsp+0x64>)
    cc60:	f007 f9ac 	bl	13fbc <k_work_reschedule>
    cc64:	e7f4      	b.n	cc50 <sc_indicate_rsp+0x20>
		cfg = find_cf_cfg(conn);
    cc66:	4620      	mov	r0, r4
    cc68:	f7ff fdc8 	bl	c7fc <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
    cc6c:	4603      	mov	r3, r0
    cc6e:	2800      	cmp	r0, #0
    cc70:	d0f2      	beq.n	cc58 <sc_indicate_rsp+0x28>
    cc72:	7a02      	ldrb	r2, [r0, #8]
    cc74:	f012 0f01 	tst.w	r2, #1
    cc78:	d0ee      	beq.n	cc58 <sc_indicate_rsp+0x28>
			atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
    cc7a:	330c      	adds	r3, #12
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    cc7c:	e8d3 2fef 	ldaex	r2, [r3]
    cc80:	f042 0201 	orr.w	r2, r2, #1
    cc84:	e8c3 2fe1 	stlex	r1, r2, [r3]
    cc88:	2900      	cmp	r1, #0
    cc8a:	d0e5      	beq.n	cc58 <sc_indicate_rsp+0x28>
    cc8c:	e7f6      	b.n	cc7c <sc_indicate_rsp+0x4c>
    cc8e:	bf00      	nop
    cc90:	20001950 	.word	0x20001950
    cc94:	20001920 	.word	0x20001920

0000cc98 <gatt_write_ccc_rsp>:
}

static void gatt_write_ccc_rsp(struct bt_conn *conn, uint8_t err,
			       const void *pdu, uint16_t length,
			       void *user_data)
{
    cc98:	b5f0      	push	{r4, r5, r6, r7, lr}
    cc9a:	b089      	sub	sp, #36	; 0x24
    cc9c:	4606      	mov	r6, r0
    cc9e:	460d      	mov	r5, r1
    cca0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	struct bt_gatt_subscribe_params *params = user_data;

	BT_DBG("err 0x%02x", err);

	atomic_clear_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);
    cca2:	f104 0314 	add.w	r3, r4, #20
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    cca6:	e8d3 2fef 	ldaex	r2, [r3]
    ccaa:	f022 0204 	bic.w	r2, r2, #4
    ccae:	e8c3 2fe1 	stlex	r1, r2, [r3]
    ccb2:	2900      	cmp	r1, #0
    ccb4:	d1f7      	bne.n	cca6 <gatt_write_ccc_rsp+0xe>

	/* if write to CCC failed we remove subscription and notify app */
	if (err) {
    ccb6:	b975      	cbnz	r5, ccd6 <gatt_write_ccc_rsp+0x3e>
			if (node == &params->node) {
				gatt_sub_remove(conn, sub, tmp, params);
				break;
			}
		}
	} else if (!params->value) {
    ccb8:	8a23      	ldrh	r3, [r4, #16]
    ccba:	b923      	cbnz	r3, ccc6 <gatt_write_ccc_rsp+0x2e>
		/* Notify with NULL data to complete unsubscribe */
		params->notify(conn, params, NULL, 0);
    ccbc:	6827      	ldr	r7, [r4, #0]
    ccbe:	461a      	mov	r2, r3
    ccc0:	4621      	mov	r1, r4
    ccc2:	4630      	mov	r0, r6
    ccc4:	47b8      	blx	r7
	}

	if (params->subscribe) {
    ccc6:	6863      	ldr	r3, [r4, #4]
    ccc8:	b31b      	cbz	r3, cd12 <gatt_write_ccc_rsp+0x7a>
		params->subscribe(conn, err, params);
    ccca:	4622      	mov	r2, r4
    cccc:	4629      	mov	r1, r5
    ccce:	4630      	mov	r0, r6
    ccd0:	4798      	blx	r3
	} else if (params->write) {
		/* TODO: Remove after deprecation */
		BT_WARN("write callback is deprecated, use subscribe cb instead");
		params->write(conn, err, NULL);
	}
}
    ccd2:	b009      	add	sp, #36	; 0x24
    ccd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sub = gatt_sub_find(conn);
    ccd6:	4630      	mov	r0, r6
    ccd8:	f7ff fdde 	bl	c898 <gatt_sub_find>
		if (!sub) {
    ccdc:	4601      	mov	r1, r0
    ccde:	2800      	cmp	r0, #0
    cce0:	d0f7      	beq.n	ccd2 <gatt_write_ccc_rsp+0x3a>
	return list->head;
    cce2:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_PEEK_NEXT(slist, snode)
    cce4:	b10b      	cbz	r3, ccea <gatt_write_ccc_rsp+0x52>
	return node->next;
    cce6:	681a      	ldr	r2, [r3, #0]
    cce8:	e009      	b.n	ccfe <gatt_write_ccc_rsp+0x66>
Z_GENLIST_PEEK_NEXT(slist, snode)
    ccea:	461a      	mov	r2, r3
    ccec:	e007      	b.n	ccfe <gatt_write_ccc_rsp+0x66>
				gatt_sub_remove(conn, sub, tmp, params);
    ccee:	4623      	mov	r3, r4
    ccf0:	4630      	mov	r0, r6
    ccf2:	f00c fbfa 	bl	194ea <gatt_sub_remove>
				break;
    ccf6:	e7e6      	b.n	ccc6 <gatt_write_ccc_rsp+0x2e>
    ccf8:	4610      	mov	r0, r2
    ccfa:	4613      	mov	r3, r2
    ccfc:	4602      	mov	r2, r0
		SYS_SLIST_FOR_EACH_NODE_SAFE(&sub->list, node, tmp) {
    ccfe:	2b00      	cmp	r3, #0
    cd00:	d0e1      	beq.n	ccc6 <gatt_write_ccc_rsp+0x2e>
			if (node == &params->node) {
    cd02:	f104 0c18 	add.w	ip, r4, #24
    cd06:	459c      	cmp	ip, r3
    cd08:	d0f1      	beq.n	ccee <gatt_write_ccc_rsp+0x56>
    cd0a:	2a00      	cmp	r2, #0
    cd0c:	d0f4      	beq.n	ccf8 <gatt_write_ccc_rsp+0x60>
	return node->next;
    cd0e:	6810      	ldr	r0, [r2, #0]
    cd10:	e7f3      	b.n	ccfa <gatt_write_ccc_rsp+0x62>
	} else if (params->write) {
    cd12:	68a3      	ldr	r3, [r4, #8]
    cd14:	2b00      	cmp	r3, #0
    cd16:	d0dc      	beq.n	ccd2 <gatt_write_ccc_rsp+0x3a>
		BT_WARN("write callback is deprecated, use subscribe cb instead");
    cd18:	4b15      	ldr	r3, [pc, #84]	; (cd70 <gatt_write_ccc_rsp+0xd8>)
    cd1a:	9307      	str	r3, [sp, #28]
    cd1c:	2302      	movs	r3, #2
    cd1e:	f88d 3004 	strb.w	r3, [sp, #4]
    cd22:	2700      	movs	r7, #0
    cd24:	f88d 7005 	strb.w	r7, [sp, #5]
    cd28:	f88d 7006 	strb.w	r7, [sp, #6]
    cd2c:	f88d 7007 	strb.w	r7, [sp, #7]
    cd30:	9a01      	ldr	r2, [sp, #4]
    cd32:	9206      	str	r2, [sp, #24]
    cd34:	4639      	mov	r1, r7
    cd36:	f367 0100 	bfi	r1, r7, #0, #1
    cd3a:	f367 0141 	bfi	r1, r7, #1, #1
    cd3e:	f367 0182 	bfi	r1, r7, #2, #1
    cd42:	f367 01c5 	bfi	r1, r7, #3, #3
    cd46:	f363 1188 	bfi	r1, r3, #6, #3
    cd4a:	2308      	movs	r3, #8
    cd4c:	f363 2152 	bfi	r1, r3, #9, #10
    cd50:	f367 41de 	bfi	r1, r7, #19, #12
    cd54:	f367 71df 	bfi	r1, r7, #31, #1
    cd58:	463b      	mov	r3, r7
    cd5a:	aa06      	add	r2, sp, #24
    cd5c:	4805      	ldr	r0, [pc, #20]	; (cd74 <gatt_write_ccc_rsp+0xdc>)
    cd5e:	f7f5 fa73 	bl	2248 <z_impl_z_log_msg_static_create>
		params->write(conn, err, NULL);
    cd62:	68a3      	ldr	r3, [r4, #8]
    cd64:	463a      	mov	r2, r7
    cd66:	4629      	mov	r1, r5
    cd68:	4630      	mov	r0, r6
    cd6a:	4798      	blx	r3
    cd6c:	e7b1      	b.n	ccd2 <gatt_write_ccc_rsp+0x3a>
    cd6e:	bf00      	nop
    cd70:	0001f12c 	.word	0x0001f12c
    cd74:	0001cff4 	.word	0x0001cff4

0000cd78 <disconnected_cb>:
{
    cd78:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
    cd7c:	6881      	ldr	r1, [r0, #8]
    cd7e:	4b2c      	ldr	r3, [pc, #176]	; (ce30 <disconnected_cb+0xb8>)
    cd80:	4299      	cmp	r1, r3
    cd82:	d002      	beq.n	cd8a <disconnected_cb+0x12>
}
    cd84:	2001      	movs	r0, #1
    cd86:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd8a:	4604      	mov	r4, r0
    cd8c:	4616      	mov	r6, r2
	ccc = attr->user_data;
    cd8e:	68c7      	ldr	r7, [r0, #12]
	if (!ccc->value) {
    cd90:	897b      	ldrh	r3, [r7, #10]
    cd92:	2b00      	cmp	r3, #0
    cd94:	d0f6      	beq.n	cd84 <disconnected_cb+0xc>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
    cd96:	2500      	movs	r5, #0
	value_used = false;
    cd98:	46aa      	mov	sl, r5
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
    cd9a:	b15d      	cbz	r5, cdb4 <disconnected_cb+0x3c>
	if (!value_used) {
    cd9c:	f1ba 0f00 	cmp.w	sl, #0
    cda0:	d1f0      	bne.n	cd84 <disconnected_cb+0xc>
		ccc->value = 0U;
    cda2:	2300      	movs	r3, #0
    cda4:	817b      	strh	r3, [r7, #10]
		if (ccc->cfg_changed) {
    cda6:	68fb      	ldr	r3, [r7, #12]
    cda8:	2b00      	cmp	r3, #0
    cdaa:	d0eb      	beq.n	cd84 <disconnected_cb+0xc>
			ccc->cfg_changed(attr, ccc->value);
    cdac:	2100      	movs	r1, #0
    cdae:	4620      	mov	r0, r4
    cdb0:	4798      	blx	r3
    cdb2:	e7e7      	b.n	cd84 <disconnected_cb+0xc>
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
    cdb4:	eb05 0885 	add.w	r8, r5, r5, lsl #2
    cdb8:	eb07 0848 	add.w	r8, r7, r8, lsl #1
		if (!cfg->value) {
    cdbc:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    cdc0:	b1cb      	cbz	r3, cdf6 <disconnected_cb+0x7e>
		if (!bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    cdc2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    cdc6:	f108 0901 	add.w	r9, r8, #1
    cdca:	464a      	mov	r2, r9
    cdcc:	f817 1013 	ldrb.w	r1, [r7, r3, lsl #1]
    cdd0:	4630      	mov	r0, r6
    cdd2:	f00b f9e5 	bl	181a0 <bt_conn_is_peer_addr_le>
    cdd6:	b998      	cbnz	r0, ce00 <disconnected_cb+0x88>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    cdd8:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    cddc:	4649      	mov	r1, r9
    cdde:	f817 0013 	ldrb.w	r0, [r7, r3, lsl #1]
    cde2:	f7fd fb4b 	bl	a47c <bt_conn_lookup_addr_le>
			if (tmp) {
    cde6:	4603      	mov	r3, r0
    cde8:	b128      	cbz	r0, cdf6 <disconnected_cb+0x7e>
				if (tmp->state == BT_CONN_CONNECTED) {
    cdea:	7a82      	ldrb	r2, [r0, #10]
    cdec:	2a07      	cmp	r2, #7
    cdee:	d004      	beq.n	cdfa <disconnected_cb+0x82>
				bt_conn_unref(tmp);
    cdf0:	4618      	mov	r0, r3
    cdf2:	f00b f973 	bl	180dc <bt_conn_unref>
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
    cdf6:	3501      	adds	r5, #1
    cdf8:	e7cf      	b.n	cd9a <disconnected_cb+0x22>
					value_used = true;
    cdfa:	f04f 0a01 	mov.w	sl, #1
    cdfe:	e7f7      	b.n	cdf0 <disconnected_cb+0x78>
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
    ce00:	f106 0b88 	add.w	fp, r6, #136	; 0x88
    ce04:	4659      	mov	r1, fp
    ce06:	7a30      	ldrb	r0, [r6, #8]
    ce08:	f00a fea2 	bl	17b50 <bt_addr_le_is_bonded>
    ce0c:	b950      	cbnz	r0, ce24 <disconnected_cb+0xac>
				if (ccc == &sc_ccc) {
    ce0e:	4b09      	ldr	r3, [pc, #36]	; (ce34 <disconnected_cb+0xbc>)
    ce10:	429f      	cmp	r7, r3
    ce12:	d003      	beq.n	ce1c <disconnected_cb+0xa4>
				clear_ccc_cfg(cfg);
    ce14:	4640      	mov	r0, r8
    ce16:	f00c fb4a 	bl	194ae <clear_ccc_cfg>
    ce1a:	e7ec      	b.n	cdf6 <disconnected_cb+0x7e>
					sc_clear(conn);
    ce1c:	4630      	mov	r0, r6
    ce1e:	f7ff fea9 	bl	cb74 <sc_clear>
    ce22:	e7f7      	b.n	ce14 <disconnected_cb+0x9c>
    ce24:	2207      	movs	r2, #7
    ce26:	4659      	mov	r1, fp
    ce28:	4648      	mov	r0, r9
    ce2a:	f00a fc81 	bl	17730 <memcpy>
}
    ce2e:	e7e2      	b.n	cdf6 <disconnected_cb+0x7e>
    ce30:	0000ca6d 	.word	0x0000ca6d
    ce34:	20000324 	.word	0x20000324

0000ce38 <gatt_write_ccc>:
	return 0;
}

static int gatt_write_ccc(struct bt_conn *conn,
			  struct bt_gatt_subscribe_params *params)
{
    ce38:	b500      	push	{lr}
    ce3a:	b085      	sub	sp, #20
    ce3c:	460a      	mov	r2, r1
	size_t len = sizeof(struct bt_att_write_req) + sizeof(uint16_t);

	BT_DBG("handle 0x%04x value 0x%04x", params->ccc_handle, params->value);

	return gatt_req_send(conn, gatt_write_ccc_rsp, params,
    ce3e:	2301      	movs	r3, #1
    ce40:	9302      	str	r3, [sp, #8]
    ce42:	2304      	movs	r3, #4
    ce44:	9301      	str	r3, [sp, #4]
    ce46:	2312      	movs	r3, #18
    ce48:	9300      	str	r3, [sp, #0]
    ce4a:	4b03      	ldr	r3, [pc, #12]	; (ce58 <gatt_write_ccc+0x20>)
    ce4c:	4903      	ldr	r1, [pc, #12]	; (ce5c <gatt_write_ccc+0x24>)
    ce4e:	f00c fc04 	bl	1965a <gatt_req_send>
			     gatt_write_ccc_buf, BT_ATT_OP_WRITE_REQ, len,
			     BT_ATT_CHAN_OPT(params));
}
    ce52:	b005      	add	sp, #20
    ce54:	f85d fb04 	ldr.w	pc, [sp], #4
    ce58:	000196df 	.word	0x000196df
    ce5c:	0000cc99 	.word	0x0000cc99

0000ce60 <bt_gatt_init>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    ce60:	4b11      	ldr	r3, [pc, #68]	; (cea8 <bt_gatt_init+0x48>)
    ce62:	2201      	movs	r2, #1
    ce64:	e8d3 1fef 	ldaex	r1, [r3]
    ce68:	2900      	cmp	r1, #0
    ce6a:	d103      	bne.n	ce74 <bt_gatt_init+0x14>
    ce6c:	e8c3 2fe0 	stlex	r0, r2, [r3]
    ce70:	2800      	cmp	r0, #0
    ce72:	d1f7      	bne.n	ce64 <bt_gatt_init+0x4>
	if (!atomic_cas(&init, 0, 1)) {
    ce74:	d116      	bne.n	cea4 <bt_gatt_init+0x44>
{
    ce76:	b510      	push	{r4, lr}
	bt_gatt_service_init();
    ce78:	f7ff fca0 	bl	c7bc <bt_gatt_service_init>
	list->head = NULL;
    ce7c:	4b0b      	ldr	r3, [pc, #44]	; (ceac <bt_gatt_init+0x4c>)
    ce7e:	2200      	movs	r2, #0
    ce80:	601a      	str	r2, [r3, #0]
	list->tail = NULL;
    ce82:	605a      	str	r2, [r3, #4]
	k_work_init_delayable(&db_hash.work, db_hash_process);
    ce84:	4c0a      	ldr	r4, [pc, #40]	; (ceb0 <bt_gatt_init+0x50>)
    ce86:	490b      	ldr	r1, [pc, #44]	; (ceb4 <bt_gatt_init+0x54>)
    ce88:	4620      	mov	r0, r4
    ce8a:	f00f fa77 	bl	1c37c <k_work_init_delayable>
		bt_long_wq_schedule(&db_hash.work, DB_HASH_TIMEOUT);
    ce8e:	f44f 72a4 	mov.w	r2, #328	; 0x148
    ce92:	2300      	movs	r3, #0
    ce94:	4620      	mov	r0, r4
    ce96:	f7f8 fc6d 	bl	5774 <bt_long_wq_schedule>
	k_work_init_delayable(&gatt_sc.work, sc_process);
    ce9a:	4907      	ldr	r1, [pc, #28]	; (ceb8 <bt_gatt_init+0x58>)
    ce9c:	4807      	ldr	r0, [pc, #28]	; (cebc <bt_gatt_init+0x5c>)
    ce9e:	f00f fa6d 	bl	1c37c <k_work_init_delayable>
}
    cea2:	bd10      	pop	{r4, pc}
    cea4:	4770      	bx	lr
    cea6:	bf00      	nop
    cea8:	200023f4 	.word	0x200023f4
    ceac:	200023dc 	.word	0x200023dc
    ceb0:	200018a8 	.word	0x200018a8
    ceb4:	00019a6f 	.word	0x00019a6f
    ceb8:	0000d449 	.word	0x0000d449
    cebc:	20001920 	.word	0x20001920

0000cec0 <bt_gatt_attr_get_handle>:
	if (!attr) {
    cec0:	b328      	cbz	r0, cf0e <bt_gatt_attr_get_handle+0x4e>
    cec2:	4684      	mov	ip, r0
	if (attr->handle) {
    cec4:	8a00      	ldrh	r0, [r0, #16]
    cec6:	bb38      	cbnz	r0, cf18 <bt_gatt_attr_get_handle+0x58>
{
    cec8:	b470      	push	{r4, r5, r6}
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    ceca:	4d14      	ldr	r5, [pc, #80]	; (cf1c <bt_gatt_attr_get_handle+0x5c>)
	uint16_t handle = 1;
    cecc:	2201      	movs	r2, #1
    cece:	e003      	b.n	ced8 <bt_gatt_attr_get_handle+0x18>
			handle += static_svc->attr_count;
    ced0:	686b      	ldr	r3, [r5, #4]
    ced2:	441a      	add	r2, r3
    ced4:	b292      	uxth	r2, r2
	STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    ced6:	3508      	adds	r5, #8
    ced8:	4b11      	ldr	r3, [pc, #68]	; (cf20 <bt_gatt_attr_get_handle+0x60>)
    ceda:	429d      	cmp	r5, r3
    cedc:	d21a      	bcs.n	cf14 <bt_gatt_attr_get_handle+0x54>
		if ((attr < &static_svc->attrs[0]) ||
    cede:	682c      	ldr	r4, [r5, #0]
    cee0:	4564      	cmp	r4, ip
    cee2:	d8f5      	bhi.n	ced0 <bt_gatt_attr_get_handle+0x10>
		    (attr > &static_svc->attrs[static_svc->attr_count - 1])) {
    cee4:	686e      	ldr	r6, [r5, #4]
    cee6:	eb06 0386 	add.w	r3, r6, r6, lsl #2
    ceea:	009b      	lsls	r3, r3, #2
    ceec:	3b14      	subs	r3, #20
    ceee:	4423      	add	r3, r4
		if ((attr < &static_svc->attrs[0]) ||
    cef0:	4563      	cmp	r3, ip
    cef2:	d3ed      	bcc.n	ced0 <bt_gatt_attr_get_handle+0x10>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
    cef4:	2300      	movs	r3, #0
    cef6:	429e      	cmp	r6, r3
    cef8:	d9ed      	bls.n	ced6 <bt_gatt_attr_get_handle+0x16>
			if (attr == &static_svc->attrs[i]) {
    cefa:	eb03 0183 	add.w	r1, r3, r3, lsl #2
    cefe:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    cf02:	4561      	cmp	r1, ip
    cf04:	d005      	beq.n	cf12 <bt_gatt_attr_get_handle+0x52>
		for (size_t i = 0; i < static_svc->attr_count; i++, handle++) {
    cf06:	3301      	adds	r3, #1
    cf08:	3201      	adds	r2, #1
    cf0a:	b292      	uxth	r2, r2
    cf0c:	e7f3      	b.n	cef6 <bt_gatt_attr_get_handle+0x36>
		return 0;
    cf0e:	2000      	movs	r0, #0
    cf10:	4770      	bx	lr
				return handle;
    cf12:	4610      	mov	r0, r2
}
    cf14:	bc70      	pop	{r4, r5, r6}
    cf16:	4770      	bx	lr
    cf18:	4770      	bx	lr
    cf1a:	bf00      	nop
    cf1c:	0001cfb4 	.word	0x0001cfb4
    cf20:	0001cfcc 	.word	0x0001cfcc

0000cf24 <bt_gatt_foreach_attr_type>:
{
    cf24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cf28:	b087      	sub	sp, #28
    cf2a:	4607      	mov	r7, r0
    cf2c:	468a      	mov	sl, r1
    cf2e:	4690      	mov	r8, r2
    cf30:	4699      	mov	r9, r3
    cf32:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
	if (!num_matches) {
    cf36:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
    cf3a:	b91b      	cbnz	r3, cf44 <bt_gatt_foreach_attr_type+0x20>
		num_matches = UINT16_MAX;
    cf3c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    cf40:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
	if (start_handle <= last_static_handle) {
    cf44:	4b18      	ldr	r3, [pc, #96]	; (cfa8 <bt_gatt_foreach_attr_type+0x84>)
    cf46:	881b      	ldrh	r3, [r3, #0]
    cf48:	42bb      	cmp	r3, r7
    cf4a:	d22a      	bcs.n	cfa2 <bt_gatt_foreach_attr_type+0x7e>
}
    cf4c:	b007      	add	sp, #28
    cf4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				handle += static_svc->attr_count;
    cf52:	b294      	uxth	r4, r2
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    cf54:	3608      	adds	r6, #8
    cf56:	4b15      	ldr	r3, [pc, #84]	; (cfac <bt_gatt_foreach_attr_type+0x88>)
    cf58:	429e      	cmp	r6, r3
    cf5a:	d2f7      	bcs.n	cf4c <bt_gatt_foreach_attr_type+0x28>
			if (handle + static_svc->attr_count < start_handle) {
    cf5c:	6873      	ldr	r3, [r6, #4]
    cf5e:	18e2      	adds	r2, r4, r3
    cf60:	42ba      	cmp	r2, r7
    cf62:	d3f6      	bcc.n	cf52 <bt_gatt_foreach_attr_type+0x2e>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    cf64:	2500      	movs	r5, #0
    cf66:	6873      	ldr	r3, [r6, #4]
    cf68:	42ab      	cmp	r3, r5
    cf6a:	d9f3      	bls.n	cf54 <bt_gatt_foreach_attr_type+0x30>
				if (gatt_foreach_iter(&static_svc->attrs[i],
    cf6c:	eb05 0085 	add.w	r0, r5, r5, lsl #2
    cf70:	f8cd b010 	str.w	fp, [sp, #16]
    cf74:	9b11      	ldr	r3, [sp, #68]	; 0x44
    cf76:	9303      	str	r3, [sp, #12]
    cf78:	ab10      	add	r3, sp, #64	; 0x40
    cf7a:	9302      	str	r3, [sp, #8]
    cf7c:	f8cd 9004 	str.w	r9, [sp, #4]
    cf80:	f8cd 8000 	str.w	r8, [sp]
    cf84:	4653      	mov	r3, sl
    cf86:	463a      	mov	r2, r7
    cf88:	4621      	mov	r1, r4
    cf8a:	f8d6 c000 	ldr.w	ip, [r6]
    cf8e:	eb0c 0080 	add.w	r0, ip, r0, lsl #2
    cf92:	f00c fb29 	bl	195e8 <gatt_foreach_iter>
    cf96:	2800      	cmp	r0, #0
    cf98:	d0d8      	beq.n	cf4c <bt_gatt_foreach_attr_type+0x28>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
    cf9a:	3501      	adds	r5, #1
    cf9c:	3401      	adds	r4, #1
    cf9e:	b2a4      	uxth	r4, r4
    cfa0:	e7e1      	b.n	cf66 <bt_gatt_foreach_attr_type+0x42>
		STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
    cfa2:	4e03      	ldr	r6, [pc, #12]	; (cfb0 <bt_gatt_foreach_attr_type+0x8c>)
		uint16_t handle = 1;
    cfa4:	2401      	movs	r4, #1
    cfa6:	e7d6      	b.n	cf56 <bt_gatt_foreach_attr_type+0x32>
    cfa8:	200028f4 	.word	0x200028f4
    cfac:	0001cfcc 	.word	0x0001cfcc
    cfb0:	0001cfb4 	.word	0x0001cfb4

0000cfb4 <db_hash_gen>:
{
    cfb4:	b510      	push	{r4, lr}
    cfb6:	b0da      	sub	sp, #360	; 0x168
	uint8_t key[16] = {};
    cfb8:	2300      	movs	r3, #0
    cfba:	934a      	str	r3, [sp, #296]	; 0x128
    cfbc:	934b      	str	r3, [sp, #300]	; 0x12c
    cfbe:	934c      	str	r3, [sp, #304]	; 0x130
    cfc0:	934d      	str	r3, [sp, #308]	; 0x134
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
    cfc2:	aa1e      	add	r2, sp, #120	; 0x78
    cfc4:	a94a      	add	r1, sp, #296	; 0x128
    cfc6:	a806      	add	r0, sp, #24
    cfc8:	f009 ff7c 	bl	16ec4 <tc_cmac_setup>
    cfcc:	b190      	cbz	r0, cff4 <db_hash_gen+0x40>
    cfce:	ac06      	add	r4, sp, #24
    cfd0:	9402      	str	r4, [sp, #8]
    cfd2:	4b3a      	ldr	r3, [pc, #232]	; (d0bc <db_hash_gen+0x108>)
    cfd4:	9301      	str	r3, [sp, #4]
    cfd6:	2200      	movs	r2, #0
    cfd8:	9200      	str	r2, [sp, #0]
    cfda:	4613      	mov	r3, r2
    cfdc:	f64f 71ff 	movw	r1, #65535	; 0xffff
    cfe0:	2001      	movs	r0, #1
    cfe2:	f7ff ff9f 	bl	cf24 <bt_gatt_foreach_attr_type>
	if (tc_cmac_final(db_hash.hash, &state.state) == TC_CRYPTO_FAIL) {
    cfe6:	4621      	mov	r1, r4
    cfe8:	4835      	ldr	r0, [pc, #212]	; (d0c0 <db_hash_gen+0x10c>)
    cfea:	f00a f808 	bl	16ffe <tc_cmac_final>
    cfee:	b338      	cbz	r0, d040 <db_hash_gen+0x8c>
 */
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
    cff0:	2300      	movs	r3, #0
    cff2:	e055      	b.n	d0a0 <db_hash_gen+0xec>
		BT_ERR("Unable to setup AES CMAC");
    cff4:	4b33      	ldr	r3, [pc, #204]	; (d0c4 <db_hash_gen+0x110>)
    cff6:	9359      	str	r3, [sp, #356]	; 0x164
    cff8:	2302      	movs	r3, #2
    cffa:	f88d 3014 	strb.w	r3, [sp, #20]
    cffe:	2300      	movs	r3, #0
    d000:	f88d 3015 	strb.w	r3, [sp, #21]
    d004:	f88d 3016 	strb.w	r3, [sp, #22]
    d008:	f88d 3017 	strb.w	r3, [sp, #23]
    d00c:	9a05      	ldr	r2, [sp, #20]
    d00e:	9258      	str	r2, [sp, #352]	; 0x160
    d010:	4619      	mov	r1, r3
    d012:	f363 0100 	bfi	r1, r3, #0, #1
    d016:	f363 0141 	bfi	r1, r3, #1, #1
    d01a:	f363 0182 	bfi	r1, r3, #2, #1
    d01e:	f363 01c5 	bfi	r1, r3, #3, #3
    d022:	2201      	movs	r2, #1
    d024:	f362 1188 	bfi	r1, r2, #6, #3
    d028:	2208      	movs	r2, #8
    d02a:	f362 2152 	bfi	r1, r2, #9, #10
    d02e:	f363 41de 	bfi	r1, r3, #19, #12
    d032:	f363 71df 	bfi	r1, r3, #31, #1
    d036:	aa58      	add	r2, sp, #352	; 0x160
    d038:	4823      	ldr	r0, [pc, #140]	; (d0c8 <db_hash_gen+0x114>)
    d03a:	f7f5 f905 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    d03e:	e03a      	b.n	d0b6 <db_hash_gen+0x102>
		BT_ERR("Unable to calculate hash");
    d040:	4b22      	ldr	r3, [pc, #136]	; (d0cc <db_hash_gen+0x118>)
    d042:	9353      	str	r3, [sp, #332]	; 0x14c
    d044:	2302      	movs	r3, #2
    d046:	f88d 3014 	strb.w	r3, [sp, #20]
    d04a:	2300      	movs	r3, #0
    d04c:	f88d 3015 	strb.w	r3, [sp, #21]
    d050:	f88d 3016 	strb.w	r3, [sp, #22]
    d054:	f88d 3017 	strb.w	r3, [sp, #23]
    d058:	9a05      	ldr	r2, [sp, #20]
    d05a:	9252      	str	r2, [sp, #328]	; 0x148
    d05c:	4619      	mov	r1, r3
    d05e:	f363 0100 	bfi	r1, r3, #0, #1
    d062:	f363 0141 	bfi	r1, r3, #1, #1
    d066:	f363 0182 	bfi	r1, r3, #2, #1
    d06a:	f363 01c5 	bfi	r1, r3, #3, #3
    d06e:	2201      	movs	r2, #1
    d070:	f362 1188 	bfi	r1, r2, #6, #3
    d074:	2208      	movs	r2, #8
    d076:	f362 2152 	bfi	r1, r2, #9, #10
    d07a:	f363 41de 	bfi	r1, r3, #19, #12
    d07e:	f363 71df 	bfi	r1, r3, #31, #1
    d082:	aa52      	add	r2, sp, #328	; 0x148
    d084:	4810      	ldr	r0, [pc, #64]	; (d0c8 <db_hash_gen+0x114>)
    d086:	f7f5 f8df 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    d08a:	e014      	b.n	d0b6 <db_hash_gen+0x102>
		uint8_t tmp = ((uint8_t *)buf)[i];
    d08c:	4a0c      	ldr	r2, [pc, #48]	; (d0c0 <db_hash_gen+0x10c>)
    d08e:	5cd0      	ldrb	r0, [r2, r3]

		((uint8_t *)buf)[i] = ((uint8_t *)buf)[length - 1 - i];
    d090:	f1c3 010f 	rsb	r1, r3, #15
    d094:	f812 c001 	ldrb.w	ip, [r2, r1]
    d098:	f802 c003 	strb.w	ip, [r2, r3]
		((uint8_t *)buf)[length - 1 - i] = tmp;
    d09c:	5450      	strb	r0, [r2, r1]
	for (i = 0; i < (length/2); i++) {
    d09e:	3301      	adds	r3, #1
    d0a0:	2b07      	cmp	r3, #7
    d0a2:	d9f3      	bls.n	d08c <db_hash_gen+0xd8>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d0a4:	4b0a      	ldr	r3, [pc, #40]	; (d0d0 <db_hash_gen+0x11c>)
    d0a6:	e8d3 2fef 	ldaex	r2, [r3]
    d0aa:	f042 0204 	orr.w	r2, r2, #4
    d0ae:	e8c3 2fe1 	stlex	r1, r2, [r3]
    d0b2:	2900      	cmp	r1, #0
    d0b4:	d1f7      	bne.n	d0a6 <db_hash_gen+0xf2>
}
    d0b6:	b05a      	add	sp, #360	; 0x168
    d0b8:	bd10      	pop	{r4, pc}
    d0ba:	bf00      	nop
    d0bc:	00019379 	.word	0x00019379
    d0c0:	20001898 	.word	0x20001898
    d0c4:	0001f164 	.word	0x0001f164
    d0c8:	0001cff4 	.word	0x0001cff4
    d0cc:	0001f180 	.word	0x0001f180
    d0d0:	20001950 	.word	0x20001950

0000d0d4 <db_hash_read>:
{
    d0d4:	b5f0      	push	{r4, r5, r6, r7, lr}
    d0d6:	b085      	sub	sp, #20
    d0d8:	4604      	mov	r4, r0
    d0da:	460d      	mov	r5, r1
    d0dc:	4616      	mov	r6, r2
    d0de:	461f      	mov	r7, r3
	(void)k_work_cancel_delayable_sync(&db_hash.work, &db_hash.sync);
    d0e0:	481b      	ldr	r0, [pc, #108]	; (d150 <db_hash_read+0x7c>)
    d0e2:	f100 0140 	add.w	r1, r0, #64	; 0x40
    d0e6:	3010      	adds	r0, #16
    d0e8:	f00f f9b4 	bl	1c454 <k_work_cancel_delayable_sync>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    d0ec:	4b19      	ldr	r3, [pc, #100]	; (d154 <db_hash_read+0x80>)
    d0ee:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(gatt_sc.flags, DB_HASH_VALID)) {
    d0f2:	f013 0f04 	tst.w	r3, #4
    d0f6:	d017      	beq.n	d128 <db_hash_read+0x54>
	cfg = find_cf_cfg(conn);
    d0f8:	4620      	mov	r0, r4
    d0fa:	f7ff fb7f 	bl	c7fc <find_cf_cfg>
	if (cfg &&
    d0fe:	4603      	mov	r3, r0
    d100:	b118      	cbz	r0, d10a <db_hash_read+0x36>
	    CF_ROBUST_CACHING(cfg) &&
    d102:	7a02      	ldrb	r2, [r0, #8]
	if (cfg &&
    d104:	f012 0f01 	tst.w	r2, #1
    d108:	d112      	bne.n	d130 <db_hash_read+0x5c>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash.hash,
    d10a:	2310      	movs	r3, #16
    d10c:	9302      	str	r3, [sp, #8]
    d10e:	4b10      	ldr	r3, [pc, #64]	; (d150 <db_hash_read+0x7c>)
    d110:	9301      	str	r3, [sp, #4]
    d112:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    d116:	9300      	str	r3, [sp, #0]
    d118:	463b      	mov	r3, r7
    d11a:	4632      	mov	r2, r6
    d11c:	4629      	mov	r1, r5
    d11e:	4620      	mov	r0, r4
    d120:	f00c fb92 	bl	19848 <bt_gatt_attr_read>
}
    d124:	b005      	add	sp, #20
    d126:	bdf0      	pop	{r4, r5, r6, r7, pc}
		db_hash_gen(true);
    d128:	2001      	movs	r0, #1
    d12a:	f7ff ff43 	bl	cfb4 <db_hash_gen>
    d12e:	e7e3      	b.n	d0f8 <db_hash_read+0x24>
	    !atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
    d130:	330c      	adds	r3, #12
    d132:	e8d3 2faf 	lda	r2, [r3]
	    CF_ROBUST_CACHING(cfg) &&
    d136:	f012 0f01 	tst.w	r2, #1
    d13a:	d1e6      	bne.n	d10a <db_hash_read+0x36>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d13c:	e8d3 2fef 	ldaex	r2, [r3]
    d140:	f042 0202 	orr.w	r2, r2, #2
    d144:	e8c3 2fe1 	stlex	r1, r2, [r3]
    d148:	2900      	cmp	r1, #0
    d14a:	d0de      	beq.n	d10a <db_hash_read+0x36>
    d14c:	e7f6      	b.n	d13c <db_hash_read+0x68>
    d14e:	bf00      	nop
    d150:	20001898 	.word	0x20001898
    d154:	20001950 	.word	0x20001950

0000d158 <gatt_find_by_uuid>:
{
    d158:	b510      	push	{r4, lr}
    d15a:	b084      	sub	sp, #16
    d15c:	4604      	mov	r4, r0
    d15e:	460a      	mov	r2, r1
	found->attr = NULL;
    d160:	2300      	movs	r3, #0
    d162:	6003      	str	r3, [r0, #0]
	bt_gatt_foreach_attr_type(found->handle, 0xffff, uuid, NULL, 1,
    d164:	9002      	str	r0, [sp, #8]
    d166:	4907      	ldr	r1, [pc, #28]	; (d184 <gatt_find_by_uuid+0x2c>)
    d168:	9101      	str	r1, [sp, #4]
    d16a:	2101      	movs	r1, #1
    d16c:	9100      	str	r1, [sp, #0]
    d16e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    d172:	8880      	ldrh	r0, [r0, #4]
    d174:	f7ff fed6 	bl	cf24 <bt_gatt_foreach_attr_type>
	return found->attr ? true : false;
    d178:	6820      	ldr	r0, [r4, #0]
}
    d17a:	3800      	subs	r0, #0
    d17c:	bf18      	it	ne
    d17e:	2001      	movne	r0, #1
    d180:	b004      	add	sp, #16
    d182:	bd10      	pop	{r4, pc}
    d184:	00019363 	.word	0x00019363

0000d188 <bt_gatt_attr_next>:
{
    d188:	b510      	push	{r4, lr}
    d18a:	b086      	sub	sp, #24
	struct bt_gatt_attr *next = NULL;
    d18c:	2400      	movs	r4, #0
    d18e:	9405      	str	r4, [sp, #20]
	uint16_t handle = bt_gatt_attr_get_handle(attr);
    d190:	f7ff fe96 	bl	cec0 <bt_gatt_attr_get_handle>
	bt_gatt_foreach_attr(handle + 1, handle + 1, find_next, &next);
    d194:	3001      	adds	r0, #1
    d196:	b280      	uxth	r0, r0
    d198:	ab05      	add	r3, sp, #20
    d19a:	9302      	str	r3, [sp, #8]
    d19c:	4b05      	ldr	r3, [pc, #20]	; (d1b4 <bt_gatt_attr_next+0x2c>)
    d19e:	9301      	str	r3, [sp, #4]
    d1a0:	9400      	str	r4, [sp, #0]
    d1a2:	4623      	mov	r3, r4
    d1a4:	4622      	mov	r2, r4
    d1a6:	4601      	mov	r1, r0
    d1a8:	f7ff febc 	bl	cf24 <bt_gatt_foreach_attr_type>
}
    d1ac:	9805      	ldr	r0, [sp, #20]
    d1ae:	b006      	add	sp, #24
    d1b0:	bd10      	pop	{r4, pc}
    d1b2:	bf00      	nop
    d1b4:	0001930b 	.word	0x0001930b

0000d1b8 <gatt_indicate>:
{
    d1b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d1bc:	b096      	sub	sp, #88	; 0x58
    d1be:	4605      	mov	r5, r0
    d1c0:	460f      	mov	r7, r1
    d1c2:	4614      	mov	r4, r2
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
    d1c4:	2294      	movs	r2, #148	; 0x94
    d1c6:	6861      	ldr	r1, [r4, #4]
    d1c8:	f00c fc56 	bl	19a78 <bt_gatt_check_perm>
    d1cc:	2800      	cmp	r0, #0
    d1ce:	d13f      	bne.n	d250 <gatt_indicate+0x98>
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_INDICATE)) {
    d1d0:	2202      	movs	r2, #2
    d1d2:	6861      	ldr	r1, [r4, #4]
    d1d4:	4628      	mov	r0, r5
    d1d6:	f00c fc81 	bl	19adc <bt_gatt_is_subscribed>
    d1da:	2800      	cmp	r0, #0
    d1dc:	d05f      	beq.n	d29e <gatt_indicate+0xe6>
	len = sizeof(*ind) + params->len;
    d1de:	8aa6      	ldrh	r6, [r4, #20]
    d1e0:	3602      	adds	r6, #2
	req = gatt_req_alloc(gatt_indicate_rsp, params, NULL,
    d1e2:	9600      	str	r6, [sp, #0]
    d1e4:	231d      	movs	r3, #29
    d1e6:	2200      	movs	r2, #0
    d1e8:	4621      	mov	r1, r4
    d1ea:	4859      	ldr	r0, [pc, #356]	; (d350 <gatt_indicate+0x198>)
    d1ec:	f00c fa27 	bl	1963e <gatt_req_alloc>
	if (!req) {
    d1f0:	4681      	mov	r9, r0
    d1f2:	2800      	cmp	r0, #0
    d1f4:	f000 80a8 	beq.w	d348 <gatt_indicate+0x190>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE, len);
    d1f8:	4632      	mov	r2, r6
    d1fa:	211d      	movs	r1, #29
    d1fc:	4628      	mov	r0, r5
    d1fe:	f7fe fe33 	bl	be68 <bt_att_create_pdu>
	if (!buf) {
    d202:	4680      	mov	r8, r0
    d204:	2800      	cmp	r0, #0
    d206:	d071      	beq.n	d2ec <gatt_indicate+0x134>
	bt_att_set_tx_meta_data(buf, NULL, NULL, BT_ATT_CHAN_OPT(params));
    d208:	2301      	movs	r3, #1
    d20a:	2200      	movs	r2, #0
    d20c:	4611      	mov	r1, r2
    d20e:	f00c f81b 	bl	19248 <bt_att_set_tx_meta_data>
    d212:	f108 0a08 	add.w	sl, r8, #8
    d216:	2102      	movs	r1, #2
    d218:	4650      	mov	r0, sl
    d21a:	f00c fff0 	bl	1a1fe <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
    d21e:	4606      	mov	r6, r0
    d220:	f826 7b02 	strh.w	r7, [r6], #2
    d224:	8aa1      	ldrh	r1, [r4, #20]
    d226:	4650      	mov	r0, sl
    d228:	f00c ffe9 	bl	1a1fe <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
    d22c:	8aa2      	ldrh	r2, [r4, #20]
    d22e:	6921      	ldr	r1, [r4, #16]
    d230:	4630      	mov	r0, r6
    d232:	f00a fa7d 	bl	17730 <memcpy>
	req->buf = buf;
    d236:	f8c9 8008 	str.w	r8, [r9, #8]
	err = bt_att_req_send(conn, req);
    d23a:	4649      	mov	r1, r9
    d23c:	4628      	mov	r0, r5
    d23e:	f00b ff4a 	bl	190d6 <bt_att_req_send>
	if (err) {
    d242:	4604      	mov	r4, r0
    d244:	2800      	cmp	r0, #0
    d246:	d17b      	bne.n	d340 <gatt_indicate+0x188>
}
    d248:	4620      	mov	r0, r4
    d24a:	b016      	add	sp, #88	; 0x58
    d24c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		BT_WARN("Link is not encrypted");
    d250:	4b40      	ldr	r3, [pc, #256]	; (d354 <gatt_indicate+0x19c>)
    d252:	9315      	str	r3, [sp, #84]	; 0x54
    d254:	2202      	movs	r2, #2
    d256:	f88d 200c 	strb.w	r2, [sp, #12]
    d25a:	2300      	movs	r3, #0
    d25c:	f88d 300d 	strb.w	r3, [sp, #13]
    d260:	f88d 300e 	strb.w	r3, [sp, #14]
    d264:	f88d 300f 	strb.w	r3, [sp, #15]
    d268:	9903      	ldr	r1, [sp, #12]
    d26a:	9114      	str	r1, [sp, #80]	; 0x50
    d26c:	4619      	mov	r1, r3
    d26e:	f363 0100 	bfi	r1, r3, #0, #1
    d272:	f363 0141 	bfi	r1, r3, #1, #1
    d276:	f363 0182 	bfi	r1, r3, #2, #1
    d27a:	f363 01c5 	bfi	r1, r3, #3, #3
    d27e:	f362 1188 	bfi	r1, r2, #6, #3
    d282:	2208      	movs	r2, #8
    d284:	f362 2152 	bfi	r1, r2, #9, #10
    d288:	f363 41de 	bfi	r1, r3, #19, #12
    d28c:	f363 71df 	bfi	r1, r3, #31, #1
    d290:	aa14      	add	r2, sp, #80	; 0x50
    d292:	4831      	ldr	r0, [pc, #196]	; (d358 <gatt_indicate+0x1a0>)
    d294:	f7f4 ffd8 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EPERM;
    d298:	f04f 34ff 	mov.w	r4, #4294967295
    d29c:	e7d4      	b.n	d248 <gatt_indicate+0x90>
			BT_WARN("Device is not subscribed to characteristic");
    d29e:	4b2f      	ldr	r3, [pc, #188]	; (d35c <gatt_indicate+0x1a4>)
    d2a0:	930f      	str	r3, [sp, #60]	; 0x3c
    d2a2:	2202      	movs	r2, #2
    d2a4:	f88d 200c 	strb.w	r2, [sp, #12]
    d2a8:	2300      	movs	r3, #0
    d2aa:	f88d 300d 	strb.w	r3, [sp, #13]
    d2ae:	f88d 300e 	strb.w	r3, [sp, #14]
    d2b2:	f88d 300f 	strb.w	r3, [sp, #15]
    d2b6:	9903      	ldr	r1, [sp, #12]
    d2b8:	910e      	str	r1, [sp, #56]	; 0x38
    d2ba:	4619      	mov	r1, r3
    d2bc:	f363 0100 	bfi	r1, r3, #0, #1
    d2c0:	f363 0141 	bfi	r1, r3, #1, #1
    d2c4:	f363 0182 	bfi	r1, r3, #2, #1
    d2c8:	f363 01c5 	bfi	r1, r3, #3, #3
    d2cc:	f362 1188 	bfi	r1, r2, #6, #3
    d2d0:	2208      	movs	r2, #8
    d2d2:	f362 2152 	bfi	r1, r2, #9, #10
    d2d6:	f363 41de 	bfi	r1, r3, #19, #12
    d2da:	f363 71df 	bfi	r1, r3, #31, #1
    d2de:	aa0e      	add	r2, sp, #56	; 0x38
    d2e0:	481d      	ldr	r0, [pc, #116]	; (d358 <gatt_indicate+0x1a0>)
    d2e2:	f7f4 ffb1 	bl	2248 <z_impl_z_log_msg_static_create>
			return -EINVAL;
    d2e6:	f06f 0415 	mvn.w	r4, #21
    d2ea:	e7ad      	b.n	d248 <gatt_indicate+0x90>
		BT_WARN("No buffer available to send indication");
    d2ec:	4b1c      	ldr	r3, [pc, #112]	; (d360 <gatt_indicate+0x1a8>)
    d2ee:	9309      	str	r3, [sp, #36]	; 0x24
    d2f0:	2202      	movs	r2, #2
    d2f2:	f88d 200c 	strb.w	r2, [sp, #12]
    d2f6:	2300      	movs	r3, #0
    d2f8:	f88d 300d 	strb.w	r3, [sp, #13]
    d2fc:	f88d 300e 	strb.w	r3, [sp, #14]
    d300:	f88d 300f 	strb.w	r3, [sp, #15]
    d304:	9903      	ldr	r1, [sp, #12]
    d306:	9108      	str	r1, [sp, #32]
    d308:	4619      	mov	r1, r3
    d30a:	f363 0100 	bfi	r1, r3, #0, #1
    d30e:	f363 0141 	bfi	r1, r3, #1, #1
    d312:	f363 0182 	bfi	r1, r3, #2, #1
    d316:	f363 01c5 	bfi	r1, r3, #3, #3
    d31a:	f362 1188 	bfi	r1, r2, #6, #3
    d31e:	2208      	movs	r2, #8
    d320:	f362 2152 	bfi	r1, r2, #9, #10
    d324:	f363 41de 	bfi	r1, r3, #19, #12
    d328:	f363 71df 	bfi	r1, r3, #31, #1
    d32c:	aa08      	add	r2, sp, #32
    d32e:	480a      	ldr	r0, [pc, #40]	; (d358 <gatt_indicate+0x1a0>)
    d330:	f7f4 ff8a 	bl	2248 <z_impl_z_log_msg_static_create>
		bt_att_req_free(req);
    d334:	4648      	mov	r0, r9
    d336:	f7ff f8bb 	bl	c4b0 <bt_att_req_free>
		return -ENOMEM;
    d33a:	f06f 040b 	mvn.w	r4, #11
    d33e:	e783      	b.n	d248 <gatt_indicate+0x90>
		bt_att_req_free(req);
    d340:	4648      	mov	r0, r9
    d342:	f7ff f8b5 	bl	c4b0 <bt_att_req_free>
    d346:	e77f      	b.n	d248 <gatt_indicate+0x90>
		return -ENOMEM;
    d348:	f06f 040b 	mvn.w	r4, #11
    d34c:	e77c      	b.n	d248 <gatt_indicate+0x90>
    d34e:	bf00      	nop
    d350:	00019341 	.word	0x00019341
    d354:	0001f19c 	.word	0x0001f19c
    d358:	0001cff4 	.word	0x0001cff4
    d35c:	0001f1b4 	.word	0x0001f1b4
    d360:	0001f1e0 	.word	0x0001f1e0

0000d364 <bt_gatt_indicate>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    d364:	4b36      	ldr	r3, [pc, #216]	; (d440 <bt_gatt_indicate+0xdc>)
    d366:	e8d3 3faf 	lda	r3, [r3]
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
    d36a:	f013 0f04 	tst.w	r3, #4
    d36e:	d05e      	beq.n	d42e <bt_gatt_indicate+0xca>
{
    d370:	b530      	push	{r4, r5, lr}
    d372:	b08d      	sub	sp, #52	; 0x34
    d374:	4605      	mov	r5, r0
    d376:	460c      	mov	r4, r1
	if (conn && conn->state != BT_CONN_CONNECTED) {
    d378:	b110      	cbz	r0, d380 <bt_gatt_indicate+0x1c>
    d37a:	7a83      	ldrb	r3, [r0, #10]
    d37c:	2b07      	cmp	r3, #7
    d37e:	d159      	bne.n	d434 <bt_gatt_indicate+0xd0>
	data.attr = params->attr;
    d380:	6860      	ldr	r0, [r4, #4]
    d382:	9005      	str	r0, [sp, #20]
	data.handle = bt_gatt_attr_get_handle(data.attr);
    d384:	f7ff fd9c 	bl	cec0 <bt_gatt_attr_get_handle>
    d388:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (params->uuid) {
    d38c:	6821      	ldr	r1, [r4, #0]
    d38e:	b341      	cbz	r1, d3e2 <bt_gatt_indicate+0x7e>
		if (!gatt_find_by_uuid(&data, params->uuid)) {
    d390:	a805      	add	r0, sp, #20
    d392:	f7ff fee1 	bl	d158 <gatt_find_by_uuid>
    d396:	2800      	cmp	r0, #0
    d398:	d04f      	beq.n	d43a <bt_gatt_indicate+0xd6>
		params->attr = data.attr;
    d39a:	9b05      	ldr	r3, [sp, #20]
    d39c:	6063      	str	r3, [r4, #4]
	if (!bt_uuid_cmp(data.attr->uuid, BT_UUID_GATT_CHRC)) {
    d39e:	9b05      	ldr	r3, [sp, #20]
    d3a0:	6818      	ldr	r0, [r3, #0]
    d3a2:	2300      	movs	r3, #0
    d3a4:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    d3a8:	f642 0303 	movw	r3, #10243	; 0x2803
    d3ac:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
    d3b0:	a90b      	add	r1, sp, #44	; 0x2c
    d3b2:	f00a fa25 	bl	17800 <bt_uuid_cmp>
    d3b6:	b948      	cbnz	r0, d3cc <bt_gatt_indicate+0x68>
		struct bt_gatt_chrc *chrc = data.attr->user_data;
    d3b8:	9805      	ldr	r0, [sp, #20]
    d3ba:	68c3      	ldr	r3, [r0, #12]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
    d3bc:	799b      	ldrb	r3, [r3, #6]
    d3be:	f013 0f20 	tst.w	r3, #32
    d3c2:	d013      	beq.n	d3ec <bt_gatt_indicate+0x88>
		data.handle = bt_gatt_attr_value_handle(data.attr);
    d3c4:	f00c fb04 	bl	199d0 <bt_gatt_attr_value_handle>
    d3c8:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (conn) {
    d3cc:	b18d      	cbz	r5, d3f2 <bt_gatt_indicate+0x8e>
		params->_ref = 1;
    d3ce:	2301      	movs	r3, #1
    d3d0:	75a3      	strb	r3, [r4, #22]
		return gatt_indicate(conn, data.handle, params);
    d3d2:	4622      	mov	r2, r4
    d3d4:	f8bd 1018 	ldrh.w	r1, [sp, #24]
    d3d8:	4628      	mov	r0, r5
    d3da:	f7ff feed 	bl	d1b8 <gatt_indicate>
}
    d3de:	b00d      	add	sp, #52	; 0x34
    d3e0:	bd30      	pop	{r4, r5, pc}
		if (!data.handle) {
    d3e2:	2800      	cmp	r0, #0
    d3e4:	d1db      	bne.n	d39e <bt_gatt_indicate+0x3a>
			return -ENOENT;
    d3e6:	f06f 0001 	mvn.w	r0, #1
    d3ea:	e7f8      	b.n	d3de <bt_gatt_indicate+0x7a>
			return -EINVAL;
    d3ec:	f06f 0015 	mvn.w	r0, #21
    d3f0:	e7f5      	b.n	d3de <bt_gatt_indicate+0x7a>
	data.err = -ENOTCONN;
    d3f2:	f06f 037f 	mvn.w	r3, #127	; 0x7f
    d3f6:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
    d3f8:	2302      	movs	r3, #2
    d3fa:	f8ad 3020 	strh.w	r3, [sp, #32]
	data.ind_params = params;
    d3fe:	9409      	str	r4, [sp, #36]	; 0x24
	params->_ref = 0;
    d400:	2300      	movs	r3, #0
    d402:	75a3      	strb	r3, [r4, #22]
	bt_gatt_foreach_attr_type(data.handle, 0xffff, BT_UUID_GATT_CCC, NULL,
    d404:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    d408:	f642 1202 	movw	r2, #10498	; 0x2902
    d40c:	f8ad 202a 	strh.w	r2, [sp, #42]	; 0x2a
    d410:	aa05      	add	r2, sp, #20
    d412:	9202      	str	r2, [sp, #8]
    d414:	4a0b      	ldr	r2, [pc, #44]	; (d444 <bt_gatt_indicate+0xe0>)
    d416:	9201      	str	r2, [sp, #4]
    d418:	2201      	movs	r2, #1
    d41a:	9200      	str	r2, [sp, #0]
    d41c:	aa0a      	add	r2, sp, #40	; 0x28
    d41e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    d422:	f8bd 0018 	ldrh.w	r0, [sp, #24]
    d426:	f7ff fd7d 	bl	cf24 <bt_gatt_foreach_attr_type>
	return data.err;
    d42a:	9807      	ldr	r0, [sp, #28]
    d42c:	e7d7      	b.n	d3de <bt_gatt_indicate+0x7a>
		return -EAGAIN;
    d42e:	f06f 000a 	mvn.w	r0, #10
}
    d432:	4770      	bx	lr
		return -ENOTCONN;
    d434:	f06f 007f 	mvn.w	r0, #127	; 0x7f
    d438:	e7d1      	b.n	d3de <bt_gatt_indicate+0x7a>
			return -ENOENT;
    d43a:	f06f 0001 	mvn.w	r0, #1
    d43e:	e7ce      	b.n	d3de <bt_gatt_indicate+0x7a>
    d440:	200000cc 	.word	0x200000cc
    d444:	0000d7e5 	.word	0x0000d7e5

0000d448 <sc_process>:
{
    d448:	b510      	push	{r4, lr}
    d44a:	b082      	sub	sp, #8
    d44c:	4603      	mov	r3, r0
	sc_range[0] = sys_cpu_to_le16(sc->start);
    d44e:	f830 2c08 	ldrh.w	r2, [r0, #-8]
    d452:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(sc->end);
    d456:	f830 2c06 	ldrh.w	r2, [r0, #-6]
    d45a:	f8ad 2006 	strh.w	r2, [sp, #6]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
    d45e:	f1a0 0120 	sub.w	r1, r0, #32
    d462:	f100 0430 	add.w	r4, r0, #48	; 0x30
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    d466:	e8d4 2fef 	ldaex	r2, [r4]
    d46a:	f022 0201 	bic.w	r2, r2, #1
    d46e:	e8c4 2fe0 	stlex	r0, r2, [r4]
    d472:	2800      	cmp	r0, #0
    d474:	d1f7      	bne.n	d466 <sc_process+0x1e>
	sc->start = 0U;
    d476:	2000      	movs	r0, #0
    d478:	f823 0c08 	strh.w	r0, [r3, #-8]
	sc->end = 0U;
    d47c:	f823 0c06 	strh.w	r0, [r3, #-6]
	sc->params.attr = &_1_gatt_svc.attrs[2];
    d480:	4a0c      	ldr	r2, [pc, #48]	; (d4b4 <sc_process+0x6c>)
    d482:	f843 2c1c 	str.w	r2, [r3, #-28]
	sc->params.func = sc_indicate_rsp;
    d486:	4a0c      	ldr	r2, [pc, #48]	; (d4b8 <sc_process+0x70>)
    d488:	f843 2c18 	str.w	r2, [r3, #-24]
	sc->params.data = &sc_range[0];
    d48c:	aa01      	add	r2, sp, #4
    d48e:	f843 2c10 	str.w	r2, [r3, #-16]
	sc->params.len = sizeof(sc_range);
    d492:	2204      	movs	r2, #4
    d494:	f823 2c0c 	strh.w	r2, [r3, #-12]
	if (bt_gatt_indicate(NULL, &sc->params)) {
    d498:	f7ff ff64 	bl	d364 <bt_gatt_indicate>
    d49c:	b108      	cbz	r0, d4a2 <sc_process+0x5a>
}
    d49e:	b002      	add	sp, #8
    d4a0:	bd10      	pop	{r4, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    d4a2:	e8d4 3fef 	ldaex	r3, [r4]
    d4a6:	f043 0302 	orr.w	r3, r3, #2
    d4aa:	e8c4 3fe2 	stlex	r2, r3, [r4]
    d4ae:	2a00      	cmp	r2, #0
    d4b0:	d0f5      	beq.n	d49e <sc_process+0x56>
    d4b2:	e7f6      	b.n	d4a2 <sc_process+0x5a>
    d4b4:	0001f2bc 	.word	0x0001f2bc
    d4b8:	0000cc31 	.word	0x0000cc31

0000d4bc <sc_restore>:
{
    d4bc:	b510      	push	{r4, lr}
    d4be:	b088      	sub	sp, #32
    d4c0:	4604      	mov	r4, r0
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
    d4c2:	f100 0188 	add.w	r1, r0, #136	; 0x88
    d4c6:	7a00      	ldrb	r0, [r0, #8]
    d4c8:	f7ff f9c2 	bl	c850 <find_sc_cfg>
	if (!cfg) {
    d4cc:	b1f0      	cbz	r0, d50c <sc_restore+0x50>
    d4ce:	4603      	mov	r3, r0
	if (!(cfg->data.start || cfg->data.end)) {
    d4d0:	8902      	ldrh	r2, [r0, #8]
    d4d2:	b90a      	cbnz	r2, d4d8 <sc_restore+0x1c>
    d4d4:	8941      	ldrh	r1, [r0, #10]
    d4d6:	b1c9      	cbz	r1, d50c <sc_restore+0x50>
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
    d4d8:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
    d4dc:	895b      	ldrh	r3, [r3, #10]
    d4de:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
    d4e2:	4620      	mov	r0, r4
    d4e4:	f7fc fefa 	bl	a2dc <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
    d4e8:	491c      	ldr	r1, [pc, #112]	; (d55c <sc_restore+0xa0>)
    d4ea:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    d4ee:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    d4f2:	4a1b      	ldr	r2, [pc, #108]	; (d560 <sc_restore+0xa4>)
    d4f4:	605a      	str	r2, [r3, #4]
	sc_restore_params[index].func = sc_restore_rsp;
    d4f6:	4a1b      	ldr	r2, [pc, #108]	; (d564 <sc_restore+0xa8>)
    d4f8:	609a      	str	r2, [r3, #8]
	sc_restore_params[index].data = &sc_range[0];
    d4fa:	aa01      	add	r2, sp, #4
    d4fc:	611a      	str	r2, [r3, #16]
	sc_restore_params[index].len = sizeof(sc_range);
    d4fe:	2204      	movs	r2, #4
    d500:	829a      	strh	r2, [r3, #20]
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
    d502:	4619      	mov	r1, r3
    d504:	4620      	mov	r0, r4
    d506:	f7ff ff2d 	bl	d364 <bt_gatt_indicate>
    d50a:	b908      	cbnz	r0, d510 <sc_restore+0x54>
}
    d50c:	b008      	add	sp, #32
    d50e:	bd10      	pop	{r4, pc}
		BT_ERR("SC restore indication failed");
    d510:	4b15      	ldr	r3, [pc, #84]	; (d568 <sc_restore+0xac>)
    d512:	9307      	str	r3, [sp, #28]
    d514:	2302      	movs	r3, #2
    d516:	f88d 3000 	strb.w	r3, [sp]
    d51a:	2300      	movs	r3, #0
    d51c:	f88d 3001 	strb.w	r3, [sp, #1]
    d520:	f88d 3002 	strb.w	r3, [sp, #2]
    d524:	f88d 3003 	strb.w	r3, [sp, #3]
    d528:	9a00      	ldr	r2, [sp, #0]
    d52a:	9206      	str	r2, [sp, #24]
    d52c:	4619      	mov	r1, r3
    d52e:	f363 0100 	bfi	r1, r3, #0, #1
    d532:	f363 0141 	bfi	r1, r3, #1, #1
    d536:	f363 0182 	bfi	r1, r3, #2, #1
    d53a:	f363 01c5 	bfi	r1, r3, #3, #3
    d53e:	2201      	movs	r2, #1
    d540:	f362 1188 	bfi	r1, r2, #6, #3
    d544:	2208      	movs	r2, #8
    d546:	f362 2152 	bfi	r1, r2, #9, #10
    d54a:	f363 41de 	bfi	r1, r3, #19, #12
    d54e:	f363 71df 	bfi	r1, r3, #31, #1
    d552:	aa06      	add	r2, sp, #24
    d554:	4805      	ldr	r0, [pc, #20]	; (d56c <sc_restore+0xb0>)
    d556:	f7f4 fe77 	bl	2248 <z_impl_z_log_msg_static_create>
    d55a:	e7d7      	b.n	d50c <sc_restore+0x50>
    d55c:	20002404 	.word	0x20002404
    d560:	0001f2bc 	.word	0x0001f2bc
    d564:	0001959d 	.word	0x0001959d
    d568:	0001f208 	.word	0x0001f208
    d56c:	0001cff4 	.word	0x0001cff4

0000d570 <update_ccc>:
{
    d570:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d574:	b082      	sub	sp, #8
    d576:	af00      	add	r7, sp, #0
	struct bt_conn *conn = data->conn;
    d578:	f8d2 8000 	ldr.w	r8, [r2]
	if (attr->write != bt_gatt_attr_write_ccc) {
    d57c:	6882      	ldr	r2, [r0, #8]
    d57e:	4b39      	ldr	r3, [pc, #228]	; (d664 <update_ccc+0xf4>)
    d580:	429a      	cmp	r2, r3
    d582:	d004      	beq.n	d58e <update_ccc+0x1e>
}
    d584:	2001      	movs	r0, #1
    d586:	3708      	adds	r7, #8
    d588:	46bd      	mov	sp, r7
    d58a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d58e:	4604      	mov	r4, r0
	ccc = attr->user_data;
    d590:	f8d0 900c 	ldr.w	r9, [r0, #12]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
    d594:	2500      	movs	r5, #0
    d596:	2d00      	cmp	r5, #0
    d598:	d1f4      	bne.n	d584 <update_ccc+0x14>
		if (!cfg->value ||
    d59a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    d59e:	eb09 0343 	add.w	r3, r9, r3, lsl #1
    d5a2:	891b      	ldrh	r3, [r3, #8]
    d5a4:	2b00      	cmp	r3, #0
    d5a6:	d054      	beq.n	d652 <update_ccc+0xe2>
		    !bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer)) {
    d5a8:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    d5ac:	eb09 0243 	add.w	r2, r9, r3, lsl #1
    d5b0:	3201      	adds	r2, #1
    d5b2:	f819 1013 	ldrb.w	r1, [r9, r3, lsl #1]
    d5b6:	4640      	mov	r0, r8
    d5b8:	f00a fdf2 	bl	181a0 <bt_conn_is_peer_addr_le>
		if (!cfg->value ||
    d5bc:	2800      	cmp	r0, #0
    d5be:	d048      	beq.n	d652 <update_ccc+0xe2>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
    d5c0:	f44f 7295 	mov.w	r2, #298	; 0x12a
    d5c4:	4621      	mov	r1, r4
    d5c6:	4640      	mov	r0, r8
    d5c8:	f00c fa56 	bl	19a78 <bt_gatt_check_perm>
		if (err) {
    d5cc:	b108      	cbz	r0, d5d2 <update_ccc+0x62>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
    d5ce:	2803      	cmp	r0, #3
    d5d0:	d00a      	beq.n	d5e8 <update_ccc+0x78>
		gatt_ccc_changed(attr, ccc);
    d5d2:	4649      	mov	r1, r9
    d5d4:	4620      	mov	r0, r4
    d5d6:	f00b fe9b 	bl	19310 <gatt_ccc_changed>
		if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
    d5da:	4b23      	ldr	r3, [pc, #140]	; (d668 <update_ccc+0xf8>)
    d5dc:	4599      	cmp	r9, r3
    d5de:	d1d1      	bne.n	d584 <update_ccc+0x14>
			sc_restore(conn);
    d5e0:	4640      	mov	r0, r8
    d5e2:	f7ff ff6b 	bl	d4bc <sc_restore>
    d5e6:	e7cd      	b.n	d584 <update_ccc+0x14>
				BT_WARN("CCC %p not writable", attr);
    d5e8:	46ea      	mov	sl, sp
    d5ea:	b088      	sub	sp, #32
    d5ec:	466b      	mov	r3, sp
    d5ee:	f113 0210 	adds.w	r2, r3, #16
    d5f2:	d030      	beq.n	d656 <update_ccc+0xe6>
    d5f4:	210c      	movs	r1, #12
    d5f6:	b11a      	cbz	r2, d600 <update_ccc+0x90>
    d5f8:	2904      	cmp	r1, #4
    d5fa:	dd01      	ble.n	d600 <update_ccc+0x90>
    d5fc:	481b      	ldr	r0, [pc, #108]	; (d66c <update_ccc+0xfc>)
    d5fe:	6158      	str	r0, [r3, #20]
    d600:	b112      	cbz	r2, d608 <update_ccc+0x98>
    d602:	2908      	cmp	r1, #8
    d604:	dd00      	ble.n	d608 <update_ccc+0x98>
    d606:	619c      	str	r4, [r3, #24]
    d608:	290b      	cmp	r1, #11
    d60a:	dd27      	ble.n	d65c <update_ccc+0xec>
    d60c:	210c      	movs	r1, #12
    d60e:	b13a      	cbz	r2, d620 <update_ccc+0xb0>
    d610:	2003      	movs	r0, #3
    d612:	7138      	strb	r0, [r7, #4]
    d614:	2000      	movs	r0, #0
    d616:	7178      	strb	r0, [r7, #5]
    d618:	71b8      	strb	r0, [r7, #6]
    d61a:	71f8      	strb	r0, [r7, #7]
    d61c:	6878      	ldr	r0, [r7, #4]
    d61e:	6118      	str	r0, [r3, #16]
    d620:	f36f 0600 	bfc	r6, #0, #1
    d624:	f36f 0641 	bfc	r6, #1, #1
    d628:	f36f 0682 	bfc	r6, #2, #1
    d62c:	f36f 06c5 	bfc	r6, #3, #3
    d630:	2302      	movs	r3, #2
    d632:	f363 1688 	bfi	r6, r3, #6, #3
    d636:	f401 717b 	and.w	r1, r1, #1004	; 0x3ec
    d63a:	f361 2652 	bfi	r6, r1, #9, #10
    d63e:	f36f 46de 	bfc	r6, #19, #12
    d642:	f36f 76df 	bfc	r6, #31, #1
    d646:	2300      	movs	r3, #0
    d648:	4631      	mov	r1, r6
    d64a:	4809      	ldr	r0, [pc, #36]	; (d670 <update_ccc+0x100>)
    d64c:	f7f4 fdfc 	bl	2248 <z_impl_z_log_msg_static_create>
    d650:	46d5      	mov	sp, sl
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
    d652:	3501      	adds	r5, #1
    d654:	e79f      	b.n	d596 <update_ccc+0x26>
				BT_WARN("CCC %p not writable", attr);
    d656:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    d65a:	e7cc      	b.n	d5f6 <update_ccc+0x86>
    d65c:	f06f 011b 	mvn.w	r1, #27
    d660:	e7d5      	b.n	d60e <update_ccc+0x9e>
    d662:	bf00      	nop
    d664:	0000ca6d 	.word	0x0000ca6d
    d668:	20000324 	.word	0x20000324
    d66c:	0001f228 	.word	0x0001f228
    d670:	0001cff4 	.word	0x0001cff4

0000d674 <gatt_notify>:
{
    d674:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    d678:	b095      	sub	sp, #84	; 0x54
    d67a:	4605      	mov	r5, r0
    d67c:	460f      	mov	r7, r1
    d67e:	4614      	mov	r4, r2
	if (bt_gatt_check_perm(conn, params->attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
    d680:	2294      	movs	r2, #148	; 0x94
    d682:	6861      	ldr	r1, [r4, #4]
    d684:	f00c f9f8 	bl	19a78 <bt_gatt_check_perm>
    d688:	bb70      	cbnz	r0, d6e8 <gatt_notify+0x74>
		if (!bt_gatt_is_subscribed(conn, params->attr, BT_GATT_CCC_NOTIFY)) {
    d68a:	2201      	movs	r2, #1
    d68c:	6861      	ldr	r1, [r4, #4]
    d68e:	4628      	mov	r0, r5
    d690:	f00c fa24 	bl	19adc <bt_gatt_is_subscribed>
    d694:	2800      	cmp	r0, #0
    d696:	d04e      	beq.n	d736 <gatt_notify+0xc2>
				sizeof(*nfy) + params->len);
    d698:	89a2      	ldrh	r2, [r4, #12]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
    d69a:	3202      	adds	r2, #2
    d69c:	211b      	movs	r1, #27
    d69e:	4628      	mov	r0, r5
    d6a0:	f7fe fbe2 	bl	be68 <bt_att_create_pdu>
	if (!buf) {
    d6a4:	4680      	mov	r8, r0
    d6a6:	2800      	cmp	r0, #0
    d6a8:	d06c      	beq.n	d784 <gatt_notify+0x110>
    d6aa:	f100 0908 	add.w	r9, r0, #8
    d6ae:	2102      	movs	r1, #2
    d6b0:	4648      	mov	r0, r9
    d6b2:	f00c fda4 	bl	1a1fe <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
    d6b6:	4606      	mov	r6, r0
    d6b8:	f826 7b02 	strh.w	r7, [r6], #2
    d6bc:	89a1      	ldrh	r1, [r4, #12]
    d6be:	4648      	mov	r0, r9
    d6c0:	f00c fd9d 	bl	1a1fe <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
    d6c4:	89a2      	ldrh	r2, [r4, #12]
    d6c6:	68a1      	ldr	r1, [r4, #8]
    d6c8:	4630      	mov	r0, r6
    d6ca:	f00a f831 	bl	17730 <memcpy>
	bt_att_set_tx_meta_data(buf, params->func, params->user_data, BT_ATT_CHAN_OPT(params));
    d6ce:	2301      	movs	r3, #1
    d6d0:	6962      	ldr	r2, [r4, #20]
    d6d2:	6921      	ldr	r1, [r4, #16]
    d6d4:	4640      	mov	r0, r8
    d6d6:	f00b fdb7 	bl	19248 <bt_att_set_tx_meta_data>
	return bt_att_send(conn, buf);
    d6da:	4641      	mov	r1, r8
    d6dc:	4628      	mov	r0, r5
    d6de:	f7ff f84b 	bl	c778 <bt_att_send>
}
    d6e2:	b015      	add	sp, #84	; 0x54
    d6e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_WARN("Link is not encrypted");
    d6e8:	4b3a      	ldr	r3, [pc, #232]	; (d7d4 <gatt_notify+0x160>)
    d6ea:	9313      	str	r3, [sp, #76]	; 0x4c
    d6ec:	2202      	movs	r2, #2
    d6ee:	f88d 2004 	strb.w	r2, [sp, #4]
    d6f2:	2300      	movs	r3, #0
    d6f4:	f88d 3005 	strb.w	r3, [sp, #5]
    d6f8:	f88d 3006 	strb.w	r3, [sp, #6]
    d6fc:	f88d 3007 	strb.w	r3, [sp, #7]
    d700:	9901      	ldr	r1, [sp, #4]
    d702:	9112      	str	r1, [sp, #72]	; 0x48
    d704:	4619      	mov	r1, r3
    d706:	f363 0100 	bfi	r1, r3, #0, #1
    d70a:	f363 0141 	bfi	r1, r3, #1, #1
    d70e:	f363 0182 	bfi	r1, r3, #2, #1
    d712:	f363 01c5 	bfi	r1, r3, #3, #3
    d716:	f362 1188 	bfi	r1, r2, #6, #3
    d71a:	2208      	movs	r2, #8
    d71c:	f362 2152 	bfi	r1, r2, #9, #10
    d720:	f363 41de 	bfi	r1, r3, #19, #12
    d724:	f363 71df 	bfi	r1, r3, #31, #1
    d728:	aa12      	add	r2, sp, #72	; 0x48
    d72a:	482b      	ldr	r0, [pc, #172]	; (d7d8 <gatt_notify+0x164>)
    d72c:	f7f4 fd8c 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EPERM;
    d730:	f04f 30ff 	mov.w	r0, #4294967295
    d734:	e7d5      	b.n	d6e2 <gatt_notify+0x6e>
			BT_WARN("Device is not subscribed to characteristic");
    d736:	4b29      	ldr	r3, [pc, #164]	; (d7dc <gatt_notify+0x168>)
    d738:	930d      	str	r3, [sp, #52]	; 0x34
    d73a:	2202      	movs	r2, #2
    d73c:	f88d 2004 	strb.w	r2, [sp, #4]
    d740:	2300      	movs	r3, #0
    d742:	f88d 3005 	strb.w	r3, [sp, #5]
    d746:	f88d 3006 	strb.w	r3, [sp, #6]
    d74a:	f88d 3007 	strb.w	r3, [sp, #7]
    d74e:	9901      	ldr	r1, [sp, #4]
    d750:	910c      	str	r1, [sp, #48]	; 0x30
    d752:	4619      	mov	r1, r3
    d754:	f363 0100 	bfi	r1, r3, #0, #1
    d758:	f363 0141 	bfi	r1, r3, #1, #1
    d75c:	f363 0182 	bfi	r1, r3, #2, #1
    d760:	f363 01c5 	bfi	r1, r3, #3, #3
    d764:	f362 1188 	bfi	r1, r2, #6, #3
    d768:	2208      	movs	r2, #8
    d76a:	f362 2152 	bfi	r1, r2, #9, #10
    d76e:	f363 41de 	bfi	r1, r3, #19, #12
    d772:	f363 71df 	bfi	r1, r3, #31, #1
    d776:	aa0c      	add	r2, sp, #48	; 0x30
    d778:	4817      	ldr	r0, [pc, #92]	; (d7d8 <gatt_notify+0x164>)
    d77a:	f7f4 fd65 	bl	2248 <z_impl_z_log_msg_static_create>
			return -EINVAL;
    d77e:	f06f 0015 	mvn.w	r0, #21
    d782:	e7ae      	b.n	d6e2 <gatt_notify+0x6e>
		BT_WARN("No buffer available to send notification");
    d784:	4b16      	ldr	r3, [pc, #88]	; (d7e0 <gatt_notify+0x16c>)
    d786:	9307      	str	r3, [sp, #28]
    d788:	2202      	movs	r2, #2
    d78a:	f88d 2004 	strb.w	r2, [sp, #4]
    d78e:	2300      	movs	r3, #0
    d790:	f88d 3005 	strb.w	r3, [sp, #5]
    d794:	f88d 3006 	strb.w	r3, [sp, #6]
    d798:	f88d 3007 	strb.w	r3, [sp, #7]
    d79c:	9901      	ldr	r1, [sp, #4]
    d79e:	9106      	str	r1, [sp, #24]
    d7a0:	4619      	mov	r1, r3
    d7a2:	f363 0100 	bfi	r1, r3, #0, #1
    d7a6:	f363 0141 	bfi	r1, r3, #1, #1
    d7aa:	f363 0182 	bfi	r1, r3, #2, #1
    d7ae:	f363 01c5 	bfi	r1, r3, #3, #3
    d7b2:	f362 1188 	bfi	r1, r2, #6, #3
    d7b6:	2208      	movs	r2, #8
    d7b8:	f362 2152 	bfi	r1, r2, #9, #10
    d7bc:	f363 41de 	bfi	r1, r3, #19, #12
    d7c0:	f363 71df 	bfi	r1, r3, #31, #1
    d7c4:	aa06      	add	r2, sp, #24
    d7c6:	4804      	ldr	r0, [pc, #16]	; (d7d8 <gatt_notify+0x164>)
    d7c8:	f7f4 fd3e 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ENOMEM;
    d7cc:	f06f 000b 	mvn.w	r0, #11
    d7d0:	e787      	b.n	d6e2 <gatt_notify+0x6e>
    d7d2:	bf00      	nop
    d7d4:	0001f19c 	.word	0x0001f19c
    d7d8:	0001cff4 	.word	0x0001cff4
    d7dc:	0001f1b4 	.word	0x0001f1b4
    d7e0:	0001f23c 	.word	0x0001f23c

0000d7e4 <notify_cb>:
{
    d7e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d7e8:	b08b      	sub	sp, #44	; 0x2c
    d7ea:	4616      	mov	r6, r2
	if (attr->write != bt_gatt_attr_write_ccc) {
    d7ec:	6882      	ldr	r2, [r0, #8]
    d7ee:	4b69      	ldr	r3, [pc, #420]	; (d994 <notify_cb+0x1b0>)
    d7f0:	429a      	cmp	r2, r3
    d7f2:	d005      	beq.n	d800 <notify_cb+0x1c>
		return BT_GATT_ITER_CONTINUE;
    d7f4:	f04f 0a01 	mov.w	sl, #1
}
    d7f8:	4650      	mov	r0, sl
    d7fa:	b00b      	add	sp, #44	; 0x2c
    d7fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d800:	4607      	mov	r7, r0
	ccc = attr->user_data;
    d802:	68c5      	ldr	r5, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
    d804:	4b64      	ldr	r3, [pc, #400]	; (d998 <notify_cb+0x1b4>)
    d806:	429d      	cmp	r5, r3
    d808:	d031      	beq.n	d86e <notify_cb+0x8a>
			err = 0;
    d80a:	2400      	movs	r4, #0
    d80c:	e088      	b.n	d920 <notify_cb+0x13c>
				sc = (struct sc_data *)data->ind_params->data;
    d80e:	6933      	ldr	r3, [r6, #16]
    d810:	691a      	ldr	r2, [r3, #16]
				sc_save(cfg->id, &cfg->peer,
    d812:	eb04 0044 	add.w	r0, r4, r4, lsl #1
    d816:	8853      	ldrh	r3, [r2, #2]
    d818:	8812      	ldrh	r2, [r2, #0]
    d81a:	4649      	mov	r1, r9
    d81c:	f8df c17c 	ldr.w	ip, [pc, #380]	; d99c <notify_cb+0x1b8>
    d820:	f81c 0020 	ldrb.w	r0, [ip, r0, lsl #2]
    d824:	f7ff f8ca 	bl	c9bc <sc_save>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    d828:	3401      	adds	r4, #1
    d82a:	2c00      	cmp	r4, #0
    d82c:	d1ed      	bne.n	d80a <notify_cb+0x26>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
    d82e:	eb04 0944 	add.w	r9, r4, r4, lsl #1
    d832:	4b5a      	ldr	r3, [pc, #360]	; (d99c <notify_cb+0x1b8>)
    d834:	eb03 0989 	add.w	r9, r3, r9, lsl #2
    d838:	f109 0901 	add.w	r9, r9, #1
    d83c:	2300      	movs	r3, #0
    d83e:	9302      	str	r3, [sp, #8]
    d840:	f8cd 300b 	str.w	r3, [sp, #11]
	return memcmp(a, b, sizeof(*a));
    d844:	2207      	movs	r2, #7
    d846:	a902      	add	r1, sp, #8
    d848:	4648      	mov	r0, r9
    d84a:	f009 ff5f 	bl	1770c <memcmp>
    d84e:	2800      	cmp	r0, #0
    d850:	d0ea      	beq.n	d828 <notify_cb+0x44>
			conn = bt_conn_lookup_state_le(cfg->id, &cfg->peer,
    d852:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    d856:	2207      	movs	r2, #7
    d858:	4649      	mov	r1, r9
    d85a:	4850      	ldr	r0, [pc, #320]	; (d99c <notify_cb+0x1b8>)
    d85c:	f810 0023 	ldrb.w	r0, [r0, r3, lsl #2]
    d860:	f7fc feca 	bl	a5f8 <bt_conn_lookup_state_le>
			if (!conn) {
    d864:	2800      	cmp	r0, #0
    d866:	d0d2      	beq.n	d80e <notify_cb+0x2a>
			bt_conn_unref(conn);
    d868:	f00a fc38 	bl	180dc <bt_conn_unref>
    d86c:	e7dc      	b.n	d828 <notify_cb+0x44>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
    d86e:	2400      	movs	r4, #0
    d870:	e7db      	b.n	d82a <notify_cb+0x46>
			bt_conn_unref(conn);
    d872:	f00a fc33 	bl	180dc <bt_conn_unref>
			continue;
    d876:	e052      	b.n	d91e <notify_cb+0x13a>
			bt_conn_unref(conn);
    d878:	4648      	mov	r0, r9
    d87a:	f00a fc2f 	bl	180dc <bt_conn_unref>
			continue;
    d87e:	e04e      	b.n	d91e <notify_cb+0x13a>
			BT_WARN("Link is not encrypted");
    d880:	4b47      	ldr	r3, [pc, #284]	; (d9a0 <notify_cb+0x1bc>)
    d882:	9309      	str	r3, [sp, #36]	; 0x24
    d884:	2202      	movs	r2, #2
    d886:	f88d 2004 	strb.w	r2, [sp, #4]
    d88a:	2300      	movs	r3, #0
    d88c:	f88d 3005 	strb.w	r3, [sp, #5]
    d890:	f88d 3006 	strb.w	r3, [sp, #6]
    d894:	f88d 3007 	strb.w	r3, [sp, #7]
    d898:	9901      	ldr	r1, [sp, #4]
    d89a:	9108      	str	r1, [sp, #32]
    d89c:	f363 0800 	bfi	r8, r3, #0, #1
    d8a0:	f363 0841 	bfi	r8, r3, #1, #1
    d8a4:	f363 0882 	bfi	r8, r3, #2, #1
    d8a8:	f363 08c5 	bfi	r8, r3, #3, #3
    d8ac:	f362 1888 	bfi	r8, r2, #6, #3
    d8b0:	2208      	movs	r2, #8
    d8b2:	f362 2852 	bfi	r8, r2, #9, #10
    d8b6:	f363 48de 	bfi	r8, r3, #19, #12
    d8ba:	f363 78df 	bfi	r8, r3, #31, #1
    d8be:	aa08      	add	r2, sp, #32
    d8c0:	4641      	mov	r1, r8
    d8c2:	4838      	ldr	r0, [pc, #224]	; (d9a4 <notify_cb+0x1c0>)
    d8c4:	f7f4 fcc0 	bl	2248 <z_impl_z_log_msg_static_create>
			bt_conn_unref(conn);
    d8c8:	4648      	mov	r0, r9
    d8ca:	f00a fc07 	bl	180dc <bt_conn_unref>
			continue;
    d8ce:	e026      	b.n	d91e <notify_cb+0x13a>
		    (cfg->value & BT_GATT_CCC_INDICATE)) {
    d8d0:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    d8d4:	eb05 0242 	add.w	r2, r5, r2, lsl #1
    d8d8:	8912      	ldrh	r2, [r2, #8]
		if ((data->type == BT_GATT_CCC_INDICATE) &&
    d8da:	f012 0f02 	tst.w	r2, #2
    d8de:	d049      	beq.n	d974 <notify_cb+0x190>
			err = gatt_indicate(conn, data->handle, data->ind_params);
    d8e0:	6932      	ldr	r2, [r6, #16]
    d8e2:	88b1      	ldrh	r1, [r6, #4]
    d8e4:	4648      	mov	r0, r9
    d8e6:	f7ff fc67 	bl	d1b8 <gatt_indicate>
			if (err == 0) {
    d8ea:	4683      	mov	fp, r0
    d8ec:	b970      	cbnz	r0, d90c <notify_cb+0x128>
				data->ind_params->_ref++;
    d8ee:	6932      	ldr	r2, [r6, #16]
    d8f0:	7d93      	ldrb	r3, [r2, #22]
    d8f2:	3301      	adds	r3, #1
    d8f4:	7593      	strb	r3, [r2, #22]
    d8f6:	e009      	b.n	d90c <notify_cb+0x128>
			   (cfg->value & BT_GATT_CCC_NOTIFY)) {
    d8f8:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    d8fc:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    d900:	891b      	ldrh	r3, [r3, #8]
		} else if ((data->type == BT_GATT_CCC_NOTIFY) &&
    d902:	f013 0f01 	tst.w	r3, #1
    d906:	d13a      	bne.n	d97e <notify_cb+0x19a>
			err = 0;
    d908:	f04f 0b00 	mov.w	fp, #0
		bt_conn_unref(conn);
    d90c:	4648      	mov	r0, r9
    d90e:	f00a fbe5 	bl	180dc <bt_conn_unref>
		if (err < 0) {
    d912:	f1bb 0f00 	cmp.w	fp, #0
    d916:	f6ff af6f 	blt.w	d7f8 <notify_cb+0x14>
		data->err = 0;
    d91a:	2300      	movs	r3, #0
    d91c:	60b3      	str	r3, [r6, #8]
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
    d91e:	3401      	adds	r4, #1
    d920:	2c00      	cmp	r4, #0
    d922:	d133      	bne.n	d98c <notify_cb+0x1a8>
		if (cfg->value != data->type) {
    d924:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    d928:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    d92c:	891a      	ldrh	r2, [r3, #8]
    d92e:	89b3      	ldrh	r3, [r6, #12]
    d930:	429a      	cmp	r2, r3
    d932:	d1f4      	bne.n	d91e <notify_cb+0x13a>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
    d934:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    d938:	eb05 0143 	add.w	r1, r5, r3, lsl #1
    d93c:	3101      	adds	r1, #1
    d93e:	f815 0013 	ldrb.w	r0, [r5, r3, lsl #1]
    d942:	f7fc fd9b 	bl	a47c <bt_conn_lookup_addr_le>
		if (!conn) {
    d946:	4681      	mov	r9, r0
    d948:	2800      	cmp	r0, #0
    d94a:	d0e8      	beq.n	d91e <notify_cb+0x13a>
		if (conn->state != BT_CONN_CONNECTED) {
    d94c:	7a83      	ldrb	r3, [r0, #10]
    d94e:	2b07      	cmp	r3, #7
    d950:	d18f      	bne.n	d872 <notify_cb+0x8e>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
    d952:	696b      	ldr	r3, [r5, #20]
    d954:	b11b      	cbz	r3, d95e <notify_cb+0x17a>
    d956:	4639      	mov	r1, r7
    d958:	4798      	blx	r3
    d95a:	2800      	cmp	r0, #0
    d95c:	d08c      	beq.n	d878 <notify_cb+0x94>
		if (bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_ENCRYPT_MASK)) {
    d95e:	2294      	movs	r2, #148	; 0x94
    d960:	4639      	mov	r1, r7
    d962:	4648      	mov	r0, r9
    d964:	f00c f888 	bl	19a78 <bt_gatt_check_perm>
    d968:	4682      	mov	sl, r0
    d96a:	2800      	cmp	r0, #0
    d96c:	d188      	bne.n	d880 <notify_cb+0x9c>
		if ((data->type == BT_GATT_CCC_INDICATE) &&
    d96e:	89b3      	ldrh	r3, [r6, #12]
    d970:	2b02      	cmp	r3, #2
    d972:	d0ad      	beq.n	d8d0 <notify_cb+0xec>
		} else if ((data->type == BT_GATT_CCC_NOTIFY) &&
    d974:	2b01      	cmp	r3, #1
    d976:	d0bf      	beq.n	d8f8 <notify_cb+0x114>
			err = 0;
    d978:	f04f 0b00 	mov.w	fp, #0
    d97c:	e7c6      	b.n	d90c <notify_cb+0x128>
			err = gatt_notify(conn, data->handle, data->nfy_params);
    d97e:	6932      	ldr	r2, [r6, #16]
    d980:	88b1      	ldrh	r1, [r6, #4]
    d982:	4648      	mov	r0, r9
    d984:	f7ff fe76 	bl	d674 <gatt_notify>
    d988:	4683      	mov	fp, r0
    d98a:	e7bf      	b.n	d90c <notify_cb+0x128>
	return BT_GATT_ITER_CONTINUE;
    d98c:	f04f 0a01 	mov.w	sl, #1
    d990:	e732      	b.n	d7f8 <notify_cb+0x14>
    d992:	bf00      	nop
    d994:	0000ca6d 	.word	0x0000ca6d
    d998:	20000324 	.word	0x20000324
    d99c:	200023f8 	.word	0x200023f8
    d9a0:	0001f19c 	.word	0x0001f19c
    d9a4:	0001cff4 	.word	0x0001cff4

0000d9a8 <bt_gatt_mult_notification>:
{
    d9a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d9ac:	b087      	sub	sp, #28
    d9ae:	af00      	add	r7, sp, #0
    d9b0:	4680      	mov	r8, r0
    d9b2:	460c      	mov	r4, r1
    d9b4:	4615      	mov	r5, r2
    d9b6:	607a      	str	r2, [r7, #4]
	sub = gatt_sub_find(conn);
    d9b8:	f7fe ff6e 	bl	c898 <gatt_sub_find>
	if (!sub) {
    d9bc:	2800      	cmp	r0, #0
    d9be:	d043      	beq.n	da48 <bt_gatt_mult_notification+0xa0>
    d9c0:	4683      	mov	fp, r0
	net_buf_simple_init_with_data(&buf, (void *)data, length);
    d9c2:	462a      	mov	r2, r5
    d9c4:	4621      	mov	r1, r4
    d9c6:	f107 000c 	add.w	r0, r7, #12
    d9ca:	f00c fb5d 	bl	1a088 <net_buf_simple_init_with_data>
	while (buf.len > sizeof(*nfy)) {
    d9ce:	465e      	mov	r6, fp
    d9d0:	e071      	b.n	dab6 <bt_gatt_mult_notification+0x10e>
			BT_ERR("Invalid data len %u > %u", len, length);
    d9d2:	466d      	mov	r5, sp
    d9d4:	b088      	sub	sp, #32
    d9d6:	466b      	mov	r3, sp
    d9d8:	f113 0210 	adds.w	r2, r3, #16
    d9dc:	d038      	beq.n	da50 <bt_gatt_mult_notification+0xa8>
    d9de:	2110      	movs	r1, #16
    d9e0:	b11a      	cbz	r2, d9ea <bt_gatt_mult_notification+0x42>
    d9e2:	2904      	cmp	r1, #4
    d9e4:	dd01      	ble.n	d9ea <bt_gatt_mult_notification+0x42>
    d9e6:	4843      	ldr	r0, [pc, #268]	; (daf4 <bt_gatt_mult_notification+0x14c>)
    d9e8:	6158      	str	r0, [r3, #20]
    d9ea:	b11a      	cbz	r2, d9f4 <bt_gatt_mult_notification+0x4c>
    d9ec:	2908      	cmp	r1, #8
    d9ee:	dd01      	ble.n	d9f4 <bt_gatt_mult_notification+0x4c>
    d9f0:	f8c3 a018 	str.w	sl, [r3, #24]
    d9f4:	b11a      	cbz	r2, d9fe <bt_gatt_mult_notification+0x56>
    d9f6:	290c      	cmp	r1, #12
    d9f8:	dd01      	ble.n	d9fe <bt_gatt_mult_notification+0x56>
    d9fa:	6878      	ldr	r0, [r7, #4]
    d9fc:	61d8      	str	r0, [r3, #28]
    d9fe:	290f      	cmp	r1, #15
    da00:	dd29      	ble.n	da56 <bt_gatt_mult_notification+0xae>
    da02:	2410      	movs	r4, #16
    da04:	b13a      	cbz	r2, da16 <bt_gatt_mult_notification+0x6e>
    da06:	2104      	movs	r1, #4
    da08:	7239      	strb	r1, [r7, #8]
    da0a:	2100      	movs	r1, #0
    da0c:	7279      	strb	r1, [r7, #9]
    da0e:	72b9      	strb	r1, [r7, #10]
    da10:	72f9      	strb	r1, [r7, #11]
    da12:	68b8      	ldr	r0, [r7, #8]
    da14:	6118      	str	r0, [r3, #16]
    da16:	2100      	movs	r1, #0
    da18:	f36f 0100 	bfc	r1, #0, #1
    da1c:	f36f 0141 	bfc	r1, #1, #1
    da20:	f36f 0182 	bfc	r1, #2, #1
    da24:	f36f 01c5 	bfc	r1, #3, #3
    da28:	2301      	movs	r3, #1
    da2a:	f363 1188 	bfi	r1, r3, #6, #3
    da2e:	f404 747d 	and.w	r4, r4, #1012	; 0x3f4
    da32:	f364 2152 	bfi	r1, r4, #9, #10
    da36:	f36f 41de 	bfc	r1, #19, #12
    da3a:	f36f 71df 	bfc	r1, #31, #1
    da3e:	2300      	movs	r3, #0
    da40:	482d      	ldr	r0, [pc, #180]	; (daf8 <bt_gatt_mult_notification+0x150>)
    da42:	f7f4 fc01 	bl	2248 <z_impl_z_log_msg_static_create>
    da46:	46ad      	mov	sp, r5
}
    da48:	371c      	adds	r7, #28
    da4a:	46bd      	mov	sp, r7
    da4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			BT_ERR("Invalid data len %u > %u", len, length);
    da50:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    da54:	e7c4      	b.n	d9e0 <bt_gatt_mult_notification+0x38>
    da56:	f06f 041b 	mvn.w	r4, #27
    da5a:	e7d3      	b.n	da04 <bt_gatt_mult_notification+0x5c>
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
    da5c:	b324      	cbz	r4, daa8 <bt_gatt_mult_notification+0x100>
Z_GENLIST_PEEK_NEXT(slist, snode)
    da5e:	f114 0318 	adds.w	r3, r4, #24
    da62:	d002      	beq.n	da6a <bt_gatt_mult_notification+0xc2>
	return node->next;
    da64:	69a3      	ldr	r3, [r4, #24]
    da66:	b103      	cbz	r3, da6a <bt_gatt_mult_notification+0xc2>
    da68:	3b18      	subs	r3, #24
    da6a:	4625      	mov	r5, r4
    da6c:	461c      	mov	r4, r3
    da6e:	b1ed      	cbz	r5, daac <bt_gatt_mult_notification+0x104>
			if (handle != params->value_handle) {
    da70:	89ab      	ldrh	r3, [r5, #12]
    da72:	4599      	cmp	r9, r3
    da74:	d1f2      	bne.n	da5c <bt_gatt_mult_notification+0xb4>
			if (check_subscribe_security_level(conn, params)) {
    da76:	4629      	mov	r1, r5
    da78:	4640      	mov	r0, r8
    da7a:	f00b fc7b 	bl	19374 <check_subscribe_security_level>
    da7e:	2800      	cmp	r0, #0
    da80:	d0ec      	beq.n	da5c <bt_gatt_mult_notification+0xb4>
				if (params->notify(conn, params, nfy->value, len) ==
    da82:	4653      	mov	r3, sl
    da84:	f10b 0204 	add.w	r2, fp, #4
    da88:	4629      	mov	r1, r5
    da8a:	4640      	mov	r0, r8
    da8c:	f8d5 c000 	ldr.w	ip, [r5]
    da90:	47e0      	blx	ip
    da92:	2800      	cmp	r0, #0
    da94:	d1e2      	bne.n	da5c <bt_gatt_mult_notification+0xb4>
					bt_gatt_unsubscribe(conn, params);
    da96:	4629      	mov	r1, r5
    da98:	4640      	mov	r0, r8
    da9a:	f00c f8ce 	bl	19c3a <bt_gatt_unsubscribe>
    da9e:	e7dd      	b.n	da5c <bt_gatt_mult_notification+0xb4>
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
    daa0:	462c      	mov	r4, r5
    daa2:	e7e4      	b.n	da6e <bt_gatt_mult_notification+0xc6>
    daa4:	462c      	mov	r4, r5
    daa6:	e7e2      	b.n	da6e <bt_gatt_mult_notification+0xc6>
    daa8:	4623      	mov	r3, r4
    daaa:	e7de      	b.n	da6a <bt_gatt_mult_notification+0xc2>
		net_buf_simple_pull_mem(&buf, len);
    daac:	4651      	mov	r1, sl
    daae:	f107 000c 	add.w	r0, r7, #12
    dab2:	f00c fbdc 	bl	1a26e <net_buf_simple_pull_mem>
	while (buf.len > sizeof(*nfy)) {
    dab6:	8a3b      	ldrh	r3, [r7, #16]
    dab8:	2b04      	cmp	r3, #4
    daba:	d9c5      	bls.n	da48 <bt_gatt_mult_notification+0xa0>
		nfy = net_buf_simple_pull_mem(&buf, sizeof(*nfy));
    dabc:	2104      	movs	r1, #4
    dabe:	f107 000c 	add.w	r0, r7, #12
    dac2:	f00c fbd4 	bl	1a26e <net_buf_simple_pull_mem>
    dac6:	4683      	mov	fp, r0
		handle = sys_cpu_to_le16(nfy->handle);
    dac8:	f8b0 9000 	ldrh.w	r9, [r0]
		len = sys_cpu_to_le16(nfy->len);
    dacc:	f8b0 a002 	ldrh.w	sl, [r0, #2]
		if (len > buf.len) {
    dad0:	8a3b      	ldrh	r3, [r7, #16]
    dad2:	4553      	cmp	r3, sl
    dad4:	f4ff af7d 	bcc.w	d9d2 <bt_gatt_mult_notification+0x2a>
	return list->head;
    dad8:	68b5      	ldr	r5, [r6, #8]
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp,
    dada:	2d00      	cmp	r5, #0
    dadc:	d0e0      	beq.n	daa0 <bt_gatt_mult_notification+0xf8>
    dade:	3d18      	subs	r5, #24
    dae0:	d0e0      	beq.n	daa4 <bt_gatt_mult_notification+0xfc>
Z_GENLIST_PEEK_NEXT(slist, snode)
    dae2:	f115 0418 	adds.w	r4, r5, #24
    dae6:	d0c2      	beq.n	da6e <bt_gatt_mult_notification+0xc6>
	return node->next;
    dae8:	69ac      	ldr	r4, [r5, #24]
    daea:	2c00      	cmp	r4, #0
    daec:	d0bf      	beq.n	da6e <bt_gatt_mult_notification+0xc6>
    daee:	3c18      	subs	r4, #24
    daf0:	e7bd      	b.n	da6e <bt_gatt_mult_notification+0xc6>
    daf2:	bf00      	nop
    daf4:	0001f268 	.word	0x0001f268
    daf8:	0001cff4 	.word	0x0001cff4

0000dafc <bt_gatt_connected>:
	}
	return 0;
}

void bt_gatt_connected(struct bt_conn *conn)
{
    dafc:	b510      	push	{r4, lr}
    dafe:	b086      	sub	sp, #24
    db00:	4604      	mov	r4, r0
	struct conn_data data;

	BT_DBG("conn %p", conn);

	data.conn = conn;
    db02:	9004      	str	r0, [sp, #16]
	data.sec = BT_SECURITY_L1;
    db04:	2001      	movs	r0, #1
    db06:	f88d 0014 	strb.w	r0, [sp, #20]
    db0a:	ab04      	add	r3, sp, #16
    db0c:	9302      	str	r3, [sp, #8]
    db0e:	4b07      	ldr	r3, [pc, #28]	; (db2c <bt_gatt_connected+0x30>)
    db10:	9301      	str	r3, [sp, #4]
    db12:	2200      	movs	r2, #0
    db14:	9200      	str	r2, [sp, #0]
    db16:	4613      	mov	r3, r2
    db18:	f64f 71ff 	movw	r1, #65535	; 0xffff
    db1c:	f7ff fa02 	bl	cf24 <bt_gatt_foreach_attr_type>
				err);
		}
	}

#if defined(CONFIG_BT_GATT_CLIENT)
	add_subscriptions(conn);
    db20:	4620      	mov	r0, r4
    db22:	f00b fe27 	bl	19774 <add_subscriptions>
	if (err) {
		BT_WARN("MTU Exchange failed (err %d)", err);
	}
#endif /* CONFIG_BT_GATT_AUTO_UPDATE_MTU */
#endif /* CONFIG_BT_GATT_CLIENT */
}
    db26:	b006      	add	sp, #24
    db28:	bd10      	pop	{r4, pc}
    db2a:	bf00      	nop
    db2c:	0000d571 	.word	0x0000d571

0000db30 <bt_gatt_att_max_mtu_changed>:

void bt_gatt_att_max_mtu_changed(struct bt_conn *conn, uint16_t tx, uint16_t rx)
{
    db30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    db32:	4605      	mov	r5, r0
    db34:	460e      	mov	r6, r1
    db36:	4617      	mov	r7, r2
	return list->head;
    db38:	4b0a      	ldr	r3, [pc, #40]	; (db64 <bt_gatt_att_max_mtu_changed+0x34>)
    db3a:	681c      	ldr	r4, [r3, #0]
	struct bt_gatt_cb *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
    db3c:	b134      	cbz	r4, db4c <bt_gatt_att_max_mtu_changed+0x1c>
    db3e:	3c04      	subs	r4, #4
    db40:	e004      	b.n	db4c <bt_gatt_att_max_mtu_changed+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
    db42:	1d23      	adds	r3, r4, #4
    db44:	d00b      	beq.n	db5e <bt_gatt_att_max_mtu_changed+0x2e>
	return node->next;
    db46:	6864      	ldr	r4, [r4, #4]
    db48:	b15c      	cbz	r4, db62 <bt_gatt_att_max_mtu_changed+0x32>
    db4a:	3c04      	subs	r4, #4
    db4c:	b14c      	cbz	r4, db62 <bt_gatt_att_max_mtu_changed+0x32>
		if (cb->att_mtu_updated) {
    db4e:	6823      	ldr	r3, [r4, #0]
    db50:	2b00      	cmp	r3, #0
    db52:	d0f6      	beq.n	db42 <bt_gatt_att_max_mtu_changed+0x12>
			cb->att_mtu_updated(conn, tx, rx);
    db54:	463a      	mov	r2, r7
    db56:	4631      	mov	r1, r6
    db58:	4628      	mov	r0, r5
    db5a:	4798      	blx	r3
    db5c:	e7f1      	b.n	db42 <bt_gatt_att_max_mtu_changed+0x12>
	SYS_SLIST_FOR_EACH_CONTAINER(&callback_list, cb, node) {
    db5e:	461c      	mov	r4, r3
    db60:	e7f4      	b.n	db4c <bt_gatt_att_max_mtu_changed+0x1c>
		}
	}
}
    db62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    db64:	200023dc 	.word	0x200023dc

0000db68 <bt_gatt_disconnected>:

	return 0;
}

void bt_gatt_disconnected(struct bt_conn *conn)
{
    db68:	b510      	push	{r4, lr}
    db6a:	b084      	sub	sp, #16
    db6c:	4604      	mov	r4, r0
    db6e:	9002      	str	r0, [sp, #8]
    db70:	4b08      	ldr	r3, [pc, #32]	; (db94 <bt_gatt_disconnected+0x2c>)
    db72:	9301      	str	r3, [sp, #4]
    db74:	2200      	movs	r2, #0
    db76:	9200      	str	r2, [sp, #0]
    db78:	4613      	mov	r3, r2
    db7a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    db7e:	2001      	movs	r0, #1
    db80:	f7ff f9d0 	bl	cf24 <bt_gatt_foreach_attr_type>
				     remove_peer_from_attr,
				     &addr_with_id);
	}

#if defined(CONFIG_BT_GATT_CLIENT)
	remove_subscriptions(conn);
    db84:	4620      	mov	r0, r4
    db86:	f00b fe1b 	bl	197c0 <remove_subscriptions>
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
    db8a:	4620      	mov	r0, r4
    db8c:	f00b fddb 	bl	19746 <remove_cf_cfg>
#endif
}
    db90:	b004      	add	sp, #16
    db92:	bd10      	pop	{r4, pc}
    db94:	0000cd79 	.word	0x0000cd79

0000db98 <bt_smp_accept>:

	return 0;
}

static int bt_smp_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
    db98:	b5b0      	push	{r4, r5, r7, lr}
    db9a:	b082      	sub	sp, #8
    db9c:	af00      	add	r7, sp, #0
    db9e:	4605      	mov	r5, r0
		.recv = bt_smp_recv,
	};

	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
    dba0:	2000      	movs	r0, #0
    dba2:	2800      	cmp	r0, #0
    dba4:	d03a      	beq.n	dc1c <bt_smp_accept+0x84>
		*chan = &smp->chan;

		return 0;
	}

	BT_ERR("No available SMP context for conn %p", conn);
    dba6:	466c      	mov	r4, sp
    dba8:	b088      	sub	sp, #32
    dbaa:	466b      	mov	r3, sp
    dbac:	f113 0210 	adds.w	r2, r3, #16
    dbb0:	d044      	beq.n	dc3c <bt_smp_accept+0xa4>
    dbb2:	210c      	movs	r1, #12
    dbb4:	b11a      	cbz	r2, dbbe <bt_smp_accept+0x26>
    dbb6:	2904      	cmp	r1, #4
    dbb8:	dd01      	ble.n	dbbe <bt_smp_accept+0x26>
    dbba:	4823      	ldr	r0, [pc, #140]	; (dc48 <bt_smp_accept+0xb0>)
    dbbc:	6158      	str	r0, [r3, #20]
    dbbe:	b112      	cbz	r2, dbc6 <bt_smp_accept+0x2e>
    dbc0:	2908      	cmp	r1, #8
    dbc2:	dd00      	ble.n	dbc6 <bt_smp_accept+0x2e>
    dbc4:	619d      	str	r5, [r3, #24]
    dbc6:	290b      	cmp	r1, #11
    dbc8:	dd3b      	ble.n	dc42 <bt_smp_accept+0xaa>
    dbca:	f04f 0c0c 	mov.w	ip, #12
    dbce:	b13a      	cbz	r2, dbe0 <bt_smp_accept+0x48>
    dbd0:	2103      	movs	r1, #3
    dbd2:	7139      	strb	r1, [r7, #4]
    dbd4:	2100      	movs	r1, #0
    dbd6:	7179      	strb	r1, [r7, #5]
    dbd8:	71b9      	strb	r1, [r7, #6]
    dbda:	71f9      	strb	r1, [r7, #7]
    dbdc:	6878      	ldr	r0, [r7, #4]
    dbde:	6118      	str	r0, [r3, #16]
    dbe0:	2100      	movs	r1, #0
    dbe2:	f36f 0100 	bfc	r1, #0, #1
    dbe6:	f36f 0141 	bfc	r1, #1, #1
    dbea:	f36f 0182 	bfc	r1, #2, #1
    dbee:	f36f 01c5 	bfc	r1, #3, #3
    dbf2:	2301      	movs	r3, #1
    dbf4:	f363 1188 	bfi	r1, r3, #6, #3
    dbf8:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    dbfc:	f36c 2152 	bfi	r1, ip, #9, #10
    dc00:	f36f 41de 	bfc	r1, #19, #12
    dc04:	f36f 71df 	bfc	r1, #31, #1
    dc08:	2300      	movs	r3, #0
    dc0a:	4810      	ldr	r0, [pc, #64]	; (dc4c <bt_smp_accept+0xb4>)
    dc0c:	f7f4 fb1c 	bl	2248 <z_impl_z_log_msg_static_create>
    dc10:	46a5      	mov	sp, r4

	return -ENOMEM;
    dc12:	f06f 000b 	mvn.w	r0, #11
}
    dc16:	3708      	adds	r7, #8
    dc18:	46bd      	mov	sp, r7
    dc1a:	bdb0      	pop	{r4, r5, r7, pc}
		if (smp->chan.conn) {
    dc1c:	238c      	movs	r3, #140	; 0x8c
    dc1e:	fb00 f303 	mul.w	r3, r0, r3
    dc22:	4a0b      	ldr	r2, [pc, #44]	; (dc50 <bt_smp_accept+0xb8>)
    dc24:	58d3      	ldr	r3, [r2, r3]
    dc26:	b10b      	cbz	r3, dc2c <bt_smp_accept+0x94>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
    dc28:	3001      	adds	r0, #1
    dc2a:	e7ba      	b.n	dba2 <bt_smp_accept+0xa>
		smp->chan.ops = &ops;
    dc2c:	4b08      	ldr	r3, [pc, #32]	; (dc50 <bt_smp_accept+0xb8>)
    dc2e:	228c      	movs	r2, #140	; 0x8c
    dc30:	fb02 3300 	mla	r3, r2, r0, r3
    dc34:	4a07      	ldr	r2, [pc, #28]	; (dc54 <bt_smp_accept+0xbc>)
    dc36:	605a      	str	r2, [r3, #4]
		*chan = &smp->chan;
    dc38:	600b      	str	r3, [r1, #0]
		return 0;
    dc3a:	e7ec      	b.n	dc16 <bt_smp_accept+0x7e>
	BT_ERR("No available SMP context for conn %p", conn);
    dc3c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    dc40:	e7b8      	b.n	dbb4 <bt_smp_accept+0x1c>
    dc42:	f06f 0c1b 	mvn.w	ip, #27
    dc46:	e7c2      	b.n	dbce <bt_smp_accept+0x36>
    dc48:	0001f3c0 	.word	0x0001f3c0
    dc4c:	0001d01c 	.word	0x0001d01c
    dc50:	20002430 	.word	0x20002430
    dc54:	0001f3f0 	.word	0x0001f3f0

0000dc58 <pool_id>:
	return &_net_buf_pool_list[id];
}

static int pool_id(struct net_buf_pool *pool)
{
	return pool - _net_buf_pool_list;
    dc58:	4b03      	ldr	r3, [pc, #12]	; (dc68 <pool_id+0x10>)
    dc5a:	1ac0      	subs	r0, r0, r3
    dc5c:	1080      	asrs	r0, r0, #2
}
    dc5e:	4b03      	ldr	r3, [pc, #12]	; (dc6c <pool_id+0x14>)
    dc60:	fb03 f000 	mul.w	r0, r3, r0
    dc64:	4770      	bx	lr
    dc66:	bf00      	nop
    dc68:	20000684 	.word	0x20000684
    dc6c:	ba2e8ba3 	.word	0xba2e8ba3

0000dc70 <net_buf_pool_get>:
}
    dc70:	222c      	movs	r2, #44	; 0x2c
    dc72:	4b02      	ldr	r3, [pc, #8]	; (dc7c <net_buf_pool_get+0xc>)
    dc74:	fb02 3000 	mla	r0, r2, r0, r3
    dc78:	4770      	bx	lr
    dc7a:	bf00      	nop
    dc7c:	20000684 	.word	0x20000684

0000dc80 <get_hf_flags>:
static uint32_t *get_hf_flags(void)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
}
    dc80:	4800      	ldr	r0, [pc, #0]	; (dc84 <get_hf_flags+0x4>)
    dc82:	4770      	bx	lr
    dc84:	20002544 	.word	0x20002544

0000dc88 <get_subsys>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    dc88:	4b03      	ldr	r3, [pc, #12]	; (dc98 <get_subsys+0x10>)
    dc8a:	1ac0      	subs	r0, r0, r3
    dc8c:	1080      	asrs	r0, r0, #2

	return (clock_control_subsys_t)offset;
}
    dc8e:	4b03      	ldr	r3, [pc, #12]	; (dc9c <get_subsys+0x14>)
    dc90:	fb03 f000 	mul.w	r0, r3, r0
    dc94:	4770      	bx	lr
    dc96:	bf00      	nop
    dc98:	200024cc 	.word	0x200024cc
    dc9c:	b6db6db7 	.word	0xb6db6db7

0000dca0 <onoff_stop>:

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    dca0:	b538      	push	{r3, r4, r5, lr}
    dca2:	4605      	mov	r5, r0
    dca4:	460c      	mov	r4, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    dca6:	f7ff ffef 	bl	dc88 <get_subsys>
    dcaa:	4601      	mov	r1, r0
    dcac:	2240      	movs	r2, #64	; 0x40
    dcae:	4803      	ldr	r0, [pc, #12]	; (dcbc <onoff_stop+0x1c>)
    dcb0:	f00c fb71 	bl	1a396 <stop>
    dcb4:	4601      	mov	r1, r0
	notify(mgr, res);
    dcb6:	4628      	mov	r0, r5
    dcb8:	47a0      	blx	r4
}
    dcba:	bd38      	pop	{r3, r4, r5, pc}
    dcbc:	0001cc14 	.word	0x0001cc14

0000dcc0 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    dcc0:	b530      	push	{r4, r5, lr}
    dcc2:	b083      	sub	sp, #12
    dcc4:	4605      	mov	r5, r0
    dcc6:	460c      	mov	r4, r1
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    dcc8:	f7ff ffde 	bl	dc88 <get_subsys>
    dccc:	4601      	mov	r1, r0
    dcce:	2340      	movs	r3, #64	; 0x40
    dcd0:	9300      	str	r3, [sp, #0]
    dcd2:	4623      	mov	r3, r4
    dcd4:	4a05      	ldr	r2, [pc, #20]	; (dcec <onoff_start+0x2c>)
    dcd6:	4806      	ldr	r0, [pc, #24]	; (dcf0 <onoff_start+0x30>)
    dcd8:	f00c fb77 	bl	1a3ca <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    dcdc:	1e01      	subs	r1, r0, #0
    dcde:	db01      	blt.n	dce4 <onoff_start+0x24>
		notify(mgr, err);
	}
}
    dce0:	b003      	add	sp, #12
    dce2:	bd30      	pop	{r4, r5, pc}
		notify(mgr, err);
    dce4:	4628      	mov	r0, r5
    dce6:	47a0      	blx	r4
}
    dce8:	e7fa      	b.n	dce0 <onoff_start+0x20>
    dcea:	bf00      	nop
    dcec:	0001a413 	.word	0x0001a413
    dcf0:	0001cc14 	.word	0x0001cc14

0000dcf4 <clock_event_handler>:
		__ASSERT_NO_MSG(false);
	}
}

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
    dcf4:	b508      	push	{r3, lr}
	const struct device *dev = CLOCK_DEVICE;

	switch (event) {
    dcf6:	2805      	cmp	r0, #5
    dcf8:	d815      	bhi.n	dd26 <clock_event_handler+0x32>
    dcfa:	e8df f000 	tbb	[pc, r0]
    dcfe:	1a03      	.short	0x1a03
    dd00:	10151414 	.word	0x10151414
	case NRFX_CLOCK_EVT_HFCLK_STARTED:
	{
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    dd04:	2100      	movs	r1, #0
    dd06:	480d      	ldr	r0, [pc, #52]	; (dd3c <clock_event_handler+0x48>)
    dd08:	f00c face 	bl	1a2a8 <get_sub_data>

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    dd0c:	6883      	ldr	r3, [r0, #8]
    dd0e:	f013 0f07 	tst.w	r3, #7
    dd12:	d108      	bne.n	dd26 <clock_event_handler+0x32>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    dd14:	2100      	movs	r1, #0
    dd16:	4809      	ldr	r0, [pc, #36]	; (dd3c <clock_event_handler+0x48>)
    dd18:	f00c fb2b 	bl	1a372 <clkstarted_handle>
    dd1c:	e003      	b.n	dd26 <clock_event_handler+0x32>

		break;
	}
#if NRF_CLOCK_HAS_HFCLK192M
	case NRFX_CLOCK_EVT_HFCLK192M_STARTED:
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
    dd1e:	2102      	movs	r1, #2
    dd20:	4806      	ldr	r0, [pc, #24]	; (dd3c <clock_event_handler+0x48>)
    dd22:	f00c fb26 	bl	1a372 <clkstarted_handle>
		break;
	default:
		__ASSERT_NO_MSG(0);
		break;
	}
}
    dd26:	bd08      	pop	{r3, pc}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
    dd28:	2103      	movs	r1, #3
    dd2a:	4804      	ldr	r0, [pc, #16]	; (dd3c <clock_event_handler+0x48>)
    dd2c:	f00c fb21 	bl	1a372 <clkstarted_handle>
		break;
    dd30:	e7f9      	b.n	dd26 <clock_event_handler+0x32>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    dd32:	2101      	movs	r1, #1
    dd34:	4801      	ldr	r0, [pc, #4]	; (dd3c <clock_event_handler+0x48>)
    dd36:	f00c fb1c 	bl	1a372 <clkstarted_handle>
}
    dd3a:	e7f4      	b.n	dd26 <clock_event_handler+0x32>
    dd3c:	0001cc14 	.word	0x0001cc14

0000dd40 <generic_hfclk_start>:
{
    dd40:	b510      	push	{r4, lr}
	__asm__ volatile(
    dd42:	f04f 0320 	mov.w	r3, #32
    dd46:	f3ef 8411 	mrs	r4, BASEPRI
    dd4a:	f383 8812 	msr	BASEPRI_MAX, r3
    dd4e:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    dd52:	4a13      	ldr	r2, [pc, #76]	; (dda0 <generic_hfclk_start+0x60>)
    dd54:	6813      	ldr	r3, [r2, #0]
    dd56:	f043 0302 	orr.w	r3, r3, #2
    dd5a:	6013      	str	r3, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    dd5c:	f013 0f01 	tst.w	r3, #1
    dd60:	d108      	bne.n	dd74 <generic_hfclk_start+0x34>
	bool already_started = false;
    dd62:	2300      	movs	r3, #0
	__asm__ volatile(
    dd64:	f384 8811 	msr	BASEPRI, r4
    dd68:	f3bf 8f6f 	isb	sy
	if (already_started) {
    dd6c:	b99b      	cbnz	r3, dd96 <generic_hfclk_start+0x56>
	hfclk_start();
    dd6e:	f00c fb58 	bl	1a422 <hfclk_start>
}
    dd72:	bd10      	pop	{r4, pc}
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    dd74:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    dd78:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    dd7c:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    dd80:	f012 0f01 	tst.w	r2, #1
    dd84:	d101      	bne.n	dd8a <generic_hfclk_start+0x4a>
	bool already_started = false;
    dd86:	2300      	movs	r3, #0
    dd88:	e7ec      	b.n	dd64 <generic_hfclk_start+0x24>
			set_on_state(get_hf_flags());
    dd8a:	f7ff ff79 	bl	dc80 <get_hf_flags>
    dd8e:	f00c fadd 	bl	1a34c <set_on_state>
			already_started = true;
    dd92:	2301      	movs	r3, #1
    dd94:	e7e6      	b.n	dd64 <generic_hfclk_start+0x24>
		clkstarted_handle(CLOCK_DEVICE,
    dd96:	2100      	movs	r1, #0
    dd98:	4802      	ldr	r0, [pc, #8]	; (dda4 <generic_hfclk_start+0x64>)
    dd9a:	f00c faea 	bl	1a372 <clkstarted_handle>
		return;
    dd9e:	e7e8      	b.n	dd72 <generic_hfclk_start+0x32>
    dda0:	2000256c 	.word	0x2000256c
    dda4:	0001cc14 	.word	0x0001cc14

0000dda8 <generic_hfclk_stop>:
{
    dda8:	b508      	push	{r3, lr}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    ddaa:	4b08      	ldr	r3, [pc, #32]	; (ddcc <generic_hfclk_stop+0x24>)
    ddac:	e8d3 2fef 	ldaex	r2, [r3]
    ddb0:	f022 0102 	bic.w	r1, r2, #2
    ddb4:	e8c3 1fe0 	stlex	r0, r1, [r3]
    ddb8:	2800      	cmp	r0, #0
    ddba:	d1f7      	bne.n	ddac <generic_hfclk_stop+0x4>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    ddbc:	f012 0f01 	tst.w	r2, #1
    ddc0:	d000      	beq.n	ddc4 <generic_hfclk_stop+0x1c>
}
    ddc2:	bd08      	pop	{r3, pc}
	hfclk_stop();
    ddc4:	f00c fb41 	bl	1a44a <hfclk_stop>
    ddc8:	e7fb      	b.n	ddc2 <generic_hfclk_stop+0x1a>
    ddca:	bf00      	nop
    ddcc:	2000256c 	.word	0x2000256c

0000ddd0 <api_blocking_start>:
{
    ddd0:	b500      	push	{lr}
    ddd2:	b087      	sub	sp, #28
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    ddd4:	f8cd d000 	str.w	sp, [sp]
    ddd8:	f8cd d004 	str.w	sp, [sp, #4]
    dddc:	2300      	movs	r3, #0
    ddde:	9302      	str	r3, [sp, #8]
    dde0:	2301      	movs	r3, #1
    dde2:	9303      	str	r3, [sp, #12]
    dde4:	ab04      	add	r3, sp, #16
    dde6:	9304      	str	r3, [sp, #16]
    dde8:	9305      	str	r3, [sp, #20]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    ddea:	466b      	mov	r3, sp
    ddec:	4a06      	ldr	r2, [pc, #24]	; (de08 <api_blocking_start+0x38>)
    ddee:	f00c fb08 	bl	1a402 <api_start>
	if (err < 0) {
    ddf2:	2800      	cmp	r0, #0
    ddf4:	db05      	blt.n	de02 <api_blocking_start+0x32>
	return z_impl_k_sem_take(sem, timeout);
    ddf6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    ddfa:	2300      	movs	r3, #0
    ddfc:	4668      	mov	r0, sp
    ddfe:	f005 feef 	bl	13be0 <z_impl_k_sem_take>
}
    de02:	b007      	add	sp, #28
    de04:	f85d fb04 	ldr.w	pc, [sp], #4
    de08:	0001a473 	.word	0x0001a473

0000de0c <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
    de0c:	b570      	push	{r4, r5, r6, lr}
    de0e:	4606      	mov	r6, r0
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    de10:	2200      	movs	r2, #0
    de12:	2101      	movs	r1, #1
    de14:	2005      	movs	r0, #5
    de16:	f7f6 f925 	bl	4064 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
    de1a:	4811      	ldr	r0, [pc, #68]	; (de60 <clk_init+0x54>)
    de1c:	f003 f9f2 	bl	11204 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    de20:	4b10      	ldr	r3, [pc, #64]	; (de64 <clk_init+0x58>)
    de22:	4298      	cmp	r0, r3
    de24:	d119      	bne.n	de5a <clk_init+0x4e>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    de26:	f00d f83a 	bl	1ae9e <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
    de2a:	2400      	movs	r4, #0
    de2c:	2c03      	cmp	r4, #3
    de2e:	d812      	bhi.n	de56 <clk_init+0x4a>
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
    de30:	4621      	mov	r1, r4
    de32:	4630      	mov	r0, r6
    de34:	f00c fa38 	bl	1a2a8 <get_sub_data>
    de38:	4605      	mov	r5, r0

		err = onoff_manager_init(get_onoff_manager(dev, i),
    de3a:	4621      	mov	r1, r4
    de3c:	4630      	mov	r0, r6
    de3e:	f00c fa40 	bl	1a2c2 <get_onoff_manager>
    de42:	4909      	ldr	r1, [pc, #36]	; (de68 <clk_init+0x5c>)
    de44:	f007 fd53 	bl	158ee <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    de48:	2800      	cmp	r0, #0
    de4a:	db05      	blt.n	de58 <clk_init+0x4c>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    de4c:	2301      	movs	r3, #1
    de4e:	60ab      	str	r3, [r5, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    de50:	441c      	add	r4, r3
    de52:	b2e4      	uxtb	r4, r4
    de54:	e7ea      	b.n	de2c <clk_init+0x20>
	}

	return 0;
    de56:	2000      	movs	r0, #0
}
    de58:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    de5a:	f06f 0004 	mvn.w	r0, #4
    de5e:	e7fb      	b.n	de58 <clk_init+0x4c>
    de60:	0000dcf5 	.word	0x0000dcf5
    de64:	0bad0000 	.word	0x0bad0000
    de68:	0001f4b8 	.word	0x0001f4b8

0000de6c <lfclk_spinwait>:
{
    de6c:	b570      	push	{r4, r5, r6, lr}
    de6e:	4605      	mov	r5, r0
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    de70:	2801      	cmp	r0, #1
    de72:	d107      	bne.n	de84 <lfclk_spinwait+0x18>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    de74:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    de78:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    de7c:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    de80:	2b02      	cmp	r3, #2
    de82:	d03f      	beq.n	df04 <lfclk_spinwait+0x98>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    de84:	f00e f883 	bl	1bf8e <k_is_in_isr>
    de88:	b920      	cbnz	r0, de94 <lfclk_spinwait+0x28>
	return !z_sys_post_kernel;
    de8a:	4b31      	ldr	r3, [pc, #196]	; (df50 <lfclk_spinwait+0xe4>)
    de8c:	781b      	ldrb	r3, [r3, #0]
    de8e:	b19b      	cbz	r3, deb8 <lfclk_spinwait+0x4c>
    de90:	2300      	movs	r3, #0
    de92:	e000      	b.n	de96 <lfclk_spinwait+0x2a>
    de94:	2301      	movs	r3, #1
	int key = isr_mode ? irq_lock() : 0;
    de96:	461c      	mov	r4, r3
    de98:	b183      	cbz	r3, debc <lfclk_spinwait+0x50>
	__asm__ volatile(
    de9a:	f04f 0320 	mov.w	r3, #32
    de9e:	f3ef 8611 	mrs	r6, BASEPRI
    dea2:	f383 8812 	msr	BASEPRI_MAX, r3
    dea6:	f3bf 8f6f 	isb	sy
	if (!isr_mode) {
    deaa:	b9a4      	cbnz	r4, ded6 <lfclk_spinwait+0x6a>
    p_reg->INTENCLR = mask;
    deac:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    deb0:	2202      	movs	r2, #2
    deb2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    deb6:	e00e      	b.n	ded6 <lfclk_spinwait+0x6a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    deb8:	2301      	movs	r3, #1
    deba:	e7ec      	b.n	de96 <lfclk_spinwait+0x2a>
	int key = isr_mode ? irq_lock() : 0;
    debc:	2600      	movs	r6, #0
    debe:	e7f4      	b.n	deaa <lfclk_spinwait+0x3e>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    dec0:	b30c      	cbz	r4, df06 <lfclk_spinwait+0x9a>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    dec2:	4630      	mov	r0, r6
    dec4:	f7f5 ff72 	bl	3dac <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    dec8:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    decc:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
    ded0:	b2db      	uxtb	r3, r3
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    ded2:	2b01      	cmp	r3, #1
    ded4:	d01c      	beq.n	df10 <lfclk_spinwait+0xa4>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    ded6:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    deda:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
    dede:	f003 0303 	and.w	r3, r3, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    dee2:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    dee6:	f412 3f80 	tst.w	r2, #65536	; 0x10000
    deea:	d128      	bne.n	df3e <lfclk_spinwait+0xd2>
    return false;
    deec:	2200      	movs	r2, #0
	while (!(nrfx_clock_is_running(d, (void *)&type)
    deee:	2a00      	cmp	r2, #0
    def0:	d0e6      	beq.n	dec0 <lfclk_spinwait+0x54>
    def2:	2b02      	cmp	r3, #2
    def4:	d001      	beq.n	defa <lfclk_spinwait+0x8e>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    def6:	2d01      	cmp	r5, #1
    def8:	d1e2      	bne.n	dec0 <lfclk_spinwait+0x54>
	if (isr_mode) {
    defa:	b314      	cbz	r4, df42 <lfclk_spinwait+0xd6>
	__asm__ volatile(
    defc:	f386 8811 	msr	BASEPRI, r6
    df00:	f3bf 8f6f 	isb	sy
}
    df04:	bd70      	pop	{r4, r5, r6, pc}
	return z_impl_k_sleep(timeout);
    df06:	2021      	movs	r0, #33	; 0x21
    df08:	2100      	movs	r1, #0
    df0a:	f006 fc0d 	bl	14728 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    df0e:	e7db      	b.n	dec8 <lfclk_spinwait+0x5c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    df10:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    df14:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
    df18:	2b00      	cmp	r3, #0
    df1a:	d0dc      	beq.n	ded6 <lfclk_spinwait+0x6a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    df1c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    df20:	2200      	movs	r2, #0
    df22:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    df26:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
    df2a:	2202      	movs	r2, #2
    df2c:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    df30:	4a08      	ldr	r2, [pc, #32]	; (df54 <lfclk_spinwait+0xe8>)
    df32:	2120      	movs	r1, #32
    df34:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    df38:	2201      	movs	r2, #1
    df3a:	609a      	str	r2, [r3, #8]
}
    df3c:	e7cb      	b.n	ded6 <lfclk_spinwait+0x6a>
                return true;
    df3e:	2201      	movs	r2, #1
    df40:	e7d5      	b.n	deee <lfclk_spinwait+0x82>
    p_reg->INTENSET = mask;
    df42:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    df46:	2202      	movs	r2, #2
    df48:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    df4c:	e7da      	b.n	df04 <lfclk_spinwait+0x98>
    df4e:	bf00      	nop
    df50:	20002900 	.word	0x20002900
    df54:	e000e100 	.word	0xe000e100

0000df58 <z_nrf_clock_control_lf_on>:
{
    df58:	b510      	push	{r4, lr}
    df5a:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    df5c:	4b0e      	ldr	r3, [pc, #56]	; (df98 <z_nrf_clock_control_lf_on+0x40>)
    df5e:	2101      	movs	r1, #1
    df60:	e8d3 2fef 	ldaex	r2, [r3]
    df64:	e8c3 1fe0 	stlex	r0, r1, [r3]
    df68:	2800      	cmp	r0, #0
    df6a:	d1f9      	bne.n	df60 <z_nrf_clock_control_lf_on+0x8>
	if (atomic_set(&on, 1) == 0) {
    df6c:	b11a      	cbz	r2, df76 <z_nrf_clock_control_lf_on+0x1e>
	switch (start_mode) {
    df6e:	1e63      	subs	r3, r4, #1
    df70:	2b01      	cmp	r3, #1
    df72:	d90d      	bls.n	df90 <z_nrf_clock_control_lf_on+0x38>
}
    df74:	bd10      	pop	{r4, pc}
				get_onoff_manager(CLOCK_DEVICE,
    df76:	4809      	ldr	r0, [pc, #36]	; (df9c <z_nrf_clock_control_lf_on+0x44>)
    df78:	f00c f9a3 	bl	1a2c2 <get_onoff_manager>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    df7c:	4908      	ldr	r1, [pc, #32]	; (dfa0 <z_nrf_clock_control_lf_on+0x48>)
    df7e:	2300      	movs	r3, #0
    df80:	604b      	str	r3, [r1, #4]
    df82:	608b      	str	r3, [r1, #8]
    df84:	60cb      	str	r3, [r1, #12]
    df86:	2301      	movs	r3, #1
    df88:	608b      	str	r3, [r1, #8]
		err = onoff_request(mgr, &cli);
    df8a:	f007 fccd 	bl	15928 <onoff_request>
    df8e:	e7ee      	b.n	df6e <z_nrf_clock_control_lf_on+0x16>
		lfclk_spinwait(start_mode);
    df90:	4620      	mov	r0, r4
    df92:	f7ff ff6b 	bl	de6c <lfclk_spinwait>
		break;
    df96:	e7ed      	b.n	df74 <z_nrf_clock_control_lf_on+0x1c>
    df98:	20002570 	.word	0x20002570
    df9c:	0001cc14 	.word	0x0001cc14
    dfa0:	200024bc 	.word	0x200024bc

0000dfa4 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    dfa4:	b510      	push	{r4, lr}
    dfa6:	4604      	mov	r4, r0
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    dfa8:	280a      	cmp	r0, #10
    dfaa:	d007      	beq.n	dfbc <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    dfac:	4b07      	ldr	r3, [pc, #28]	; (dfcc <console_out+0x28>)
    dfae:	6818      	ldr	r0, [r3, #0]
    dfb0:	b2e1      	uxtb	r1, r4
	const struct uart_driver_api *api =
    dfb2:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    dfb4:	685b      	ldr	r3, [r3, #4]
    dfb6:	4798      	blx	r3

	return c;
}
    dfb8:	4620      	mov	r0, r4
    dfba:	bd10      	pop	{r4, pc}
		uart_poll_out(uart_console_dev, '\r');
    dfbc:	4b03      	ldr	r3, [pc, #12]	; (dfcc <console_out+0x28>)
    dfbe:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
    dfc0:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    dfc2:	685b      	ldr	r3, [r3, #4]
    dfc4:	210d      	movs	r1, #13
    dfc6:	4798      	blx	r3
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
}
    dfc8:	e7f0      	b.n	dfac <console_out+0x8>
    dfca:	bf00      	nop
    dfcc:	20002574 	.word	0x20002574

0000dfd0 <uart_console_hook_install>:
/**
 * @brief Install printk/stdout hook for UART console output
 */

static void uart_console_hook_install(void)
{
    dfd0:	b510      	push	{r4, lr}
#if defined(CONFIG_STDOUT_CONSOLE)
	__stdout_hook_install(console_out);
    dfd2:	4c04      	ldr	r4, [pc, #16]	; (dfe4 <uart_console_hook_install+0x14>)
    dfd4:	4620      	mov	r0, r4
    dfd6:	f7f7 fb29 	bl	562c <__stdout_hook_install>
#endif
#if defined(CONFIG_PRINTK)
	__printk_hook_install(console_out);
    dfda:	4620      	mov	r0, r4
    dfdc:	f7f2 ff94 	bl	f08 <__printk_hook_install>
#endif
}
    dfe0:	bd10      	pop	{r4, pc}
    dfe2:	bf00      	nop
    dfe4:	0000dfa5 	.word	0x0000dfa5

0000dfe8 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    dfe8:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    dfea:	4806      	ldr	r0, [pc, #24]	; (e004 <uart_console_init+0x1c>)
    dfec:	4b06      	ldr	r3, [pc, #24]	; (e008 <uart_console_init+0x20>)
    dfee:	6018      	str	r0, [r3, #0]
    dff0:	f00d feed 	bl	1bdce <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
    dff4:	b118      	cbz	r0, dffe <uart_console_init+0x16>
		return -ENODEV;
	}

	uart_console_hook_install();
    dff6:	f7ff ffeb 	bl	dfd0 <uart_console_hook_install>

	return 0;
    dffa:	2000      	movs	r0, #0
}
    dffc:	bd08      	pop	{r3, pc}
		return -ENODEV;
    dffe:	f06f 0012 	mvn.w	r0, #18
    e002:	e7fb      	b.n	dffc <uart_console_init+0x14>
    e004:	0001cc5c 	.word	0x0001cc5c
    e008:	20002574 	.word	0x20002574

0000e00c <get_dev>:
			dev = DEVICE_DT_INST_GET(i); \
		}

	if (0) {
	} /* Followed by else if from FOREACH macro. Done to avoid return statement in macro.  */
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    e00c:	b128      	cbz	r0, e01a <get_dev+0xe>
    e00e:	2801      	cmp	r0, #1
    e010:	d101      	bne.n	e016 <get_dev+0xa>
    e012:	4803      	ldr	r0, [pc, #12]	; (e020 <get_dev+0x14>)
	#undef GPIO_NRF_GET_DEV

	return dev;
}
    e014:	4770      	bx	lr
	const struct device *dev = NULL;
    e016:	2000      	movs	r0, #0
    e018:	4770      	bx	lr
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    e01a:	4802      	ldr	r0, [pc, #8]	; (e024 <get_dev+0x18>)
    e01c:	4770      	bx	lr
    e01e:	bf00      	nop
    e020:	0001cc2c 	.word	0x0001cc2c
    e024:	0001cc44 	.word	0x0001cc44

0000e028 <gpio_nrfx_pin_interrupt_configure>:
{
    e028:	b5f0      	push	{r4, r5, r6, r7, lr}
    e02a:	b085      	sub	sp, #20
    e02c:	460e      	mov	r6, r1
    e02e:	4619      	mov	r1, r3
	return port->config;
    e030:	6843      	ldr	r3, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    e032:	7b1b      	ldrb	r3, [r3, #12]
    e034:	f006 051f 	and.w	r5, r6, #31
    e038:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
    e03c:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
    e040:	d022      	beq.n	e088 <gpio_nrfx_pin_interrupt_configure+0x60>
    e042:	4607      	mov	r7, r0
    e044:	4614      	mov	r4, r2
	nrfx_gpiote_trigger_config_t trigger_config = {
    e046:	2300      	movs	r3, #0
    e048:	9301      	str	r3, [sp, #4]
    e04a:	9302      	str	r3, [sp, #8]
		.trigger = get_trigger(mode, trig),
    e04c:	4610      	mov	r0, r2
    e04e:	f00c fa88 	bl	1a562 <get_trigger>
	nrfx_gpiote_trigger_config_t trigger_config = {
    e052:	f88d 0004 	strb.w	r0, [sp, #4]
	return port->config;
    e056:	687b      	ldr	r3, [r7, #4]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
    e058:	6899      	ldr	r1, [r3, #8]
    e05a:	40f1      	lsrs	r1, r6
    e05c:	f011 0f01 	tst.w	r1, #1
    e060:	d102      	bne.n	e068 <gpio_nrfx_pin_interrupt_configure+0x40>
    e062:	f1b4 7fa0 	cmp.w	r4, #20971520	; 0x1400000
    e066:	d014      	beq.n	e092 <gpio_nrfx_pin_interrupt_configure+0x6a>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    e068:	2300      	movs	r3, #0
    e06a:	aa01      	add	r2, sp, #4
    e06c:	4619      	mov	r1, r3
    e06e:	4628      	mov	r0, r5
    e070:	f003 fb6c 	bl	1174c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    e074:	4b1a      	ldr	r3, [pc, #104]	; (e0e0 <gpio_nrfx_pin_interrupt_configure+0xb8>)
    e076:	4298      	cmp	r0, r3
    e078:	d12f      	bne.n	e0da <gpio_nrfx_pin_interrupt_configure+0xb2>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    e07a:	2101      	movs	r1, #1
    e07c:	4628      	mov	r0, r5
    e07e:	f003 fd47 	bl	11b10 <nrfx_gpiote_trigger_enable>
	return 0;
    e082:	2000      	movs	r0, #0
}
    e084:	b005      	add	sp, #20
    e086:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrfx_gpiote_trigger_disable(abs_pin);
    e088:	4628      	mov	r0, r5
    e08a:	f003 fda3 	bl	11bd4 <nrfx_gpiote_trigger_disable>
		return 0;
    e08e:	2000      	movs	r0, #0
    e090:	e7f8      	b.n	e084 <gpio_nrfx_pin_interrupt_configure+0x5c>
    *p_pin = pin_number & 0x1F;
    e092:	f005 031f 	and.w	r3, r5, #31
    return pin_number >> 5;
    e096:	096a      	lsrs	r2, r5, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
    e098:	2a01      	cmp	r2, #1
    e09a:	d012      	beq.n	e0c2 <gpio_nrfx_pin_interrupt_configure+0x9a>
        case 0: return NRF_P0;
    e09c:	4a11      	ldr	r2, [pc, #68]	; (e0e4 <gpio_nrfx_pin_interrupt_configure+0xbc>)
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    e09e:	3380      	adds	r3, #128	; 0x80
    e0a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    e0a4:	f013 0f01 	tst.w	r3, #1
    e0a8:	d1de      	bne.n	e068 <gpio_nrfx_pin_interrupt_configure+0x40>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    e0aa:	f10d 010f 	add.w	r1, sp, #15
    e0ae:	4628      	mov	r0, r5
    e0b0:	f003 fcd2 	bl	11a58 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    e0b4:	4b0c      	ldr	r3, [pc, #48]	; (e0e8 <gpio_nrfx_pin_interrupt_configure+0xc0>)
    e0b6:	4298      	cmp	r0, r3
    e0b8:	d005      	beq.n	e0c6 <gpio_nrfx_pin_interrupt_configure+0x9e>
		trigger_config.p_in_channel = &ch;
    e0ba:	f10d 030f 	add.w	r3, sp, #15
    e0be:	9302      	str	r3, [sp, #8]
    e0c0:	e7d2      	b.n	e068 <gpio_nrfx_pin_interrupt_configure+0x40>
        case 1: return NRF_P1;
    e0c2:	4a0a      	ldr	r2, [pc, #40]	; (e0ec <gpio_nrfx_pin_interrupt_configure+0xc4>)
    e0c4:	e7eb      	b.n	e09e <gpio_nrfx_pin_interrupt_configure+0x76>
			err = nrfx_gpiote_channel_alloc(&ch);
    e0c6:	f10d 000f 	add.w	r0, sp, #15
    e0ca:	f003 fd19 	bl	11b00 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    e0ce:	4b04      	ldr	r3, [pc, #16]	; (e0e0 <gpio_nrfx_pin_interrupt_configure+0xb8>)
    e0d0:	4298      	cmp	r0, r3
    e0d2:	d0f2      	beq.n	e0ba <gpio_nrfx_pin_interrupt_configure+0x92>
				return -ENOMEM;
    e0d4:	f06f 000b 	mvn.w	r0, #11
    e0d8:	e7d4      	b.n	e084 <gpio_nrfx_pin_interrupt_configure+0x5c>
		return -EINVAL;
    e0da:	f06f 0015 	mvn.w	r0, #21
    e0de:	e7d1      	b.n	e084 <gpio_nrfx_pin_interrupt_configure+0x5c>
    e0e0:	0bad0000 	.word	0x0bad0000
    e0e4:	50842500 	.word	0x50842500
    e0e8:	0bad0004 	.word	0x0bad0004
    e0ec:	50842800 	.word	0x50842800

0000e0f0 <gpio_nrfx_pin_configure>:
{
    e0f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e0f4:	b086      	sub	sp, #24
    e0f6:	460e      	mov	r6, r1
    e0f8:	4614      	mov	r4, r2
	return port->config;
    e0fa:	f8d0 8004 	ldr.w	r8, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    e0fe:	f898 300c 	ldrb.w	r3, [r8, #12]
    e102:	f001 051f 	and.w	r5, r1, #31
    e106:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
    e10a:	f10d 0117 	add.w	r1, sp, #23
    e10e:	4628      	mov	r0, r5
    e110:	f003 fca2 	bl	11a58 <nrfx_gpiote_channel_get>
    e114:	4607      	mov	r7, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
    e116:	f414 3f40 	tst.w	r4, #196608	; 0x30000
    e11a:	d03a      	beq.n	e192 <gpio_nrfx_pin_configure+0xa2>
	nrfx_gpiote_trigger_config_t trigger_config = {
    e11c:	2100      	movs	r1, #0
    e11e:	9103      	str	r1, [sp, #12]
    e120:	9104      	str	r1, [sp, #16]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    e122:	460b      	mov	r3, r1
    e124:	aa03      	add	r2, sp, #12
    e126:	4628      	mov	r0, r5
    e128:	f003 fb10 	bl	1174c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    e12c:	4b33      	ldr	r3, [pc, #204]	; (e1fc <gpio_nrfx_pin_configure+0x10c>)
    e12e:	4298      	cmp	r0, r3
    e130:	d161      	bne.n	e1f6 <gpio_nrfx_pin_configure+0x106>
	if (free_ch) {
    e132:	429f      	cmp	r7, r3
    e134:	d03d      	beq.n	e1b2 <gpio_nrfx_pin_configure+0xc2>
	if (flags & GPIO_OUTPUT) {
    e136:	f414 3f00 	tst.w	r4, #131072	; 0x20000
    e13a:	d049      	beq.n	e1d0 <gpio_nrfx_pin_configure+0xe0>
		int rv = get_drive(flags, &drive);
    e13c:	f10d 0103 	add.w	r1, sp, #3
    e140:	4620      	mov	r0, r4
    e142:	f00c f99b 	bl	1a47c <get_drive>
		if (rv != 0) {
    e146:	4607      	mov	r7, r0
    e148:	bb50      	cbnz	r0, e1a0 <gpio_nrfx_pin_configure+0xb0>
		nrfx_gpiote_output_config_t output_config = {
    e14a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    e14e:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
    e152:	f414 3f80 	tst.w	r4, #65536	; 0x10000
    e156:	bf0c      	ite	eq
    e158:	2301      	moveq	r3, #1
    e15a:	2300      	movne	r3, #0
		nrfx_gpiote_output_config_t output_config = {
    e15c:	f88d 3005 	strb.w	r3, [sp, #5]
			.pull = get_pull(flags)
    e160:	4620      	mov	r0, r4
    e162:	f00c f9ce 	bl	1a502 <get_pull>
		nrfx_gpiote_output_config_t output_config = {
    e166:	f88d 0006 	strb.w	r0, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    e16a:	f414 2f00 	tst.w	r4, #524288	; 0x80000
    e16e:	d025      	beq.n	e1bc <gpio_nrfx_pin_configure+0xcc>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    e170:	f8d8 3004 	ldr.w	r3, [r8, #4]
    e174:	2101      	movs	r1, #1
    e176:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
    e17a:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    e17c:	2200      	movs	r2, #0
    e17e:	a901      	add	r1, sp, #4
    e180:	4628      	mov	r0, r5
    e182:	f003 fb9d 	bl	118c0 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    e186:	4b1d      	ldr	r3, [pc, #116]	; (e1fc <gpio_nrfx_pin_configure+0x10c>)
    e188:	4298      	cmp	r0, r3
    e18a:	d009      	beq.n	e1a0 <gpio_nrfx_pin_configure+0xb0>
    e18c:	f06f 0715 	mvn.w	r7, #21
    e190:	e006      	b.n	e1a0 <gpio_nrfx_pin_configure+0xb0>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
    e192:	4628      	mov	r0, r5
    e194:	f003 fd4e 	bl	11c34 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
    e198:	4b18      	ldr	r3, [pc, #96]	; (e1fc <gpio_nrfx_pin_configure+0x10c>)
    e19a:	429f      	cmp	r7, r3
    e19c:	d004      	beq.n	e1a8 <gpio_nrfx_pin_configure+0xb8>
		return 0;
    e19e:	2700      	movs	r7, #0
}
    e1a0:	4638      	mov	r0, r7
    e1a2:	b006      	add	sp, #24
    e1a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			err = nrfx_gpiote_channel_free(ch);
    e1a8:	f89d 0017 	ldrb.w	r0, [sp, #23]
    e1ac:	f003 fca0 	bl	11af0 <nrfx_gpiote_channel_free>
    e1b0:	e7f5      	b.n	e19e <gpio_nrfx_pin_configure+0xae>
		err = nrfx_gpiote_channel_free(ch);
    e1b2:	f89d 0017 	ldrb.w	r0, [sp, #23]
    e1b6:	f003 fc9b 	bl	11af0 <nrfx_gpiote_channel_free>
    e1ba:	e7bc      	b.n	e136 <gpio_nrfx_pin_configure+0x46>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    e1bc:	f414 2f80 	tst.w	r4, #262144	; 0x40000
    e1c0:	d0dc      	beq.n	e17c <gpio_nrfx_pin_configure+0x8c>
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    e1c2:	f8d8 2004 	ldr.w	r2, [r8, #4]
    e1c6:	2301      	movs	r3, #1
    e1c8:	fa03 f606 	lsl.w	r6, r3, r6
    p_reg->OUTCLR = clr_mask;
    e1cc:	60d6      	str	r6, [r2, #12]
}
    e1ce:	e7d5      	b.n	e17c <gpio_nrfx_pin_configure+0x8c>
		.pull = get_pull(flags)
    e1d0:	4620      	mov	r0, r4
    e1d2:	f00c f996 	bl	1a502 <get_pull>
	nrfx_gpiote_input_config_t input_config = {
    e1d6:	f88d 0008 	strb.w	r0, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    e1da:	2300      	movs	r3, #0
    e1dc:	461a      	mov	r2, r3
    e1de:	a902      	add	r1, sp, #8
    e1e0:	4628      	mov	r0, r5
    e1e2:	f003 fab3 	bl	1174c <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    e1e6:	4b05      	ldr	r3, [pc, #20]	; (e1fc <gpio_nrfx_pin_configure+0x10c>)
    e1e8:	4298      	cmp	r0, r3
    e1ea:	d101      	bne.n	e1f0 <gpio_nrfx_pin_configure+0x100>
    e1ec:	2700      	movs	r7, #0
    e1ee:	e7d7      	b.n	e1a0 <gpio_nrfx_pin_configure+0xb0>
    e1f0:	f06f 0715 	mvn.w	r7, #21
    e1f4:	e7d4      	b.n	e1a0 <gpio_nrfx_pin_configure+0xb0>
		return -EINVAL;
    e1f6:	f06f 0715 	mvn.w	r7, #21
    e1fa:	e7d1      	b.n	e1a0 <gpio_nrfx_pin_configure+0xb0>
    e1fc:	0bad0000 	.word	0x0bad0000

0000e200 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    e200:	b508      	push	{r3, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    e202:	f003 fc6b 	bl	11adc <nrfx_gpiote_is_init>
    e206:	b108      	cbz	r0, e20c <gpio_nrfx_init+0xc>
		return 0;
    e208:	2000      	movs	r0, #0

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    e20a:	bd08      	pop	{r3, pc}
	err = nrfx_gpiote_init(0/*not used*/);
    e20c:	f003 fc3c 	bl	11a88 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    e210:	4b08      	ldr	r3, [pc, #32]	; (e234 <gpio_nrfx_init+0x34>)
    e212:	4298      	cmp	r0, r3
    e214:	d10a      	bne.n	e22c <gpio_nrfx_init+0x2c>
	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    e216:	2100      	movs	r1, #0
    e218:	4807      	ldr	r0, [pc, #28]	; (e238 <gpio_nrfx_init+0x38>)
    e21a:	f003 fc17 	bl	11a4c <nrfx_gpiote_global_callback_set>
	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    e21e:	2200      	movs	r2, #0
    e220:	2105      	movs	r1, #5
    e222:	200d      	movs	r0, #13
    e224:	f7f5 ff1e 	bl	4064 <z_arm_irq_priority_set>
	return 0;
    e228:	2000      	movs	r0, #0
    e22a:	e7ee      	b.n	e20a <gpio_nrfx_init+0xa>
		return -EIO;
    e22c:	f06f 0004 	mvn.w	r0, #4
    e230:	e7eb      	b.n	e20a <gpio_nrfx_init+0xa>
    e232:	bf00      	nop
    e234:	0bad0000 	.word	0x0bad0000
    e238:	0001a601 	.word	0x0001a601

0000e23c <i2c_nrfx_twim_configure>:
}

static int i2c_nrfx_twim_configure(const struct device *dev,
				   uint32_t i2c_config)
{
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
    e23c:	6843      	ldr	r3, [r0, #4]

	if (I2C_ADDR_10_BITS & i2c_config) {
    e23e:	f011 0f01 	tst.w	r1, #1
    e242:	d148      	bne.n	e2d6 <i2c_nrfx_twim_configure+0x9a>
		return -EINVAL;
	}

	switch (I2C_SPEED_GET(i2c_config)) {
    e244:	f3c1 0142 	ubfx	r1, r1, #1, #3
    e248:	2902      	cmp	r1, #2
    e24a:	d036      	beq.n	e2ba <i2c_nrfx_twim_configure+0x7e>
    e24c:	2903      	cmp	r1, #3
    e24e:	d03b      	beq.n	e2c8 <i2c_nrfx_twim_configure+0x8c>
    e250:	2901      	cmp	r1, #1
    e252:	d02b      	beq.n	e2ac <i2c_nrfx_twim_configure+0x70>
{
    e254:	b500      	push	{lr}
    e256:	b089      	sub	sp, #36	; 0x24
		nrf_twim_frequency_set(dev_config->twim.p_twim,
				       NRF_TWIM_FREQ_1000K);
		break;
#endif
	default:
		LOG_ERR("unsupported speed");
    e258:	4b20      	ldr	r3, [pc, #128]	; (e2dc <i2c_nrfx_twim_configure+0xa0>)
    e25a:	9307      	str	r3, [sp, #28]
    e25c:	2302      	movs	r3, #2
    e25e:	f88d 3004 	strb.w	r3, [sp, #4]
    e262:	2300      	movs	r3, #0
    e264:	f88d 3005 	strb.w	r3, [sp, #5]
    e268:	f88d 3006 	strb.w	r3, [sp, #6]
    e26c:	f88d 3007 	strb.w	r3, [sp, #7]
    e270:	9a01      	ldr	r2, [sp, #4]
    e272:	9206      	str	r2, [sp, #24]
    e274:	4619      	mov	r1, r3
    e276:	f363 0100 	bfi	r1, r3, #0, #1
    e27a:	f363 0141 	bfi	r1, r3, #1, #1
    e27e:	f363 0182 	bfi	r1, r3, #2, #1
    e282:	f363 01c5 	bfi	r1, r3, #3, #3
    e286:	2201      	movs	r2, #1
    e288:	f362 1188 	bfi	r1, r2, #6, #3
    e28c:	2208      	movs	r2, #8
    e28e:	f362 2152 	bfi	r1, r2, #9, #10
    e292:	f363 41de 	bfi	r1, r3, #19, #12
    e296:	f363 71df 	bfi	r1, r3, #31, #1
    e29a:	aa06      	add	r2, sp, #24
    e29c:	4810      	ldr	r0, [pc, #64]	; (e2e0 <i2c_nrfx_twim_configure+0xa4>)
    e29e:	f7f3 ffd3 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    e2a2:	f06f 0015 	mvn.w	r0, #21
	}

	return 0;
}
    e2a6:	b009      	add	sp, #36	; 0x24
    e2a8:	f85d fb04 	ldr.w	pc, [sp], #4
		nrf_twim_frequency_set(dev_config->twim.p_twim,
    e2ac:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
    e2ae:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
    e2b2:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	return 0;
    e2b6:	2000      	movs	r0, #0
}
    e2b8:	4770      	bx	lr
		nrf_twim_frequency_set(dev_config->twim.p_twim,
    e2ba:	681b      	ldr	r3, [r3, #0]
    p_reg->FREQUENCY = frequency;
    e2bc:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
    e2c0:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	return 0;
    e2c4:	2000      	movs	r0, #0
}
    e2c6:	4770      	bx	lr
		nrf_twim_frequency_set(dev_config->twim.p_twim,
    e2c8:	681b      	ldr	r3, [r3, #0]
    p_reg->FREQUENCY = frequency;
    e2ca:	f04f 627f 	mov.w	r2, #267386880	; 0xff00000
    e2ce:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	return 0;
    e2d2:	2000      	movs	r0, #0
}
    e2d4:	4770      	bx	lr
		return -EINVAL;
    e2d6:	f06f 0015 	mvn.w	r0, #21
}
    e2da:	4770      	bx	lr
    e2dc:	0001f524 	.word	0x0001f524
    e2e0:	0001d03c 	.word	0x0001d03c

0000e2e4 <event_handler>:
{
    e2e4:	b508      	push	{r3, lr}
	switch (p_event->type) {
    e2e6:	7803      	ldrb	r3, [r0, #0]
    e2e8:	2b01      	cmp	r3, #1
    e2ea:	d00c      	beq.n	e306 <event_handler+0x22>
    e2ec:	2b02      	cmp	r3, #2
    e2ee:	d00d      	beq.n	e30c <event_handler+0x28>
    e2f0:	b113      	cbz	r3, e2f8 <event_handler+0x14>
		dev_data->res = NRFX_ERROR_INTERNAL;
    e2f2:	4b08      	ldr	r3, [pc, #32]	; (e314 <event_handler+0x30>)
    e2f4:	630b      	str	r3, [r1, #48]	; 0x30
		break;
    e2f6:	e001      	b.n	e2fc <event_handler+0x18>
		dev_data->res = NRFX_SUCCESS;
    e2f8:	4b07      	ldr	r3, [pc, #28]	; (e318 <event_handler+0x34>)
    e2fa:	630b      	str	r3, [r1, #48]	; 0x30
	k_sem_give(&dev_data->completion_sync);
    e2fc:	f101 0018 	add.w	r0, r1, #24
	z_impl_k_sem_give(sem);
    e300:	f005 fc46 	bl	13b90 <z_impl_k_sem_give>
}
    e304:	bd08      	pop	{r3, pc}
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    e306:	4b05      	ldr	r3, [pc, #20]	; (e31c <event_handler+0x38>)
    e308:	630b      	str	r3, [r1, #48]	; 0x30
		break;
    e30a:	e7f7      	b.n	e2fc <event_handler+0x18>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    e30c:	4b04      	ldr	r3, [pc, #16]	; (e320 <event_handler+0x3c>)
    e30e:	630b      	str	r3, [r1, #48]	; 0x30
		break;
    e310:	e7f4      	b.n	e2fc <event_handler+0x18>
    e312:	bf00      	nop
    e314:	0bad0001 	.word	0x0bad0001
    e318:	0bad0000 	.word	0x0bad0000
    e31c:	0bae0001 	.word	0x0bae0001
    e320:	0bae0002 	.word	0x0bae0002

0000e324 <i2c_nrfx_twim_init>:
	return ret;
}
#endif /* CONFIG_PM_DEVICE */

static int i2c_nrfx_twim_init(const struct device *dev)
{
    e324:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e328:	b082      	sub	sp, #8
    e32a:	af00      	add	r7, sp, #0
    e32c:	4604      	mov	r4, r0
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
    e32e:	6845      	ldr	r5, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
    e330:	f8d0 8010 	ldr.w	r8, [r0, #16]

	dev_config->irq_connect();
    e334:	69eb      	ldr	r3, [r5, #28]
    e336:	4798      	blx	r3

#ifdef CONFIG_PINCTRL
	int err = pinctrl_apply_state(dev_config->pcfg,
    e338:	6a2e      	ldr	r6, [r5, #32]
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
    e33a:	1d3a      	adds	r2, r7, #4
    e33c:	2100      	movs	r1, #0
    e33e:	4630      	mov	r0, r6
    e340:	f00c fcc2 	bl	1acc8 <pinctrl_lookup_state>
	if (ret < 0) {
    e344:	2800      	cmp	r0, #0
    e346:	db05      	blt.n	e354 <i2c_nrfx_twim_init+0x30>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
    e348:	687b      	ldr	r3, [r7, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
    e34a:	6832      	ldr	r2, [r6, #0]
    e34c:	7919      	ldrb	r1, [r3, #4]
    e34e:	6818      	ldr	r0, [r3, #0]
    e350:	f002 f9ac 	bl	106ac <pinctrl_configure_pins>
				      COND_CODE_1(CONFIG_PM_DEVICE_RUNTIME,
						  (PINCTRL_STATE_SLEEP),
						  (PINCTRL_STATE_DEFAULT)));
	if (err < 0) {
    e354:	2800      	cmp	r0, #0
    e356:	db0d      	blt.n	e374 <i2c_nrfx_twim_init+0x50>
		return err;
	}
#endif

	if (nrfx_twim_init(&dev_config->twim, &dev_config->twim_config,
    e358:	4643      	mov	r3, r8
    e35a:	4a31      	ldr	r2, [pc, #196]	; (e420 <i2c_nrfx_twim_init+0xfc>)
    e35c:	f105 0108 	add.w	r1, r5, #8
    e360:	4628      	mov	r0, r5
    e362:	f004 fa87 	bl	12874 <nrfx_twim_init>
    e366:	4b2f      	ldr	r3, [pc, #188]	; (e424 <i2c_nrfx_twim_init+0x100>)
    e368:	4298      	cmp	r0, r3
    e36a:	d107      	bne.n	e37c <i2c_nrfx_twim_init+0x58>

#ifdef CONFIG_PM_DEVICE_RUNTIME
	pm_device_init_suspended(dev);
	pm_device_runtime_enable(dev);
#else
	nrfx_twim_enable(&dev_config->twim);
    e36c:	4628      	mov	r0, r5
    e36e:	f004 facb 	bl	12908 <nrfx_twim_enable>
#endif

	return 0;
    e372:	2000      	movs	r0, #0
}
    e374:	3708      	adds	r7, #8
    e376:	46bd      	mov	sp, r7
    e378:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LOG_ERR("Failed to initialize device: %s", dev->name);
    e37c:	6820      	ldr	r0, [r4, #0]
    e37e:	2302      	movs	r3, #2
    e380:	713b      	strb	r3, [r7, #4]
    e382:	466c      	mov	r4, sp
    e384:	b088      	sub	sp, #32
    e386:	466b      	mov	r3, sp
    e388:	f113 0210 	adds.w	r2, r3, #16
    e38c:	d039      	beq.n	e402 <i2c_nrfx_twim_init+0xde>
    e38e:	250d      	movs	r5, #13
    e390:	b11a      	cbz	r2, e39a <i2c_nrfx_twim_init+0x76>
    e392:	2d04      	cmp	r5, #4
    e394:	dd01      	ble.n	e39a <i2c_nrfx_twim_init+0x76>
    e396:	4924      	ldr	r1, [pc, #144]	; (e428 <i2c_nrfx_twim_init+0x104>)
    e398:	6159      	str	r1, [r3, #20]
    e39a:	2102      	movs	r1, #2
    e39c:	7039      	strb	r1, [r7, #0]
    e39e:	b112      	cbz	r2, e3a6 <i2c_nrfx_twim_init+0x82>
    e3a0:	2d08      	cmp	r5, #8
    e3a2:	dd00      	ble.n	e3a6 <i2c_nrfx_twim_init+0x82>
    e3a4:	6198      	str	r0, [r3, #24]
    e3a6:	b11a      	cbz	r2, e3b0 <i2c_nrfx_twim_init+0x8c>
    e3a8:	f103 011c 	add.w	r1, r3, #28
    e3ac:	2000      	movs	r0, #0
    e3ae:	b358      	cbz	r0, e408 <i2c_nrfx_twim_init+0xe4>
    e3b0:	2d0c      	cmp	r5, #12
    e3b2:	dd32      	ble.n	e41a <i2c_nrfx_twim_init+0xf6>
    e3b4:	250d      	movs	r5, #13
    e3b6:	b142      	cbz	r2, e3ca <i2c_nrfx_twim_init+0xa6>
    e3b8:	2103      	movs	r1, #3
    e3ba:	7139      	strb	r1, [r7, #4]
    e3bc:	2100      	movs	r1, #0
    e3be:	7179      	strb	r1, [r7, #5]
    e3c0:	71b9      	strb	r1, [r7, #6]
    e3c2:	2101      	movs	r1, #1
    e3c4:	71f9      	strb	r1, [r7, #7]
    e3c6:	6878      	ldr	r0, [r7, #4]
    e3c8:	6118      	str	r0, [r3, #16]
    e3ca:	2100      	movs	r1, #0
    e3cc:	f36f 0100 	bfc	r1, #0, #1
    e3d0:	f36f 0141 	bfc	r1, #1, #1
    e3d4:	f36f 0182 	bfc	r1, #2, #1
    e3d8:	f36f 01c5 	bfc	r1, #3, #3
    e3dc:	2301      	movs	r3, #1
    e3de:	f363 1188 	bfi	r1, r3, #6, #3
    e3e2:	f3c5 0309 	ubfx	r3, r5, #0, #10
    e3e6:	f363 2152 	bfi	r1, r3, #9, #10
    e3ea:	f36f 41de 	bfc	r1, #19, #12
    e3ee:	f36f 71df 	bfc	r1, #31, #1
    e3f2:	2300      	movs	r3, #0
    e3f4:	480d      	ldr	r0, [pc, #52]	; (e42c <i2c_nrfx_twim_init+0x108>)
    e3f6:	f7f3 ff27 	bl	2248 <z_impl_z_log_msg_static_create>
    e3fa:	46a5      	mov	sp, r4
		return -EIO;
    e3fc:	f06f 0004 	mvn.w	r0, #4
    e400:	e7b8      	b.n	e374 <i2c_nrfx_twim_init+0x50>
		LOG_ERR("Failed to initialize device: %s", dev->name);
    e402:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    e406:	e7c3      	b.n	e390 <i2c_nrfx_twim_init+0x6c>
    e408:	f107 0608 	add.w	r6, r7, #8
    e40c:	4406      	add	r6, r0
    e40e:	f816 6c08 	ldrb.w	r6, [r6, #-8]
    e412:	f801 6b01 	strb.w	r6, [r1], #1
    e416:	3001      	adds	r0, #1
    e418:	e7c9      	b.n	e3ae <i2c_nrfx_twim_init+0x8a>
    e41a:	f06f 051b 	mvn.w	r5, #27
    e41e:	e7ca      	b.n	e3b6 <i2c_nrfx_twim_init+0x92>
    e420:	0000e2e5 	.word	0x0000e2e5
    e424:	0bad0000 	.word	0x0bad0000
    e428:	0001f538 	.word	0x0001f538
    e42c:	0001d03c 	.word	0x0001d03c

0000e430 <i2c_nrfx_twim_recover_bus>:
{
    e430:	b570      	push	{r4, r5, r6, lr}
    e432:	b082      	sub	sp, #8
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
    e434:	6844      	ldr	r4, [r0, #4]
	scl_pin = nrf_twim_scl_pin_get(dev_config->twim.p_twim);
    e436:	6823      	ldr	r3, [r4, #0]
    return p_reg->PSEL.SCL;
    e438:	f8d3 5508 	ldr.w	r5, [r3, #1288]	; 0x508
    return p_reg->PSEL.SDA;
    e43c:	f8d3 650c 	ldr.w	r6, [r3, #1292]	; 0x50c
		nrfx_twim_disable(&dev_config->twim);
    e440:	4620      	mov	r0, r4
    e442:	f004 fa71 	bl	12928 <nrfx_twim_disable>
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
    e446:	4631      	mov	r1, r6
    e448:	4628      	mov	r0, r5
    e44a:	f004 faa5 	bl	12998 <nrfx_twi_twim_bus_recover>
    e44e:	4605      	mov	r5, r0
		(void)pinctrl_apply_state(dev_config->pcfg,
    e450:	6a26      	ldr	r6, [r4, #32]
	ret = pinctrl_lookup_state(config, id, &state);
    e452:	aa01      	add	r2, sp, #4
    e454:	2100      	movs	r1, #0
    e456:	4630      	mov	r0, r6
    e458:	f00c fc36 	bl	1acc8 <pinctrl_lookup_state>
	if (ret < 0) {
    e45c:	2800      	cmp	r0, #0
    e45e:	db05      	blt.n	e46c <i2c_nrfx_twim_recover_bus+0x3c>
	return pinctrl_apply_state_direct(config, state);
    e460:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
    e462:	6832      	ldr	r2, [r6, #0]
    e464:	7919      	ldrb	r1, [r3, #4]
    e466:	6818      	ldr	r0, [r3, #0]
    e468:	f002 f920 	bl	106ac <pinctrl_configure_pins>
		nrfx_twim_enable(&dev_config->twim);
    e46c:	4620      	mov	r0, r4
    e46e:	f004 fa4b 	bl	12908 <nrfx_twim_enable>
	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
    e472:	4b04      	ldr	r3, [pc, #16]	; (e484 <i2c_nrfx_twim_recover_bus+0x54>)
    e474:	429d      	cmp	r5, r3
    e476:	d102      	bne.n	e47e <i2c_nrfx_twim_recover_bus+0x4e>
    e478:	2000      	movs	r0, #0
}
    e47a:	b002      	add	sp, #8
    e47c:	bd70      	pop	{r4, r5, r6, pc}
	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
    e47e:	f06f 000f 	mvn.w	r0, #15
    e482:	e7fa      	b.n	e47a <i2c_nrfx_twim_recover_bus+0x4a>
    e484:	0bad0000 	.word	0x0bad0000

0000e488 <i2c_nrfx_twim_transfer>:
{
    e488:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e48c:	b091      	sub	sp, #68	; 0x44
    e48e:	af00      	add	r7, sp, #0
    e490:	6038      	str	r0, [r7, #0]
    e492:	4689      	mov	r9, r1
    e494:	4692      	mov	sl, r2
	struct i2c_nrfx_twim_data *dev_data = dev->data;
    e496:	6901      	ldr	r1, [r0, #16]
    e498:	460c      	mov	r4, r1
    e49a:	60b9      	str	r1, [r7, #8]
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
    e49c:	6842      	ldr	r2, [r0, #4]
    e49e:	60fa      	str	r2, [r7, #12]
	uint8_t *msg_buf = dev_data->msg_buf;
    e4a0:	6b48      	ldr	r0, [r1, #52]	; 0x34
    e4a2:	61b8      	str	r0, [r7, #24]
	uint16_t concat_buf_size = dev_config->concat_buf_size;
    e4a4:	8b12      	ldrh	r2, [r2, #24]
    e4a6:	613a      	str	r2, [r7, #16]
	nrfx_twim_xfer_desc_t cur_xfer = {
    e4a8:	2500      	movs	r5, #0
    e4aa:	62fd      	str	r5, [r7, #44]	; 0x2c
    e4ac:	633d      	str	r5, [r7, #48]	; 0x30
    e4ae:	637d      	str	r5, [r7, #52]	; 0x34
    e4b0:	63bd      	str	r5, [r7, #56]	; 0x38
    e4b2:	63fd      	str	r5, [r7, #60]	; 0x3c
    e4b4:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
	return z_impl_k_sem_take(sem, timeout);
    e4b8:	f04f 32ff 	mov.w	r2, #4294967295
    e4bc:	f04f 33ff 	mov.w	r3, #4294967295
    e4c0:	4608      	mov	r0, r1
    e4c2:	f005 fb8d 	bl	13be0 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
    e4c6:	f104 0318 	add.w	r3, r4, #24
    e4ca:	4618      	mov	r0, r3
    e4cc:	607b      	str	r3, [r7, #4]
    e4ce:	2200      	movs	r2, #0
    e4d0:	2300      	movs	r3, #0
    e4d2:	f005 fb85 	bl	13be0 <z_impl_k_sem_take>
	for (size_t i = 0; i < num_msgs; i++) {
    e4d6:	462e      	mov	r6, r5
	uint16_t msg_buf_used = 0;
    e4d8:	462c      	mov	r4, r5
	int ret = 0;
    e4da:	617d      	str	r5, [r7, #20]
	for (size_t i = 0; i < num_msgs; i++) {
    e4dc:	e04c      	b.n	e578 <i2c_nrfx_twim_transfer+0xf0>
				&& ((msgs[i].flags & I2C_MSG_READ)
    e4de:	2200      	movs	r2, #0
		if (concat_next || (msg_buf_used != 0)) {
    e4e0:	61fa      	str	r2, [r7, #28]
    e4e2:	b912      	cbnz	r2, e4ea <i2c_nrfx_twim_transfer+0x62>
    e4e4:	2c00      	cmp	r4, #0
    e4e6:	f000 80e1 	beq.w	e6ac <i2c_nrfx_twim_transfer+0x224>
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
    e4ea:	4620      	mov	r0, r4
    e4ec:	686a      	ldr	r2, [r5, #4]
    e4ee:	18a1      	adds	r1, r4, r2
    e4f0:	f8d7 c010 	ldr.w	ip, [r7, #16]
    e4f4:	4561      	cmp	r1, ip
    e4f6:	d868      	bhi.n	e5ca <i2c_nrfx_twim_transfer+0x142>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
    e4f8:	f013 0f01 	tst.w	r3, #1
    e4fc:	f000 80cf 	beq.w	e69e <i2c_nrfx_twim_transfer+0x216>
			msg_buf_used += msgs[i].len;
    e500:	686b      	ldr	r3, [r5, #4]
    e502:	441c      	add	r4, r3
    e504:	b2a4      	uxth	r4, r4
		if (concat_next) {
    e506:	69fb      	ldr	r3, [r7, #28]
    e508:	2b00      	cmp	r3, #0
    e50a:	d134      	bne.n	e576 <i2c_nrfx_twim_transfer+0xee>
		if (msg_buf_used == 0) {
    e50c:	2c00      	cmp	r4, #0
    e50e:	f040 8142 	bne.w	e796 <i2c_nrfx_twim_transfer+0x30e>
			cur_xfer.p_primary_buf = msgs[i].buf;
    e512:	f859 300b 	ldr.w	r3, [r9, fp]
    e516:	63bb      	str	r3, [r7, #56]	; 0x38
			cur_xfer.primary_length = msgs[i].len;
    e518:	686b      	ldr	r3, [r5, #4]
    e51a:	633b      	str	r3, [r7, #48]	; 0x30
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
    e51c:	7a2b      	ldrb	r3, [r5, #8]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
    e51e:	f003 0201 	and.w	r2, r3, #1
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
    e522:	f887 202c 	strb.w	r2, [r7, #44]	; 0x2c
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
    e526:	f013 0f02 	tst.w	r3, #2
    e52a:	f000 8138 	beq.w	e79e <i2c_nrfx_twim_transfer+0x316>
    e52e:	2200      	movs	r2, #0
    e530:	f107 012c 	add.w	r1, r7, #44	; 0x2c
    e534:	68f8      	ldr	r0, [r7, #12]
    e536:	f004 fa15 	bl	12964 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
    e53a:	4b9f      	ldr	r3, [pc, #636]	; (e7b8 <i2c_nrfx_twim_transfer+0x330>)
    e53c:	4298      	cmp	r0, r3
    e53e:	f040 8130 	bne.w	e7a2 <i2c_nrfx_twim_transfer+0x31a>
    e542:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    e546:	2300      	movs	r3, #0
    e548:	6878      	ldr	r0, [r7, #4]
    e54a:	f005 fb49 	bl	13be0 <z_impl_k_sem_take>
		if (ret != 0) {
    e54e:	6178      	str	r0, [r7, #20]
    e550:	2800      	cmp	r0, #0
    e552:	f040 8139 	bne.w	e7c8 <i2c_nrfx_twim_transfer+0x340>
		res = dev_data->res;
    e556:	68bb      	ldr	r3, [r7, #8]
    e558:	6b1b      	ldr	r3, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
    e55a:	4a97      	ldr	r2, [pc, #604]	; (e7b8 <i2c_nrfx_twim_transfer+0x330>)
    e55c:	4293      	cmp	r3, r2
    e55e:	f040 8179 	bne.w	e854 <i2c_nrfx_twim_transfer+0x3cc>
		if ((msgs[i].flags & I2C_MSG_READ)
    e562:	7a2b      	ldrb	r3, [r5, #8]
    e564:	f013 0f01 	tst.w	r3, #1
    e568:	d004      	beq.n	e574 <i2c_nrfx_twim_transfer+0xec>
		    && cur_xfer.p_primary_buf == msg_buf) {
    e56a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    e56c:	69ba      	ldr	r2, [r7, #24]
    e56e:	429a      	cmp	r2, r3
    e570:	f000 81b7 	beq.w	e8e2 <i2c_nrfx_twim_transfer+0x45a>
		msg_buf_used = 0;
    e574:	2400      	movs	r4, #0
    e576:	4646      	mov	r6, r8
	for (size_t i = 0; i < num_msgs; i++) {
    e578:	4556      	cmp	r6, sl
    e57a:	f080 81c8 	bcs.w	e90e <i2c_nrfx_twim_transfer+0x486>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
    e57e:	eb06 0546 	add.w	r5, r6, r6, lsl #1
    e582:	ea4f 0b85 	mov.w	fp, r5, lsl #2
    e586:	eb09 0585 	add.w	r5, r9, r5, lsl #2
    e58a:	7a2b      	ldrb	r3, [r5, #8]
    e58c:	f013 0f08 	tst.w	r3, #8
    e590:	f040 81ba 	bne.w	e908 <i2c_nrfx_twim_transfer+0x480>
		bool concat_next = ((i + 1) < num_msgs)
    e594:	f106 0801 	add.w	r8, r6, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
    e598:	45d0      	cmp	r8, sl
    e59a:	d2a0      	bcs.n	e4de <i2c_nrfx_twim_transfer+0x56>
				&& !(msgs[i].flags & I2C_MSG_STOP)
    e59c:	f013 0f02 	tst.w	r3, #2
    e5a0:	d10d      	bne.n	e5be <i2c_nrfx_twim_transfer+0x136>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
    e5a2:	eb08 0248 	add.w	r2, r8, r8, lsl #1
    e5a6:	eb09 0282 	add.w	r2, r9, r2, lsl #2
    e5aa:	7a12      	ldrb	r2, [r2, #8]
    e5ac:	f012 0f04 	tst.w	r2, #4
    e5b0:	d107      	bne.n	e5c2 <i2c_nrfx_twim_transfer+0x13a>
				    == (msgs[i + 1].flags & I2C_MSG_READ));
    e5b2:	405a      	eors	r2, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
    e5b4:	f012 0f01 	tst.w	r2, #1
    e5b8:	d005      	beq.n	e5c6 <i2c_nrfx_twim_transfer+0x13e>
    e5ba:	2200      	movs	r2, #0
    e5bc:	e790      	b.n	e4e0 <i2c_nrfx_twim_transfer+0x58>
    e5be:	2200      	movs	r2, #0
    e5c0:	e78e      	b.n	e4e0 <i2c_nrfx_twim_transfer+0x58>
    e5c2:	2200      	movs	r2, #0
    e5c4:	e78c      	b.n	e4e0 <i2c_nrfx_twim_transfer+0x58>
    e5c6:	2201      	movs	r2, #1
    e5c8:	e78a      	b.n	e4e0 <i2c_nrfx_twim_transfer+0x58>
				LOG_ERR("Need to use concatenation buffer and "
    e5ca:	683b      	ldr	r3, [r7, #0]
    e5cc:	6818      	ldr	r0, [r3, #0]
    e5ce:	2305      	movs	r3, #5
    e5d0:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    e5d4:	466e      	mov	r6, sp
    e5d6:	b08c      	sub	sp, #48	; 0x30
    e5d8:	466b      	mov	r3, sp
    e5da:	f113 0510 	adds.w	r5, r3, #16
    e5de:	d04f      	beq.n	e680 <i2c_nrfx_twim_transfer+0x1f8>
    e5e0:	2119      	movs	r1, #25
    e5e2:	b12d      	cbz	r5, e5f0 <i2c_nrfx_twim_transfer+0x168>
    e5e4:	2904      	cmp	r1, #4
    e5e6:	dd03      	ble.n	e5f0 <i2c_nrfx_twim_transfer+0x168>
    e5e8:	f8df c1d0 	ldr.w	ip, [pc, #464]	; e7bc <i2c_nrfx_twim_transfer+0x334>
    e5ec:	f8c3 c014 	str.w	ip, [r3, #20]
    e5f0:	b115      	cbz	r5, e5f8 <i2c_nrfx_twim_transfer+0x170>
    e5f2:	2908      	cmp	r1, #8
    e5f4:	dd00      	ble.n	e5f8 <i2c_nrfx_twim_transfer+0x170>
    e5f6:	619c      	str	r4, [r3, #24]
    e5f8:	b115      	cbz	r5, e600 <i2c_nrfx_twim_transfer+0x178>
    e5fa:	290c      	cmp	r1, #12
    e5fc:	dd00      	ble.n	e600 <i2c_nrfx_twim_transfer+0x178>
    e5fe:	61da      	str	r2, [r3, #28]
    e600:	b11d      	cbz	r5, e60a <i2c_nrfx_twim_transfer+0x182>
    e602:	2910      	cmp	r1, #16
    e604:	dd01      	ble.n	e60a <i2c_nrfx_twim_transfer+0x182>
    e606:	693a      	ldr	r2, [r7, #16]
    e608:	621a      	str	r2, [r3, #32]
    e60a:	2205      	movs	r2, #5
    e60c:	f887 2024 	strb.w	r2, [r7, #36]	; 0x24
    e610:	b115      	cbz	r5, e618 <i2c_nrfx_twim_transfer+0x190>
    e612:	2914      	cmp	r1, #20
    e614:	dd00      	ble.n	e618 <i2c_nrfx_twim_transfer+0x190>
    e616:	6258      	str	r0, [r3, #36]	; 0x24
    e618:	b11d      	cbz	r5, e622 <i2c_nrfx_twim_transfer+0x19a>
    e61a:	f103 0228 	add.w	r2, r3, #40	; 0x28
    e61e:	2000      	movs	r0, #0
    e620:	b388      	cbz	r0, e686 <i2c_nrfx_twim_transfer+0x1fe>
    e622:	2918      	cmp	r1, #24
    e624:	dd38      	ble.n	e698 <i2c_nrfx_twim_transfer+0x210>
    e626:	2219      	movs	r2, #25
    e628:	b165      	cbz	r5, e644 <i2c_nrfx_twim_transfer+0x1bc>
    e62a:	2106      	movs	r1, #6
    e62c:	f887 1028 	strb.w	r1, [r7, #40]	; 0x28
    e630:	2100      	movs	r1, #0
    e632:	f887 1029 	strb.w	r1, [r7, #41]	; 0x29
    e636:	f887 102a 	strb.w	r1, [r7, #42]	; 0x2a
    e63a:	2101      	movs	r1, #1
    e63c:	f887 102b 	strb.w	r1, [r7, #43]	; 0x2b
    e640:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e642:	6118      	str	r0, [r3, #16]
    e644:	2100      	movs	r1, #0
    e646:	f36f 0100 	bfc	r1, #0, #1
    e64a:	f36f 0141 	bfc	r1, #1, #1
    e64e:	f36f 0182 	bfc	r1, #2, #1
    e652:	f36f 01c5 	bfc	r1, #3, #3
    e656:	2301      	movs	r3, #1
    e658:	f363 1188 	bfi	r1, r3, #6, #3
    e65c:	f3c2 0209 	ubfx	r2, r2, #0, #10
    e660:	f362 2152 	bfi	r1, r2, #9, #10
    e664:	f36f 41de 	bfc	r1, #19, #12
    e668:	f36f 71df 	bfc	r1, #31, #1
    e66c:	2300      	movs	r3, #0
    e66e:	462a      	mov	r2, r5
    e670:	4853      	ldr	r0, [pc, #332]	; (e7c0 <i2c_nrfx_twim_transfer+0x338>)
    e672:	f7f3 fde9 	bl	2248 <z_impl_z_log_msg_static_create>
    e676:	46b5      	mov	sp, r6
				ret = -ENOSPC;
    e678:	f06f 031b 	mvn.w	r3, #27
    e67c:	617b      	str	r3, [r7, #20]
				break;
    e67e:	e146      	b.n	e90e <i2c_nrfx_twim_transfer+0x486>
				LOG_ERR("Need to use concatenation buffer and "
    e680:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    e684:	e7ad      	b.n	e5e2 <i2c_nrfx_twim_transfer+0x15a>
    e686:	f107 0440 	add.w	r4, r7, #64	; 0x40
    e68a:	4404      	add	r4, r0
    e68c:	f814 4c1c 	ldrb.w	r4, [r4, #-28]
    e690:	f802 4b01 	strb.w	r4, [r2], #1
    e694:	3001      	adds	r0, #1
    e696:	e7c3      	b.n	e620 <i2c_nrfx_twim_transfer+0x198>
    e698:	f06f 021b 	mvn.w	r2, #27
    e69c:	e7c4      	b.n	e628 <i2c_nrfx_twim_transfer+0x1a0>
				memcpy(msg_buf + msg_buf_used,
    e69e:	f859 100b 	ldr.w	r1, [r9, fp]
    e6a2:	69bb      	ldr	r3, [r7, #24]
    e6a4:	4418      	add	r0, r3
    e6a6:	f009 f843 	bl	17730 <memcpy>
    e6aa:	e729      	b.n	e500 <i2c_nrfx_twim_transfer+0x78>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
    e6ac:	f013 0f01 	tst.w	r3, #1
    e6b0:	f47f af29 	bne.w	e506 <i2c_nrfx_twim_transfer+0x7e>
			   !nrfx_is_in_ram(msgs[i].buf)) {
    e6b4:	f859 100b 	ldr.w	r1, [r9, fp]

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    e6b8:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
    e6bc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    e6c0:	f43f af21 	beq.w	e506 <i2c_nrfx_twim_transfer+0x7e>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
    e6c4:	686a      	ldr	r2, [r5, #4]
    e6c6:	68fb      	ldr	r3, [r7, #12]
    e6c8:	8b5b      	ldrh	r3, [r3, #26]
    e6ca:	429a      	cmp	r2, r3
    e6cc:	d804      	bhi.n	e6d8 <i2c_nrfx_twim_transfer+0x250>
			memcpy(msg_buf, msgs[i].buf, msgs[i].len);
    e6ce:	69b8      	ldr	r0, [r7, #24]
    e6d0:	f009 f82e 	bl	17730 <memcpy>
			msg_buf_used = msgs[i].len;
    e6d4:	88ac      	ldrh	r4, [r5, #4]
    e6d6:	e716      	b.n	e506 <i2c_nrfx_twim_transfer+0x7e>
				LOG_ERR("Cannot copy flash buffer of size: %u. "
    e6d8:	683b      	ldr	r3, [r7, #0]
    e6da:	6818      	ldr	r0, [r3, #0]
    e6dc:	2303      	movs	r3, #3
    e6de:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
    e6e2:	466d      	mov	r5, sp
    e6e4:	b08a      	sub	sp, #40	; 0x28
    e6e6:	466b      	mov	r3, sp
    e6e8:	f113 0410 	adds.w	r4, r3, #16
    e6ec:	d044      	beq.n	e778 <i2c_nrfx_twim_transfer+0x2f0>
    e6ee:	2111      	movs	r1, #17
    e6f0:	b11c      	cbz	r4, e6fa <i2c_nrfx_twim_transfer+0x272>
    e6f2:	2904      	cmp	r1, #4
    e6f4:	dd01      	ble.n	e6fa <i2c_nrfx_twim_transfer+0x272>
    e6f6:	4e33      	ldr	r6, [pc, #204]	; (e7c4 <i2c_nrfx_twim_transfer+0x33c>)
    e6f8:	615e      	str	r6, [r3, #20]
    e6fa:	b114      	cbz	r4, e702 <i2c_nrfx_twim_transfer+0x27a>
    e6fc:	2908      	cmp	r1, #8
    e6fe:	dd00      	ble.n	e702 <i2c_nrfx_twim_transfer+0x27a>
    e700:	619a      	str	r2, [r3, #24]
    e702:	2203      	movs	r2, #3
    e704:	f887 2024 	strb.w	r2, [r7, #36]	; 0x24
    e708:	b114      	cbz	r4, e710 <i2c_nrfx_twim_transfer+0x288>
    e70a:	290c      	cmp	r1, #12
    e70c:	dd00      	ble.n	e710 <i2c_nrfx_twim_transfer+0x288>
    e70e:	61d8      	str	r0, [r3, #28]
    e710:	b11c      	cbz	r4, e71a <i2c_nrfx_twim_transfer+0x292>
    e712:	f103 0220 	add.w	r2, r3, #32
    e716:	2000      	movs	r0, #0
    e718:	b388      	cbz	r0, e77e <i2c_nrfx_twim_transfer+0x2f6>
    e71a:	2910      	cmp	r1, #16
    e71c:	dd38      	ble.n	e790 <i2c_nrfx_twim_transfer+0x308>
    e71e:	2211      	movs	r2, #17
    e720:	b164      	cbz	r4, e73c <i2c_nrfx_twim_transfer+0x2b4>
    e722:	2104      	movs	r1, #4
    e724:	f887 1028 	strb.w	r1, [r7, #40]	; 0x28
    e728:	2100      	movs	r1, #0
    e72a:	f887 1029 	strb.w	r1, [r7, #41]	; 0x29
    e72e:	f887 102a 	strb.w	r1, [r7, #42]	; 0x2a
    e732:	2101      	movs	r1, #1
    e734:	f887 102b 	strb.w	r1, [r7, #43]	; 0x2b
    e738:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e73a:	6118      	str	r0, [r3, #16]
    e73c:	2100      	movs	r1, #0
    e73e:	f36f 0100 	bfc	r1, #0, #1
    e742:	f36f 0141 	bfc	r1, #1, #1
    e746:	f36f 0182 	bfc	r1, #2, #1
    e74a:	f36f 01c5 	bfc	r1, #3, #3
    e74e:	2301      	movs	r3, #1
    e750:	f363 1188 	bfi	r1, r3, #6, #3
    e754:	f3c2 0209 	ubfx	r2, r2, #0, #10
    e758:	f362 2152 	bfi	r1, r2, #9, #10
    e75c:	f36f 41de 	bfc	r1, #19, #12
    e760:	f36f 71df 	bfc	r1, #31, #1
    e764:	2300      	movs	r3, #0
    e766:	4622      	mov	r2, r4
    e768:	4815      	ldr	r0, [pc, #84]	; (e7c0 <i2c_nrfx_twim_transfer+0x338>)
    e76a:	f7f3 fd6d 	bl	2248 <z_impl_z_log_msg_static_create>
    e76e:	46ad      	mov	sp, r5
				ret = -EINVAL;
    e770:	f06f 0315 	mvn.w	r3, #21
    e774:	617b      	str	r3, [r7, #20]
				break;
    e776:	e0ca      	b.n	e90e <i2c_nrfx_twim_transfer+0x486>
				LOG_ERR("Cannot copy flash buffer of size: %u. "
    e778:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    e77c:	e7b8      	b.n	e6f0 <i2c_nrfx_twim_transfer+0x268>
    e77e:	f107 0640 	add.w	r6, r7, #64	; 0x40
    e782:	4406      	add	r6, r0
    e784:	f816 6c1c 	ldrb.w	r6, [r6, #-28]
    e788:	f802 6b01 	strb.w	r6, [r2], #1
    e78c:	3001      	adds	r0, #1
    e78e:	e7c3      	b.n	e718 <i2c_nrfx_twim_transfer+0x290>
    e790:	f06f 021b 	mvn.w	r2, #27
    e794:	e7c4      	b.n	e720 <i2c_nrfx_twim_transfer+0x298>
			cur_xfer.p_primary_buf = msg_buf;
    e796:	69bb      	ldr	r3, [r7, #24]
    e798:	63bb      	str	r3, [r7, #56]	; 0x38
			cur_xfer.primary_length = msg_buf_used;
    e79a:	633c      	str	r4, [r7, #48]	; 0x30
    e79c:	e6be      	b.n	e51c <i2c_nrfx_twim_transfer+0x94>
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
    e79e:	2220      	movs	r2, #32
    e7a0:	e6c6      	b.n	e530 <i2c_nrfx_twim_transfer+0xa8>
			if (res == NRFX_ERROR_BUSY) {
    e7a2:	330b      	adds	r3, #11
    e7a4:	4298      	cmp	r0, r3
    e7a6:	d003      	beq.n	e7b0 <i2c_nrfx_twim_transfer+0x328>
				ret = -EIO;
    e7a8:	f06f 0304 	mvn.w	r3, #4
    e7ac:	617b      	str	r3, [r7, #20]
    e7ae:	e0ae      	b.n	e90e <i2c_nrfx_twim_transfer+0x486>
				ret = -EBUSY;
    e7b0:	f06f 030f 	mvn.w	r3, #15
    e7b4:	617b      	str	r3, [r7, #20]
    e7b6:	e0aa      	b.n	e90e <i2c_nrfx_twim_transfer+0x486>
    e7b8:	0bad0000 	.word	0x0bad0000
    e7bc:	0001f558 	.word	0x0001f558
    e7c0:	0001d03c 	.word	0x0001d03c
    e7c4:	0001f5e8 	.word	0x0001f5e8
			LOG_ERR("Error on I2C line occurred for message %d", i);
    e7c8:	466c      	mov	r4, sp
    e7ca:	b088      	sub	sp, #32
    e7cc:	466b      	mov	r3, sp
    e7ce:	f113 0210 	adds.w	r2, r3, #16
    e7d2:	d039      	beq.n	e848 <i2c_nrfx_twim_transfer+0x3c0>
    e7d4:	210c      	movs	r1, #12
    e7d6:	b11a      	cbz	r2, e7e0 <i2c_nrfx_twim_transfer+0x358>
    e7d8:	2904      	cmp	r1, #4
    e7da:	dd01      	ble.n	e7e0 <i2c_nrfx_twim_transfer+0x358>
    e7dc:	4850      	ldr	r0, [pc, #320]	; (e920 <i2c_nrfx_twim_transfer+0x498>)
    e7de:	6158      	str	r0, [r3, #20]
    e7e0:	b112      	cbz	r2, e7e8 <i2c_nrfx_twim_transfer+0x360>
    e7e2:	2908      	cmp	r1, #8
    e7e4:	dd00      	ble.n	e7e8 <i2c_nrfx_twim_transfer+0x360>
    e7e6:	619e      	str	r6, [r3, #24]
    e7e8:	290b      	cmp	r1, #11
    e7ea:	dd30      	ble.n	e84e <i2c_nrfx_twim_transfer+0x3c6>
    e7ec:	250c      	movs	r5, #12
    e7ee:	b15a      	cbz	r2, e808 <i2c_nrfx_twim_transfer+0x380>
    e7f0:	2103      	movs	r1, #3
    e7f2:	f887 1028 	strb.w	r1, [r7, #40]	; 0x28
    e7f6:	2100      	movs	r1, #0
    e7f8:	f887 1029 	strb.w	r1, [r7, #41]	; 0x29
    e7fc:	f887 102a 	strb.w	r1, [r7, #42]	; 0x2a
    e800:	f887 102b 	strb.w	r1, [r7, #43]	; 0x2b
    e804:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e806:	6118      	str	r0, [r3, #16]
    e808:	2100      	movs	r1, #0
    e80a:	f36f 0100 	bfc	r1, #0, #1
    e80e:	f36f 0141 	bfc	r1, #1, #1
    e812:	f36f 0182 	bfc	r1, #2, #1
    e816:	f36f 01c5 	bfc	r1, #3, #3
    e81a:	2301      	movs	r3, #1
    e81c:	f363 1188 	bfi	r1, r3, #6, #3
    e820:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    e824:	f365 2152 	bfi	r1, r5, #9, #10
    e828:	f36f 41de 	bfc	r1, #19, #12
    e82c:	f36f 71df 	bfc	r1, #31, #1
    e830:	2300      	movs	r3, #0
    e832:	483c      	ldr	r0, [pc, #240]	; (e924 <i2c_nrfx_twim_transfer+0x49c>)
    e834:	f7f3 fd08 	bl	2248 <z_impl_z_log_msg_static_create>
    e838:	46a5      	mov	sp, r4
			(void)i2c_nrfx_twim_recover_bus(dev);
    e83a:	6838      	ldr	r0, [r7, #0]
    e83c:	f7ff fdf8 	bl	e430 <i2c_nrfx_twim_recover_bus>
			ret = -EIO;
    e840:	f06f 0304 	mvn.w	r3, #4
    e844:	617b      	str	r3, [r7, #20]
			break;
    e846:	e062      	b.n	e90e <i2c_nrfx_twim_transfer+0x486>
			LOG_ERR("Error on I2C line occurred for message %d", i);
    e848:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    e84c:	e7c3      	b.n	e7d6 <i2c_nrfx_twim_transfer+0x34e>
    e84e:	f06f 051b 	mvn.w	r5, #27
    e852:	e7cc      	b.n	e7ee <i2c_nrfx_twim_transfer+0x366>
			LOG_ERR("Error 0x%08X occurred for message %d", res, i);
    e854:	466c      	mov	r4, sp
    e856:	b088      	sub	sp, #32
    e858:	4669      	mov	r1, sp
    e85a:	f111 0210 	adds.w	r2, r1, #16
    e85e:	d03a      	beq.n	e8d6 <i2c_nrfx_twim_transfer+0x44e>
    e860:	2010      	movs	r0, #16
    e862:	b11a      	cbz	r2, e86c <i2c_nrfx_twim_transfer+0x3e4>
    e864:	2804      	cmp	r0, #4
    e866:	dd01      	ble.n	e86c <i2c_nrfx_twim_transfer+0x3e4>
    e868:	4d2f      	ldr	r5, [pc, #188]	; (e928 <i2c_nrfx_twim_transfer+0x4a0>)
    e86a:	614d      	str	r5, [r1, #20]
    e86c:	b112      	cbz	r2, e874 <i2c_nrfx_twim_transfer+0x3ec>
    e86e:	2808      	cmp	r0, #8
    e870:	dd00      	ble.n	e874 <i2c_nrfx_twim_transfer+0x3ec>
    e872:	618b      	str	r3, [r1, #24]
    e874:	b112      	cbz	r2, e87c <i2c_nrfx_twim_transfer+0x3f4>
    e876:	280c      	cmp	r0, #12
    e878:	dd00      	ble.n	e87c <i2c_nrfx_twim_transfer+0x3f4>
    e87a:	61ce      	str	r6, [r1, #28]
    e87c:	280f      	cmp	r0, #15
    e87e:	dd2d      	ble.n	e8dc <i2c_nrfx_twim_transfer+0x454>
    e880:	2310      	movs	r3, #16
    e882:	b15a      	cbz	r2, e89c <i2c_nrfx_twim_transfer+0x414>
    e884:	2004      	movs	r0, #4
    e886:	f887 0028 	strb.w	r0, [r7, #40]	; 0x28
    e88a:	2000      	movs	r0, #0
    e88c:	f887 0029 	strb.w	r0, [r7, #41]	; 0x29
    e890:	f887 002a 	strb.w	r0, [r7, #42]	; 0x2a
    e894:	f887 002b 	strb.w	r0, [r7, #43]	; 0x2b
    e898:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    e89a:	6108      	str	r0, [r1, #16]
    e89c:	2100      	movs	r1, #0
    e89e:	f36f 0100 	bfc	r1, #0, #1
    e8a2:	f36f 0141 	bfc	r1, #1, #1
    e8a6:	f36f 0182 	bfc	r1, #2, #1
    e8aa:	f36f 01c5 	bfc	r1, #3, #3
    e8ae:	2001      	movs	r0, #1
    e8b0:	f360 1188 	bfi	r1, r0, #6, #3
    e8b4:	f403 737d 	and.w	r3, r3, #1012	; 0x3f4
    e8b8:	f363 2152 	bfi	r1, r3, #9, #10
    e8bc:	f36f 41de 	bfc	r1, #19, #12
    e8c0:	f36f 71df 	bfc	r1, #31, #1
    e8c4:	2300      	movs	r3, #0
    e8c6:	4817      	ldr	r0, [pc, #92]	; (e924 <i2c_nrfx_twim_transfer+0x49c>)
    e8c8:	f7f3 fcbe 	bl	2248 <z_impl_z_log_msg_static_create>
    e8cc:	46a5      	mov	sp, r4
			ret = -EIO;
    e8ce:	f06f 0304 	mvn.w	r3, #4
    e8d2:	617b      	str	r3, [r7, #20]
			break;
    e8d4:	e01b      	b.n	e90e <i2c_nrfx_twim_transfer+0x486>
			LOG_ERR("Error 0x%08X occurred for message %d", res, i);
    e8d6:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    e8da:	e7c2      	b.n	e862 <i2c_nrfx_twim_transfer+0x3da>
    e8dc:	f06f 031b 	mvn.w	r3, #27
    e8e0:	e7cf      	b.n	e882 <i2c_nrfx_twim_transfer+0x3fa>
			while (msg_buf_used >= msgs[j].len) {
    e8e2:	4615      	mov	r5, r2
    e8e4:	e007      	b.n	e8f6 <i2c_nrfx_twim_transfer+0x46e>
				msg_buf_used -= msgs[j].len;
    e8e6:	1aa4      	subs	r4, r4, r2
    e8e8:	b2a4      	uxth	r4, r4
				memcpy(msgs[j].buf,
    e8ea:	1929      	adds	r1, r5, r4
    e8ec:	f859 0000 	ldr.w	r0, [r9, r0]
    e8f0:	f008 ff1e 	bl	17730 <memcpy>
				j--;
    e8f4:	3e01      	subs	r6, #1
			while (msg_buf_used >= msgs[j].len) {
    e8f6:	eb06 0346 	add.w	r3, r6, r6, lsl #1
    e8fa:	0098      	lsls	r0, r3, #2
    e8fc:	eb09 0383 	add.w	r3, r9, r3, lsl #2
    e900:	685a      	ldr	r2, [r3, #4]
    e902:	4294      	cmp	r4, r2
    e904:	d2ef      	bcs.n	e8e6 <i2c_nrfx_twim_transfer+0x45e>
    e906:	e635      	b.n	e574 <i2c_nrfx_twim_transfer+0xec>
			ret = -ENOTSUP;
    e908:	f06f 0385 	mvn.w	r3, #133	; 0x85
    e90c:	617b      	str	r3, [r7, #20]
	z_impl_k_sem_give(sem);
    e90e:	68b8      	ldr	r0, [r7, #8]
    e910:	f005 f93e 	bl	13b90 <z_impl_k_sem_give>
}
    e914:	6978      	ldr	r0, [r7, #20]
    e916:	3744      	adds	r7, #68	; 0x44
    e918:	46bd      	mov	sp, r7
    e91a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e91e:	bf00      	nop
    e920:	0001f650 	.word	0x0001f650
    e924:	0001d03c 	.word	0x0001d03c
    e928:	0001f67c 	.word	0x0001f67c

0000e92c <configure>:
	}
}

static int configure(const struct device *dev,
		     const struct spi_config *spi_cfg)
{
    e92c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e930:	b0a1      	sub	sp, #132	; 0x84
    e932:	af00      	add	r7, sp, #0
    e934:	460c      	mov	r4, r1
	struct spi_nrfx_data *dev_data = dev->data;
    e936:	6905      	ldr	r5, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
    e938:	6846      	ldr	r6, [r0, #4]
	struct spi_context *ctx = &dev_data->ctx;
	uint32_t max_freq = dev_config->max_freq;
    e93a:	f8d6 9008 	ldr.w	r9, [r6, #8]
	nrfx_spim_config_t config;
	nrfx_err_t result;

	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
    e93e:	f895 806d 	ldrb.w	r8, [r5, #109]	; 0x6d
    e942:	f1b8 0f00 	cmp.w	r8, #0
    e946:	d003      	beq.n	e950 <configure+0x24>
	._ctx_name.num_cs_gpios = DT_PROP_LEN_OR(_node_id, cs_gpios, 0),

static inline bool spi_context_configured(struct spi_context *ctx,
					  const struct spi_config *config)
{
	return !!(ctx->config == config);
    e948:	682b      	ldr	r3, [r5, #0]
    e94a:	428b      	cmp	r3, r1
    e94c:	f000 81ea 	beq.w	ed24 <configure+0x3f8>
		/* Already configured. No need to do it again. */
		return 0;
	}

	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
    e950:	88a3      	ldrh	r3, [r4, #4]
    e952:	f413 6f00 	tst.w	r3, #2048	; 0x800
    e956:	d14f      	bne.n	e9f8 <configure+0xcc>
		LOG_ERR("Half-duplex not supported");
		return -ENOTSUP;
	}

	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    e958:	f013 0f01 	tst.w	r3, #1
    e95c:	d171      	bne.n	ea42 <configure+0x116>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
		return -EINVAL;
	}

	if (spi_cfg->operation & SPI_MODE_LOOP) {
    e95e:	f013 0f08 	tst.w	r3, #8
    e962:	f040 80c0 	bne.w	eae6 <configure+0x1ba>
	    (spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
		LOG_ERR("Only single line mode is supported");
		return -EINVAL;
	}

	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    e966:	f3c3 1345 	ubfx	r3, r3, #5, #6
    e96a:	2b08      	cmp	r3, #8
    e96c:	f040 80e0 	bne.w	eb30 <configure+0x204>
		LOG_ERR("Word sizes other than 8 bits are not supported");
		return -EINVAL;
	}

	if (spi_cfg->frequency < 125000) {
    e970:	6822      	ldr	r2, [r4, #0]
    e972:	4bbc      	ldr	r3, [pc, #752]	; (ec64 <configure+0x338>)
    e974:	429a      	cmp	r2, r3
    e976:	f240 8100 	bls.w	eb7a <configure+0x24e>
#if defined(CONFIG_SOC_NRF5340_CPUAPP)
	/* On nRF5340, the 32 Mbps speed is supported by the application core
	 * when it is running at 128 MHz (see the Timing specifications section
	 * in the nRF5340 PS).
	 */
	if (max_freq > 16000000 &&
    e97a:	4bbb      	ldr	r3, [pc, #748]	; (ec68 <configure+0x33c>)
    e97c:	4599      	cmp	r9, r3
    e97e:	d908      	bls.n	e992 <configure+0x66>
                        CLOCK_HFCLKCTRL_HCLK_Msk);
}

NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
    e980:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e984:	f8d3 3558 	ldr.w	r3, [r3, #1368]	; 0x558
    e988:	f013 0f03 	tst.w	r3, #3
    e98c:	d001      	beq.n	e992 <configure+0x66>
	    nrf_clock_hfclk_div_get(NRF_CLOCK) != NRF_CLOCK_HFCLK_DIV_1) {
		max_freq = 16000000;
    e98e:	f8df 92d8 	ldr.w	r9, [pc, #728]	; ec68 <configure+0x33c>
	}
#endif

	config = dev_config->def_config;
    e992:	f107 0c08 	add.w	ip, r7, #8
    e996:	f106 0e0c 	add.w	lr, r6, #12
    e99a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
    e99e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    e9a2:	e89e 0003 	ldmia.w	lr, {r0, r1}
    e9a6:	e88c 0003 	stmia.w	ip, {r0, r1}

	/* Limit the frequency to that supported by the SPIM instance. */
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
    e9aa:	6823      	ldr	r3, [r4, #0]
    e9ac:	454b      	cmp	r3, r9
    e9ae:	bf28      	it	cs
    e9b0:	464b      	movcs	r3, r9
	if (frequency < 250000) {
    e9b2:	4aae      	ldr	r2, [pc, #696]	; (ec6c <configure+0x340>)
    e9b4:	4293      	cmp	r3, r2
    e9b6:	f240 8105 	bls.w	ebc4 <configure+0x298>
	} else if (frequency < 500000) {
    e9ba:	4aad      	ldr	r2, [pc, #692]	; (ec70 <configure+0x344>)
    e9bc:	4293      	cmp	r3, r2
    e9be:	f240 8129 	bls.w	ec14 <configure+0x2e8>
	} else if (frequency < 1000000) {
    e9c2:	4aac      	ldr	r2, [pc, #688]	; (ec74 <configure+0x348>)
    e9c4:	4293      	cmp	r3, r2
    e9c6:	f240 8128 	bls.w	ec1a <configure+0x2ee>
	} else if (frequency < 2000000) {
    e9ca:	4aab      	ldr	r2, [pc, #684]	; (ec78 <configure+0x34c>)
    e9cc:	4293      	cmp	r3, r2
    e9ce:	f240 8127 	bls.w	ec20 <configure+0x2f4>
	} else if (frequency < 4000000) {
    e9d2:	4aaa      	ldr	r2, [pc, #680]	; (ec7c <configure+0x350>)
    e9d4:	4293      	cmp	r3, r2
    e9d6:	f240 8126 	bls.w	ec26 <configure+0x2fa>
	} else if (frequency < 8000000) {
    e9da:	4aa9      	ldr	r2, [pc, #676]	; (ec80 <configure+0x354>)
    e9dc:	4293      	cmp	r3, r2
    e9de:	f0c0 8125 	bcc.w	ec2c <configure+0x300>
	} else if (frequency < 16000000) {
    e9e2:	4aa1      	ldr	r2, [pc, #644]	; (ec68 <configure+0x33c>)
    e9e4:	4293      	cmp	r3, r2
    e9e6:	f0c0 8124 	bcc.w	ec32 <configure+0x306>
	} else if (frequency < 32000000) {
    e9ea:	4aa6      	ldr	r2, [pc, #664]	; (ec84 <configure+0x358>)
    e9ec:	4293      	cmp	r3, r2
    e9ee:	f080 8123 	bcs.w	ec38 <configure+0x30c>
		return NRF_SPIM_FREQ_16M;
    e9f2:	f04f 6320 	mov.w	r3, #167772160	; 0xa000000
    e9f6:	e0e7      	b.n	ebc8 <configure+0x29c>
		LOG_ERR("Half-duplex not supported");
    e9f8:	4ba3      	ldr	r3, [pc, #652]	; (ec88 <configure+0x35c>)
    e9fa:	67fb      	str	r3, [r7, #124]	; 0x7c
    e9fc:	2302      	movs	r3, #2
    e9fe:	713b      	strb	r3, [r7, #4]
    ea00:	2300      	movs	r3, #0
    ea02:	717b      	strb	r3, [r7, #5]
    ea04:	71bb      	strb	r3, [r7, #6]
    ea06:	71fb      	strb	r3, [r7, #7]
    ea08:	687a      	ldr	r2, [r7, #4]
    ea0a:	67ba      	str	r2, [r7, #120]	; 0x78
    ea0c:	4619      	mov	r1, r3
    ea0e:	f363 0100 	bfi	r1, r3, #0, #1
    ea12:	f363 0141 	bfi	r1, r3, #1, #1
    ea16:	f363 0182 	bfi	r1, r3, #2, #1
    ea1a:	f363 01c5 	bfi	r1, r3, #3, #3
    ea1e:	2201      	movs	r2, #1
    ea20:	f362 1188 	bfi	r1, r2, #6, #3
    ea24:	2208      	movs	r2, #8
    ea26:	f362 2152 	bfi	r1, r2, #9, #10
    ea2a:	f363 41de 	bfi	r1, r3, #19, #12
    ea2e:	f363 71df 	bfi	r1, r3, #31, #1
    ea32:	f107 0278 	add.w	r2, r7, #120	; 0x78
    ea36:	4895      	ldr	r0, [pc, #596]	; (ec8c <configure+0x360>)
    ea38:	f7f3 fc06 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ENOTSUP;
    ea3c:	f06f 0085 	mvn.w	r0, #133	; 0x85
    ea40:	e0e4      	b.n	ec0c <configure+0x2e0>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
    ea42:	6800      	ldr	r0, [r0, #0]
    ea44:	2302      	movs	r3, #2
    ea46:	713b      	strb	r3, [r7, #4]
    ea48:	466c      	mov	r4, sp
    ea4a:	b088      	sub	sp, #32
    ea4c:	466b      	mov	r3, sp
    ea4e:	f113 0210 	adds.w	r2, r3, #16
    ea52:	d039      	beq.n	eac8 <configure+0x19c>
    ea54:	250d      	movs	r5, #13
    ea56:	b11a      	cbz	r2, ea60 <configure+0x134>
    ea58:	2d04      	cmp	r5, #4
    ea5a:	dd01      	ble.n	ea60 <configure+0x134>
    ea5c:	498c      	ldr	r1, [pc, #560]	; (ec90 <configure+0x364>)
    ea5e:	6159      	str	r1, [r3, #20]
    ea60:	2102      	movs	r1, #2
    ea62:	7039      	strb	r1, [r7, #0]
    ea64:	b112      	cbz	r2, ea6c <configure+0x140>
    ea66:	2d08      	cmp	r5, #8
    ea68:	dd00      	ble.n	ea6c <configure+0x140>
    ea6a:	6198      	str	r0, [r3, #24]
    ea6c:	b11a      	cbz	r2, ea76 <configure+0x14a>
    ea6e:	f103 011c 	add.w	r1, r3, #28
    ea72:	2000      	movs	r0, #0
    ea74:	b358      	cbz	r0, eace <configure+0x1a2>
    ea76:	2d0c      	cmp	r5, #12
    ea78:	dd32      	ble.n	eae0 <configure+0x1b4>
    ea7a:	250d      	movs	r5, #13
    ea7c:	b142      	cbz	r2, ea90 <configure+0x164>
    ea7e:	2103      	movs	r1, #3
    ea80:	7139      	strb	r1, [r7, #4]
    ea82:	2100      	movs	r1, #0
    ea84:	7179      	strb	r1, [r7, #5]
    ea86:	71b9      	strb	r1, [r7, #6]
    ea88:	2101      	movs	r1, #1
    ea8a:	71f9      	strb	r1, [r7, #7]
    ea8c:	6878      	ldr	r0, [r7, #4]
    ea8e:	6118      	str	r0, [r3, #16]
    ea90:	2100      	movs	r1, #0
    ea92:	f36f 0100 	bfc	r1, #0, #1
    ea96:	f36f 0141 	bfc	r1, #1, #1
    ea9a:	f36f 0182 	bfc	r1, #2, #1
    ea9e:	f36f 01c5 	bfc	r1, #3, #3
    eaa2:	2301      	movs	r3, #1
    eaa4:	f363 1188 	bfi	r1, r3, #6, #3
    eaa8:	f3c5 0309 	ubfx	r3, r5, #0, #10
    eaac:	f363 2152 	bfi	r1, r3, #9, #10
    eab0:	f36f 41de 	bfc	r1, #19, #12
    eab4:	f36f 71df 	bfc	r1, #31, #1
    eab8:	2300      	movs	r3, #0
    eaba:	4874      	ldr	r0, [pc, #464]	; (ec8c <configure+0x360>)
    eabc:	f7f3 fbc4 	bl	2248 <z_impl_z_log_msg_static_create>
    eac0:	46a5      	mov	sp, r4
		return -EINVAL;
    eac2:	f06f 0015 	mvn.w	r0, #21
    eac6:	e0a1      	b.n	ec0c <configure+0x2e0>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
    eac8:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    eacc:	e7c3      	b.n	ea56 <configure+0x12a>
    eace:	f107 0680 	add.w	r6, r7, #128	; 0x80
    ead2:	4406      	add	r6, r0
    ead4:	f816 6c80 	ldrb.w	r6, [r6, #-128]
    ead8:	f801 6b01 	strb.w	r6, [r1], #1
    eadc:	3001      	adds	r0, #1
    eade:	e7c9      	b.n	ea74 <configure+0x148>
    eae0:	f06f 051b 	mvn.w	r5, #27
    eae4:	e7ca      	b.n	ea7c <configure+0x150>
		LOG_ERR("Loopback mode is not supported");
    eae6:	4b6b      	ldr	r3, [pc, #428]	; (ec94 <configure+0x368>)
    eae8:	667b      	str	r3, [r7, #100]	; 0x64
    eaea:	2302      	movs	r3, #2
    eaec:	713b      	strb	r3, [r7, #4]
    eaee:	2300      	movs	r3, #0
    eaf0:	717b      	strb	r3, [r7, #5]
    eaf2:	71bb      	strb	r3, [r7, #6]
    eaf4:	71fb      	strb	r3, [r7, #7]
    eaf6:	687a      	ldr	r2, [r7, #4]
    eaf8:	663a      	str	r2, [r7, #96]	; 0x60
    eafa:	4619      	mov	r1, r3
    eafc:	f363 0100 	bfi	r1, r3, #0, #1
    eb00:	f363 0141 	bfi	r1, r3, #1, #1
    eb04:	f363 0182 	bfi	r1, r3, #2, #1
    eb08:	f363 01c5 	bfi	r1, r3, #3, #3
    eb0c:	2201      	movs	r2, #1
    eb0e:	f362 1188 	bfi	r1, r2, #6, #3
    eb12:	2208      	movs	r2, #8
    eb14:	f362 2152 	bfi	r1, r2, #9, #10
    eb18:	f363 41de 	bfi	r1, r3, #19, #12
    eb1c:	f363 71df 	bfi	r1, r3, #31, #1
    eb20:	f107 0260 	add.w	r2, r7, #96	; 0x60
    eb24:	4859      	ldr	r0, [pc, #356]	; (ec8c <configure+0x360>)
    eb26:	f7f3 fb8f 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    eb2a:	f06f 0015 	mvn.w	r0, #21
    eb2e:	e06d      	b.n	ec0c <configure+0x2e0>
		LOG_ERR("Word sizes other than 8 bits are not supported");
    eb30:	4b59      	ldr	r3, [pc, #356]	; (ec98 <configure+0x36c>)
    eb32:	64fb      	str	r3, [r7, #76]	; 0x4c
    eb34:	2302      	movs	r3, #2
    eb36:	713b      	strb	r3, [r7, #4]
    eb38:	2300      	movs	r3, #0
    eb3a:	717b      	strb	r3, [r7, #5]
    eb3c:	71bb      	strb	r3, [r7, #6]
    eb3e:	71fb      	strb	r3, [r7, #7]
    eb40:	687a      	ldr	r2, [r7, #4]
    eb42:	64ba      	str	r2, [r7, #72]	; 0x48
    eb44:	4619      	mov	r1, r3
    eb46:	f363 0100 	bfi	r1, r3, #0, #1
    eb4a:	f363 0141 	bfi	r1, r3, #1, #1
    eb4e:	f363 0182 	bfi	r1, r3, #2, #1
    eb52:	f363 01c5 	bfi	r1, r3, #3, #3
    eb56:	2201      	movs	r2, #1
    eb58:	f362 1188 	bfi	r1, r2, #6, #3
    eb5c:	2208      	movs	r2, #8
    eb5e:	f362 2152 	bfi	r1, r2, #9, #10
    eb62:	f363 41de 	bfi	r1, r3, #19, #12
    eb66:	f363 71df 	bfi	r1, r3, #31, #1
    eb6a:	f107 0248 	add.w	r2, r7, #72	; 0x48
    eb6e:	4847      	ldr	r0, [pc, #284]	; (ec8c <configure+0x360>)
    eb70:	f7f3 fb6a 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    eb74:	f06f 0015 	mvn.w	r0, #21
    eb78:	e048      	b.n	ec0c <configure+0x2e0>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    eb7a:	4b48      	ldr	r3, [pc, #288]	; (ec9c <configure+0x370>)
    eb7c:	637b      	str	r3, [r7, #52]	; 0x34
    eb7e:	2302      	movs	r3, #2
    eb80:	713b      	strb	r3, [r7, #4]
    eb82:	2300      	movs	r3, #0
    eb84:	717b      	strb	r3, [r7, #5]
    eb86:	71bb      	strb	r3, [r7, #6]
    eb88:	71fb      	strb	r3, [r7, #7]
    eb8a:	687a      	ldr	r2, [r7, #4]
    eb8c:	633a      	str	r2, [r7, #48]	; 0x30
    eb8e:	4619      	mov	r1, r3
    eb90:	f363 0100 	bfi	r1, r3, #0, #1
    eb94:	f363 0141 	bfi	r1, r3, #1, #1
    eb98:	f363 0182 	bfi	r1, r3, #2, #1
    eb9c:	f363 01c5 	bfi	r1, r3, #3, #3
    eba0:	2201      	movs	r2, #1
    eba2:	f362 1188 	bfi	r1, r2, #6, #3
    eba6:	2208      	movs	r2, #8
    eba8:	f362 2152 	bfi	r1, r2, #9, #10
    ebac:	f363 41de 	bfi	r1, r3, #19, #12
    ebb0:	f363 71df 	bfi	r1, r3, #31, #1
    ebb4:	f107 0230 	add.w	r2, r7, #48	; 0x30
    ebb8:	4834      	ldr	r0, [pc, #208]	; (ec8c <configure+0x360>)
    ebba:	f7f3 fb45 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EINVAL;
    ebbe:	f06f 0015 	mvn.w	r0, #21
    ebc2:	e023      	b.n	ec0c <configure+0x2e0>
		return NRF_SPIM_FREQ_125K;
    ebc4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
    ebc8:	613b      	str	r3, [r7, #16]
						      max_freq));
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
    ebca:	88a3      	ldrh	r3, [r4, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    ebcc:	f013 0f02 	tst.w	r3, #2
    ebd0:	d035      	beq.n	ec3e <configure+0x312>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
    ebd2:	f013 0f04 	tst.w	r3, #4
    ebd6:	d037      	beq.n	ec48 <configure+0x31c>
			return NRF_SPIM_MODE_3;
    ebd8:	2303      	movs	r3, #3
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
    ebda:	753b      	strb	r3, [r7, #20]
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
    ebdc:	88a3      	ldrh	r3, [r4, #4]
	if (operation & SPI_TRANSFER_LSB) {
    ebde:	f013 0f10 	tst.w	r3, #16
    ebe2:	d035      	beq.n	ec50 <configure+0x324>
		return NRF_SPIM_BIT_ORDER_LSB_FIRST;
    ebe4:	2301      	movs	r3, #1
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
    ebe6:	757b      	strb	r3, [r7, #21]

	if (dev_data->initialized) {
    ebe8:	f1b8 0f00 	cmp.w	r8, #0
    ebec:	d132      	bne.n	ec54 <configure+0x328>
		nrfx_spim_uninit(&dev_config->spim);
		dev_data->initialized = false;
	}

	result = nrfx_spim_init(&dev_config->spim, &config,
    ebee:	462b      	mov	r3, r5
    ebf0:	4a2b      	ldr	r2, [pc, #172]	; (eca0 <configure+0x374>)
    ebf2:	f107 0108 	add.w	r1, r7, #8
    ebf6:	4630      	mov	r0, r6
    ebf8:	f003 fa76 	bl	120e8 <nrfx_spim_init>
				event_handler, dev_data);
	if (result != NRFX_SUCCESS) {
    ebfc:	4b29      	ldr	r3, [pc, #164]	; (eca4 <configure+0x378>)
    ebfe:	4298      	cmp	r0, r3
    ec00:	d152      	bne.n	eca8 <configure+0x37c>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
		return -EIO;
	}

	dev_data->initialized = true;
    ec02:	2301      	movs	r3, #1
    ec04:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d

	ctx->config = spi_cfg;
    ec08:	602c      	str	r4, [r5, #0]

	return 0;
    ec0a:	2000      	movs	r0, #0
}
    ec0c:	3784      	adds	r7, #132	; 0x84
    ec0e:	46bd      	mov	sp, r7
    ec10:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return NRF_SPIM_FREQ_250K;
    ec14:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    ec18:	e7d6      	b.n	ebc8 <configure+0x29c>
		return NRF_SPIM_FREQ_500K;
    ec1a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    ec1e:	e7d3      	b.n	ebc8 <configure+0x29c>
		return NRF_SPIM_FREQ_1M;
    ec20:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    ec24:	e7d0      	b.n	ebc8 <configure+0x29c>
		return NRF_SPIM_FREQ_2M;
    ec26:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    ec2a:	e7cd      	b.n	ebc8 <configure+0x29c>
		return NRF_SPIM_FREQ_4M;
    ec2c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    ec30:	e7ca      	b.n	ebc8 <configure+0x29c>
		return NRF_SPIM_FREQ_8M;
    ec32:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    ec36:	e7c7      	b.n	ebc8 <configure+0x29c>
		return NRF_SPIM_FREQ_32M;
    ec38:	f04f 53a0 	mov.w	r3, #335544320	; 0x14000000
    ec3c:	e7c4      	b.n	ebc8 <configure+0x29c>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
    ec3e:	f013 0f04 	tst.w	r3, #4
    ec42:	d003      	beq.n	ec4c <configure+0x320>
			return NRF_SPIM_MODE_1;
    ec44:	2301      	movs	r3, #1
    ec46:	e7c8      	b.n	ebda <configure+0x2ae>
			return NRF_SPIM_MODE_2;
    ec48:	2302      	movs	r3, #2
    ec4a:	e7c6      	b.n	ebda <configure+0x2ae>
			return NRF_SPIM_MODE_0;
    ec4c:	2300      	movs	r3, #0
    ec4e:	e7c4      	b.n	ebda <configure+0x2ae>
		return NRF_SPIM_BIT_ORDER_MSB_FIRST;
    ec50:	2300      	movs	r3, #0
    ec52:	e7c8      	b.n	ebe6 <configure+0x2ba>
		nrfx_spim_uninit(&dev_config->spim);
    ec54:	4630      	mov	r0, r6
    ec56:	f003 fac7 	bl	121e8 <nrfx_spim_uninit>
		dev_data->initialized = false;
    ec5a:	2300      	movs	r3, #0
    ec5c:	f885 306d 	strb.w	r3, [r5, #109]	; 0x6d
    ec60:	e7c5      	b.n	ebee <configure+0x2c2>
    ec62:	bf00      	nop
    ec64:	0001e847 	.word	0x0001e847
    ec68:	00f42400 	.word	0x00f42400
    ec6c:	0003d08f 	.word	0x0003d08f
    ec70:	0007a11f 	.word	0x0007a11f
    ec74:	000f423f 	.word	0x000f423f
    ec78:	001e847f 	.word	0x001e847f
    ec7c:	003d08ff 	.word	0x003d08ff
    ec80:	007a1200 	.word	0x007a1200
    ec84:	01e84800 	.word	0x01e84800
    ec88:	0001f718 	.word	0x0001f718
    ec8c:	0001d0a4 	.word	0x0001d0a4
    ec90:	0001f734 	.word	0x0001f734
    ec94:	0001f758 	.word	0x0001f758
    ec98:	0001f778 	.word	0x0001f778
    ec9c:	0001f7a8 	.word	0x0001f7a8
    eca0:	0000f165 	.word	0x0000f165
    eca4:	0bad0000 	.word	0x0bad0000
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
    eca8:	466d      	mov	r5, sp
    ecaa:	b088      	sub	sp, #32
    ecac:	466b      	mov	r3, sp
    ecae:	f113 0210 	adds.w	r2, r3, #16
    ecb2:	d031      	beq.n	ed18 <configure+0x3ec>
    ecb4:	210c      	movs	r1, #12
    ecb6:	b11a      	cbz	r2, ecc0 <configure+0x394>
    ecb8:	2904      	cmp	r1, #4
    ecba:	dd01      	ble.n	ecc0 <configure+0x394>
    ecbc:	4c1a      	ldr	r4, [pc, #104]	; (ed28 <configure+0x3fc>)
    ecbe:	615c      	str	r4, [r3, #20]
    ecc0:	b112      	cbz	r2, ecc8 <configure+0x39c>
    ecc2:	2908      	cmp	r1, #8
    ecc4:	dd00      	ble.n	ecc8 <configure+0x39c>
    ecc6:	6198      	str	r0, [r3, #24]
    ecc8:	290b      	cmp	r1, #11
    ecca:	dd28      	ble.n	ed1e <configure+0x3f2>
    eccc:	240c      	movs	r4, #12
    ecce:	b13a      	cbz	r2, ece0 <configure+0x3b4>
    ecd0:	2103      	movs	r1, #3
    ecd2:	7139      	strb	r1, [r7, #4]
    ecd4:	2100      	movs	r1, #0
    ecd6:	7179      	strb	r1, [r7, #5]
    ecd8:	71b9      	strb	r1, [r7, #6]
    ecda:	71f9      	strb	r1, [r7, #7]
    ecdc:	6878      	ldr	r0, [r7, #4]
    ecde:	6118      	str	r0, [r3, #16]
    ece0:	2100      	movs	r1, #0
    ece2:	f36f 0100 	bfc	r1, #0, #1
    ece6:	f36f 0141 	bfc	r1, #1, #1
    ecea:	f36f 0182 	bfc	r1, #2, #1
    ecee:	f36f 01c5 	bfc	r1, #3, #3
    ecf2:	2301      	movs	r3, #1
    ecf4:	f363 1188 	bfi	r1, r3, #6, #3
    ecf8:	f404 737b 	and.w	r3, r4, #1004	; 0x3ec
    ecfc:	f363 2152 	bfi	r1, r3, #9, #10
    ed00:	f36f 41de 	bfc	r1, #19, #12
    ed04:	f36f 71df 	bfc	r1, #31, #1
    ed08:	2300      	movs	r3, #0
    ed0a:	4808      	ldr	r0, [pc, #32]	; (ed2c <configure+0x400>)
    ed0c:	f7f3 fa9c 	bl	2248 <z_impl_z_log_msg_static_create>
    ed10:	46ad      	mov	sp, r5
		return -EIO;
    ed12:	f06f 0004 	mvn.w	r0, #4
    ed16:	e779      	b.n	ec0c <configure+0x2e0>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
    ed18:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    ed1c:	e7cb      	b.n	ecb6 <configure+0x38a>
    ed1e:	f06f 041b 	mvn.w	r4, #27
    ed22:	e7d4      	b.n	ecce <configure+0x3a2>
		return 0;
    ed24:	2000      	movs	r0, #0
    ed26:	e771      	b.n	ec0c <configure+0x2e0>
    ed28:	0001f7dc 	.word	0x0001f7dc
    ed2c:	0001d0a4 	.word	0x0001d0a4

0000ed30 <spi_context_cs_configure_all>:
	k_sem_give(&ctx->sync);
#endif /* CONFIG_SPI_ASYNC */
}

static inline int spi_context_cs_configure_all(struct spi_context *ctx)
{
    ed30:	b5f0      	push	{r4, r5, r6, r7, lr}
    ed32:	b083      	sub	sp, #12
    ed34:	af00      	add	r7, sp, #0
    ed36:	4605      	mov	r5, r0
	int ret;
	const struct gpio_dt_spec *cs_gpio;

	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
    ed38:	6884      	ldr	r4, [r0, #8]
    ed3a:	e069      	b.n	ee10 <spi_context_cs_configure_all+0xe0>
		if (!device_is_ready(cs_gpio->port)) {
			LOG_ERR("CS GPIO port %s pin %d is not ready",
    ed3c:	6823      	ldr	r3, [r4, #0]
    ed3e:	681e      	ldr	r6, [r3, #0]
    ed40:	7920      	ldrb	r0, [r4, #4]
    ed42:	2302      	movs	r3, #2
    ed44:	713b      	strb	r3, [r7, #4]
    ed46:	466c      	mov	r4, sp
    ed48:	b08a      	sub	sp, #40	; 0x28
    ed4a:	466b      	mov	r3, sp
    ed4c:	f113 0210 	adds.w	r2, r3, #16
    ed50:	d03d      	beq.n	edce <spi_context_cs_configure_all+0x9e>
    ed52:	2511      	movs	r5, #17
    ed54:	b11a      	cbz	r2, ed5e <spi_context_cs_configure_all+0x2e>
    ed56:	2d04      	cmp	r5, #4
    ed58:	dd01      	ble.n	ed5e <spi_context_cs_configure_all+0x2e>
    ed5a:	4941      	ldr	r1, [pc, #260]	; (ee60 <spi_context_cs_configure_all+0x130>)
    ed5c:	6159      	str	r1, [r3, #20]
    ed5e:	2102      	movs	r1, #2
    ed60:	7039      	strb	r1, [r7, #0]
    ed62:	b112      	cbz	r2, ed6a <spi_context_cs_configure_all+0x3a>
    ed64:	2d08      	cmp	r5, #8
    ed66:	dd00      	ble.n	ed6a <spi_context_cs_configure_all+0x3a>
    ed68:	619e      	str	r6, [r3, #24]
    ed6a:	b112      	cbz	r2, ed72 <spi_context_cs_configure_all+0x42>
    ed6c:	2d0c      	cmp	r5, #12
    ed6e:	dd00      	ble.n	ed72 <spi_context_cs_configure_all+0x42>
    ed70:	61d8      	str	r0, [r3, #28]
    ed72:	b11a      	cbz	r2, ed7c <spi_context_cs_configure_all+0x4c>
    ed74:	f103 0120 	add.w	r1, r3, #32
    ed78:	2000      	movs	r0, #0
    ed7a:	b358      	cbz	r0, edd4 <spi_context_cs_configure_all+0xa4>
    ed7c:	2d10      	cmp	r5, #16
    ed7e:	dd32      	ble.n	ede6 <spi_context_cs_configure_all+0xb6>
    ed80:	2511      	movs	r5, #17
    ed82:	b142      	cbz	r2, ed96 <spi_context_cs_configure_all+0x66>
    ed84:	2104      	movs	r1, #4
    ed86:	7139      	strb	r1, [r7, #4]
    ed88:	2100      	movs	r1, #0
    ed8a:	7179      	strb	r1, [r7, #5]
    ed8c:	71b9      	strb	r1, [r7, #6]
    ed8e:	2101      	movs	r1, #1
    ed90:	71f9      	strb	r1, [r7, #7]
    ed92:	6878      	ldr	r0, [r7, #4]
    ed94:	6118      	str	r0, [r3, #16]
    ed96:	2100      	movs	r1, #0
    ed98:	f36f 0100 	bfc	r1, #0, #1
    ed9c:	f36f 0141 	bfc	r1, #1, #1
    eda0:	f36f 0182 	bfc	r1, #2, #1
    eda4:	f36f 01c5 	bfc	r1, #3, #3
    eda8:	2301      	movs	r3, #1
    edaa:	f363 1188 	bfi	r1, r3, #6, #3
    edae:	f3c5 0309 	ubfx	r3, r5, #0, #10
    edb2:	f363 2152 	bfi	r1, r3, #9, #10
    edb6:	f36f 41de 	bfc	r1, #19, #12
    edba:	f36f 71df 	bfc	r1, #31, #1
    edbe:	2300      	movs	r3, #0
    edc0:	4828      	ldr	r0, [pc, #160]	; (ee64 <spi_context_cs_configure_all+0x134>)
    edc2:	f7f3 fa41 	bl	2248 <z_impl_z_log_msg_static_create>
    edc6:	46a5      	mov	sp, r4
				cs_gpio->port->name, cs_gpio->pin);
			return -ENODEV;
    edc8:	f06f 0012 	mvn.w	r0, #18
    edcc:	e045      	b.n	ee5a <spi_context_cs_configure_all+0x12a>
			LOG_ERR("CS GPIO port %s pin %d is not ready",
    edce:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    edd2:	e7bf      	b.n	ed54 <spi_context_cs_configure_all+0x24>
    edd4:	f107 0608 	add.w	r6, r7, #8
    edd8:	4406      	add	r6, r0
    edda:	f816 6c08 	ldrb.w	r6, [r6, #-8]
    edde:	f801 6b01 	strb.w	r6, [r1], #1
    ede2:	3001      	adds	r0, #1
    ede4:	e7c9      	b.n	ed7a <spi_context_cs_configure_all+0x4a>
    ede6:	f06f 051b 	mvn.w	r5, #27
    edea:	e7ca      	b.n	ed82 <spi_context_cs_configure_all+0x52>
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
    edec:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    edf0:	f013 0f01 	tst.w	r3, #1
    edf4:	d028      	beq.n	ee48 <spi_context_cs_configure_all+0x118>
		data->invert |= (gpio_port_pins_t)BIT(pin);
    edf6:	2301      	movs	r3, #1
    edf8:	fa03 fe01 	lsl.w	lr, r3, r1
    edfc:	6833      	ldr	r3, [r6, #0]
    edfe:	ea43 030e 	orr.w	r3, r3, lr
    ee02:	6033      	str	r3, [r6, #0]
	return api->pin_configure(port, pin, flags);
    ee04:	f8dc 3000 	ldr.w	r3, [ip]
    ee08:	4798      	blx	r3
		}

		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
		if (ret < 0) {
    ee0a:	2800      	cmp	r0, #0
    ee0c:	db25      	blt.n	ee5a <spi_context_cs_configure_all+0x12a>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
    ee0e:	3408      	adds	r4, #8
    ee10:	68ab      	ldr	r3, [r5, #8]
    ee12:	68ea      	ldr	r2, [r5, #12]
    ee14:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    ee18:	429c      	cmp	r4, r3
    ee1a:	d21d      	bcs.n	ee58 <spi_context_cs_configure_all+0x128>
		if (!device_is_ready(cs_gpio->port)) {
    ee1c:	6820      	ldr	r0, [r4, #0]
    ee1e:	f00c ffd6 	bl	1bdce <z_device_is_ready>
    ee22:	2800      	cmp	r0, #0
    ee24:	d08a      	beq.n	ed3c <spi_context_cs_configure_all+0xc>
	return gpio_pin_configure(spec->port,
    ee26:	6820      	ldr	r0, [r4, #0]
    ee28:	7921      	ldrb	r1, [r4, #4]
				  spec->dt_flags | extra_flags);
    ee2a:	88e3      	ldrh	r3, [r4, #6]
	return gpio_pin_configure(spec->port,
    ee2c:	f443 13b0 	orr.w	r3, r3, #1441792	; 0x160000
	const struct gpio_driver_api *api =
    ee30:	f8d0 c008 	ldr.w	ip, [r0, #8]
	struct gpio_driver_data *data =
    ee34:	6906      	ldr	r6, [r0, #16]
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
    ee36:	f413 2f40 	tst.w	r3, #786432	; 0xc0000
    ee3a:	d0d7      	beq.n	edec <spi_context_cs_configure_all+0xbc>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    ee3c:	f013 0f01 	tst.w	r3, #1
    ee40:	d0d4      	beq.n	edec <spi_context_cs_configure_all+0xbc>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    ee42:	f483 2340 	eor.w	r3, r3, #786432	; 0xc0000
    ee46:	e7d1      	b.n	edec <spi_context_cs_configure_all+0xbc>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    ee48:	2301      	movs	r3, #1
    ee4a:	fa03 fe01 	lsl.w	lr, r3, r1
    ee4e:	6833      	ldr	r3, [r6, #0]
    ee50:	ea23 030e 	bic.w	r3, r3, lr
    ee54:	6033      	str	r3, [r6, #0]
    ee56:	e7d5      	b.n	ee04 <spi_context_cs_configure_all+0xd4>
			return ret;
		}
	}

	return 0;
    ee58:	2000      	movs	r0, #0
}
    ee5a:	370c      	adds	r7, #12
    ee5c:	46bd      	mov	sp, r7
    ee5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ee60:	0001f804 	.word	0x0001f804
    ee64:	0001d0a4 	.word	0x0001d0a4

0000ee68 <transfer_next_chunk>:
	return 0;
}
#endif

static void transfer_next_chunk(const struct device *dev)
{
    ee68:	b570      	push	{r4, r5, r6, lr}
    ee6a:	b084      	sub	sp, #16
	struct spi_nrfx_data *dev_data = dev->data;
    ee6c:	6904      	ldr	r4, [r0, #16]
	const struct spi_nrfx_config *dev_config = dev->config;
    ee6e:	6846      	ldr	r6, [r0, #4]
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    ee70:	6da3      	ldr	r3, [r4, #88]	; 0x58
    ee72:	2b00      	cmp	r3, #0
    ee74:	d068      	beq.n	ef48 <transfer_next_chunk+0xe0>
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    ee76:	6e25      	ldr	r5, [r4, #96]	; 0x60
    ee78:	2d00      	cmp	r5, #0
    ee7a:	d067      	beq.n	ef4c <transfer_next_chunk+0xe4>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
    ee7c:	429d      	cmp	r5, r3
    ee7e:	bf28      	it	cs
    ee80:	461d      	movcs	r5, r3
	struct spi_context *ctx = &dev_data->ctx;
	int error = 0;

	size_t chunk_len = spi_context_max_continuous_chunk(ctx);

	if (chunk_len > 0) {
    ee82:	2d00      	cmp	r5, #0
    ee84:	d072      	beq.n	ef6c <transfer_next_chunk+0x104>
		nrfx_spim_xfer_desc_t xfer;
		nrfx_err_t result;
		const uint8_t *tx_buf = ctx->tx_buf;
    ee86:	6d61      	ldr	r1, [r4, #84]	; 0x54
	return !!(ctx->tx_buf && ctx->tx_len);
    ee88:	2900      	cmp	r1, #0
    ee8a:	d061      	beq.n	ef50 <transfer_next_chunk+0xe8>
    ee8c:	2b00      	cmp	r3, #0
    ee8e:	d161      	bne.n	ef54 <transfer_next_chunk+0xec>
#if (CONFIG_SPI_NRFX_RAM_BUFFER_SIZE > 0)
		if (spi_context_tx_buf_on(ctx) && !nrfx_is_in_ram(tx_buf)) {
    ee90:	b163      	cbz	r3, eeac <transfer_next_chunk+0x44>
    ee92:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
    ee96:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    ee9a:	d007      	beq.n	eeac <transfer_next_chunk+0x44>
			if (chunk_len > CONFIG_SPI_NRFX_RAM_BUFFER_SIZE) {
    ee9c:	2d08      	cmp	r5, #8
    ee9e:	d900      	bls.n	eea2 <transfer_next_chunk+0x3a>
				chunk_len = CONFIG_SPI_NRFX_RAM_BUFFER_SIZE;
    eea0:	2508      	movs	r5, #8
			}

			memcpy(dev_data->buffer, tx_buf, chunk_len);
    eea2:	462a      	mov	r2, r5
    eea4:	6f20      	ldr	r0, [r4, #112]	; 0x70
    eea6:	f008 fc43 	bl	17730 <memcpy>
			tx_buf = dev_data->buffer;
    eeaa:	6f21      	ldr	r1, [r4, #112]	; 0x70
		}
#endif
		if (chunk_len > MAX_CHUNK_LEN) {
    eeac:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
    eeb0:	d301      	bcc.n	eeb6 <transfer_next_chunk+0x4e>
			chunk_len = MAX_CHUNK_LEN;
    eeb2:	f64f 75ff 	movw	r5, #65535	; 0xffff
		}

		dev_data->chunk_len = chunk_len;
    eeb6:	66a5      	str	r5, [r4, #104]	; 0x68

		xfer.p_tx_buffer = tx_buf;
    eeb8:	9100      	str	r1, [sp, #0]
    eeba:	6d63      	ldr	r3, [r4, #84]	; 0x54
    eebc:	2b00      	cmp	r3, #0
    eebe:	d04b      	beq.n	ef58 <transfer_next_chunk+0xf0>
    eec0:	6da3      	ldr	r3, [r4, #88]	; 0x58
    eec2:	2b00      	cmp	r3, #0
    eec4:	d14a      	bne.n	ef5c <transfer_next_chunk+0xf4>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    eec6:	2b00      	cmp	r3, #0
    eec8:	d04a      	beq.n	ef60 <transfer_next_chunk+0xf8>
    eeca:	462b      	mov	r3, r5
    eecc:	9301      	str	r3, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    eece:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    eed0:	9302      	str	r3, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    eed2:	2b00      	cmp	r3, #0
    eed4:	d046      	beq.n	ef64 <transfer_next_chunk+0xfc>
    eed6:	6e23      	ldr	r3, [r4, #96]	; 0x60
    eed8:	2b00      	cmp	r3, #0
    eeda:	d145      	bne.n	ef68 <transfer_next_chunk+0x100>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    eedc:	b903      	cbnz	r3, eee0 <transfer_next_chunk+0x78>
    eede:	2500      	movs	r5, #0
    eee0:	9503      	str	r5, [sp, #12]
				error = -EIO;
			}
		}
#endif
		if (error == 0) {
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    eee2:	2200      	movs	r2, #0
    eee4:	4669      	mov	r1, sp
    eee6:	4630      	mov	r0, r6
    eee8:	f003 f9d2 	bl	12290 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
    eeec:	4b25      	ldr	r3, [pc, #148]	; (ef84 <transfer_next_chunk+0x11c>)
    eeee:	4298      	cmp	r0, r3
    eef0:	d028      	beq.n	ef44 <transfer_next_chunk+0xdc>
				return;
			}
			error = -EIO;
    eef2:	f06f 0504 	mvn.w	r5, #4
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    eef6:	6823      	ldr	r3, [r4, #0]
    eef8:	b1e3      	cbz	r3, ef34 <transfer_next_chunk+0xcc>
    eefa:	689a      	ldr	r2, [r3, #8]
    eefc:	b1d2      	cbz	r2, ef34 <transfer_next_chunk+0xcc>
    eefe:	6811      	ldr	r1, [r2, #0]
    ef00:	b1c1      	cbz	r1, ef34 <transfer_next_chunk+0xcc>
			    ctx->config->operation & SPI_HOLD_ON_CS) {
    ef02:	889b      	ldrh	r3, [r3, #4]
			if (!force_off &&
    ef04:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    ef08:	d114      	bne.n	ef34 <transfer_next_chunk+0xcc>
			k_busy_wait(ctx->config->cs->delay);
    ef0a:	6890      	ldr	r0, [r2, #8]
	z_impl_k_busy_wait(usec_to_wait);
    ef0c:	f00d fcff 	bl	1c90e <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
    ef10:	6823      	ldr	r3, [r4, #0]
    ef12:	689b      	ldr	r3, [r3, #8]
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
	return gpio_pin_set(spec->port, spec->pin, value);
    ef14:	6818      	ldr	r0, [r3, #0]
    ef16:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
    ef18:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    ef1a:	681a      	ldr	r2, [r3, #0]
    ef1c:	2301      	movs	r3, #1
    ef1e:	408b      	lsls	r3, r1
    ef20:	421a      	tst	r2, r3
    ef22:	d125      	bne.n	ef70 <transfer_next_chunk+0x108>
    ef24:	2300      	movs	r3, #0
	if (value != 0)	{
    ef26:	b32b      	cbz	r3, ef74 <transfer_next_chunk+0x10c>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    ef28:	2301      	movs	r3, #1
    ef2a:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    ef2e:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    ef30:	68db      	ldr	r3, [r3, #12]
    ef32:	4798      	blx	r3
	ctx->sync_status = status;
    ef34:	6425      	str	r5, [r4, #64]	; 0x40
	k_sem_give(&ctx->sync);
    ef36:	f104 0028 	add.w	r0, r4, #40	; 0x28
	z_impl_k_sem_give(sem);
    ef3a:	f004 fe29 	bl	13b90 <z_impl_k_sem_give>
	spi_context_cs_control(ctx, false);

	LOG_DBG("Transaction finished with status %d", error);

	spi_context_complete(ctx, error);
	dev_data->busy = false;
    ef3e:	2300      	movs	r3, #0
    ef40:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
}
    ef44:	b004      	add	sp, #16
    ef46:	bd70      	pop	{r4, r5, r6, pc}
		return ctx->rx_len;
    ef48:	6e25      	ldr	r5, [r4, #96]	; 0x60
    ef4a:	e79a      	b.n	ee82 <transfer_next_chunk+0x1a>
		return ctx->tx_len;
    ef4c:	461d      	mov	r5, r3
    ef4e:	e798      	b.n	ee82 <transfer_next_chunk+0x1a>
	return !!(ctx->tx_buf && ctx->tx_len);
    ef50:	2300      	movs	r3, #0
    ef52:	e79d      	b.n	ee90 <transfer_next_chunk+0x28>
    ef54:	2301      	movs	r3, #1
    ef56:	e79b      	b.n	ee90 <transfer_next_chunk+0x28>
    ef58:	2300      	movs	r3, #0
    ef5a:	e7b4      	b.n	eec6 <transfer_next_chunk+0x5e>
    ef5c:	2301      	movs	r3, #1
    ef5e:	e7b2      	b.n	eec6 <transfer_next_chunk+0x5e>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    ef60:	2300      	movs	r3, #0
    ef62:	e7b3      	b.n	eecc <transfer_next_chunk+0x64>
	return !!(ctx->rx_buf && ctx->rx_len);
    ef64:	2300      	movs	r3, #0
    ef66:	e7b9      	b.n	eedc <transfer_next_chunk+0x74>
    ef68:	2301      	movs	r3, #1
    ef6a:	e7b7      	b.n	eedc <transfer_next_chunk+0x74>
	int error = 0;
    ef6c:	2500      	movs	r5, #0
    ef6e:	e7c2      	b.n	eef6 <transfer_next_chunk+0x8e>
		value = (value != 0) ? 0 : 1;
    ef70:	2301      	movs	r3, #1
    ef72:	e7d8      	b.n	ef26 <transfer_next_chunk+0xbe>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    ef74:	2301      	movs	r3, #1
    ef76:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    ef7a:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    ef7c:	691b      	ldr	r3, [r3, #16]
    ef7e:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
    ef80:	e7d8      	b.n	ef34 <transfer_next_chunk+0xcc>
    ef82:	bf00      	nop
    ef84:	0bad0000 	.word	0x0bad0000

0000ef88 <transceive>:
		      const struct spi_config *spi_cfg,
		      const struct spi_buf_set *tx_bufs,
		      const struct spi_buf_set *rx_bufs,
		      bool asynchronous,
		      struct k_poll_signal *signal)
{
    ef88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ef8c:	b088      	sub	sp, #32
    ef8e:	4606      	mov	r6, r0
    ef90:	460d      	mov	r5, r1
    ef92:	4690      	mov	r8, r2
    ef94:	461f      	mov	r7, r3
	struct spi_nrfx_data *dev_data = dev->data;
    ef96:	6904      	ldr	r4, [r0, #16]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
    ef98:	888b      	ldrh	r3, [r1, #4]
    ef9a:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    ef9e:	d004      	beq.n	efaa <transceive+0x22>
	return sem->count;
    efa0:	69a3      	ldr	r3, [r4, #24]
    efa2:	b913      	cbnz	r3, efaa <transceive+0x22>
		(ctx->owner == spi_cfg)) {
    efa4:	6863      	ldr	r3, [r4, #4]
		(k_sem_count_get(&ctx->lock) == 0) &&
    efa6:	4299      	cmp	r1, r3
    efa8:	d008      	beq.n	efbc <transceive+0x34>
	k_sem_take(&ctx->lock, K_FOREVER);
    efaa:	f104 0010 	add.w	r0, r4, #16
	return z_impl_k_sem_take(sem, timeout);
    efae:	f04f 32ff 	mov.w	r2, #4294967295
    efb2:	f04f 33ff 	mov.w	r3, #4294967295
    efb6:	f004 fe13 	bl	13be0 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
    efba:	6065      	str	r5, [r4, #4]
	int error;

	spi_context_lock(&dev_data->ctx, asynchronous, signal, spi_cfg);

	error = configure(dev, spi_cfg);
    efbc:	4629      	mov	r1, r5
    efbe:	4630      	mov	r0, r6
    efc0:	f7ff fcb4 	bl	e92c <configure>
	if (error == 0) {
    efc4:	4605      	mov	r5, r0
    efc6:	b148      	cbz	r0, efdc <transceive+0x54>
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
    efc8:	6823      	ldr	r3, [r4, #0]
    efca:	889b      	ldrh	r3, [r3, #4]
    efcc:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    efd0:	f000 80bd 	beq.w	f14e <transceive+0x1c6>
	}

	spi_context_release(&dev_data->ctx, error);

	return error;
}
    efd4:	4628      	mov	r0, r5
    efd6:	b008      	add	sp, #32
    efd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		dev_data->busy = true;
    efdc:	2301      	movs	r3, #1
    efde:	f884 306c 	strb.w	r3, [r4, #108]	; 0x6c
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
    efe2:	f1b8 0f00 	cmp.w	r8, #0
    efe6:	d015      	beq.n	f014 <transceive+0x8c>
    efe8:	f8d8 3000 	ldr.w	r3, [r8]
    efec:	6463      	str	r3, [r4, #68]	; 0x44
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
    efee:	b19b      	cbz	r3, f018 <transceive+0x90>
    eff0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    eff4:	64a3      	str	r3, [r4, #72]	; 0x48
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
    eff6:	f104 0144 	add.w	r1, r4, #68	; 0x44
    effa:	f104 0348 	add.w	r3, r4, #72	; 0x48
	while (*count) {
    effe:	681a      	ldr	r2, [r3, #0]
    f000:	b182      	cbz	r2, f024 <transceive+0x9c>
		if (((*current)->len / dfs) != 0) {
    f002:	680a      	ldr	r2, [r1, #0]
    f004:	6850      	ldr	r0, [r2, #4]
    f006:	b948      	cbnz	r0, f01c <transceive+0x94>
		++(*current);
    f008:	3208      	adds	r2, #8
    f00a:	600a      	str	r2, [r1, #0]
		--(*count);
    f00c:	681a      	ldr	r2, [r3, #0]
    f00e:	3a01      	subs	r2, #1
    f010:	601a      	str	r2, [r3, #0]
    f012:	e7f4      	b.n	effe <transceive+0x76>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
    f014:	4643      	mov	r3, r8
    f016:	e7e9      	b.n	efec <transceive+0x64>
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
    f018:	2300      	movs	r3, #0
    f01a:	e7eb      	b.n	eff4 <transceive+0x6c>
			*buf_len = (*current)->len / dfs;
    f01c:	65a0      	str	r0, [r4, #88]	; 0x58
			return (*current)->buf;
    f01e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    f020:	681b      	ldr	r3, [r3, #0]
    f022:	e001      	b.n	f028 <transceive+0xa0>
	*buf_len = 0;
    f024:	2300      	movs	r3, #0
    f026:	65a3      	str	r3, [r4, #88]	; 0x58
	ctx->tx_buf = (const uint8_t *)
    f028:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
    f02a:	b19f      	cbz	r7, f054 <transceive+0xcc>
    f02c:	683b      	ldr	r3, [r7, #0]
    f02e:	64e3      	str	r3, [r4, #76]	; 0x4c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
    f030:	b193      	cbz	r3, f058 <transceive+0xd0>
    f032:	687b      	ldr	r3, [r7, #4]
    f034:	6523      	str	r3, [r4, #80]	; 0x50
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
    f036:	f104 014c 	add.w	r1, r4, #76	; 0x4c
    f03a:	f104 0250 	add.w	r2, r4, #80	; 0x50
	while (*count) {
    f03e:	6813      	ldr	r3, [r2, #0]
    f040:	b183      	cbz	r3, f064 <transceive+0xdc>
		if (((*current)->len / dfs) != 0) {
    f042:	680b      	ldr	r3, [r1, #0]
    f044:	6858      	ldr	r0, [r3, #4]
    f046:	b948      	cbnz	r0, f05c <transceive+0xd4>
		++(*current);
    f048:	3308      	adds	r3, #8
    f04a:	600b      	str	r3, [r1, #0]
		--(*count);
    f04c:	6813      	ldr	r3, [r2, #0]
    f04e:	3b01      	subs	r3, #1
    f050:	6013      	str	r3, [r2, #0]
    f052:	e7f4      	b.n	f03e <transceive+0xb6>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
    f054:	463b      	mov	r3, r7
    f056:	e7ea      	b.n	f02e <transceive+0xa6>
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
    f058:	2300      	movs	r3, #0
    f05a:	e7eb      	b.n	f034 <transceive+0xac>
			*buf_len = (*current)->len / dfs;
    f05c:	6620      	str	r0, [r4, #96]	; 0x60
			return (*current)->buf;
    f05e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    f060:	681b      	ldr	r3, [r3, #0]
    f062:	e000      	b.n	f066 <transceive+0xde>
	*buf_len = 0;
    f064:	6623      	str	r3, [r4, #96]	; 0x60
	ctx->rx_buf = (uint8_t *)
    f066:	65e3      	str	r3, [r4, #92]	; 0x5c
	ctx->sync_status = 0;
    f068:	2300      	movs	r3, #0
    f06a:	6423      	str	r3, [r4, #64]	; 0x40
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    f06c:	6823      	ldr	r3, [r4, #0]
    f06e:	b1bb      	cbz	r3, f0a0 <transceive+0x118>
    f070:	689b      	ldr	r3, [r3, #8]
    f072:	b1ab      	cbz	r3, f0a0 <transceive+0x118>
    f074:	6818      	ldr	r0, [r3, #0]
    f076:	b198      	cbz	r0, f0a0 <transceive+0x118>
	return gpio_pin_set(spec->port, spec->pin, value);
    f078:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
    f07a:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    f07c:	681a      	ldr	r2, [r3, #0]
    f07e:	2301      	movs	r3, #1
    f080:	408b      	lsls	r3, r1
    f082:	421a      	tst	r2, r3
    f084:	d100      	bne.n	f088 <transceive+0x100>
    f086:	2501      	movs	r5, #1
	if (value != 0)	{
    f088:	b395      	cbz	r5, f0f0 <transceive+0x168>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    f08a:	2301      	movs	r3, #1
    f08c:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    f090:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    f092:	68db      	ldr	r3, [r3, #12]
    f094:	4798      	blx	r3
			k_busy_wait(ctx->config->cs->delay);
    f096:	6823      	ldr	r3, [r4, #0]
    f098:	689b      	ldr	r3, [r3, #8]
    f09a:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
    f09c:	f00d fc37 	bl	1c90e <z_impl_k_busy_wait>
		transfer_next_chunk(dev);
    f0a0:	4630      	mov	r0, r6
    f0a2:	f7ff fee1 	bl	ee68 <transfer_next_chunk>
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
    f0a6:	6e20      	ldr	r0, [r4, #96]	; 0x60
    f0a8:	6da3      	ldr	r3, [r4, #88]	; 0x58
    f0aa:	4298      	cmp	r0, r3
    f0ac:	bf38      	it	cc
    f0ae:	4618      	movcc	r0, r3
    f0b0:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
    f0b4:	fb03 f000 	mul.w	r0, r3, r0
			     ctx->config->frequency;
    f0b8:	4625      	mov	r5, r4
    f0ba:	f855 3b28 	ldr.w	r3, [r5], #40
    f0be:	681b      	ldr	r3, [r3, #0]
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
    f0c0:	fbb0 f0f3 	udiv	r0, r0, r3
		timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
    f0c4:	30c8      	adds	r0, #200	; 0xc8
    f0c6:	0c41      	lsrs	r1, r0, #17
    f0c8:	03c0      	lsls	r0, r0, #15
    f0ca:	f240 33e7 	movw	r3, #999	; 0x3e7
    f0ce:	18c0      	adds	r0, r0, r3
    f0d0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    f0d4:	f04f 0300 	mov.w	r3, #0
    f0d8:	f141 0100 	adc.w	r1, r1, #0
    f0dc:	f7f1 f83a 	bl	154 <__aeabi_uldivmod>
    f0e0:	4602      	mov	r2, r0
    f0e2:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
    f0e4:	4628      	mov	r0, r5
    f0e6:	f004 fd7b 	bl	13be0 <z_impl_k_sem_take>
	if (k_sem_take(&ctx->sync, timeout)) {
    f0ea:	b940      	cbnz	r0, f0fe <transceive+0x176>
	status = ctx->sync_status;
    f0ec:	6c25      	ldr	r5, [r4, #64]	; 0x40
	return status;
    f0ee:	e76b      	b.n	efc8 <transceive+0x40>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    f0f0:	2301      	movs	r3, #1
    f0f2:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    f0f6:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    f0f8:	691b      	ldr	r3, [r3, #16]
    f0fa:	4798      	blx	r3
    f0fc:	e7cb      	b.n	f096 <transceive+0x10e>
		LOG_ERR("Timeout waiting for transfer complete");
    f0fe:	4b17      	ldr	r3, [pc, #92]	; (f15c <transceive+0x1d4>)
    f100:	9307      	str	r3, [sp, #28]
    f102:	2302      	movs	r3, #2
    f104:	f88d 3004 	strb.w	r3, [sp, #4]
    f108:	2300      	movs	r3, #0
    f10a:	f88d 3005 	strb.w	r3, [sp, #5]
    f10e:	f88d 3006 	strb.w	r3, [sp, #6]
    f112:	f88d 3007 	strb.w	r3, [sp, #7]
    f116:	9a01      	ldr	r2, [sp, #4]
    f118:	9206      	str	r2, [sp, #24]
    f11a:	4619      	mov	r1, r3
    f11c:	f363 0100 	bfi	r1, r3, #0, #1
    f120:	f363 0141 	bfi	r1, r3, #1, #1
    f124:	f363 0182 	bfi	r1, r3, #2, #1
    f128:	f363 01c5 	bfi	r1, r3, #3, #3
    f12c:	2201      	movs	r2, #1
    f12e:	f362 1188 	bfi	r1, r2, #6, #3
    f132:	2208      	movs	r2, #8
    f134:	f362 2152 	bfi	r1, r2, #9, #10
    f138:	f363 41de 	bfi	r1, r3, #19, #12
    f13c:	f363 71df 	bfi	r1, r3, #31, #1
    f140:	aa06      	add	r2, sp, #24
    f142:	4807      	ldr	r0, [pc, #28]	; (f160 <transceive+0x1d8>)
    f144:	f7f3 f880 	bl	2248 <z_impl_z_log_msg_static_create>
		return -ETIMEDOUT;
    f148:	f06f 0573 	mvn.w	r5, #115	; 0x73
    f14c:	e73c      	b.n	efc8 <transceive+0x40>
		ctx->owner = NULL;
    f14e:	2300      	movs	r3, #0
    f150:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
    f152:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
    f156:	f004 fd1b 	bl	13b90 <z_impl_k_sem_give>
	return error;
    f15a:	e73b      	b.n	efd4 <transceive+0x4c>
    f15c:	0001f828 	.word	0x0001f828
    f160:	0001d0a4 	.word	0x0001d0a4

0000f164 <event_handler>:
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
    f164:	7803      	ldrb	r3, [r0, #0]
    f166:	2b00      	cmp	r3, #0
    f168:	f040 80a5 	bne.w	f2b6 <event_handler+0x152>
{
    f16c:	b510      	push	{r4, lr}
    f16e:	b08e      	sub	sp, #56	; 0x38
    f170:	460c      	mov	r4, r1
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
    f172:	6e8a      	ldr	r2, [r1, #104]	; 0x68
	if (!ctx->tx_len) {
    f174:	6d8b      	ldr	r3, [r1, #88]	; 0x58
    f176:	b14b      	cbz	r3, f18c <event_handler+0x28>
	if (len > ctx->tx_len) {
    f178:	429a      	cmp	r2, r3
    f17a:	d819      	bhi.n	f1b0 <event_handler+0x4c>
	ctx->tx_len -= len;
    f17c:	1a9b      	subs	r3, r3, r2
    f17e:	658b      	str	r3, [r1, #88]	; 0x58
	if (!ctx->tx_len) {
    f180:	2b00      	cmp	r3, #0
    f182:	d03b      	beq.n	f1fc <event_handler+0x98>
	} else if (ctx->tx_buf) {
    f184:	6d4b      	ldr	r3, [r1, #84]	; 0x54
    f186:	b10b      	cbz	r3, f18c <event_handler+0x28>
		ctx->tx_buf += dfs * len;
    f188:	4413      	add	r3, r2
    f18a:	654b      	str	r3, [r1, #84]	; 0x54
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    f18c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
	if (!ctx->rx_len) {
    f18e:	6e23      	ldr	r3, [r4, #96]	; 0x60
    f190:	b14b      	cbz	r3, f1a6 <event_handler+0x42>
	if (len > ctx->rx_len) {
    f192:	429a      	cmp	r2, r3
    f194:	d84d      	bhi.n	f232 <event_handler+0xce>
	ctx->rx_len -= len;
    f196:	1a9b      	subs	r3, r3, r2
    f198:	6623      	str	r3, [r4, #96]	; 0x60
	if (!ctx->rx_len) {
    f19a:	2b00      	cmp	r3, #0
    f19c:	d06f      	beq.n	f27e <event_handler+0x11a>
	} else if (ctx->rx_buf) {
    f19e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    f1a0:	b10b      	cbz	r3, f1a6 <event_handler+0x42>
		ctx->rx_buf += dfs * len;
    f1a2:	4413      	add	r3, r2
    f1a4:	65e3      	str	r3, [r4, #92]	; 0x5c
		transfer_next_chunk(dev_data->dev);
    f1a6:	6e60      	ldr	r0, [r4, #100]	; 0x64
    f1a8:	f7ff fe5e 	bl	ee68 <transfer_next_chunk>
}
    f1ac:	b00e      	add	sp, #56	; 0x38
    f1ae:	bd10      	pop	{r4, pc}
		LOG_ERR("Update exceeds current buffer");
    f1b0:	4b41      	ldr	r3, [pc, #260]	; (f2b8 <event_handler+0x154>)
    f1b2:	930d      	str	r3, [sp, #52]	; 0x34
    f1b4:	2302      	movs	r3, #2
    f1b6:	f88d 3004 	strb.w	r3, [sp, #4]
    f1ba:	2300      	movs	r3, #0
    f1bc:	f88d 3005 	strb.w	r3, [sp, #5]
    f1c0:	f88d 3006 	strb.w	r3, [sp, #6]
    f1c4:	f88d 3007 	strb.w	r3, [sp, #7]
    f1c8:	9a01      	ldr	r2, [sp, #4]
    f1ca:	920c      	str	r2, [sp, #48]	; 0x30
    f1cc:	4619      	mov	r1, r3
    f1ce:	f363 0100 	bfi	r1, r3, #0, #1
    f1d2:	f363 0141 	bfi	r1, r3, #1, #1
    f1d6:	f363 0182 	bfi	r1, r3, #2, #1
    f1da:	f363 01c5 	bfi	r1, r3, #3, #3
    f1de:	2201      	movs	r2, #1
    f1e0:	f362 1188 	bfi	r1, r2, #6, #3
    f1e4:	2208      	movs	r2, #8
    f1e6:	f362 2152 	bfi	r1, r2, #9, #10
    f1ea:	f363 41de 	bfi	r1, r3, #19, #12
    f1ee:	f363 71df 	bfi	r1, r3, #31, #1
    f1f2:	aa0c      	add	r2, sp, #48	; 0x30
    f1f4:	4831      	ldr	r0, [pc, #196]	; (f2bc <event_handler+0x158>)
    f1f6:	f7f3 f827 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    f1fa:	e7c7      	b.n	f18c <event_handler+0x28>
		++ctx->current_tx;
    f1fc:	6c4b      	ldr	r3, [r1, #68]	; 0x44
    f1fe:	3308      	adds	r3, #8
    f200:	644b      	str	r3, [r1, #68]	; 0x44
		--ctx->tx_count;
    f202:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    f204:	3b01      	subs	r3, #1
    f206:	648b      	str	r3, [r1, #72]	; 0x48
			spi_context_get_next_buf(&ctx->current_tx,
    f208:	3144      	adds	r1, #68	; 0x44
    f20a:	f104 0248 	add.w	r2, r4, #72	; 0x48
	while (*count) {
    f20e:	6813      	ldr	r3, [r2, #0]
    f210:	b163      	cbz	r3, f22c <event_handler+0xc8>
		if (((*current)->len / dfs) != 0) {
    f212:	680b      	ldr	r3, [r1, #0]
    f214:	6858      	ldr	r0, [r3, #4]
    f216:	b928      	cbnz	r0, f224 <event_handler+0xc0>
		++(*current);
    f218:	3308      	adds	r3, #8
    f21a:	600b      	str	r3, [r1, #0]
		--(*count);
    f21c:	6813      	ldr	r3, [r2, #0]
    f21e:	3b01      	subs	r3, #1
    f220:	6013      	str	r3, [r2, #0]
    f222:	e7f4      	b.n	f20e <event_handler+0xaa>
			*buf_len = (*current)->len / dfs;
    f224:	65a0      	str	r0, [r4, #88]	; 0x58
			return (*current)->buf;
    f226:	6c63      	ldr	r3, [r4, #68]	; 0x44
    f228:	681b      	ldr	r3, [r3, #0]
    f22a:	e000      	b.n	f22e <event_handler+0xca>
	*buf_len = 0;
    f22c:	65a3      	str	r3, [r4, #88]	; 0x58
		ctx->tx_buf = (const uint8_t *)
    f22e:	6563      	str	r3, [r4, #84]	; 0x54
    f230:	e7ac      	b.n	f18c <event_handler+0x28>
		LOG_ERR("Update exceeds current buffer");
    f232:	4b21      	ldr	r3, [pc, #132]	; (f2b8 <event_handler+0x154>)
    f234:	9307      	str	r3, [sp, #28]
    f236:	2302      	movs	r3, #2
    f238:	f88d 3004 	strb.w	r3, [sp, #4]
    f23c:	2300      	movs	r3, #0
    f23e:	f88d 3005 	strb.w	r3, [sp, #5]
    f242:	f88d 3006 	strb.w	r3, [sp, #6]
    f246:	f88d 3007 	strb.w	r3, [sp, #7]
    f24a:	9a01      	ldr	r2, [sp, #4]
    f24c:	9206      	str	r2, [sp, #24]
    f24e:	4619      	mov	r1, r3
    f250:	f363 0100 	bfi	r1, r3, #0, #1
    f254:	f363 0141 	bfi	r1, r3, #1, #1
    f258:	f363 0182 	bfi	r1, r3, #2, #1
    f25c:	f363 01c5 	bfi	r1, r3, #3, #3
    f260:	2201      	movs	r2, #1
    f262:	f362 1188 	bfi	r1, r2, #6, #3
    f266:	2208      	movs	r2, #8
    f268:	f362 2152 	bfi	r1, r2, #9, #10
    f26c:	f363 41de 	bfi	r1, r3, #19, #12
    f270:	f363 71df 	bfi	r1, r3, #31, #1
    f274:	aa06      	add	r2, sp, #24
    f276:	4811      	ldr	r0, [pc, #68]	; (f2bc <event_handler+0x158>)
    f278:	f7f2 ffe6 	bl	2248 <z_impl_z_log_msg_static_create>
		return;
    f27c:	e793      	b.n	f1a6 <event_handler+0x42>
		++ctx->current_rx;
    f27e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    f280:	3308      	adds	r3, #8
    f282:	64e3      	str	r3, [r4, #76]	; 0x4c
		--ctx->rx_count;
    f284:	6d23      	ldr	r3, [r4, #80]	; 0x50
    f286:	3b01      	subs	r3, #1
    f288:	6523      	str	r3, [r4, #80]	; 0x50
			spi_context_get_next_buf(&ctx->current_rx,
    f28a:	f104 014c 	add.w	r1, r4, #76	; 0x4c
    f28e:	f104 0250 	add.w	r2, r4, #80	; 0x50
	while (*count) {
    f292:	6813      	ldr	r3, [r2, #0]
    f294:	b163      	cbz	r3, f2b0 <event_handler+0x14c>
		if (((*current)->len / dfs) != 0) {
    f296:	680b      	ldr	r3, [r1, #0]
    f298:	6858      	ldr	r0, [r3, #4]
    f29a:	b928      	cbnz	r0, f2a8 <event_handler+0x144>
		++(*current);
    f29c:	3308      	adds	r3, #8
    f29e:	600b      	str	r3, [r1, #0]
		--(*count);
    f2a0:	6813      	ldr	r3, [r2, #0]
    f2a2:	3b01      	subs	r3, #1
    f2a4:	6013      	str	r3, [r2, #0]
    f2a6:	e7f4      	b.n	f292 <event_handler+0x12e>
			*buf_len = (*current)->len / dfs;
    f2a8:	6620      	str	r0, [r4, #96]	; 0x60
			return (*current)->buf;
    f2aa:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    f2ac:	681b      	ldr	r3, [r3, #0]
    f2ae:	e000      	b.n	f2b2 <event_handler+0x14e>
	*buf_len = 0;
    f2b0:	6623      	str	r3, [r4, #96]	; 0x60
		ctx->rx_buf = (uint8_t *)
    f2b2:	65e3      	str	r3, [r4, #92]	; 0x5c
    f2b4:	e777      	b.n	f1a6 <event_handler+0x42>
    f2b6:	4770      	bx	lr
    f2b8:	0001f850 	.word	0x0001f850
    f2bc:	0001d0a4 	.word	0x0001d0a4

0000f2c0 <common_init>:
 * @param gpiop where to store the GPIO device pointer
 *
 * @return negative on error, otherwise zero.
 */
static int common_init(const struct device *dev)
{
    f2c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    f2c2:	b083      	sub	sp, #12
    f2c4:	af00      	add	r7, sp, #0
	const struct driver_config *cfg = dev->config;
    f2c6:	6844      	ldr	r4, [r0, #4]
	gpio_flags_t flags;

	if (!device_is_ready(cfg->enable.port)) {
    f2c8:	68e0      	ldr	r0, [r4, #12]
    f2ca:	f00c fd80 	bl	1bdce <z_device_is_ready>
    f2ce:	b138      	cbz	r0, f2e0 <common_init+0x20>
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
		return -ENODEV;
	}

	bool on = cfg->options & (OPTION_ALWAYS_ON | OPTION_BOOT_ON);
    f2d0:	7d23      	ldrb	r3, [r4, #20]
	uint32_t delay_us = 0;

	if (on) {
    f2d2:	f013 0f03 	tst.w	r3, #3
    f2d6:	d056      	beq.n	f386 <common_init+0xc6>
		flags = GPIO_OUTPUT_ACTIVE;
		delay_us = cfg->startup_delay_us;
    f2d8:	6865      	ldr	r5, [r4, #4]
		flags = GPIO_OUTPUT_ACTIVE;
    f2da:	f44f 13d0 	mov.w	r3, #1703936	; 0x1a0000
    f2de:	e055      	b.n	f38c <common_init+0xcc>
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
    f2e0:	68e3      	ldr	r3, [r4, #12]
    f2e2:	6818      	ldr	r0, [r3, #0]
    f2e4:	2302      	movs	r3, #2
    f2e6:	713b      	strb	r3, [r7, #4]
    f2e8:	466c      	mov	r4, sp
    f2ea:	b088      	sub	sp, #32
    f2ec:	466b      	mov	r3, sp
    f2ee:	f113 0210 	adds.w	r2, r3, #16
    f2f2:	d039      	beq.n	f368 <common_init+0xa8>
    f2f4:	250d      	movs	r5, #13
    f2f6:	b11a      	cbz	r2, f300 <common_init+0x40>
    f2f8:	2d04      	cmp	r5, #4
    f2fa:	dd01      	ble.n	f300 <common_init+0x40>
    f2fc:	493c      	ldr	r1, [pc, #240]	; (f3f0 <common_init+0x130>)
    f2fe:	6159      	str	r1, [r3, #20]
    f300:	2102      	movs	r1, #2
    f302:	7039      	strb	r1, [r7, #0]
    f304:	b112      	cbz	r2, f30c <common_init+0x4c>
    f306:	2d08      	cmp	r5, #8
    f308:	dd00      	ble.n	f30c <common_init+0x4c>
    f30a:	6198      	str	r0, [r3, #24]
    f30c:	b11a      	cbz	r2, f316 <common_init+0x56>
    f30e:	f103 011c 	add.w	r1, r3, #28
    f312:	2000      	movs	r0, #0
    f314:	b358      	cbz	r0, f36e <common_init+0xae>
    f316:	2d0c      	cmp	r5, #12
    f318:	dd32      	ble.n	f380 <common_init+0xc0>
    f31a:	250d      	movs	r5, #13
    f31c:	b142      	cbz	r2, f330 <common_init+0x70>
    f31e:	2103      	movs	r1, #3
    f320:	7139      	strb	r1, [r7, #4]
    f322:	2100      	movs	r1, #0
    f324:	7179      	strb	r1, [r7, #5]
    f326:	71b9      	strb	r1, [r7, #6]
    f328:	2101      	movs	r1, #1
    f32a:	71f9      	strb	r1, [r7, #7]
    f32c:	6878      	ldr	r0, [r7, #4]
    f32e:	6118      	str	r0, [r3, #16]
    f330:	2100      	movs	r1, #0
    f332:	f36f 0100 	bfc	r1, #0, #1
    f336:	f36f 0141 	bfc	r1, #1, #1
    f33a:	f36f 0182 	bfc	r1, #2, #1
    f33e:	f36f 01c5 	bfc	r1, #3, #3
    f342:	2301      	movs	r3, #1
    f344:	f363 1188 	bfi	r1, r3, #6, #3
    f348:	f3c5 0509 	ubfx	r5, r5, #0, #10
    f34c:	f365 2152 	bfi	r1, r5, #9, #10
    f350:	f36f 41de 	bfc	r1, #19, #12
    f354:	f36f 71df 	bfc	r1, #31, #1
    f358:	2300      	movs	r3, #0
    f35a:	4826      	ldr	r0, [pc, #152]	; (f3f4 <common_init+0x134>)
    f35c:	f7f2 ff74 	bl	2248 <z_impl_z_log_msg_static_create>
    f360:	46a5      	mov	sp, r4
		return -ENODEV;
    f362:	f06f 0412 	mvn.w	r4, #18
    f366:	e033      	b.n	f3d0 <common_init+0x110>
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
    f368:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    f36c:	e7c3      	b.n	f2f6 <common_init+0x36>
    f36e:	f107 0608 	add.w	r6, r7, #8
    f372:	4406      	add	r6, r0
    f374:	f816 6c08 	ldrb.w	r6, [r6, #-8]
    f378:	f801 6b01 	strb.w	r6, [r1], #1
    f37c:	3001      	adds	r0, #1
    f37e:	e7c9      	b.n	f314 <common_init+0x54>
    f380:	f06f 051b 	mvn.w	r5, #27
    f384:	e7ca      	b.n	f31c <common_init+0x5c>
	uint32_t delay_us = 0;
    f386:	2500      	movs	r5, #0
	} else {
		flags = GPIO_OUTPUT_INACTIVE;
    f388:	f44f 13b0 	mov.w	r3, #1441792	; 0x160000
	return gpio_pin_configure(spec->port,
    f38c:	68e0      	ldr	r0, [r4, #12]
    f38e:	7c21      	ldrb	r1, [r4, #16]
				  spec->dt_flags | extra_flags);
    f390:	8a62      	ldrh	r2, [r4, #18]
	return gpio_pin_configure(spec->port,
    f392:	4313      	orrs	r3, r2
	const struct gpio_driver_api *api =
    f394:	6886      	ldr	r6, [r0, #8]
	struct gpio_driver_data *data =
    f396:	6904      	ldr	r4, [r0, #16]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
    f398:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    f39c:	d007      	beq.n	f3ae <common_init+0xee>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
    f39e:	f413 2f40 	tst.w	r3, #786432	; 0xc0000
    f3a2:	d004      	beq.n	f3ae <common_init+0xee>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    f3a4:	f013 0f01 	tst.w	r3, #1
    f3a8:	d001      	beq.n	f3ae <common_init+0xee>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    f3aa:	f483 2340 	eor.w	r3, r3, #786432	; 0xc0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
    f3ae:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    f3b2:	f013 0f01 	tst.w	r3, #1
    f3b6:	d00f      	beq.n	f3d8 <common_init+0x118>
		data->invert |= (gpio_port_pins_t)BIT(pin);
    f3b8:	2301      	movs	r3, #1
    f3ba:	fa03 fc01 	lsl.w	ip, r3, r1
    f3be:	6823      	ldr	r3, [r4, #0]
    f3c0:	ea43 030c 	orr.w	r3, r3, ip
    f3c4:	6023      	str	r3, [r4, #0]
	return api->pin_configure(port, pin, flags);
    f3c6:	6833      	ldr	r3, [r6, #0]
    f3c8:	4798      	blx	r3
	}

	int rc = gpio_pin_configure_dt(&cfg->enable, flags);

	if ((rc == 0) && (delay_us > 0)) {
    f3ca:	4604      	mov	r4, r0
    f3cc:	b900      	cbnz	r0, f3d0 <common_init+0x110>
    f3ce:	b95d      	cbnz	r5, f3e8 <common_init+0x128>
		 */
		k_busy_wait(delay_us);
	}

	return rc;
}
    f3d0:	4620      	mov	r0, r4
    f3d2:	370c      	adds	r7, #12
    f3d4:	46bd      	mov	sp, r7
    f3d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    f3d8:	2301      	movs	r3, #1
    f3da:	fa03 fc01 	lsl.w	ip, r3, r1
    f3de:	6823      	ldr	r3, [r4, #0]
    f3e0:	ea23 030c 	bic.w	r3, r3, ip
    f3e4:	6023      	str	r3, [r4, #0]
    f3e6:	e7ee      	b.n	f3c6 <common_init+0x106>
	z_impl_k_busy_wait(usec_to_wait);
    f3e8:	4628      	mov	r0, r5
    f3ea:	f00d fa90 	bl	1c90e <z_impl_k_busy_wait>
}
    f3ee:	e7ef      	b.n	f3d0 <common_init+0x110>
    f3f0:	0001f8f8 	.word	0x0001f8f8
    f3f4:	0001d094 	.word	0x0001d094

0000f3f8 <regulator_fixed_init_sync>:
	.enable = enable_sync,
	.disable = disable_sync,
};

static int regulator_fixed_init_sync(const struct device *dev)
{
    f3f8:	b5b0      	push	{r4, r5, r7, lr}
    f3fa:	b082      	sub	sp, #8
    f3fc:	af00      	add	r7, sp, #0
    f3fe:	4605      	mov	r5, r0
	const struct driver_config *cfg = dev->config;
	int rc = common_init(dev);
    f400:	f7ff ff5e 	bl	f2c0 <common_init>
    f404:	4604      	mov	r4, r0
	__ASSERT(cfg->startup_delay_us == 0,
		 "sync not valid with startup delay");
	__ASSERT(cfg->off_on_delay_us == 0,
		 "sync not valid with shutdown delay");

	LOG_INF("%s sync: %d", dev->name, rc);
    f406:	6828      	ldr	r0, [r5, #0]
    f408:	2302      	movs	r3, #2
    f40a:	713b      	strb	r3, [r7, #4]
    f40c:	b08a      	sub	sp, #40	; 0x28
    f40e:	466b      	mov	r3, sp
    f410:	f113 0210 	adds.w	r2, r3, #16
    f414:	d043      	beq.n	f49e <regulator_fixed_init_sync+0xa6>
    f416:	f04f 0c11 	mov.w	ip, #17
    f41a:	b122      	cbz	r2, f426 <regulator_fixed_init_sync+0x2e>
    f41c:	f1bc 0f04 	cmp.w	ip, #4
    f420:	dd01      	ble.n	f426 <regulator_fixed_init_sync+0x2e>
    f422:	4926      	ldr	r1, [pc, #152]	; (f4bc <regulator_fixed_init_sync+0xc4>)
    f424:	6159      	str	r1, [r3, #20]
    f426:	2102      	movs	r1, #2
    f428:	7039      	strb	r1, [r7, #0]
    f42a:	b11a      	cbz	r2, f434 <regulator_fixed_init_sync+0x3c>
    f42c:	f1bc 0f08 	cmp.w	ip, #8
    f430:	dd00      	ble.n	f434 <regulator_fixed_init_sync+0x3c>
    f432:	6198      	str	r0, [r3, #24]
    f434:	b11a      	cbz	r2, f43e <regulator_fixed_init_sync+0x46>
    f436:	f1bc 0f0c 	cmp.w	ip, #12
    f43a:	dd00      	ble.n	f43e <regulator_fixed_init_sync+0x46>
    f43c:	61dc      	str	r4, [r3, #28]
    f43e:	b11a      	cbz	r2, f448 <regulator_fixed_init_sync+0x50>
    f440:	f103 0120 	add.w	r1, r3, #32
    f444:	2000      	movs	r0, #0
    f446:	b368      	cbz	r0, f4a4 <regulator_fixed_init_sync+0xac>
    f448:	f1bc 0f10 	cmp.w	ip, #16
    f44c:	dd33      	ble.n	f4b6 <regulator_fixed_init_sync+0xbe>
    f44e:	f04f 0c11 	mov.w	ip, #17
    f452:	b142      	cbz	r2, f466 <regulator_fixed_init_sync+0x6e>
    f454:	2104      	movs	r1, #4
    f456:	7139      	strb	r1, [r7, #4]
    f458:	2100      	movs	r1, #0
    f45a:	7179      	strb	r1, [r7, #5]
    f45c:	71b9      	strb	r1, [r7, #6]
    f45e:	2101      	movs	r1, #1
    f460:	71f9      	strb	r1, [r7, #7]
    f462:	6878      	ldr	r0, [r7, #4]
    f464:	6118      	str	r0, [r3, #16]
    f466:	2100      	movs	r1, #0
    f468:	f36f 0100 	bfc	r1, #0, #1
    f46c:	f36f 0141 	bfc	r1, #1, #1
    f470:	f36f 0182 	bfc	r1, #2, #1
    f474:	f36f 01c5 	bfc	r1, #3, #3
    f478:	2303      	movs	r3, #3
    f47a:	f363 1188 	bfi	r1, r3, #6, #3
    f47e:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    f482:	f36c 2152 	bfi	r1, ip, #9, #10
    f486:	f36f 41de 	bfc	r1, #19, #12
    f48a:	f36f 71df 	bfc	r1, #31, #1
    f48e:	2300      	movs	r3, #0
    f490:	480b      	ldr	r0, [pc, #44]	; (f4c0 <regulator_fixed_init_sync+0xc8>)
    f492:	f7f2 fed9 	bl	2248 <z_impl_z_log_msg_static_create>

	return rc;
}
    f496:	4620      	mov	r0, r4
    f498:	3708      	adds	r7, #8
    f49a:	46bd      	mov	sp, r7
    f49c:	bdb0      	pop	{r4, r5, r7, pc}
	LOG_INF("%s sync: %d", dev->name, rc);
    f49e:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    f4a2:	e7ba      	b.n	f41a <regulator_fixed_init_sync+0x22>
    f4a4:	f107 0508 	add.w	r5, r7, #8
    f4a8:	4405      	add	r5, r0
    f4aa:	f815 5c08 	ldrb.w	r5, [r5, #-8]
    f4ae:	f801 5b01 	strb.w	r5, [r1], #1
    f4b2:	3001      	adds	r0, #1
    f4b4:	e7c7      	b.n	f446 <regulator_fixed_init_sync+0x4e>
    f4b6:	f06f 0c1b 	mvn.w	ip, #27
    f4ba:	e7ca      	b.n	f452 <regulator_fixed_init_sync+0x5a>
    f4bc:	0001f910 	.word	0x0001f910
    f4c0:	0001d094 	.word	0x0001d094

0000f4c4 <baudrate_set>:
#endif
};

static inline NRF_UARTE_Type *get_uarte_instance(const struct device *dev)
{
	const struct uarte_nrfx_config *config = dev->config;
    f4c4:	6843      	ldr	r3, [r0, #4]

	return config->uarte_regs;
    f4c6:	681a      	ldr	r2, [r3, #0]
static int baudrate_set(const struct device *dev, uint32_t baudrate)
{
	nrf_uarte_baudrate_t nrf_baudrate; /* calculated baudrate divisor */
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);

	switch (baudrate) {
    f4c8:	f5b1 4f16 	cmp.w	r1, #38400	; 0x9600
    f4cc:	d06f      	beq.n	f5ae <baudrate_set+0xea>
    f4ce:	d83a      	bhi.n	f546 <baudrate_set+0x82>
    f4d0:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
    f4d4:	d06e      	beq.n	f5b4 <baudrate_set+0xf0>
    f4d6:	d90a      	bls.n	f4ee <baudrate_set+0x2a>
    f4d8:	f5b1 4fe1 	cmp.w	r1, #28800	; 0x7080
    f4dc:	d075      	beq.n	f5ca <baudrate_set+0x106>
    f4de:	d924      	bls.n	f52a <baudrate_set+0x66>
    f4e0:	f647 2312 	movw	r3, #31250	; 0x7a12
    f4e4:	4299      	cmp	r1, r3
    f4e6:	d12b      	bne.n	f540 <baudrate_set+0x7c>
		break;
	case 28800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
		break;
	case 31250:
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    f4e8:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    f4ec:	e013      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f4ee:	f5b1 6f96 	cmp.w	r1, #1200	; 0x4b0
    f4f2:	d061      	beq.n	f5b8 <baudrate_set+0xf4>
    f4f4:	d907      	bls.n	f506 <baudrate_set+0x42>
    f4f6:	f5b1 6f16 	cmp.w	r1, #2400	; 0x960
    f4fa:	d063      	beq.n	f5c4 <baudrate_set+0x100>
    f4fc:	f5b1 5f96 	cmp.w	r1, #4800	; 0x12c0
    f500:	d110      	bne.n	f524 <baudrate_set+0x60>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    f502:	4b3c      	ldr	r3, [pc, #240]	; (f5f4 <baudrate_set+0x130>)
    f504:	e007      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f506:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    f50a:	d058      	beq.n	f5be <baudrate_set+0xfa>
    f50c:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
    f510:	d105      	bne.n	f51e <baudrate_set+0x5a>
		nrf_baudrate = 0x00027000;
    f512:	f44f 331c 	mov.w	r3, #159744	; 0x27000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    f516:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
		return -EINVAL;
	}

	nrf_uarte_baudrate_set(uarte, nrf_baudrate);

	return 0;
    f51a:	2000      	movs	r0, #0
    f51c:	4770      	bx	lr
	switch (baudrate) {
    f51e:	f06f 0015 	mvn.w	r0, #21
    f522:	4770      	bx	lr
    f524:	f06f 0015 	mvn.w	r0, #21
    f528:	4770      	bx	lr
    f52a:	f5b1 5f61 	cmp.w	r1, #14400	; 0x3840
    f52e:	d04e      	beq.n	f5ce <baudrate_set+0x10a>
    f530:	f5b1 4f96 	cmp.w	r1, #19200	; 0x4b00
    f534:	d101      	bne.n	f53a <baudrate_set+0x76>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    f536:	4b30      	ldr	r3, [pc, #192]	; (f5f8 <baudrate_set+0x134>)
    f538:	e7ed      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f53a:	f06f 0015 	mvn.w	r0, #21
    f53e:	4770      	bx	lr
    f540:	f06f 0015 	mvn.w	r0, #21
    f544:	4770      	bx	lr
    f546:	f5b1 3f61 	cmp.w	r1, #230400	; 0x38400
    f54a:	d042      	beq.n	f5d2 <baudrate_set+0x10e>
    f54c:	d909      	bls.n	f562 <baudrate_set+0x9e>
    f54e:	f5b1 2f61 	cmp.w	r1, #921600	; 0xe1000
    f552:	d046      	beq.n	f5e2 <baudrate_set+0x11e>
    f554:	d91f      	bls.n	f596 <baudrate_set+0xd2>
    f556:	4b29      	ldr	r3, [pc, #164]	; (f5fc <baudrate_set+0x138>)
    f558:	4299      	cmp	r1, r3
    f55a:	d148      	bne.n	f5ee <baudrate_set+0x12a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    f55c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    f560:	e7d9      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f562:	f5b1 3f96 	cmp.w	r1, #76800	; 0x12c00
    f566:	d037      	beq.n	f5d8 <baudrate_set+0x114>
    f568:	d905      	bls.n	f576 <baudrate_set+0xb2>
    f56a:	f5b1 3fe1 	cmp.w	r1, #115200	; 0x1c200
    f56e:	d10f      	bne.n	f590 <baudrate_set+0xcc>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    f570:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    f574:	e7cf      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f576:	f64d 23c0 	movw	r3, #56000	; 0xdac0
    f57a:	4299      	cmp	r1, r3
    f57c:	d02e      	beq.n	f5dc <baudrate_set+0x118>
    f57e:	f5b1 4f61 	cmp.w	r1, #57600	; 0xe100
    f582:	d102      	bne.n	f58a <baudrate_set+0xc6>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    f584:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    f588:	e7c5      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f58a:	f06f 0015 	mvn.w	r0, #21
    f58e:	4770      	bx	lr
    f590:	f06f 0015 	mvn.w	r0, #21
    f594:	4770      	bx	lr
    f596:	4b1a      	ldr	r3, [pc, #104]	; (f600 <baudrate_set+0x13c>)
    f598:	4299      	cmp	r1, r3
    f59a:	d025      	beq.n	f5e8 <baudrate_set+0x124>
    f59c:	f5b1 2fe1 	cmp.w	r1, #460800	; 0x70800
    f5a0:	d102      	bne.n	f5a8 <baudrate_set+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    f5a2:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    f5a6:	e7b6      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f5a8:	f06f 0015 	mvn.w	r0, #21
    f5ac:	4770      	bx	lr
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    f5ae:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    f5b2:	e7b0      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    f5b4:	4b13      	ldr	r3, [pc, #76]	; (f604 <baudrate_set+0x140>)
    f5b6:	e7ae      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    f5b8:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    f5bc:	e7ab      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f5be:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    f5c2:	e7a8      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    f5c4:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    f5c8:	e7a5      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    f5ca:	4b0f      	ldr	r3, [pc, #60]	; (f608 <baudrate_set+0x144>)
    f5cc:	e7a3      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    f5ce:	4b0f      	ldr	r3, [pc, #60]	; (f60c <baudrate_set+0x148>)
    f5d0:	e7a1      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    f5d2:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    f5d6:	e79e      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    f5d8:	4b0d      	ldr	r3, [pc, #52]	; (f610 <baudrate_set+0x14c>)
    f5da:	e79c      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    f5dc:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    f5e0:	e799      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    f5e2:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    f5e6:	e796      	b.n	f516 <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    f5e8:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    f5ec:	e793      	b.n	f516 <baudrate_set+0x52>
	switch (baudrate) {
    f5ee:	f06f 0015 	mvn.w	r0, #21
}
    f5f2:	4770      	bx	lr
    f5f4:	0013b000 	.word	0x0013b000
    f5f8:	004ea000 	.word	0x004ea000
    f5fc:	000f4240 	.word	0x000f4240
    f600:	0003d090 	.word	0x0003d090
    f604:	00275000 	.word	0x00275000
    f608:	0075c000 	.word	0x0075c000
    f60c:	003af000 	.word	0x003af000
    f610:	013a9000 	.word	0x013a9000

0000f614 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    f614:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f618:	4605      	mov	r5, r0
    f61a:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = dev->data;
    f61c:	f8d0 8010 	ldr.w	r8, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    f620:	f00c fcb5 	bl	1bf8e <k_is_in_isr>
    f624:	b920      	cbnz	r0, f630 <uarte_nrfx_poll_out+0x1c>
	return !z_sys_post_kernel;
    f626:	4b17      	ldr	r3, [pc, #92]	; (f684 <uarte_nrfx_poll_out+0x70>)
    f628:	781b      	ldrb	r3, [r3, #0]
    f62a:	b143      	cbz	r3, f63e <uarte_nrfx_poll_out+0x2a>
    f62c:	2300      	movs	r3, #0
    f62e:	e000      	b.n	f632 <uarte_nrfx_poll_out+0x1e>
    f630:	2301      	movs	r3, #1

		t = now;
	}
#endif

	if (isr_mode) {
    f632:	b953      	cbnz	r3, f64a <uarte_nrfx_poll_out+0x36>
			}

			irq_unlock(key);
		}
	} else {
		key = wait_tx_ready(dev);
    f634:	4628      	mov	r0, r5
    f636:	f00b fa10 	bl	1aa5a <wait_tx_ready>
    f63a:	4606      	mov	r6, r0
    f63c:	e013      	b.n	f666 <uarte_nrfx_poll_out+0x52>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    f63e:	2301      	movs	r3, #1
    f640:	e7f7      	b.n	f632 <uarte_nrfx_poll_out+0x1e>
    f642:	f384 8811 	msr	BASEPRI, r4
    f646:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    f64a:	f04f 0320 	mov.w	r3, #32
    f64e:	f3ef 8411 	mrs	r4, BASEPRI
    f652:	f383 8812 	msr	BASEPRI_MAX, r3
    f656:	f3bf 8f6f 	isb	sy
    f65a:	4626      	mov	r6, r4
			if (is_tx_ready(dev)) {
    f65c:	4628      	mov	r0, r5
    f65e:	f00b f9ad 	bl	1a9bc <is_tx_ready>
    f662:	2800      	cmp	r0, #0
    f664:	d0ed      	beq.n	f642 <uarte_nrfx_poll_out+0x2e>
	}

	*data->char_out = c;
    f666:	f8d8 3010 	ldr.w	r3, [r8, #16]
    f66a:	701f      	strb	r7, [r3, #0]
	tx_start(dev, data->char_out, 1);
    f66c:	2201      	movs	r2, #1
    f66e:	f8d8 1010 	ldr.w	r1, [r8, #16]
    f672:	4628      	mov	r0, r5
    f674:	f00b f9bc 	bl	1a9f0 <tx_start>
	__asm__ volatile(
    f678:	f386 8811 	msr	BASEPRI, r6
    f67c:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
    f680:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f684:	20002900 	.word	0x20002900

0000f688 <endtx_stoptx_ppi_init>:
#endif /* UARTE_INTERRUPT_DRIVEN */
};

static int endtx_stoptx_ppi_init(NRF_UARTE_Type *uarte,
				 struct uarte_nrfx_data *data)
{
    f688:	b530      	push	{r4, r5, lr}
    f68a:	b089      	sub	sp, #36	; 0x24
    f68c:	4605      	mov	r5, r0
    f68e:	460c      	mov	r4, r1
	nrfx_err_t ret;

	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    f690:	f101 0018 	add.w	r0, r1, #24
    f694:	f001 fe2c 	bl	112f0 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    f698:	4b1d      	ldr	r3, [pc, #116]	; (f710 <endtx_stoptx_ppi_init+0x88>)
    f69a:	4298      	cmp	r0, r3
    f69c:	d10f      	bne.n	f6be <endtx_stoptx_ppi_init+0x36>
		LOG_ERR("Failed to allocate PPI Channel");
		return -EIO;
	}

	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
    f69e:	7e23      	ldrb	r3, [r4, #24]
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    f6a0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    f6a4:	f8c5 31a0 	str.w	r3, [r5, #416]	; 0x1a0
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    f6a8:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c
		nrf_uarte_event_address_get(uarte, NRF_UARTE_EVENT_ENDTX),
		nrf_uarte_task_address_get(uarte, NRF_UARTE_TASK_STOPTX));
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    f6ac:	7e22      	ldrb	r2, [r4, #24]
    f6ae:	2301      	movs	r3, #1
    f6b0:	4093      	lsls	r3, r2
    f6b2:	4a18      	ldr	r2, [pc, #96]	; (f714 <endtx_stoptx_ppi_init+0x8c>)
    f6b4:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504

	return 0;
    f6b8:	2000      	movs	r0, #0
}
    f6ba:	b009      	add	sp, #36	; 0x24
    f6bc:	bd30      	pop	{r4, r5, pc}
		LOG_ERR("Failed to allocate PPI Channel");
    f6be:	4b16      	ldr	r3, [pc, #88]	; (f718 <endtx_stoptx_ppi_init+0x90>)
    f6c0:	9307      	str	r3, [sp, #28]
    f6c2:	2302      	movs	r3, #2
    f6c4:	f88d 3004 	strb.w	r3, [sp, #4]
    f6c8:	2300      	movs	r3, #0
    f6ca:	f88d 3005 	strb.w	r3, [sp, #5]
    f6ce:	f88d 3006 	strb.w	r3, [sp, #6]
    f6d2:	f88d 3007 	strb.w	r3, [sp, #7]
    f6d6:	9a01      	ldr	r2, [sp, #4]
    f6d8:	9206      	str	r2, [sp, #24]
    f6da:	4619      	mov	r1, r3
    f6dc:	f363 0100 	bfi	r1, r3, #0, #1
    f6e0:	f363 0141 	bfi	r1, r3, #1, #1
    f6e4:	f363 0182 	bfi	r1, r3, #2, #1
    f6e8:	f363 01c5 	bfi	r1, r3, #3, #3
    f6ec:	2201      	movs	r2, #1
    f6ee:	f362 1188 	bfi	r1, r2, #6, #3
    f6f2:	2208      	movs	r2, #8
    f6f4:	f362 2152 	bfi	r1, r2, #9, #10
    f6f8:	f363 41de 	bfi	r1, r3, #19, #12
    f6fc:	f363 71df 	bfi	r1, r3, #31, #1
    f700:	aa06      	add	r2, sp, #24
    f702:	4806      	ldr	r0, [pc, #24]	; (f71c <endtx_stoptx_ppi_init+0x94>)
    f704:	f7f2 fda0 	bl	2248 <z_impl_z_log_msg_static_create>
		return -EIO;
    f708:	f06f 0004 	mvn.w	r0, #4
    f70c:	e7d5      	b.n	f6ba <endtx_stoptx_ppi_init+0x32>
    f70e:	bf00      	nop
    f710:	0bad0000 	.word	0x0bad0000
    f714:	50017000 	.word	0x50017000
    f718:	0001f99c 	.word	0x0001f99c
    f71c:	0001d0bc 	.word	0x0001d0bc

0000f720 <hci_ept_bound>:
	net_buf_unref(buf);
	return 0;
}

static void hci_ept_bound(void *priv)
{
    f720:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    f722:	4802      	ldr	r0, [pc, #8]	; (f72c <hci_ept_bound+0xc>)
    f724:	f004 fa34 	bl	13b90 <z_impl_k_sem_give>
	k_sem_give(&ipc_bound_sem);
}
    f728:	bd08      	pop	{r3, pc}
    f72a:	bf00      	nop
    f72c:	20000624 	.word	0x20000624

0000f730 <bt_rpmsg_init>:
	.quirks         = BT_QUIRK_NO_AUTO_DLE,
#endif
};

static int bt_rpmsg_init(const struct device *unused)
{
    f730:	b5b0      	push	{r4, r5, r7, lr}
    f732:	b082      	sub	sp, #8
    f734:	af00      	add	r7, sp, #0
	ARG_UNUSED(unused);

	int err;

	err = bt_hci_driver_register(&drv);
    f736:	4823      	ldr	r0, [pc, #140]	; (f7c4 <bt_rpmsg_init+0x94>)
    f738:	f7f8 ffac 	bl	8694 <bt_hci_driver_register>
	if (err < 0) {
    f73c:	1e04      	subs	r4, r0, #0
    f73e:	db03      	blt.n	f748 <bt_rpmsg_init+0x18>
		BT_ERR("Failed to register BT HIC driver (err %d)", err);
	}

	return err;
}
    f740:	4620      	mov	r0, r4
    f742:	3708      	adds	r7, #8
    f744:	46bd      	mov	sp, r7
    f746:	bdb0      	pop	{r4, r5, r7, pc}
		BT_ERR("Failed to register BT HIC driver (err %d)", err);
    f748:	466d      	mov	r5, sp
    f74a:	b088      	sub	sp, #32
    f74c:	466b      	mov	r3, sp
    f74e:	f113 0210 	adds.w	r2, r3, #16
    f752:	d030      	beq.n	f7b6 <bt_rpmsg_init+0x86>
    f754:	210c      	movs	r1, #12
    f756:	b11a      	cbz	r2, f760 <bt_rpmsg_init+0x30>
    f758:	2904      	cmp	r1, #4
    f75a:	dd01      	ble.n	f760 <bt_rpmsg_init+0x30>
    f75c:	481a      	ldr	r0, [pc, #104]	; (f7c8 <bt_rpmsg_init+0x98>)
    f75e:	6158      	str	r0, [r3, #20]
    f760:	b112      	cbz	r2, f768 <bt_rpmsg_init+0x38>
    f762:	2908      	cmp	r1, #8
    f764:	dd00      	ble.n	f768 <bt_rpmsg_init+0x38>
    f766:	619c      	str	r4, [r3, #24]
    f768:	290b      	cmp	r1, #11
    f76a:	dd27      	ble.n	f7bc <bt_rpmsg_init+0x8c>
    f76c:	f04f 0c0c 	mov.w	ip, #12
    f770:	b13a      	cbz	r2, f782 <bt_rpmsg_init+0x52>
    f772:	2103      	movs	r1, #3
    f774:	7139      	strb	r1, [r7, #4]
    f776:	2100      	movs	r1, #0
    f778:	7179      	strb	r1, [r7, #5]
    f77a:	71b9      	strb	r1, [r7, #6]
    f77c:	71f9      	strb	r1, [r7, #7]
    f77e:	6878      	ldr	r0, [r7, #4]
    f780:	6118      	str	r0, [r3, #16]
    f782:	2100      	movs	r1, #0
    f784:	f36f 0100 	bfc	r1, #0, #1
    f788:	f36f 0141 	bfc	r1, #1, #1
    f78c:	f36f 0182 	bfc	r1, #2, #1
    f790:	f36f 01c5 	bfc	r1, #3, #3
    f794:	2301      	movs	r3, #1
    f796:	f363 1188 	bfi	r1, r3, #6, #3
    f79a:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    f79e:	f36c 2152 	bfi	r1, ip, #9, #10
    f7a2:	f36f 41de 	bfc	r1, #19, #12
    f7a6:	f36f 71df 	bfc	r1, #31, #1
    f7aa:	2300      	movs	r3, #0
    f7ac:	4807      	ldr	r0, [pc, #28]	; (f7cc <bt_rpmsg_init+0x9c>)
    f7ae:	f7f2 fd4b 	bl	2248 <z_impl_z_log_msg_static_create>
    f7b2:	46ad      	mov	sp, r5
	return err;
    f7b4:	e7c4      	b.n	f740 <bt_rpmsg_init+0x10>
		BT_ERR("Failed to register BT HIC driver (err %d)", err);
    f7b6:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    f7ba:	e7cc      	b.n	f756 <bt_rpmsg_init+0x26>
    f7bc:	f06f 0c1b 	mvn.w	ip, #27
    f7c0:	e7d6      	b.n	f770 <bt_rpmsg_init+0x40>
    f7c2:	bf00      	nop
    f7c4:	0001fc84 	.word	0x0001fc84
    f7c8:	0001fa20 	.word	0x0001fa20
    f7cc:	0001d004 	.word	0x0001d004

0000f7d0 <bt_rpmsg_send>:
{
    f7d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    f7d2:	b083      	sub	sp, #12
    f7d4:	af00      	add	r7, sp, #0
    f7d6:	4604      	mov	r4, r0
    f7d8:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
    f7da:	2902      	cmp	r1, #2
    f7dc:	d041      	beq.n	f862 <bt_rpmsg_send+0x92>
    f7de:	4608      	mov	r0, r1
    f7e0:	2904      	cmp	r1, #4
    f7e2:	d03d      	beq.n	f860 <bt_rpmsg_send+0x90>
    f7e4:	2900      	cmp	r1, #0
    f7e6:	d04e      	beq.n	f886 <bt_rpmsg_send+0xb6>
		BT_ERR("Unknown type %u", bt_buf_get_type(buf));
    f7e8:	466e      	mov	r6, sp
    f7ea:	b088      	sub	sp, #32
    f7ec:	466b      	mov	r3, sp
    f7ee:	f113 0210 	adds.w	r2, r3, #16
    f7f2:	d02f      	beq.n	f854 <bt_rpmsg_send+0x84>
    f7f4:	210c      	movs	r1, #12
    f7f6:	b11a      	cbz	r2, f800 <bt_rpmsg_send+0x30>
    f7f8:	2904      	cmp	r1, #4
    f7fa:	dd01      	ble.n	f800 <bt_rpmsg_send+0x30>
    f7fc:	4d41      	ldr	r5, [pc, #260]	; (f904 <bt_rpmsg_send+0x134>)
    f7fe:	615d      	str	r5, [r3, #20]
    f800:	b112      	cbz	r2, f808 <bt_rpmsg_send+0x38>
    f802:	2908      	cmp	r1, #8
    f804:	dd00      	ble.n	f808 <bt_rpmsg_send+0x38>
    f806:	6198      	str	r0, [r3, #24]
    f808:	290b      	cmp	r1, #11
    f80a:	dd26      	ble.n	f85a <bt_rpmsg_send+0x8a>
    f80c:	250c      	movs	r5, #12
    f80e:	b13a      	cbz	r2, f820 <bt_rpmsg_send+0x50>
    f810:	2103      	movs	r1, #3
    f812:	7139      	strb	r1, [r7, #4]
    f814:	2100      	movs	r1, #0
    f816:	7179      	strb	r1, [r7, #5]
    f818:	71b9      	strb	r1, [r7, #6]
    f81a:	71f9      	strb	r1, [r7, #7]
    f81c:	6878      	ldr	r0, [r7, #4]
    f81e:	6118      	str	r0, [r3, #16]
    f820:	2100      	movs	r1, #0
    f822:	f36f 0100 	bfc	r1, #0, #1
    f826:	f36f 0141 	bfc	r1, #1, #1
    f82a:	f36f 0182 	bfc	r1, #2, #1
    f82e:	f36f 01c5 	bfc	r1, #3, #3
    f832:	2301      	movs	r3, #1
    f834:	f363 1188 	bfi	r1, r3, #6, #3
    f838:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    f83c:	f365 2152 	bfi	r1, r5, #9, #10
    f840:	f36f 41de 	bfc	r1, #19, #12
    f844:	f36f 71df 	bfc	r1, #31, #1
    f848:	2300      	movs	r3, #0
    f84a:	482f      	ldr	r0, [pc, #188]	; (f908 <bt_rpmsg_send+0x138>)
    f84c:	f7f2 fcfc 	bl	2248 <z_impl_z_log_msg_static_create>
    f850:	46b5      	mov	sp, r6
		goto done;
    f852:	e011      	b.n	f878 <bt_rpmsg_send+0xa8>
		BT_ERR("Unknown type %u", bt_buf_get_type(buf));
    f854:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    f858:	e7cd      	b.n	f7f6 <bt_rpmsg_send+0x26>
    f85a:	f06f 051b 	mvn.w	r5, #27
    f85e:	e7d6      	b.n	f80e <bt_rpmsg_send+0x3e>
		pkt_indicator = RPMSG_ISO;
    f860:	2105      	movs	r1, #5
	net_buf_simple_push_u8(&buf->b, val);
    f862:	f104 0008 	add.w	r0, r4, #8
    f866:	f00a fcf3 	bl	1a250 <net_buf_simple_push_u8>
	err = ipc_service_send(&hci_ept, buf->data, buf->len);
    f86a:	89a2      	ldrh	r2, [r4, #12]
    f86c:	68a1      	ldr	r1, [r4, #8]
    f86e:	4827      	ldr	r0, [pc, #156]	; (f90c <bt_rpmsg_send+0x13c>)
    f870:	f7f3 f85a 	bl	2928 <ipc_service_send>
	if (err < 0) {
    f874:	2800      	cmp	r0, #0
    f876:	db08      	blt.n	f88a <bt_rpmsg_send+0xba>
	net_buf_unref(buf);
    f878:	4620      	mov	r0, r4
    f87a:	f00a fc76 	bl	1a16a <net_buf_unref>
}
    f87e:	2000      	movs	r0, #0
    f880:	370c      	adds	r7, #12
    f882:	46bd      	mov	sp, r7
    f884:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pkt_indicator = RPMSG_CMD;
    f886:	2101      	movs	r1, #1
    f888:	e7eb      	b.n	f862 <bt_rpmsg_send+0x92>
		BT_ERR("Failed to send (err %d)", err);
    f88a:	466d      	mov	r5, sp
    f88c:	b088      	sub	sp, #32
    f88e:	466b      	mov	r3, sp
    f890:	f113 0210 	adds.w	r2, r3, #16
    f894:	d030      	beq.n	f8f8 <bt_rpmsg_send+0x128>
    f896:	210c      	movs	r1, #12
    f898:	b11a      	cbz	r2, f8a2 <bt_rpmsg_send+0xd2>
    f89a:	2904      	cmp	r1, #4
    f89c:	dd01      	ble.n	f8a2 <bt_rpmsg_send+0xd2>
    f89e:	4e1c      	ldr	r6, [pc, #112]	; (f910 <bt_rpmsg_send+0x140>)
    f8a0:	615e      	str	r6, [r3, #20]
    f8a2:	b112      	cbz	r2, f8aa <bt_rpmsg_send+0xda>
    f8a4:	2908      	cmp	r1, #8
    f8a6:	dd00      	ble.n	f8aa <bt_rpmsg_send+0xda>
    f8a8:	6198      	str	r0, [r3, #24]
    f8aa:	290b      	cmp	r1, #11
    f8ac:	dd27      	ble.n	f8fe <bt_rpmsg_send+0x12e>
    f8ae:	f04f 0c0c 	mov.w	ip, #12
    f8b2:	b13a      	cbz	r2, f8c4 <bt_rpmsg_send+0xf4>
    f8b4:	2103      	movs	r1, #3
    f8b6:	7139      	strb	r1, [r7, #4]
    f8b8:	2100      	movs	r1, #0
    f8ba:	7179      	strb	r1, [r7, #5]
    f8bc:	71b9      	strb	r1, [r7, #6]
    f8be:	71f9      	strb	r1, [r7, #7]
    f8c0:	6878      	ldr	r0, [r7, #4]
    f8c2:	6118      	str	r0, [r3, #16]
    f8c4:	2100      	movs	r1, #0
    f8c6:	f36f 0100 	bfc	r1, #0, #1
    f8ca:	f36f 0141 	bfc	r1, #1, #1
    f8ce:	f36f 0182 	bfc	r1, #2, #1
    f8d2:	f36f 01c5 	bfc	r1, #3, #3
    f8d6:	2301      	movs	r3, #1
    f8d8:	f363 1188 	bfi	r1, r3, #6, #3
    f8dc:	f40c 737b 	and.w	r3, ip, #1004	; 0x3ec
    f8e0:	f363 2152 	bfi	r1, r3, #9, #10
    f8e4:	f36f 41de 	bfc	r1, #19, #12
    f8e8:	f36f 71df 	bfc	r1, #31, #1
    f8ec:	2300      	movs	r3, #0
    f8ee:	4806      	ldr	r0, [pc, #24]	; (f908 <bt_rpmsg_send+0x138>)
    f8f0:	f7f2 fcaa 	bl	2248 <z_impl_z_log_msg_static_create>
    f8f4:	46ad      	mov	sp, r5
    f8f6:	e7bf      	b.n	f878 <bt_rpmsg_send+0xa8>
    f8f8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    f8fc:	e7cc      	b.n	f898 <bt_rpmsg_send+0xc8>
    f8fe:	f06f 0c1b 	mvn.w	ip, #27
    f902:	e7d6      	b.n	f8b2 <bt_rpmsg_send+0xe2>
    f904:	0001fa4c 	.word	0x0001fa4c
    f908:	0001d004 	.word	0x0001d004
    f90c:	200025b0 	.word	0x200025b0
    f910:	0001fa5c 	.word	0x0001fa5c

0000f914 <bt_rpmsg_open>:
{
    f914:	b5f0      	push	{r4, r5, r6, r7, lr}
    f916:	b083      	sub	sp, #12
    f918:	af00      	add	r7, sp, #0
	err = ipc_service_open_instance(hci_ipc_instance);
    f91a:	4869      	ldr	r0, [pc, #420]	; (fac0 <bt_rpmsg_open+0x1ac>)
    f91c:	f7f2 ff38 	bl	2790 <ipc_service_open_instance>
	if (err && (err != -EALREADY)) {
    f920:	2800      	cmp	r0, #0
    f922:	d040      	beq.n	f9a6 <bt_rpmsg_open+0x92>
    f924:	4604      	mov	r4, r0
    f926:	f110 0f78 	cmn.w	r0, #120	; 0x78
    f92a:	d03c      	beq.n	f9a6 <bt_rpmsg_open+0x92>
		BT_ERR("IPC service instance initialization failed: %d\n", err);
    f92c:	466d      	mov	r5, sp
    f92e:	b088      	sub	sp, #32
    f930:	466b      	mov	r3, sp
    f932:	f113 0210 	adds.w	r2, r3, #16
    f936:	d030      	beq.n	f99a <bt_rpmsg_open+0x86>
    f938:	210c      	movs	r1, #12
    f93a:	b11a      	cbz	r2, f944 <bt_rpmsg_open+0x30>
    f93c:	2904      	cmp	r1, #4
    f93e:	dd01      	ble.n	f944 <bt_rpmsg_open+0x30>
    f940:	4860      	ldr	r0, [pc, #384]	; (fac4 <bt_rpmsg_open+0x1b0>)
    f942:	6158      	str	r0, [r3, #20]
    f944:	b112      	cbz	r2, f94c <bt_rpmsg_open+0x38>
    f946:	2908      	cmp	r1, #8
    f948:	dd00      	ble.n	f94c <bt_rpmsg_open+0x38>
    f94a:	619c      	str	r4, [r3, #24]
    f94c:	290b      	cmp	r1, #11
    f94e:	dd27      	ble.n	f9a0 <bt_rpmsg_open+0x8c>
    f950:	f04f 0c0c 	mov.w	ip, #12
    f954:	b13a      	cbz	r2, f966 <bt_rpmsg_open+0x52>
    f956:	2103      	movs	r1, #3
    f958:	7139      	strb	r1, [r7, #4]
    f95a:	2100      	movs	r1, #0
    f95c:	7179      	strb	r1, [r7, #5]
    f95e:	71b9      	strb	r1, [r7, #6]
    f960:	71f9      	strb	r1, [r7, #7]
    f962:	6878      	ldr	r0, [r7, #4]
    f964:	6118      	str	r0, [r3, #16]
    f966:	2100      	movs	r1, #0
    f968:	f36f 0100 	bfc	r1, #0, #1
    f96c:	f36f 0141 	bfc	r1, #1, #1
    f970:	f36f 0182 	bfc	r1, #2, #1
    f974:	f36f 01c5 	bfc	r1, #3, #3
    f978:	2301      	movs	r3, #1
    f97a:	f363 1188 	bfi	r1, r3, #6, #3
    f97e:	f40c 737b 	and.w	r3, ip, #1004	; 0x3ec
    f982:	f363 2152 	bfi	r1, r3, #9, #10
    f986:	f36f 41de 	bfc	r1, #19, #12
    f98a:	f36f 71df 	bfc	r1, #31, #1
    f98e:	2300      	movs	r3, #0
    f990:	484d      	ldr	r0, [pc, #308]	; (fac8 <bt_rpmsg_open+0x1b4>)
    f992:	f7f2 fc59 	bl	2248 <z_impl_z_log_msg_static_create>
    f996:	46ad      	mov	sp, r5
		return err;
    f998:	e043      	b.n	fa22 <bt_rpmsg_open+0x10e>
		BT_ERR("IPC service instance initialization failed: %d\n", err);
    f99a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    f99e:	e7cc      	b.n	f93a <bt_rpmsg_open+0x26>
    f9a0:	f06f 0c1b 	mvn.w	ip, #27
    f9a4:	e7d6      	b.n	f954 <bt_rpmsg_open+0x40>
	err = ipc_service_register_endpoint(hci_ipc_instance, &hci_ept, &hci_ept_cfg);
    f9a6:	4a49      	ldr	r2, [pc, #292]	; (facc <bt_rpmsg_open+0x1b8>)
    f9a8:	4949      	ldr	r1, [pc, #292]	; (fad0 <bt_rpmsg_open+0x1bc>)
    f9aa:	4845      	ldr	r0, [pc, #276]	; (fac0 <bt_rpmsg_open+0x1ac>)
    f9ac:	f7f2 ff54 	bl	2858 <ipc_service_register_endpoint>
	if (err) {
    f9b0:	4604      	mov	r4, r0
    f9b2:	2800      	cmp	r0, #0
    f9b4:	d03f      	beq.n	fa36 <bt_rpmsg_open+0x122>
		BT_ERR("Registering endpoint failed with %d", err);
    f9b6:	466d      	mov	r5, sp
    f9b8:	b088      	sub	sp, #32
    f9ba:	466b      	mov	r3, sp
    f9bc:	f113 0210 	adds.w	r2, r3, #16
    f9c0:	d033      	beq.n	fa2a <bt_rpmsg_open+0x116>
    f9c2:	210c      	movs	r1, #12
    f9c4:	b11a      	cbz	r2, f9ce <bt_rpmsg_open+0xba>
    f9c6:	2904      	cmp	r1, #4
    f9c8:	dd01      	ble.n	f9ce <bt_rpmsg_open+0xba>
    f9ca:	4842      	ldr	r0, [pc, #264]	; (fad4 <bt_rpmsg_open+0x1c0>)
    f9cc:	6158      	str	r0, [r3, #20]
    f9ce:	b112      	cbz	r2, f9d6 <bt_rpmsg_open+0xc2>
    f9d0:	2908      	cmp	r1, #8
    f9d2:	dd00      	ble.n	f9d6 <bt_rpmsg_open+0xc2>
    f9d4:	619c      	str	r4, [r3, #24]
    f9d6:	290b      	cmp	r1, #11
    f9d8:	dd2a      	ble.n	fa30 <bt_rpmsg_open+0x11c>
    f9da:	f04f 0c0c 	mov.w	ip, #12
    f9de:	b13a      	cbz	r2, f9f0 <bt_rpmsg_open+0xdc>
    f9e0:	2103      	movs	r1, #3
    f9e2:	7139      	strb	r1, [r7, #4]
    f9e4:	2100      	movs	r1, #0
    f9e6:	7179      	strb	r1, [r7, #5]
    f9e8:	71b9      	strb	r1, [r7, #6]
    f9ea:	71f9      	strb	r1, [r7, #7]
    f9ec:	6878      	ldr	r0, [r7, #4]
    f9ee:	6118      	str	r0, [r3, #16]
    f9f0:	2100      	movs	r1, #0
    f9f2:	f36f 0100 	bfc	r1, #0, #1
    f9f6:	f36f 0141 	bfc	r1, #1, #1
    f9fa:	f36f 0182 	bfc	r1, #2, #1
    f9fe:	f36f 01c5 	bfc	r1, #3, #3
    fa02:	2301      	movs	r3, #1
    fa04:	f363 1188 	bfi	r1, r3, #6, #3
    fa08:	f40c 7c7b 	and.w	ip, ip, #1004	; 0x3ec
    fa0c:	f36c 2152 	bfi	r1, ip, #9, #10
    fa10:	f36f 41de 	bfc	r1, #19, #12
    fa14:	f36f 71df 	bfc	r1, #31, #1
    fa18:	2300      	movs	r3, #0
    fa1a:	482b      	ldr	r0, [pc, #172]	; (fac8 <bt_rpmsg_open+0x1b4>)
    fa1c:	f7f2 fc14 	bl	2248 <z_impl_z_log_msg_static_create>
    fa20:	46ad      	mov	sp, r5
}
    fa22:	4620      	mov	r0, r4
    fa24:	370c      	adds	r7, #12
    fa26:	46bd      	mov	sp, r7
    fa28:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("Registering endpoint failed with %d", err);
    fa2a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    fa2e:	e7c9      	b.n	f9c4 <bt_rpmsg_open+0xb0>
    fa30:	f06f 0c1b 	mvn.w	ip, #27
    fa34:	e7d3      	b.n	f9de <bt_rpmsg_open+0xca>
	return z_impl_k_sem_take(sem, timeout);
    fa36:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    fa3a:	2300      	movs	r3, #0
    fa3c:	4826      	ldr	r0, [pc, #152]	; (fad8 <bt_rpmsg_open+0x1c4>)
    fa3e:	f004 f8cf 	bl	13be0 <z_impl_k_sem_take>
	if (err) {
    fa42:	4604      	mov	r4, r0
    fa44:	2800      	cmp	r0, #0
    fa46:	d0ec      	beq.n	fa22 <bt_rpmsg_open+0x10e>
		BT_ERR("Endpoint binding failed with %d", err);
    fa48:	466e      	mov	r6, sp
    fa4a:	b088      	sub	sp, #32
    fa4c:	466b      	mov	r3, sp
    fa4e:	f113 0210 	adds.w	r2, r3, #16
    fa52:	d02f      	beq.n	fab4 <bt_rpmsg_open+0x1a0>
    fa54:	210c      	movs	r1, #12
    fa56:	b11a      	cbz	r2, fa60 <bt_rpmsg_open+0x14c>
    fa58:	2904      	cmp	r1, #4
    fa5a:	dd01      	ble.n	fa60 <bt_rpmsg_open+0x14c>
    fa5c:	481f      	ldr	r0, [pc, #124]	; (fadc <bt_rpmsg_open+0x1c8>)
    fa5e:	6158      	str	r0, [r3, #20]
    fa60:	b112      	cbz	r2, fa68 <bt_rpmsg_open+0x154>
    fa62:	2908      	cmp	r1, #8
    fa64:	dd00      	ble.n	fa68 <bt_rpmsg_open+0x154>
    fa66:	619c      	str	r4, [r3, #24]
    fa68:	290b      	cmp	r1, #11
    fa6a:	dd26      	ble.n	faba <bt_rpmsg_open+0x1a6>
    fa6c:	250c      	movs	r5, #12
    fa6e:	b13a      	cbz	r2, fa80 <bt_rpmsg_open+0x16c>
    fa70:	2103      	movs	r1, #3
    fa72:	7139      	strb	r1, [r7, #4]
    fa74:	2100      	movs	r1, #0
    fa76:	7179      	strb	r1, [r7, #5]
    fa78:	71b9      	strb	r1, [r7, #6]
    fa7a:	71f9      	strb	r1, [r7, #7]
    fa7c:	6878      	ldr	r0, [r7, #4]
    fa7e:	6118      	str	r0, [r3, #16]
    fa80:	2100      	movs	r1, #0
    fa82:	f36f 0100 	bfc	r1, #0, #1
    fa86:	f36f 0141 	bfc	r1, #1, #1
    fa8a:	f36f 0182 	bfc	r1, #2, #1
    fa8e:	f36f 01c5 	bfc	r1, #3, #3
    fa92:	2301      	movs	r3, #1
    fa94:	f363 1188 	bfi	r1, r3, #6, #3
    fa98:	f405 757b 	and.w	r5, r5, #1004	; 0x3ec
    fa9c:	f365 2152 	bfi	r1, r5, #9, #10
    faa0:	f36f 41de 	bfc	r1, #19, #12
    faa4:	f36f 71df 	bfc	r1, #31, #1
    faa8:	2300      	movs	r3, #0
    faaa:	4807      	ldr	r0, [pc, #28]	; (fac8 <bt_rpmsg_open+0x1b4>)
    faac:	f7f2 fbcc 	bl	2248 <z_impl_z_log_msg_static_create>
    fab0:	46b5      	mov	sp, r6
		return err;
    fab2:	e7b6      	b.n	fa22 <bt_rpmsg_open+0x10e>
		BT_ERR("Endpoint binding failed with %d", err);
    fab4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    fab8:	e7cd      	b.n	fa56 <bt_rpmsg_open+0x142>
    faba:	f06f 051b 	mvn.w	r5, #27
    fabe:	e7d6      	b.n	fa6e <bt_rpmsg_open+0x15a>
    fac0:	0001cc74 	.word	0x0001cc74
    fac4:	0001fa74 	.word	0x0001fa74
    fac8:	0001d004 	.word	0x0001d004
    facc:	20000404 	.word	0x20000404
    fad0:	200025b0 	.word	0x200025b0
    fad4:	0001faa4 	.word	0x0001faa4
    fad8:	20000624 	.word	0x20000624
    fadc:	0001fac8 	.word	0x0001fac8

0000fae0 <bt_rpmsg_evt_recv>:
{
    fae0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    fae4:	b095      	sub	sp, #84	; 0x54
    fae6:	af00      	add	r7, sp, #0
	if (remaining < sizeof(hdr)) {
    fae8:	2901      	cmp	r1, #1
    faea:	d934      	bls.n	fb56 <bt_rpmsg_evt_recv+0x76>
    faec:	4681      	mov	r9, r0
    faee:	4688      	mov	r8, r1
	discardable = is_hci_event_discardable(data);
    faf0:	f00b f84a 	bl	1ab88 <is_hci_event_discardable>
    faf4:	4604      	mov	r4, r0
	memcpy((void *)&hdr, data, sizeof(hdr));
    faf6:	2202      	movs	r2, #2
    faf8:	4649      	mov	r1, r9
    fafa:	1d38      	adds	r0, r7, #4
    fafc:	f007 fe18 	bl	17730 <memcpy>
	data += sizeof(hdr);
    fb00:	f109 0902 	add.w	r9, r9, #2
	remaining -= sizeof(hdr);
    fb04:	f1a8 0802 	sub.w	r8, r8, #2
	if (remaining != hdr.len) {
    fb08:	797b      	ldrb	r3, [r7, #5]
    fb0a:	4543      	cmp	r3, r8
    fb0c:	d04f      	beq.n	fbae <bt_rpmsg_evt_recv+0xce>
		BT_ERR("Event payload length is not correct");
    fb0e:	4b6a      	ldr	r3, [pc, #424]	; (fcb8 <bt_rpmsg_evt_recv+0x1d8>)
    fb10:	637b      	str	r3, [r7, #52]	; 0x34
    fb12:	2302      	movs	r3, #2
    fb14:	703b      	strb	r3, [r7, #0]
    fb16:	2600      	movs	r6, #0
    fb18:	707e      	strb	r6, [r7, #1]
    fb1a:	70be      	strb	r6, [r7, #2]
    fb1c:	70fe      	strb	r6, [r7, #3]
    fb1e:	683b      	ldr	r3, [r7, #0]
    fb20:	633b      	str	r3, [r7, #48]	; 0x30
    fb22:	4631      	mov	r1, r6
    fb24:	f366 0100 	bfi	r1, r6, #0, #1
    fb28:	f366 0141 	bfi	r1, r6, #1, #1
    fb2c:	f366 0182 	bfi	r1, r6, #2, #1
    fb30:	f366 01c5 	bfi	r1, r6, #3, #3
    fb34:	2301      	movs	r3, #1
    fb36:	f363 1188 	bfi	r1, r3, #6, #3
    fb3a:	2308      	movs	r3, #8
    fb3c:	f363 2152 	bfi	r1, r3, #9, #10
    fb40:	f366 41de 	bfi	r1, r6, #19, #12
    fb44:	f366 71df 	bfi	r1, r6, #31, #1
    fb48:	4633      	mov	r3, r6
    fb4a:	f107 0230 	add.w	r2, r7, #48	; 0x30
    fb4e:	485b      	ldr	r0, [pc, #364]	; (fcbc <bt_rpmsg_evt_recv+0x1dc>)
    fb50:	f7f2 fb7a 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    fb54:	e066      	b.n	fc24 <bt_rpmsg_evt_recv+0x144>
		BT_ERR("Not enough data for event header");
    fb56:	4b5a      	ldr	r3, [pc, #360]	; (fcc0 <bt_rpmsg_evt_recv+0x1e0>)
    fb58:	64fb      	str	r3, [r7, #76]	; 0x4c
    fb5a:	2302      	movs	r3, #2
    fb5c:	703b      	strb	r3, [r7, #0]
    fb5e:	2600      	movs	r6, #0
    fb60:	707e      	strb	r6, [r7, #1]
    fb62:	70be      	strb	r6, [r7, #2]
    fb64:	70fe      	strb	r6, [r7, #3]
    fb66:	683b      	ldr	r3, [r7, #0]
    fb68:	64bb      	str	r3, [r7, #72]	; 0x48
    fb6a:	4631      	mov	r1, r6
    fb6c:	f366 0100 	bfi	r1, r6, #0, #1
    fb70:	f366 0141 	bfi	r1, r6, #1, #1
    fb74:	f366 0182 	bfi	r1, r6, #2, #1
    fb78:	f366 01c5 	bfi	r1, r6, #3, #3
    fb7c:	2301      	movs	r3, #1
    fb7e:	f363 1188 	bfi	r1, r3, #6, #3
    fb82:	2308      	movs	r3, #8
    fb84:	f363 2152 	bfi	r1, r3, #9, #10
    fb88:	f366 41de 	bfi	r1, r6, #19, #12
    fb8c:	f366 71df 	bfi	r1, r6, #31, #1
    fb90:	4633      	mov	r3, r6
    fb92:	f107 0248 	add.w	r2, r7, #72	; 0x48
    fb96:	4849      	ldr	r0, [pc, #292]	; (fcbc <bt_rpmsg_evt_recv+0x1dc>)
    fb98:	f7f2 fb56 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    fb9c:	e042      	b.n	fc24 <bt_rpmsg_evt_recv+0x144>
		buf = bt_buf_get_evt(hdr.evt, discardable, discardable ? K_NO_WAIT : K_SECONDS(10));
    fb9e:	2200      	movs	r2, #0
    fba0:	2300      	movs	r3, #0
    fba2:	4621      	mov	r1, r4
    fba4:	f7f5 fe66 	bl	5874 <bt_buf_get_evt>
		if (!buf) {
    fba8:	4606      	mov	r6, r0
    fbaa:	b138      	cbz	r0, fbbc <bt_rpmsg_evt_recv+0xdc>
	} while (!buf);
    fbac:	bb4e      	cbnz	r6, fc02 <bt_rpmsg_evt_recv+0x122>
		buf = bt_buf_get_evt(hdr.evt, discardable, discardable ? K_NO_WAIT : K_SECONDS(10));
    fbae:	7938      	ldrb	r0, [r7, #4]
    fbb0:	2c00      	cmp	r4, #0
    fbb2:	d1f4      	bne.n	fb9e <bt_rpmsg_evt_recv+0xbe>
    fbb4:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
    fbb8:	2300      	movs	r3, #0
    fbba:	e7f2      	b.n	fba2 <bt_rpmsg_evt_recv+0xc2>
			if (discardable) {
    fbbc:	bb94      	cbnz	r4, fc24 <bt_rpmsg_evt_recv+0x144>
			BT_WARN("Couldn't allocate a buffer after waiting 10 seconds.");
    fbbe:	4b41      	ldr	r3, [pc, #260]	; (fcc4 <bt_rpmsg_evt_recv+0x1e4>)
    fbc0:	61fb      	str	r3, [r7, #28]
    fbc2:	2202      	movs	r2, #2
    fbc4:	703a      	strb	r2, [r7, #0]
    fbc6:	2300      	movs	r3, #0
    fbc8:	707b      	strb	r3, [r7, #1]
    fbca:	70bb      	strb	r3, [r7, #2]
    fbcc:	70fb      	strb	r3, [r7, #3]
    fbce:	6839      	ldr	r1, [r7, #0]
    fbd0:	61b9      	str	r1, [r7, #24]
    fbd2:	f363 0500 	bfi	r5, r3, #0, #1
    fbd6:	f363 0541 	bfi	r5, r3, #1, #1
    fbda:	f363 0582 	bfi	r5, r3, #2, #1
    fbde:	f363 05c5 	bfi	r5, r3, #3, #3
    fbe2:	f362 1588 	bfi	r5, r2, #6, #3
    fbe6:	2208      	movs	r2, #8
    fbe8:	f362 2552 	bfi	r5, r2, #9, #10
    fbec:	f363 45de 	bfi	r5, r3, #19, #12
    fbf0:	f363 75df 	bfi	r5, r3, #31, #1
    fbf4:	f107 0218 	add.w	r2, r7, #24
    fbf8:	4629      	mov	r1, r5
    fbfa:	4830      	ldr	r0, [pc, #192]	; (fcbc <bt_rpmsg_evt_recv+0x1dc>)
    fbfc:	f7f2 fb24 	bl	2248 <z_impl_z_log_msg_static_create>
    fc00:	e7d4      	b.n	fbac <bt_rpmsg_evt_recv+0xcc>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    fc02:	f106 0408 	add.w	r4, r6, #8
    fc06:	2202      	movs	r2, #2
    fc08:	1d39      	adds	r1, r7, #4
    fc0a:	4620      	mov	r0, r4
    fc0c:	f00a fafd 	bl	1a20a <net_buf_simple_add_mem>
	return net_buf_simple_tailroom(&buf->b);
    fc10:	4620      	mov	r0, r4
    fc12:	f00a fb40 	bl	1a296 <net_buf_simple_tailroom>
	if (buf_tailroom < remaining) {
    fc16:	4580      	cmp	r8, r0
    fc18:	d809      	bhi.n	fc2e <bt_rpmsg_evt_recv+0x14e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    fc1a:	4642      	mov	r2, r8
    fc1c:	4649      	mov	r1, r9
    fc1e:	4620      	mov	r0, r4
    fc20:	f00a faf3 	bl	1a20a <net_buf_simple_add_mem>
}
    fc24:	4630      	mov	r0, r6
    fc26:	3754      	adds	r7, #84	; 0x54
    fc28:	46bd      	mov	sp, r7
    fc2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_ERR("Not enough space in buffer %zu/%zu",
    fc2e:	466c      	mov	r4, sp
    fc30:	b088      	sub	sp, #32
    fc32:	466b      	mov	r3, sp
    fc34:	f113 0210 	adds.w	r2, r3, #16
    fc38:	d038      	beq.n	fcac <bt_rpmsg_evt_recv+0x1cc>
    fc3a:	2110      	movs	r1, #16
    fc3c:	b11a      	cbz	r2, fc46 <bt_rpmsg_evt_recv+0x166>
    fc3e:	2904      	cmp	r1, #4
    fc40:	dd01      	ble.n	fc46 <bt_rpmsg_evt_recv+0x166>
    fc42:	4d21      	ldr	r5, [pc, #132]	; (fcc8 <bt_rpmsg_evt_recv+0x1e8>)
    fc44:	615d      	str	r5, [r3, #20]
    fc46:	b11a      	cbz	r2, fc50 <bt_rpmsg_evt_recv+0x170>
    fc48:	2908      	cmp	r1, #8
    fc4a:	dd01      	ble.n	fc50 <bt_rpmsg_evt_recv+0x170>
    fc4c:	f8c3 8018 	str.w	r8, [r3, #24]
    fc50:	b112      	cbz	r2, fc58 <bt_rpmsg_evt_recv+0x178>
    fc52:	290c      	cmp	r1, #12
    fc54:	dd00      	ble.n	fc58 <bt_rpmsg_evt_recv+0x178>
    fc56:	61d8      	str	r0, [r3, #28]
    fc58:	290f      	cmp	r1, #15
    fc5a:	dd2a      	ble.n	fcb2 <bt_rpmsg_evt_recv+0x1d2>
    fc5c:	2510      	movs	r5, #16
    fc5e:	b13a      	cbz	r2, fc70 <bt_rpmsg_evt_recv+0x190>
    fc60:	2104      	movs	r1, #4
    fc62:	7039      	strb	r1, [r7, #0]
    fc64:	2100      	movs	r1, #0
    fc66:	7079      	strb	r1, [r7, #1]
    fc68:	70b9      	strb	r1, [r7, #2]
    fc6a:	70f9      	strb	r1, [r7, #3]
    fc6c:	6838      	ldr	r0, [r7, #0]
    fc6e:	6118      	str	r0, [r3, #16]
    fc70:	2100      	movs	r1, #0
    fc72:	f36f 0100 	bfc	r1, #0, #1
    fc76:	f36f 0141 	bfc	r1, #1, #1
    fc7a:	f36f 0182 	bfc	r1, #2, #1
    fc7e:	f36f 01c5 	bfc	r1, #3, #3
    fc82:	2301      	movs	r3, #1
    fc84:	f363 1188 	bfi	r1, r3, #6, #3
    fc88:	f405 757d 	and.w	r5, r5, #1012	; 0x3f4
    fc8c:	f365 2152 	bfi	r1, r5, #9, #10
    fc90:	f36f 41de 	bfc	r1, #19, #12
    fc94:	f36f 71df 	bfc	r1, #31, #1
    fc98:	2300      	movs	r3, #0
    fc9a:	4808      	ldr	r0, [pc, #32]	; (fcbc <bt_rpmsg_evt_recv+0x1dc>)
    fc9c:	f7f2 fad4 	bl	2248 <z_impl_z_log_msg_static_create>
    fca0:	46a5      	mov	sp, r4
		net_buf_unref(buf);
    fca2:	4630      	mov	r0, r6
    fca4:	f00a fa61 	bl	1a16a <net_buf_unref>
		return NULL;
    fca8:	2600      	movs	r6, #0
    fcaa:	e7bb      	b.n	fc24 <bt_rpmsg_evt_recv+0x144>
		BT_ERR("Not enough space in buffer %zu/%zu",
    fcac:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    fcb0:	e7c4      	b.n	fc3c <bt_rpmsg_evt_recv+0x15c>
    fcb2:	f06f 051b 	mvn.w	r5, #27
    fcb6:	e7d2      	b.n	fc5e <bt_rpmsg_evt_recv+0x17e>
    fcb8:	0001fb0c 	.word	0x0001fb0c
    fcbc:	0001d004 	.word	0x0001d004
    fcc0:	0001fae8 	.word	0x0001fae8
    fcc4:	0001fb30 	.word	0x0001fb30
    fcc8:	0001fb68 	.word	0x0001fb68

0000fccc <bt_rpmsg_acl_recv>:
{
    fccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fcd0:	b094      	sub	sp, #80	; 0x50
    fcd2:	af00      	add	r7, sp, #0
	if (remaining < sizeof(hdr)) {
    fcd4:	2903      	cmp	r1, #3
    fcd6:	d929      	bls.n	fd2c <bt_rpmsg_acl_recv+0x60>
    fcd8:	4605      	mov	r5, r0
    fcda:	460c      	mov	r4, r1
	buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_NO_WAIT);
    fcdc:	2200      	movs	r2, #0
    fcde:	2300      	movs	r3, #0
    fce0:	2003      	movs	r0, #3
    fce2:	f7f5 fd93 	bl	580c <bt_buf_get_rx>
	if (buf) {
    fce6:	4606      	mov	r6, r0
    fce8:	2800      	cmp	r0, #0
    fcea:	d043      	beq.n	fd74 <bt_rpmsg_acl_recv+0xa8>
		memcpy((void *)&hdr, data, sizeof(hdr));
    fcec:	2204      	movs	r2, #4
    fcee:	4629      	mov	r1, r5
    fcf0:	18b8      	adds	r0, r7, r2
    fcf2:	f007 fd1d 	bl	17730 <memcpy>
		data += sizeof(hdr);
    fcf6:	3504      	adds	r5, #4
		remaining -= sizeof(hdr);
    fcf8:	3c04      	subs	r4, #4
    fcfa:	f106 0808 	add.w	r8, r6, #8
    fcfe:	2204      	movs	r2, #4
    fd00:	18b9      	adds	r1, r7, r2
    fd02:	4640      	mov	r0, r8
    fd04:	f00a fa81 	bl	1a20a <net_buf_simple_add_mem>
	if (remaining != sys_le16_to_cpu(hdr.len)) {
    fd08:	88fb      	ldrh	r3, [r7, #6]
    fd0a:	429c      	cmp	r4, r3
    fd0c:	d155      	bne.n	fdba <bt_rpmsg_acl_recv+0xee>
	return net_buf_simple_tailroom(&buf->b);
    fd0e:	4640      	mov	r0, r8
    fd10:	f00a fac1 	bl	1a296 <net_buf_simple_tailroom>
	if (buf_tailroom < remaining) {
    fd14:	4284      	cmp	r4, r0
    fd16:	d878      	bhi.n	fe0a <bt_rpmsg_acl_recv+0x13e>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    fd18:	4622      	mov	r2, r4
    fd1a:	4629      	mov	r1, r5
    fd1c:	4640      	mov	r0, r8
    fd1e:	f00a fa74 	bl	1a20a <net_buf_simple_add_mem>
}
    fd22:	4630      	mov	r0, r6
    fd24:	3750      	adds	r7, #80	; 0x50
    fd26:	46bd      	mov	sp, r7
    fd28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("Not enough data for ACL header");
    fd2c:	4b5a      	ldr	r3, [pc, #360]	; (fe98 <bt_rpmsg_acl_recv+0x1cc>)
    fd2e:	64fb      	str	r3, [r7, #76]	; 0x4c
    fd30:	2302      	movs	r3, #2
    fd32:	703b      	strb	r3, [r7, #0]
    fd34:	2600      	movs	r6, #0
    fd36:	707e      	strb	r6, [r7, #1]
    fd38:	70be      	strb	r6, [r7, #2]
    fd3a:	70fe      	strb	r6, [r7, #3]
    fd3c:	683b      	ldr	r3, [r7, #0]
    fd3e:	64bb      	str	r3, [r7, #72]	; 0x48
    fd40:	4631      	mov	r1, r6
    fd42:	f366 0100 	bfi	r1, r6, #0, #1
    fd46:	f366 0141 	bfi	r1, r6, #1, #1
    fd4a:	f366 0182 	bfi	r1, r6, #2, #1
    fd4e:	f366 01c5 	bfi	r1, r6, #3, #3
    fd52:	2301      	movs	r3, #1
    fd54:	f363 1188 	bfi	r1, r3, #6, #3
    fd58:	2308      	movs	r3, #8
    fd5a:	f363 2152 	bfi	r1, r3, #9, #10
    fd5e:	f366 41de 	bfi	r1, r6, #19, #12
    fd62:	f366 71df 	bfi	r1, r6, #31, #1
    fd66:	4633      	mov	r3, r6
    fd68:	f107 0248 	add.w	r2, r7, #72	; 0x48
    fd6c:	484b      	ldr	r0, [pc, #300]	; (fe9c <bt_rpmsg_acl_recv+0x1d0>)
    fd6e:	f7f2 fa6b 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    fd72:	e7d6      	b.n	fd22 <bt_rpmsg_acl_recv+0x56>
		BT_ERR("No available ACL buffers!");
    fd74:	4b4a      	ldr	r3, [pc, #296]	; (fea0 <bt_rpmsg_acl_recv+0x1d4>)
    fd76:	61fb      	str	r3, [r7, #28]
    fd78:	2302      	movs	r3, #2
    fd7a:	703b      	strb	r3, [r7, #0]
    fd7c:	2300      	movs	r3, #0
    fd7e:	707b      	strb	r3, [r7, #1]
    fd80:	70bb      	strb	r3, [r7, #2]
    fd82:	70fb      	strb	r3, [r7, #3]
    fd84:	683a      	ldr	r2, [r7, #0]
    fd86:	61ba      	str	r2, [r7, #24]
    fd88:	4619      	mov	r1, r3
    fd8a:	f363 0100 	bfi	r1, r3, #0, #1
    fd8e:	f363 0141 	bfi	r1, r3, #1, #1
    fd92:	f363 0182 	bfi	r1, r3, #2, #1
    fd96:	f363 01c5 	bfi	r1, r3, #3, #3
    fd9a:	2201      	movs	r2, #1
    fd9c:	f362 1188 	bfi	r1, r2, #6, #3
    fda0:	2208      	movs	r2, #8
    fda2:	f362 2152 	bfi	r1, r2, #9, #10
    fda6:	f363 41de 	bfi	r1, r3, #19, #12
    fdaa:	f363 71df 	bfi	r1, r3, #31, #1
    fdae:	f107 0218 	add.w	r2, r7, #24
    fdb2:	483a      	ldr	r0, [pc, #232]	; (fe9c <bt_rpmsg_acl_recv+0x1d0>)
    fdb4:	f7f2 fa48 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    fdb8:	e7b3      	b.n	fd22 <bt_rpmsg_acl_recv+0x56>
		BT_ERR("ACL payload length is not correct");
    fdba:	4b3a      	ldr	r3, [pc, #232]	; (fea4 <bt_rpmsg_acl_recv+0x1d8>)
    fdbc:	637b      	str	r3, [r7, #52]	; 0x34
    fdbe:	2302      	movs	r3, #2
    fdc0:	703b      	strb	r3, [r7, #0]
    fdc2:	2400      	movs	r4, #0
    fdc4:	707c      	strb	r4, [r7, #1]
    fdc6:	70bc      	strb	r4, [r7, #2]
    fdc8:	70fc      	strb	r4, [r7, #3]
    fdca:	683b      	ldr	r3, [r7, #0]
    fdcc:	633b      	str	r3, [r7, #48]	; 0x30
    fdce:	4621      	mov	r1, r4
    fdd0:	f364 0100 	bfi	r1, r4, #0, #1
    fdd4:	f364 0141 	bfi	r1, r4, #1, #1
    fdd8:	f364 0182 	bfi	r1, r4, #2, #1
    fddc:	f364 01c5 	bfi	r1, r4, #3, #3
    fde0:	2301      	movs	r3, #1
    fde2:	f363 1188 	bfi	r1, r3, #6, #3
    fde6:	2308      	movs	r3, #8
    fde8:	f363 2152 	bfi	r1, r3, #9, #10
    fdec:	f364 41de 	bfi	r1, r4, #19, #12
    fdf0:	f364 71df 	bfi	r1, r4, #31, #1
    fdf4:	4623      	mov	r3, r4
    fdf6:	f107 0230 	add.w	r2, r7, #48	; 0x30
    fdfa:	4828      	ldr	r0, [pc, #160]	; (fe9c <bt_rpmsg_acl_recv+0x1d0>)
    fdfc:	f7f2 fa24 	bl	2248 <z_impl_z_log_msg_static_create>
		net_buf_unref(buf);
    fe00:	4630      	mov	r0, r6
    fe02:	f00a f9b2 	bl	1a16a <net_buf_unref>
		return NULL;
    fe06:	4626      	mov	r6, r4
    fe08:	e78b      	b.n	fd22 <bt_rpmsg_acl_recv+0x56>
		BT_ERR("Not enough space in buffer %zu/%zu",
    fe0a:	466d      	mov	r5, sp
    fe0c:	b088      	sub	sp, #32
    fe0e:	466b      	mov	r3, sp
    fe10:	f113 0210 	adds.w	r2, r3, #16
    fe14:	d039      	beq.n	fe8a <bt_rpmsg_acl_recv+0x1be>
    fe16:	2110      	movs	r1, #16
    fe18:	b12a      	cbz	r2, fe26 <bt_rpmsg_acl_recv+0x15a>
    fe1a:	2904      	cmp	r1, #4
    fe1c:	dd03      	ble.n	fe26 <bt_rpmsg_acl_recv+0x15a>
    fe1e:	f8df c088 	ldr.w	ip, [pc, #136]	; fea8 <bt_rpmsg_acl_recv+0x1dc>
    fe22:	f8c3 c014 	str.w	ip, [r3, #20]
    fe26:	b112      	cbz	r2, fe2e <bt_rpmsg_acl_recv+0x162>
    fe28:	2908      	cmp	r1, #8
    fe2a:	dd00      	ble.n	fe2e <bt_rpmsg_acl_recv+0x162>
    fe2c:	619c      	str	r4, [r3, #24]
    fe2e:	b112      	cbz	r2, fe36 <bt_rpmsg_acl_recv+0x16a>
    fe30:	290c      	cmp	r1, #12
    fe32:	dd00      	ble.n	fe36 <bt_rpmsg_acl_recv+0x16a>
    fe34:	61d8      	str	r0, [r3, #28]
    fe36:	290f      	cmp	r1, #15
    fe38:	dd2a      	ble.n	fe90 <bt_rpmsg_acl_recv+0x1c4>
    fe3a:	2410      	movs	r4, #16
    fe3c:	b13a      	cbz	r2, fe4e <bt_rpmsg_acl_recv+0x182>
    fe3e:	2104      	movs	r1, #4
    fe40:	7039      	strb	r1, [r7, #0]
    fe42:	2100      	movs	r1, #0
    fe44:	7079      	strb	r1, [r7, #1]
    fe46:	70b9      	strb	r1, [r7, #2]
    fe48:	70f9      	strb	r1, [r7, #3]
    fe4a:	6838      	ldr	r0, [r7, #0]
    fe4c:	6118      	str	r0, [r3, #16]
    fe4e:	2100      	movs	r1, #0
    fe50:	f36f 0100 	bfc	r1, #0, #1
    fe54:	f36f 0141 	bfc	r1, #1, #1
    fe58:	f36f 0182 	bfc	r1, #2, #1
    fe5c:	f36f 01c5 	bfc	r1, #3, #3
    fe60:	2301      	movs	r3, #1
    fe62:	f363 1188 	bfi	r1, r3, #6, #3
    fe66:	f404 737d 	and.w	r3, r4, #1012	; 0x3f4
    fe6a:	f363 2152 	bfi	r1, r3, #9, #10
    fe6e:	f36f 41de 	bfc	r1, #19, #12
    fe72:	f36f 71df 	bfc	r1, #31, #1
    fe76:	2300      	movs	r3, #0
    fe78:	4808      	ldr	r0, [pc, #32]	; (fe9c <bt_rpmsg_acl_recv+0x1d0>)
    fe7a:	f7f2 f9e5 	bl	2248 <z_impl_z_log_msg_static_create>
    fe7e:	46ad      	mov	sp, r5
		net_buf_unref(buf);
    fe80:	4630      	mov	r0, r6
    fe82:	f00a f972 	bl	1a16a <net_buf_unref>
		return NULL;
    fe86:	2600      	movs	r6, #0
    fe88:	e74b      	b.n	fd22 <bt_rpmsg_acl_recv+0x56>
		BT_ERR("Not enough space in buffer %zu/%zu",
    fe8a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    fe8e:	e7c3      	b.n	fe18 <bt_rpmsg_acl_recv+0x14c>
    fe90:	f06f 041b 	mvn.w	r4, #27
    fe94:	e7d2      	b.n	fe3c <bt_rpmsg_acl_recv+0x170>
    fe96:	bf00      	nop
    fe98:	0001fb8c 	.word	0x0001fb8c
    fe9c:	0001d004 	.word	0x0001d004
    fea0:	0001fbac 	.word	0x0001fbac
    fea4:	0001fbc8 	.word	0x0001fbc8
    fea8:	0001fb68 	.word	0x0001fb68

0000feac <bt_rpmsg_iso_recv>:
{
    feac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    feb0:	b094      	sub	sp, #80	; 0x50
    feb2:	af00      	add	r7, sp, #0
	if (remaining < sizeof(hdr)) {
    feb4:	2903      	cmp	r1, #3
    feb6:	d92b      	bls.n	ff10 <bt_rpmsg_iso_recv+0x64>
    feb8:	4605      	mov	r5, r0
    feba:	460c      	mov	r4, r1
	buf = bt_buf_get_rx(BT_BUF_ISO_IN, K_NO_WAIT);
    febc:	2200      	movs	r2, #0
    febe:	2300      	movs	r3, #0
    fec0:	2005      	movs	r0, #5
    fec2:	f7f5 fca3 	bl	580c <bt_buf_get_rx>
	if (buf) {
    fec6:	4606      	mov	r6, r0
    fec8:	2800      	cmp	r0, #0
    feca:	d045      	beq.n	ff58 <bt_rpmsg_iso_recv+0xac>
		memcpy((void *)&hdr, data, sizeof(hdr));
    fecc:	2204      	movs	r2, #4
    fece:	4629      	mov	r1, r5
    fed0:	18b8      	adds	r0, r7, r2
    fed2:	f007 fc2d 	bl	17730 <memcpy>
		data += sizeof(hdr);
    fed6:	3504      	adds	r5, #4
		remaining -= sizeof(hdr);
    fed8:	3c04      	subs	r4, #4
    feda:	f106 0808 	add.w	r8, r6, #8
    fede:	2204      	movs	r2, #4
    fee0:	18b9      	adds	r1, r7, r2
    fee2:	4640      	mov	r0, r8
    fee4:	f00a f991 	bl	1a20a <net_buf_simple_add_mem>
	if (remaining != bt_iso_hdr_len(sys_le16_to_cpu(hdr.len))) {
    fee8:	88fb      	ldrh	r3, [r7, #6]
    feea:	f3c3 030d 	ubfx	r3, r3, #0, #14
    feee:	429c      	cmp	r4, r3
    fef0:	d155      	bne.n	ff9e <bt_rpmsg_iso_recv+0xf2>
	return net_buf_simple_tailroom(&buf->b);
    fef2:	4640      	mov	r0, r8
    fef4:	f00a f9cf 	bl	1a296 <net_buf_simple_tailroom>
	if (buf_tailroom < remaining) {
    fef8:	4284      	cmp	r4, r0
    fefa:	d878      	bhi.n	ffee <bt_rpmsg_iso_recv+0x142>
	return net_buf_simple_add_mem(&buf->b, mem, len);
    fefc:	4622      	mov	r2, r4
    fefe:	4629      	mov	r1, r5
    ff00:	4640      	mov	r0, r8
    ff02:	f00a f982 	bl	1a20a <net_buf_simple_add_mem>
}
    ff06:	4630      	mov	r0, r6
    ff08:	3750      	adds	r7, #80	; 0x50
    ff0a:	46bd      	mov	sp, r7
    ff0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("Not enough data for ISO header");
    ff10:	4b5a      	ldr	r3, [pc, #360]	; (1007c <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x7c>)
    ff12:	64fb      	str	r3, [r7, #76]	; 0x4c
    ff14:	2302      	movs	r3, #2
    ff16:	703b      	strb	r3, [r7, #0]
    ff18:	2600      	movs	r6, #0
    ff1a:	707e      	strb	r6, [r7, #1]
    ff1c:	70be      	strb	r6, [r7, #2]
    ff1e:	70fe      	strb	r6, [r7, #3]
    ff20:	683b      	ldr	r3, [r7, #0]
    ff22:	64bb      	str	r3, [r7, #72]	; 0x48
    ff24:	4631      	mov	r1, r6
    ff26:	f366 0100 	bfi	r1, r6, #0, #1
    ff2a:	f366 0141 	bfi	r1, r6, #1, #1
    ff2e:	f366 0182 	bfi	r1, r6, #2, #1
    ff32:	f366 01c5 	bfi	r1, r6, #3, #3
    ff36:	2301      	movs	r3, #1
    ff38:	f363 1188 	bfi	r1, r3, #6, #3
    ff3c:	2308      	movs	r3, #8
    ff3e:	f363 2152 	bfi	r1, r3, #9, #10
    ff42:	f366 41de 	bfi	r1, r6, #19, #12
    ff46:	f366 71df 	bfi	r1, r6, #31, #1
    ff4a:	4633      	mov	r3, r6
    ff4c:	f107 0248 	add.w	r2, r7, #72	; 0x48
    ff50:	484b      	ldr	r0, [pc, #300]	; (10080 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x80>)
    ff52:	f7f2 f979 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    ff56:	e7d6      	b.n	ff06 <bt_rpmsg_iso_recv+0x5a>
		BT_ERR("No available ISO buffers!");
    ff58:	4b4a      	ldr	r3, [pc, #296]	; (10084 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x84>)
    ff5a:	61fb      	str	r3, [r7, #28]
    ff5c:	2302      	movs	r3, #2
    ff5e:	703b      	strb	r3, [r7, #0]
    ff60:	2300      	movs	r3, #0
    ff62:	707b      	strb	r3, [r7, #1]
    ff64:	70bb      	strb	r3, [r7, #2]
    ff66:	70fb      	strb	r3, [r7, #3]
    ff68:	683a      	ldr	r2, [r7, #0]
    ff6a:	61ba      	str	r2, [r7, #24]
    ff6c:	4619      	mov	r1, r3
    ff6e:	f363 0100 	bfi	r1, r3, #0, #1
    ff72:	f363 0141 	bfi	r1, r3, #1, #1
    ff76:	f363 0182 	bfi	r1, r3, #2, #1
    ff7a:	f363 01c5 	bfi	r1, r3, #3, #3
    ff7e:	2201      	movs	r2, #1
    ff80:	f362 1188 	bfi	r1, r2, #6, #3
    ff84:	2208      	movs	r2, #8
    ff86:	f362 2152 	bfi	r1, r2, #9, #10
    ff8a:	f363 41de 	bfi	r1, r3, #19, #12
    ff8e:	f363 71df 	bfi	r1, r3, #31, #1
    ff92:	f107 0218 	add.w	r2, r7, #24
    ff96:	483a      	ldr	r0, [pc, #232]	; (10080 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x80>)
    ff98:	f7f2 f956 	bl	2248 <z_impl_z_log_msg_static_create>
		return NULL;
    ff9c:	e7b3      	b.n	ff06 <bt_rpmsg_iso_recv+0x5a>
		BT_ERR("ISO payload length is not correct");
    ff9e:	4b3a      	ldr	r3, [pc, #232]	; (10088 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x88>)
    ffa0:	637b      	str	r3, [r7, #52]	; 0x34
    ffa2:	2302      	movs	r3, #2
    ffa4:	703b      	strb	r3, [r7, #0]
    ffa6:	2400      	movs	r4, #0
    ffa8:	707c      	strb	r4, [r7, #1]
    ffaa:	70bc      	strb	r4, [r7, #2]
    ffac:	70fc      	strb	r4, [r7, #3]
    ffae:	683b      	ldr	r3, [r7, #0]
    ffb0:	633b      	str	r3, [r7, #48]	; 0x30
    ffb2:	4621      	mov	r1, r4
    ffb4:	f364 0100 	bfi	r1, r4, #0, #1
    ffb8:	f364 0141 	bfi	r1, r4, #1, #1
    ffbc:	f364 0182 	bfi	r1, r4, #2, #1
    ffc0:	f364 01c5 	bfi	r1, r4, #3, #3
    ffc4:	2301      	movs	r3, #1
    ffc6:	f363 1188 	bfi	r1, r3, #6, #3
    ffca:	2308      	movs	r3, #8
    ffcc:	f363 2152 	bfi	r1, r3, #9, #10
    ffd0:	f364 41de 	bfi	r1, r4, #19, #12
    ffd4:	f364 71df 	bfi	r1, r4, #31, #1
    ffd8:	4623      	mov	r3, r4
    ffda:	f107 0230 	add.w	r2, r7, #48	; 0x30
    ffde:	4828      	ldr	r0, [pc, #160]	; (10080 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x80>)
    ffe0:	f7f2 f932 	bl	2248 <z_impl_z_log_msg_static_create>
		net_buf_unref(buf);
    ffe4:	4630      	mov	r0, r6
    ffe6:	f00a f8c0 	bl	1a16a <net_buf_unref>
		return NULL;
    ffea:	4626      	mov	r6, r4
    ffec:	e78b      	b.n	ff06 <bt_rpmsg_iso_recv+0x5a>
		BT_ERR("Not enough space in buffer %zu/%zu",
    ffee:	466d      	mov	r5, sp
    fff0:	b088      	sub	sp, #32
    fff2:	466b      	mov	r3, sp
    fff4:	f113 0210 	adds.w	r2, r3, #16
    fff8:	d039      	beq.n	1006e <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x6e>
    fffa:	2110      	movs	r1, #16
    fffc:	b12a      	cbz	r2, 1000a <CONFIG_RPMSG_NRF53_SRAM_SIZE+0xa>
    fffe:	2904      	cmp	r1, #4
   10000:	dd03      	ble.n	1000a <CONFIG_RPMSG_NRF53_SRAM_SIZE+0xa>
   10002:	f8df c088 	ldr.w	ip, [pc, #136]	; 1008c <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x8c>
   10006:	f8c3 c014 	str.w	ip, [r3, #20]
   1000a:	b112      	cbz	r2, 10012 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x12>
   1000c:	2908      	cmp	r1, #8
   1000e:	dd00      	ble.n	10012 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x12>
   10010:	619c      	str	r4, [r3, #24]
   10012:	b112      	cbz	r2, 1001a <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x1a>
   10014:	290c      	cmp	r1, #12
   10016:	dd00      	ble.n	1001a <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x1a>
   10018:	61d8      	str	r0, [r3, #28]
   1001a:	290f      	cmp	r1, #15
   1001c:	dd2a      	ble.n	10074 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x74>
   1001e:	2410      	movs	r4, #16
   10020:	b13a      	cbz	r2, 10032 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x32>
   10022:	2104      	movs	r1, #4
   10024:	7039      	strb	r1, [r7, #0]
   10026:	2100      	movs	r1, #0
   10028:	7079      	strb	r1, [r7, #1]
   1002a:	70b9      	strb	r1, [r7, #2]
   1002c:	70f9      	strb	r1, [r7, #3]
   1002e:	6838      	ldr	r0, [r7, #0]
   10030:	6118      	str	r0, [r3, #16]
   10032:	2100      	movs	r1, #0
   10034:	f36f 0100 	bfc	r1, #0, #1
   10038:	f36f 0141 	bfc	r1, #1, #1
   1003c:	f36f 0182 	bfc	r1, #2, #1
   10040:	f36f 01c5 	bfc	r1, #3, #3
   10044:	2301      	movs	r3, #1
   10046:	f363 1188 	bfi	r1, r3, #6, #3
   1004a:	f404 737d 	and.w	r3, r4, #1012	; 0x3f4
   1004e:	f363 2152 	bfi	r1, r3, #9, #10
   10052:	f36f 41de 	bfc	r1, #19, #12
   10056:	f36f 71df 	bfc	r1, #31, #1
   1005a:	2300      	movs	r3, #0
   1005c:	4808      	ldr	r0, [pc, #32]	; (10080 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x80>)
   1005e:	f7f2 f8f3 	bl	2248 <z_impl_z_log_msg_static_create>
   10062:	46ad      	mov	sp, r5
		net_buf_unref(buf);
   10064:	4630      	mov	r0, r6
   10066:	f00a f880 	bl	1a16a <net_buf_unref>
		return NULL;
   1006a:	2600      	movs	r6, #0
   1006c:	e74b      	b.n	ff06 <bt_rpmsg_iso_recv+0x5a>
		BT_ERR("Not enough space in buffer %zu/%zu",
   1006e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   10072:	e7c3      	b.n	fffc <bt_rpmsg_iso_recv+0x150>
   10074:	f06f 041b 	mvn.w	r4, #27
   10078:	e7d2      	b.n	10020 <CONFIG_RPMSG_NRF53_SRAM_SIZE+0x20>
   1007a:	bf00      	nop
   1007c:	0001fbec 	.word	0x0001fbec
   10080:	0001d004 	.word	0x0001d004
   10084:	0001fc0c 	.word	0x0001fc0c
   10088:	0001fc28 	.word	0x0001fc28
   1008c:	0001fb68 	.word	0x0001fb68

00010090 <bt_rpmsg_rx>:
{
   10090:	b5b0      	push	{r4, r5, r7, lr}
   10092:	b082      	sub	sp, #8
   10094:	af00      	add	r7, sp, #0
	pkt_indicator = *data++;
   10096:	f810 3b01 	ldrb.w	r3, [r0], #1
	remaining -= sizeof(pkt_indicator);
   1009a:	3901      	subs	r1, #1
	switch (pkt_indicator) {
   1009c:	2b04      	cmp	r3, #4
   1009e:	d039      	beq.n	10114 <bt_rpmsg_rx+0x84>
   100a0:	2b05      	cmp	r3, #5
   100a2:	d042      	beq.n	1012a <bt_rpmsg_rx+0x9a>
   100a4:	2b02      	cmp	r3, #2
   100a6:	d03d      	beq.n	10124 <bt_rpmsg_rx+0x94>
		BT_ERR("Unknown HCI type %u", pkt_indicator);
   100a8:	466c      	mov	r4, sp
   100aa:	b088      	sub	sp, #32
   100ac:	4669      	mov	r1, sp
   100ae:	f111 0210 	adds.w	r2, r1, #16
   100b2:	d03d      	beq.n	10130 <bt_rpmsg_rx+0xa0>
   100b4:	200c      	movs	r0, #12
   100b6:	b11a      	cbz	r2, 100c0 <bt_rpmsg_rx+0x30>
   100b8:	2804      	cmp	r0, #4
   100ba:	dd01      	ble.n	100c0 <bt_rpmsg_rx+0x30>
   100bc:	4d1f      	ldr	r5, [pc, #124]	; (1013c <bt_rpmsg_rx+0xac>)
   100be:	614d      	str	r5, [r1, #20]
   100c0:	b112      	cbz	r2, 100c8 <bt_rpmsg_rx+0x38>
   100c2:	2808      	cmp	r0, #8
   100c4:	dd00      	ble.n	100c8 <bt_rpmsg_rx+0x38>
   100c6:	618b      	str	r3, [r1, #24]
   100c8:	280b      	cmp	r0, #11
   100ca:	dd34      	ble.n	10136 <bt_rpmsg_rx+0xa6>
   100cc:	230c      	movs	r3, #12
   100ce:	b13a      	cbz	r2, 100e0 <bt_rpmsg_rx+0x50>
   100d0:	2003      	movs	r0, #3
   100d2:	7138      	strb	r0, [r7, #4]
   100d4:	2000      	movs	r0, #0
   100d6:	7178      	strb	r0, [r7, #5]
   100d8:	71b8      	strb	r0, [r7, #6]
   100da:	71f8      	strb	r0, [r7, #7]
   100dc:	6878      	ldr	r0, [r7, #4]
   100de:	6108      	str	r0, [r1, #16]
   100e0:	2100      	movs	r1, #0
   100e2:	f36f 0100 	bfc	r1, #0, #1
   100e6:	f36f 0141 	bfc	r1, #1, #1
   100ea:	f36f 0182 	bfc	r1, #2, #1
   100ee:	f36f 01c5 	bfc	r1, #3, #3
   100f2:	2001      	movs	r0, #1
   100f4:	f360 1188 	bfi	r1, r0, #6, #3
   100f8:	f403 737b 	and.w	r3, r3, #1004	; 0x3ec
   100fc:	f363 2152 	bfi	r1, r3, #9, #10
   10100:	f36f 41de 	bfc	r1, #19, #12
   10104:	f36f 71df 	bfc	r1, #31, #1
   10108:	2300      	movs	r3, #0
   1010a:	480d      	ldr	r0, [pc, #52]	; (10140 <bt_rpmsg_rx+0xb0>)
   1010c:	f7f2 f89c 	bl	2248 <z_impl_z_log_msg_static_create>
   10110:	46a5      	mov	sp, r4
   10112:	e004      	b.n	1011e <bt_rpmsg_rx+0x8e>
		buf = bt_rpmsg_evt_recv(data, remaining);
   10114:	f7ff fce4 	bl	fae0 <bt_rpmsg_evt_recv>
	if (buf) {
   10118:	b108      	cbz	r0, 1011e <bt_rpmsg_rx+0x8e>
		bt_recv(buf);
   1011a:	f7f8 fa3f 	bl	859c <bt_recv>
}
   1011e:	3708      	adds	r7, #8
   10120:	46bd      	mov	sp, r7
   10122:	bdb0      	pop	{r4, r5, r7, pc}
		buf = bt_rpmsg_acl_recv(data, remaining);
   10124:	f7ff fdd2 	bl	fccc <bt_rpmsg_acl_recv>
		break;
   10128:	e7f6      	b.n	10118 <bt_rpmsg_rx+0x88>
		buf = bt_rpmsg_iso_recv(data, remaining);
   1012a:	f7ff febf 	bl	feac <bt_rpmsg_iso_recv>
		break;
   1012e:	e7f3      	b.n	10118 <bt_rpmsg_rx+0x88>
		BT_ERR("Unknown HCI type %u", pkt_indicator);
   10130:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   10134:	e7bf      	b.n	100b6 <bt_rpmsg_rx+0x26>
   10136:	f06f 031b 	mvn.w	r3, #27
   1013a:	e7c8      	b.n	100ce <bt_rpmsg_rx+0x3e>
   1013c:	0001fc4c 	.word	0x0001fc4c
   10140:	0001d004 	.word	0x0001d004

00010144 <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(int32_t chan, uint32_t cyc)
{
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   10144:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
   10148:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   1014c:	4b01      	ldr	r3, [pc, #4]	; (10154 <set_comparator+0x10>)
   1014e:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
}
   10152:	4770      	bx	lr
   10154:	50015000 	.word	0x50015000

00010158 <get_comparator>:
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   10158:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   1015c:	4b01      	ldr	r3, [pc, #4]	; (10164 <get_comparator+0xc>)
   1015e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

static uint32_t get_comparator(int32_t chan)
{
	return nrf_rtc_cc_get(RTC, chan);
}
   10162:	4770      	bx	lr
   10164:	50015000 	.word	0x50015000

00010168 <event_enable>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
}

static void event_enable(int32_t chan)
{
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   10168:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   1016c:	4083      	lsls	r3, r0
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   1016e:	4a02      	ldr	r2, [pc, #8]	; (10178 <event_enable+0x10>)
   10170:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
}
   10174:	4770      	bx	lr
   10176:	bf00      	nop
   10178:	50015000 	.word	0x50015000

0001017c <event_disable>:

static void event_disable(int32_t chan)
{
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   1017c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   10180:	4083      	lsls	r3, r0
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   10182:	4a02      	ldr	r2, [pc, #8]	; (1018c <event_disable+0x10>)
   10184:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
}
   10188:	4770      	bx	lr
   1018a:	bf00      	nop
   1018c:	50015000 	.word	0x50015000

00010190 <counter>:
     return p_reg->COUNTER;
   10190:	4b01      	ldr	r3, [pc, #4]	; (10198 <counter+0x8>)
   10192:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

static uint32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
   10196:	4770      	bx	lr
   10198:	50015000 	.word	0x50015000

0001019c <compare_int_lock>:
	return 0;
#endif
}

static bool compare_int_lock(int32_t chan)
{
   1019c:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   1019e:	2301      	movs	r3, #1
   101a0:	4083      	lsls	r3, r0
   101a2:	ea6f 0c03 	mvn.w	ip, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   101a6:	4a0d      	ldr	r2, [pc, #52]	; (101dc <compare_int_lock+0x40>)
   101a8:	e8d2 1fef 	ldaex	r1, [r2]
   101ac:	ea01 0e0c 	and.w	lr, r1, ip
   101b0:	e8c2 efe4 	stlex	r4, lr, [r2]
   101b4:	2c00      	cmp	r4, #0
   101b6:	d1f7      	bne.n	101a8 <compare_int_lock+0xc>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   101b8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   101bc:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   101c0:	f102 2250 	add.w	r2, r2, #1342197760	; 0x50005000
   101c4:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   101c8:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   101cc:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   101d0:	420b      	tst	r3, r1
}
   101d2:	bf14      	ite	ne
   101d4:	2001      	movne	r0, #1
   101d6:	2000      	moveq	r0, #0
   101d8:	bd10      	pop	{r4, pc}
   101da:	bf00      	nop
   101dc:	200025c0 	.word	0x200025c0

000101e0 <channel_processing_check_and_clear>:
		event_enable(chan);
	}
}

static bool channel_processing_check_and_clear(int32_t chan)
{
   101e0:	b570      	push	{r4, r5, r6, lr}
   101e2:	4604      	mov	r4, r0
	bool result = false;

	uint32_t mcu_critical_state = full_int_lock();
   101e4:	f00a fcf4 	bl	1abd0 <full_int_lock>
   101e8:	4605      	mov	r5, r0

	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   101ea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   101ee:	40a3      	lsls	r3, r4
    return p_reg->INTENSET & mask;
   101f0:	4a15      	ldr	r2, [pc, #84]	; (10248 <channel_processing_check_and_clear+0x68>)
   101f2:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
   101f6:	4213      	tst	r3, r2
   101f8:	d105      	bne.n	10206 <channel_processing_check_and_clear+0x26>
	bool result = false;
   101fa:	2600      	movs	r6, #0
		if (result) {
			event_clear(chan);
		}
	}

	full_int_unlock(mcu_critical_state);
   101fc:	4628      	mov	r0, r5
   101fe:	f00a fcf0 	bl	1abe2 <full_int_unlock>

	return result;
}
   10202:	4630      	mov	r0, r6
   10204:	bd70      	pop	{r4, r5, r6, pc}
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   10206:	2301      	movs	r3, #1
   10208:	40a3      	lsls	r3, r4
   1020a:	43db      	mvns	r3, r3
   1020c:	4a0f      	ldr	r2, [pc, #60]	; (1024c <channel_processing_check_and_clear+0x6c>)
   1020e:	e8d2 1fef 	ldaex	r1, [r2]
   10212:	ea01 0003 	and.w	r0, r1, r3
   10216:	e8c2 0fe6 	stlex	r6, r0, [r2]
   1021a:	2e00      	cmp	r6, #0
   1021c:	d1f7      	bne.n	1020e <channel_processing_check_and_clear+0x2e>
   1021e:	b959      	cbnz	r1, 10238 <channel_processing_check_and_clear+0x58>
			 nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   10220:	f104 0350 	add.w	r3, r4, #80	; 0x50
   10224:	009b      	lsls	r3, r3, #2
   10226:	b29b      	uxth	r3, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   10228:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
   1022c:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   10230:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   10232:	b113      	cbz	r3, 1023a <channel_processing_check_and_clear+0x5a>
   10234:	2301      	movs	r3, #1
   10236:	e000      	b.n	1023a <channel_processing_check_and_clear+0x5a>
   10238:	2301      	movs	r3, #1
		if (result) {
   1023a:	461e      	mov	r6, r3
   1023c:	2b00      	cmp	r3, #0
   1023e:	d0dd      	beq.n	101fc <channel_processing_check_and_clear+0x1c>
			event_clear(chan);
   10240:	4620      	mov	r0, r4
   10242:	f00a fcb6 	bl	1abb2 <event_clear>
   10246:	e7d9      	b.n	101fc <channel_processing_check_and_clear+0x1c>
   10248:	50015000 	.word	0x50015000
   1024c:	200025bc 	.word	0x200025bc

00010250 <compare_int_unlock>:
	if (key) {
   10250:	b901      	cbnz	r1, 10254 <compare_int_unlock+0x4>
}
   10252:	4770      	bx	lr
		atomic_or(&int_mask, BIT(chan));
   10254:	2301      	movs	r3, #1
   10256:	4083      	lsls	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   10258:	4a0e      	ldr	r2, [pc, #56]	; (10294 <compare_int_unlock+0x44>)
   1025a:	e8d2 1fef 	ldaex	r1, [r2]
   1025e:	4319      	orrs	r1, r3
   10260:	e8c2 1fec 	stlex	ip, r1, [r2]
   10264:	f1bc 0f00 	cmp.w	ip, #0
   10268:	d1f7      	bne.n	1025a <compare_int_unlock+0xa>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   1026a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   1026e:	4083      	lsls	r3, r0
    p_reg->INTENSET = mask;
   10270:	4a09      	ldr	r2, [pc, #36]	; (10298 <compare_int_unlock+0x48>)
   10272:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   10276:	4b09      	ldr	r3, [pc, #36]	; (1029c <compare_int_unlock+0x4c>)
   10278:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   1027c:	fa23 f000 	lsr.w	r0, r3, r0
   10280:	f010 0f01 	tst.w	r0, #1
   10284:	d0e5      	beq.n	10252 <compare_int_unlock+0x2>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10286:	4b06      	ldr	r3, [pc, #24]	; (102a0 <compare_int_unlock+0x50>)
   10288:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   1028c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   10290:	e7df      	b.n	10252 <compare_int_unlock+0x2>
   10292:	bf00      	nop
   10294:	200025c0 	.word	0x200025c0
   10298:	50015000 	.word	0x50015000
   1029c:	200025bc 	.word	0x200025bc
   102a0:	e000e100 	.word	0xe000e100

000102a4 <sys_clock_timeout_handler>:
{
   102a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   102a8:	4607      	mov	r7, r0
   102aa:	4614      	mov	r4, r2
   102ac:	461e      	mov	r6, r3
	uint32_t cc_value = absolute_time_to_cc(expire_time);
   102ae:	4610      	mov	r0, r2
   102b0:	4619      	mov	r1, r3
   102b2:	f00a fc8a 	bl	1abca <absolute_time_to_cc>
   102b6:	4605      	mov	r5, r0
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   102b8:	4b15      	ldr	r3, [pc, #84]	; (10310 <sys_clock_timeout_handler+0x6c>)
   102ba:	681a      	ldr	r2, [r3, #0]
   102bc:	1aa0      	subs	r0, r4, r2
	last_count += dticks * CYC_PER_TICK;
   102be:	601c      	str	r4, [r3, #0]
   102c0:	605e      	str	r6, [r3, #4]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   102c2:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   102c6:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   102ca:	d309      	bcc.n	102e0 <sys_clock_timeout_handler+0x3c>
	return false;
   102cc:	2400      	movs	r4, #0
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   102ce:	f004 fb97 	bl	14a00 <sys_clock_announce>
	if (cc_value == get_comparator(chan)) {
   102d2:	4638      	mov	r0, r7
   102d4:	f7ff ff40 	bl	10158 <get_comparator>
   102d8:	42a8      	cmp	r0, r5
   102da:	d00e      	beq.n	102fa <sys_clock_timeout_handler+0x56>
}
   102dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   102e0:	4b0c      	ldr	r3, [pc, #48]	; (10314 <sys_clock_timeout_handler+0x70>)
   102e2:	681b      	ldr	r3, [r3, #0]
   102e4:	0a1a      	lsrs	r2, r3, #8
   102e6:	061b      	lsls	r3, r3, #24
   102e8:	eb15 0803 	adds.w	r8, r5, r3
   102ec:	f142 0900 	adc.w	r9, r2, #0
   102f0:	4b09      	ldr	r3, [pc, #36]	; (10318 <sys_clock_timeout_handler+0x74>)
   102f2:	e9c3 8900 	strd	r8, r9, [r3]
		return true;
   102f6:	2401      	movs	r4, #1
   102f8:	e7e9      	b.n	102ce <sys_clock_timeout_handler+0x2a>
		if (!anchor_updated) {
   102fa:	b11c      	cbz	r4, 10304 <sys_clock_timeout_handler+0x60>
		event_enable(chan);
   102fc:	4638      	mov	r0, r7
   102fe:	f7ff ff33 	bl	10168 <event_enable>
}
   10302:	e7eb      	b.n	102dc <sys_clock_timeout_handler+0x38>
			set_comparator(chan, COUNTER_HALF_SPAN);
   10304:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
   10308:	4638      	mov	r0, r7
   1030a:	f7ff ff1b 	bl	10144 <set_comparator>
   1030e:	e7f5      	b.n	102fc <sys_clock_timeout_handler+0x58>
   10310:	20001980 	.word	0x20001980
   10314:	200025c4 	.word	0x200025c4
   10318:	20001958 	.word	0x20001958

0001031c <z_nrf_rtc_timer_compare_evt_address_get>:
}

NRF_STATIC_INLINE nrf_rtc_event_t nrf_rtc_compare_event_get(uint8_t index)
{
    return (nrf_rtc_event_t)NRFX_OFFSETOF(NRF_RTC_Type, EVENTS_COMPARE[index]);
   1031c:	b2c3      	uxtb	r3, r0
   1031e:	009b      	lsls	r3, r3, #2
}
   10320:	4801      	ldr	r0, [pc, #4]	; (10328 <z_nrf_rtc_timer_compare_evt_address_get+0xc>)
   10322:	4418      	add	r0, r3
   10324:	4770      	bx	lr
   10326:	bf00      	nop
   10328:	50015140 	.word	0x50015140

0001032c <z_nrf_rtc_timer_compare_read>:
    return p_reg->CC[ch];
   1032c:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   10330:	4b01      	ldr	r3, [pc, #4]	; (10338 <z_nrf_rtc_timer_compare_read+0xc>)
   10332:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
   10336:	4770      	bx	lr
   10338:	50015000 	.word	0x50015000

0001033c <z_nrf_rtc_timer_read>:
{
   1033c:	b538      	push	{r3, r4, r5, lr}
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   1033e:	4b0d      	ldr	r3, [pc, #52]	; (10374 <z_nrf_rtc_timer_read+0x38>)
   10340:	681c      	ldr	r4, [r3, #0]
   10342:	0a25      	lsrs	r5, r4, #8
   10344:	0624      	lsls	r4, r4, #24
  __ASM volatile ("dmb 0xF":::"memory");
   10346:	f3bf 8f5f 	dmb	sy
	uint32_t cntr = counter();
   1034a:	f7ff ff21 	bl	10190 <counter>
   1034e:	4603      	mov	r3, r0
	val += cntr;
   10350:	1900      	adds	r0, r0, r4
   10352:	f145 0100 	adc.w	r1, r5, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   10356:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   1035a:	d20a      	bcs.n	10372 <z_nrf_rtc_timer_read+0x36>
		if (val < anchor) {
   1035c:	4b06      	ldr	r3, [pc, #24]	; (10378 <z_nrf_rtc_timer_read+0x3c>)
   1035e:	e9d3 2300 	ldrd	r2, r3, [r3]
   10362:	4290      	cmp	r0, r2
   10364:	eb71 0303 	sbcs.w	r3, r1, r3
   10368:	d203      	bcs.n	10372 <z_nrf_rtc_timer_read+0x36>
			val += COUNTER_SPAN;
   1036a:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   1036e:	f141 0100 	adc.w	r1, r1, #0
}
   10372:	bd38      	pop	{r3, r4, r5, pc}
   10374:	200025c4 	.word	0x200025c4
   10378:	20001958 	.word	0x20001958

0001037c <compare_set_nolocks>:
{
   1037c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1037e:	4606      	mov	r6, r0
   10380:	4614      	mov	r4, r2
   10382:	461d      	mov	r5, r3
	uint32_t cc_value = absolute_time_to_cc(target_time);
   10384:	4610      	mov	r0, r2
   10386:	4619      	mov	r1, r3
   10388:	f00a fc1f 	bl	1abca <absolute_time_to_cc>
   1038c:	4607      	mov	r7, r0
	uint64_t curr_time = z_nrf_rtc_timer_read();
   1038e:	f7ff ffd5 	bl	1033c <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   10392:	42a0      	cmp	r0, r4
   10394:	eb71 0305 	sbcs.w	r3, r1, r5
   10398:	d21d      	bcs.n	103d6 <compare_set_nolocks+0x5a>
		if (target_time - curr_time > COUNTER_SPAN) {
   1039a:	1a23      	subs	r3, r4, r0
   1039c:	eb65 0101 	sbc.w	r1, r5, r1
   103a0:	4a19      	ldr	r2, [pc, #100]	; (10408 <compare_set_nolocks+0x8c>)
   103a2:	4293      	cmp	r3, r2
   103a4:	f171 0300 	sbcs.w	r3, r1, #0
   103a8:	d22b      	bcs.n	10402 <compare_set_nolocks+0x86>
		if (target_time != cc_data[chan].target_time) {
   103aa:	4b18      	ldr	r3, [pc, #96]	; (1040c <compare_set_nolocks+0x90>)
   103ac:	eb03 1306 	add.w	r3, r3, r6, lsl #4
   103b0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   103b4:	42ab      	cmp	r3, r5
   103b6:	bf08      	it	eq
   103b8:	42a2      	cmpeq	r2, r4
   103ba:	d016      	beq.n	103ea <compare_set_nolocks+0x6e>
			uint32_t cc_set = set_absolute_alarm(chan, cc_value);
   103bc:	4639      	mov	r1, r7
   103be:	4630      	mov	r0, r6
   103c0:	f00a fc14 	bl	1abec <set_absolute_alarm>
			target_time += counter_sub(cc_set, cc_value);
   103c4:	4639      	mov	r1, r7
   103c6:	f00a fbf0 	bl	1abaa <counter_sub>
   103ca:	1900      	adds	r0, r0, r4
   103cc:	f145 0300 	adc.w	r3, r5, #0
   103d0:	4604      	mov	r4, r0
   103d2:	461d      	mov	r5, r3
   103d4:	e009      	b.n	103ea <compare_set_nolocks+0x6e>
		atomic_or(&force_isr_mask, BIT(chan));
   103d6:	2301      	movs	r3, #1
   103d8:	40b3      	lsls	r3, r6
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   103da:	4a0d      	ldr	r2, [pc, #52]	; (10410 <compare_set_nolocks+0x94>)
   103dc:	e8d2 1fef 	ldaex	r1, [r2]
   103e0:	4319      	orrs	r1, r3
   103e2:	e8c2 1fe0 	stlex	r0, r1, [r2]
   103e6:	2800      	cmp	r0, #0
   103e8:	d1f8      	bne.n	103dc <compare_set_nolocks+0x60>
	cc_data[chan].target_time = target_time;
   103ea:	4b08      	ldr	r3, [pc, #32]	; (1040c <compare_set_nolocks+0x90>)
   103ec:	0132      	lsls	r2, r6, #4
   103ee:	eb03 1606 	add.w	r6, r3, r6, lsl #4
   103f2:	e9c6 4502 	strd	r4, r5, [r6, #8]
	cc_data[chan].callback = handler;
   103f6:	9906      	ldr	r1, [sp, #24]
   103f8:	5099      	str	r1, [r3, r2]
	cc_data[chan].user_context = user_data;
   103fa:	9b07      	ldr	r3, [sp, #28]
   103fc:	6073      	str	r3, [r6, #4]
	return ret;
   103fe:	2000      	movs	r0, #0
}
   10400:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return -EINVAL;
   10402:	f06f 0015 	mvn.w	r0, #21
   10406:	e7fb      	b.n	10400 <compare_set_nolocks+0x84>
   10408:	01000001 	.word	0x01000001
   1040c:	20001960 	.word	0x20001960
   10410:	200025bc 	.word	0x200025bc

00010414 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   10414:	b530      	push	{r4, r5, lr}
   10416:	b083      	sub	sp, #12
    p_reg->PRESCALER = val;
   10418:	2300      	movs	r3, #0
   1041a:	4a1f      	ldr	r2, [pc, #124]	; (10498 <sys_clock_driver_init+0x84>)
   1041c:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   10420:	e00f      	b.n	10442 <sys_clock_driver_init+0x2e>
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   10422:	4a1e      	ldr	r2, [pc, #120]	; (1049c <sys_clock_driver_init+0x88>)
   10424:	eb02 1203 	add.w	r2, r2, r3, lsl #4
   10428:	f04f 30ff 	mov.w	r0, #4294967295
   1042c:	f04f 31ff 	mov.w	r1, #4294967295
   10430:	e9c2 0102 	strd	r0, r1, [r2, #8]
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   10434:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   10438:	409a      	lsls	r2, r3
    p_reg->INTENSET = mask;
   1043a:	4917      	ldr	r1, [pc, #92]	; (10498 <sys_clock_driver_init+0x84>)
   1043c:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   10440:	3301      	adds	r3, #1
   10442:	2b01      	cmp	r3, #1
   10444:	dded      	ble.n	10422 <sys_clock_driver_init+0xe>
   10446:	4c14      	ldr	r4, [pc, #80]	; (10498 <sys_clock_driver_init+0x84>)
   10448:	2502      	movs	r5, #2
   1044a:	f8c4 5304 	str.w	r5, [r4, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1044e:	4b14      	ldr	r3, [pc, #80]	; (104a0 <sys_clock_driver_init+0x8c>)
   10450:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   10454:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   10458:	2200      	movs	r2, #0
   1045a:	2101      	movs	r1, #1
   1045c:	2015      	movs	r0, #21
   1045e:	f7f3 fe01 	bl	4064 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   10462:	2015      	movs	r0, #21
   10464:	f7f3 fdce 	bl	4004 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   10468:	2301      	movs	r3, #1
   1046a:	60a3      	str	r3, [r4, #8]
   1046c:	6023      	str	r3, [r4, #0]

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   1046e:	4b0d      	ldr	r3, [pc, #52]	; (104a4 <sys_clock_driver_init+0x90>)
   10470:	2203      	movs	r2, #3
   10472:	601a      	str	r2, [r3, #0]
	if (CONFIG_NRF_RTC_TIMER_USER_CHAN_COUNT) {
		alloc_mask = BIT_MASK(EXT_CHAN_COUNT) << 1;
   10474:	4b0c      	ldr	r3, [pc, #48]	; (104a8 <sys_clock_driver_init+0x94>)
   10476:	601d      	str	r5, [r3, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   10478:	2400      	movs	r4, #0
   1047a:	9401      	str	r4, [sp, #4]
   1047c:	4b0b      	ldr	r3, [pc, #44]	; (104ac <sys_clock_driver_init+0x98>)
   1047e:	9300      	str	r3, [sp, #0]
   10480:	4a0b      	ldr	r2, [pc, #44]	; (104b0 <sys_clock_driver_init+0x9c>)
   10482:	2300      	movs	r3, #0
   10484:	4620      	mov	r0, r4
   10486:	f00a fbf7 	bl	1ac78 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   1048a:	4628      	mov	r0, r5
   1048c:	f7fd fd64 	bl	df58 <z_nrf_clock_control_lf_on>

	return 0;
}
   10490:	4620      	mov	r0, r4
   10492:	b003      	add	sp, #12
   10494:	bd30      	pop	{r4, r5, pc}
   10496:	bf00      	nop
   10498:	50015000 	.word	0x50015000
   1049c:	20001960 	.word	0x20001960
   104a0:	e000e100 	.word	0xe000e100
   104a4:	200025c0 	.word	0x200025c0
   104a8:	200025b8 	.word	0x200025b8
   104ac:	000102a5 	.word	0x000102a5
   104b0:	007fffff 	.word	0x007fffff

000104b4 <process_channel>:
{
   104b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   104b8:	b082      	sub	sp, #8
   104ba:	4604      	mov	r4, r0
	if (channel_processing_check_and_clear(chan)) {
   104bc:	f7ff fe90 	bl	101e0 <channel_processing_check_and_clear>
   104c0:	b910      	cbnz	r0, 104c8 <process_channel+0x14>
}
   104c2:	b002      	add	sp, #8
   104c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_time = z_nrf_rtc_timer_read();
   104c8:	f7ff ff38 	bl	1033c <z_nrf_rtc_timer_read>
   104cc:	4682      	mov	sl, r0
   104ce:	460e      	mov	r6, r1
		mcu_critical_state = full_int_lock();
   104d0:	f00a fb7e 	bl	1abd0 <full_int_lock>
   104d4:	4605      	mov	r5, r0
		expire_time = cc_data[chan].target_time;
   104d6:	4b13      	ldr	r3, [pc, #76]	; (10524 <process_channel+0x70>)
   104d8:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   104dc:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   104e0:	45c2      	cmp	sl, r8
   104e2:	eb76 0309 	sbcs.w	r3, r6, r9
   104e6:	d20b      	bcs.n	10500 <process_channel+0x4c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   104e8:	2600      	movs	r6, #0
		full_int_unlock(mcu_critical_state);
   104ea:	4628      	mov	r0, r5
   104ec:	f00a fb79 	bl	1abe2 <full_int_unlock>
		if (handler) {
   104f0:	2e00      	cmp	r6, #0
   104f2:	d0e6      	beq.n	104c2 <process_channel+0xe>
			handler(chan, expire_time, user_context);
   104f4:	9700      	str	r7, [sp, #0]
   104f6:	4642      	mov	r2, r8
   104f8:	464b      	mov	r3, r9
   104fa:	4620      	mov	r0, r4
   104fc:	47b0      	blx	r6
}
   104fe:	e7e0      	b.n	104c2 <process_channel+0xe>
			handler = cc_data[chan].callback;
   10500:	4a08      	ldr	r2, [pc, #32]	; (10524 <process_channel+0x70>)
   10502:	0123      	lsls	r3, r4, #4
   10504:	eb02 1104 	add.w	r1, r2, r4, lsl #4
   10508:	58d6      	ldr	r6, [r2, r3]
			user_context = cc_data[chan].user_context;
   1050a:	684f      	ldr	r7, [r1, #4]
			cc_data[chan].callback = NULL;
   1050c:	2000      	movs	r0, #0
   1050e:	50d0      	str	r0, [r2, r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   10510:	f04f 32ff 	mov.w	r2, #4294967295
   10514:	f04f 33ff 	mov.w	r3, #4294967295
   10518:	e9c1 2302 	strd	r2, r3, [r1, #8]
			event_disable(chan);
   1051c:	4620      	mov	r0, r4
   1051e:	f7ff fe2d 	bl	1017c <event_disable>
   10522:	e7e2      	b.n	104ea <process_channel+0x36>
   10524:	20001960 	.word	0x20001960

00010528 <rtc_nrf_isr>:
{
   10528:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
   1052a:	4b0e      	ldr	r3, [pc, #56]	; (10564 <rtc_nrf_isr+0x3c>)
   1052c:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   10530:	f013 0f02 	tst.w	r3, #2
   10534:	d00d      	beq.n	10552 <rtc_nrf_isr+0x2a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   10536:	4b0b      	ldr	r3, [pc, #44]	; (10564 <rtc_nrf_isr+0x3c>)
   10538:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   1053c:	b14b      	cbz	r3, 10552 <rtc_nrf_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1053e:	4b09      	ldr	r3, [pc, #36]	; (10564 <rtc_nrf_isr+0x3c>)
   10540:	2200      	movs	r2, #0
   10542:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   10546:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
		overflow_cnt++;
   1054a:	4a07      	ldr	r2, [pc, #28]	; (10568 <rtc_nrf_isr+0x40>)
   1054c:	6813      	ldr	r3, [r2, #0]
   1054e:	3301      	adds	r3, #1
   10550:	6013      	str	r3, [r2, #0]
{
   10552:	2400      	movs	r4, #0
   10554:	e003      	b.n	1055e <rtc_nrf_isr+0x36>
		process_channel(chan);
   10556:	4620      	mov	r0, r4
   10558:	f7ff ffac 	bl	104b4 <process_channel>
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
   1055c:	3401      	adds	r4, #1
   1055e:	2c01      	cmp	r4, #1
   10560:	ddf9      	ble.n	10556 <rtc_nrf_isr+0x2e>
}
   10562:	bd10      	pop	{r4, pc}
   10564:	50015000 	.word	0x50015000
   10568:	200025c4 	.word	0x200025c4

0001056c <z_nrf_rtc_timer_chan_alloc>:
		chan = alloc_mask ? 31 - __builtin_clz(alloc_mask) : -1;
   1056c:	4b17      	ldr	r3, [pc, #92]	; (105cc <z_nrf_rtc_timer_chan_alloc+0x60>)
   1056e:	6818      	ldr	r0, [r3, #0]
   10570:	b330      	cbz	r0, 105c0 <z_nrf_rtc_timer_chan_alloc+0x54>
   10572:	fab0 f080 	clz	r0, r0
		if (chan < 0) {
   10576:	f1d0 001f 	rsbs	r0, r0, #31
   1057a:	d424      	bmi.n	105c6 <z_nrf_rtc_timer_chan_alloc+0x5a>
{
   1057c:	b500      	push	{lr}
		prev = atomic_and(&alloc_mask, ~BIT(chan));
   1057e:	2301      	movs	r3, #1
   10580:	4083      	lsls	r3, r0
   10582:	43db      	mvns	r3, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   10584:	4911      	ldr	r1, [pc, #68]	; (105cc <z_nrf_rtc_timer_chan_alloc+0x60>)
   10586:	e8d1 2fef 	ldaex	r2, [r1]
   1058a:	ea02 0c03 	and.w	ip, r2, r3
   1058e:	e8c1 cfee 	stlex	lr, ip, [r1]
   10592:	f1be 0f00 	cmp.w	lr, #0
   10596:	d1f6      	bne.n	10586 <z_nrf_rtc_timer_chan_alloc+0x1a>
	} while (!(prev & BIT(chan)));
   10598:	fa22 f300 	lsr.w	r3, r2, r0
   1059c:	f013 0f01 	tst.w	r3, #1
   105a0:	d10c      	bne.n	105bc <z_nrf_rtc_timer_chan_alloc+0x50>
		chan = alloc_mask ? 31 - __builtin_clz(alloc_mask) : -1;
   105a2:	4b0a      	ldr	r3, [pc, #40]	; (105cc <z_nrf_rtc_timer_chan_alloc+0x60>)
   105a4:	6818      	ldr	r0, [r3, #0]
   105a6:	b138      	cbz	r0, 105b8 <z_nrf_rtc_timer_chan_alloc+0x4c>
   105a8:	fab0 f080 	clz	r0, r0
		if (chan < 0) {
   105ac:	f1d0 001f 	rsbs	r0, r0, #31
   105b0:	d5e5      	bpl.n	1057e <z_nrf_rtc_timer_chan_alloc+0x12>
			return -ENOMEM;
   105b2:	f06f 000b 	mvn.w	r0, #11
   105b6:	e001      	b.n	105bc <z_nrf_rtc_timer_chan_alloc+0x50>
   105b8:	f06f 000b 	mvn.w	r0, #11
}
   105bc:	f85d fb04 	ldr.w	pc, [sp], #4
			return -ENOMEM;
   105c0:	f06f 000b 	mvn.w	r0, #11
   105c4:	4770      	bx	lr
   105c6:	f06f 000b 	mvn.w	r0, #11
}
   105ca:	4770      	bx	lr
   105cc:	200025b8 	.word	0x200025b8

000105d0 <z_nrf_rtc_timer_chan_free>:
	atomic_or(&alloc_mask, BIT(chan));
   105d0:	2301      	movs	r3, #1
   105d2:	4083      	lsls	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   105d4:	4a04      	ldr	r2, [pc, #16]	; (105e8 <z_nrf_rtc_timer_chan_free+0x18>)
   105d6:	e8d2 1fef 	ldaex	r1, [r2]
   105da:	4319      	orrs	r1, r3
   105dc:	e8c2 1fe0 	stlex	r0, r1, [r2]
   105e0:	2800      	cmp	r0, #0
   105e2:	d1f8      	bne.n	105d6 <z_nrf_rtc_timer_chan_free+0x6>
}
   105e4:	4770      	bx	lr
   105e6:	bf00      	nop
   105e8:	200025b8 	.word	0x200025b8

000105ec <sys_clock_set_timeout>:
{
   105ec:	b510      	push	{r4, lr}
   105ee:	b082      	sub	sp, #8
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   105f0:	f1b0 3fff 	cmp.w	r0, #4294967295
   105f4:	d006      	beq.n	10604 <sys_clock_set_timeout+0x18>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   105f6:	2801      	cmp	r0, #1
   105f8:	dd06      	ble.n	10608 <sys_clock_set_timeout+0x1c>
   105fa:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   105fe:	da05      	bge.n	1060c <sys_clock_set_timeout+0x20>
   10600:	1e44      	subs	r4, r0, #1
   10602:	e004      	b.n	1060e <sys_clock_set_timeout+0x22>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   10604:	480f      	ldr	r0, [pc, #60]	; (10644 <sys_clock_set_timeout+0x58>)
   10606:	e7f8      	b.n	105fa <sys_clock_set_timeout+0xe>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   10608:	2400      	movs	r4, #0
   1060a:	e000      	b.n	1060e <sys_clock_set_timeout+0x22>
   1060c:	4c0d      	ldr	r4, [pc, #52]	; (10644 <sys_clock_set_timeout+0x58>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   1060e:	f7ff fe95 	bl	1033c <z_nrf_rtc_timer_read>
   10612:	4b0d      	ldr	r3, [pc, #52]	; (10648 <sys_clock_set_timeout+0x5c>)
   10614:	6819      	ldr	r1, [r3, #0]
   10616:	685b      	ldr	r3, [r3, #4]
   10618:	1a40      	subs	r0, r0, r1
	if (unannounced >= COUNTER_HALF_SPAN) {
   1061a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   1061e:	d300      	bcc.n	10622 <sys_clock_set_timeout+0x36>
		ticks = 0;
   10620:	2400      	movs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   10622:	4420      	add	r0, r4
   10624:	1c42      	adds	r2, r0, #1
	if (cyc > MAX_CYCLES) {
   10626:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
   1062a:	d300      	bcc.n	1062e <sys_clock_set_timeout+0x42>
		cyc = MAX_CYCLES;
   1062c:	4a05      	ldr	r2, [pc, #20]	; (10644 <sys_clock_set_timeout+0x58>)
	uint64_t target_time = cyc + last_count;
   1062e:	2000      	movs	r0, #0
   10630:	188a      	adds	r2, r1, r2
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   10632:	9001      	str	r0, [sp, #4]
   10634:	4905      	ldr	r1, [pc, #20]	; (1064c <sys_clock_set_timeout+0x60>)
   10636:	9100      	str	r1, [sp, #0]
   10638:	f143 0300 	adc.w	r3, r3, #0
   1063c:	f00a fb1c 	bl	1ac78 <compare_set>
}
   10640:	b002      	add	sp, #8
   10642:	bd10      	pop	{r4, pc}
   10644:	007fffff 	.word	0x007fffff
   10648:	20001980 	.word	0x20001980
   1064c:	000102a5 	.word	0x000102a5

00010650 <sys_clock_elapsed>:
{
   10650:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   10652:	f7ff fe73 	bl	1033c <z_nrf_rtc_timer_read>
   10656:	4b02      	ldr	r3, [pc, #8]	; (10660 <sys_clock_elapsed+0x10>)
   10658:	681b      	ldr	r3, [r3, #0]
}
   1065a:	1ac0      	subs	r0, r0, r3
   1065c:	bd08      	pop	{r3, pc}
   1065e:	bf00      	nop
   10660:	20001980 	.word	0x20001980

00010664 <nrf_pin_configure>:
 */
__unused static void nrf_pin_configure(pinctrl_soc_pin_t pin,
				       nrf_gpio_pin_dir_t dir,
				       nrf_gpio_pin_input_t input,
				       nrf_gpio_pin_drive_t drive)
{
   10664:	b510      	push	{r4, lr}
	/* force input direction and disconnected buffer for low power */
	if (NRF_GET_LP(pin) == NRF_LP_ENABLE) {
   10666:	f410 5f80 	tst.w	r0, #4096	; 0x1000
   1066a:	d001      	beq.n	10670 <nrf_pin_configure+0xc>
		dir = NRF_GPIO_PIN_DIR_INPUT;
		input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   1066c:	2201      	movs	r2, #1
		dir = NRF_GPIO_PIN_DIR_INPUT;
   1066e:	2100      	movs	r1, #0
	}

	nrf_gpio_cfg(NRF_GET_PIN(pin), dir, input, NRF_GET_PULL(pin), drive,
   10670:	f3c0 1e81 	ubfx	lr, r0, #6, #2
    *p_pin = pin_number & 0x1F;
   10674:	f000 0c1f 	and.w	ip, r0, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   10678:	f010 0f20 	tst.w	r0, #32
   1067c:	d110      	bne.n	106a0 <nrf_pin_configure+0x3c>
        case 0: return NRF_P0;
   1067e:	4c09      	ldr	r4, [pc, #36]	; (106a4 <nrf_pin_configure+0x40>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   10680:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
   10684:	f854 002c 	ldr.w	r0, [r4, ip, lsl #2]
   10688:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   1068c:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
   10690:	ea41 018e 	orr.w	r1, r1, lr, lsl #2
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   10694:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   10698:	4301      	orrs	r1, r0
    reg->PIN_CNF[pin_number] = cnf;
   1069a:	f844 102c 	str.w	r1, [r4, ip, lsl #2]
		     NRF_GPIO_PIN_NOSENSE);
}
   1069e:	bd10      	pop	{r4, pc}
        case 1: return NRF_P1;
   106a0:	4c01      	ldr	r4, [pc, #4]	; (106a8 <nrf_pin_configure+0x44>)
   106a2:	e7ed      	b.n	10680 <nrf_pin_configure+0x1c>
   106a4:	50842500 	.word	0x50842500
   106a8:	50842800 	.word	0x50842800

000106ac <pinctrl_configure_pins>:

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
   106ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   106b0:	4606      	mov	r6, r0
   106b2:	460f      	mov	r7, r1
   106b4:	4690      	mov	r8, r2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   106b6:	2400      	movs	r4, #0
   106b8:	e015      	b.n	106e6 <pinctrl_configure_pins+0x3a>
		__unused nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);

		switch (NRF_GET_FUN(pins[i])) {
#if defined(NRF_PSEL_UART)
		case NRF_FUN_UART_TX:
			NRF_PSEL_UART(reg, TXD) = NRF_GET_PIN(pins[i]);
   106ba:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   106be:	f8c8 550c 	str.w	r5, [r8, #1292]	; 0x50c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 1);
   106c2:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
    *p_pin = pin_number & 0x1F;
   106c6:	f001 021f 	and.w	r2, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   106ca:	f011 0f20 	tst.w	r1, #32
   106ce:	d15f      	bne.n	10790 <pinctrl_configure_pins+0xe4>
        case 0: return NRF_P0;
   106d0:	4dbb      	ldr	r5, [pc, #748]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   106d2:	2101      	movs	r1, #1
   106d4:	fa01 f202 	lsl.w	r2, r1, r2
    p_reg->OUTSET = set_mask;
   106d8:	60aa      	str	r2, [r5, #8]
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   106da:	460a      	mov	r2, r1
   106dc:	5830      	ldr	r0, [r6, r0]
   106de:	f7ff ffc1 	bl	10664 <nrf_pin_configure>
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   106e2:	3401      	adds	r4, #1
   106e4:	b2e4      	uxtb	r4, r4
   106e6:	42bc      	cmp	r4, r7
   106e8:	f080 81b0 	bcs.w	10a4c <pinctrl_configure_pins+0x3a0>
		__unused nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   106ec:	00a0      	lsls	r0, r4, #2
   106ee:	f856 5024 	ldr.w	r5, [r6, r4, lsl #2]
   106f2:	f3c5 2303 	ubfx	r3, r5, #8, #4
		switch (NRF_GET_FUN(pins[i])) {
   106f6:	0c2a      	lsrs	r2, r5, #16
   106f8:	2a22      	cmp	r2, #34	; 0x22
   106fa:	f200 81a9 	bhi.w	10a50 <pinctrl_configure_pins+0x3a4>
   106fe:	a101      	add	r1, pc, #4	; (adr r1, 10704 <pinctrl_configure_pins+0x58>)
   10700:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   10704:	000106bb 	.word	0x000106bb
   10708:	00010795 	.word	0x00010795
   1070c:	000107ab 	.word	0x000107ab
   10710:	000107d9 	.word	0x000107d9
   10714:	000107ef 	.word	0x000107ef
   10718:	0001081d 	.word	0x0001081d
   1071c:	0001084b 	.word	0x0001084b
   10720:	00010a51 	.word	0x00010a51
   10724:	00010a51 	.word	0x00010a51
   10728:	00010a51 	.word	0x00010a51
   1072c:	00010a51 	.word	0x00010a51
   10730:	00010861 	.word	0x00010861
   10734:	00010879 	.word	0x00010879
   10738:	00010a51 	.word	0x00010a51
   1073c:	00010a51 	.word	0x00010a51
   10740:	00010a51 	.word	0x00010a51
   10744:	00010a51 	.word	0x00010a51
   10748:	00010a51 	.word	0x00010a51
   1074c:	00010a51 	.word	0x00010a51
   10750:	00010a51 	.word	0x00010a51
   10754:	00010a51 	.word	0x00010a51
   10758:	00010a51 	.word	0x00010a51
   1075c:	00010891 	.word	0x00010891
   10760:	000108dd 	.word	0x000108dd
   10764:	00010929 	.word	0x00010929
   10768:	00010975 	.word	0x00010975
   1076c:	00010a51 	.word	0x00010a51
   10770:	00010a51 	.word	0x00010a51
   10774:	00010a51 	.word	0x00010a51
   10778:	000109c9 	.word	0x000109c9
   1077c:	000109df 	.word	0x000109df
   10780:	000109f5 	.word	0x000109f5
   10784:	00010a0b 	.word	0x00010a0b
   10788:	00010a21 	.word	0x00010a21
   1078c:	00010a37 	.word	0x00010a37
        case 1: return NRF_P1;
   10790:	4d8c      	ldr	r5, [pc, #560]	; (109c4 <pinctrl_configure_pins+0x318>)
   10792:	e79e      	b.n	106d2 <pinctrl_configure_pins+0x26>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
		case NRF_FUN_UART_RX:
			NRF_PSEL_UART(reg, RXD) = NRF_GET_PIN(pins[i]);
   10794:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10798:	f8c8 5514 	str.w	r5, [r8, #1300]	; 0x514
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   1079c:	2200      	movs	r2, #0
   1079e:	4611      	mov	r1, r2
   107a0:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   107a4:	f7ff ff5e 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   107a8:	e79b      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_UART_RTS:
			NRF_PSEL_UART(reg, RTS) = NRF_GET_PIN(pins[i]);
   107aa:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   107ae:	f8c8 5508 	str.w	r5, [r8, #1288]	; 0x508
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 1);
   107b2:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
    *p_pin = pin_number & 0x1F;
   107b6:	f001 021f 	and.w	r2, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   107ba:	f011 0f20 	tst.w	r1, #32
   107be:	d109      	bne.n	107d4 <pinctrl_configure_pins+0x128>
        case 0: return NRF_P0;
   107c0:	4d7f      	ldr	r5, [pc, #508]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   107c2:	2101      	movs	r1, #1
   107c4:	fa01 f202 	lsl.w	r2, r1, r2
    p_reg->OUTSET = set_mask;
   107c8:	60aa      	str	r2, [r5, #8]
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   107ca:	460a      	mov	r2, r1
   107cc:	5830      	ldr	r0, [r6, r0]
   107ce:	f7ff ff49 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   107d2:	e786      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   107d4:	4d7b      	ldr	r5, [pc, #492]	; (109c4 <pinctrl_configure_pins+0x318>)
   107d6:	e7f4      	b.n	107c2 <pinctrl_configure_pins+0x116>
		case NRF_FUN_UART_CTS:
			NRF_PSEL_UART(reg, CTS) = NRF_GET_PIN(pins[i]);
   107d8:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   107dc:	f8c8 5510 	str.w	r5, [r8, #1296]	; 0x510
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   107e0:	2200      	movs	r2, #0
   107e2:	4611      	mov	r1, r2
   107e4:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   107e8:	f7ff ff3c 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   107ec:	e779      	b.n	106e2 <pinctrl_configure_pins+0x36>
#endif /* defined(NRF_PSEL_UART) */
#if defined(NRF_PSEL_SPIM)
		case NRF_FUN_SPIM_SCK:
			NRF_PSEL_SPIM(reg, SCK) = NRF_GET_PIN(pins[i]);
   107ee:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   107f2:	f8c8 5508 	str.w	r5, [r8, #1288]	; 0x508
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 0);
   107f6:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
    *p_pin = pin_number & 0x1F;
   107fa:	f001 021f 	and.w	r2, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   107fe:	f011 0f20 	tst.w	r1, #32
   10802:	d109      	bne.n	10818 <pinctrl_configure_pins+0x16c>
        case 0: return NRF_P0;
   10804:	4d6e      	ldr	r5, [pc, #440]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   10806:	2101      	movs	r1, #1
   10808:	fa01 f202 	lsl.w	r2, r1, r2
    p_reg->OUTCLR = clr_mask;
   1080c:	60ea      	str	r2, [r5, #12]
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   1080e:	2200      	movs	r2, #0
   10810:	5830      	ldr	r0, [r6, r0]
   10812:	f7ff ff27 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   10816:	e764      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   10818:	4d6a      	ldr	r5, [pc, #424]	; (109c4 <pinctrl_configure_pins+0x318>)
   1081a:	e7f4      	b.n	10806 <pinctrl_configure_pins+0x15a>
		case NRF_FUN_SPIM_MOSI:
			NRF_PSEL_SPIM(reg, MOSI) = NRF_GET_PIN(pins[i]);
   1081c:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10820:	f8c8 550c 	str.w	r5, [r8, #1292]	; 0x50c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 0);
   10824:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
    *p_pin = pin_number & 0x1F;
   10828:	f001 021f 	and.w	r2, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1082c:	f011 0f20 	tst.w	r1, #32
   10830:	d109      	bne.n	10846 <pinctrl_configure_pins+0x19a>
        case 0: return NRF_P0;
   10832:	4d63      	ldr	r5, [pc, #396]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   10834:	2101      	movs	r1, #1
   10836:	fa01 f202 	lsl.w	r2, r1, r2
    p_reg->OUTCLR = clr_mask;
   1083a:	60ea      	str	r2, [r5, #12]
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   1083c:	460a      	mov	r2, r1
   1083e:	5830      	ldr	r0, [r6, r0]
   10840:	f7ff ff10 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   10844:	e74d      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   10846:	4d5f      	ldr	r5, [pc, #380]	; (109c4 <pinctrl_configure_pins+0x318>)
   10848:	e7f4      	b.n	10834 <pinctrl_configure_pins+0x188>
		case NRF_FUN_SPIM_MISO:
			NRF_PSEL_SPIM(reg, MISO) = NRF_GET_PIN(pins[i]);
   1084a:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   1084e:	f8c8 5510 	str.w	r5, [r8, #1296]	; 0x510
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   10852:	2200      	movs	r2, #0
   10854:	4611      	mov	r1, r2
   10856:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   1085a:	f7ff ff03 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   1085e:	e740      	b.n	106e2 <pinctrl_configure_pins+0x36>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
#endif /* defined(NRF_PSEL_SPIS) */
#if defined(NRF_PSEL_TWIM)
		case NRF_FUN_TWIM_SCL:
			NRF_PSEL_TWIM(reg, SCL) = NRF_GET_PIN(pins[i]);
   10860:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10864:	f8c8 5508 	str.w	r5, [r8, #1288]	; 0x508
			if (drive == NRF_DRIVE_S0S1) {
   10868:	b903      	cbnz	r3, 1086c <pinctrl_configure_pins+0x1c0>
				 * suitable for TWI/TWIM peripherals (S0D1).
				 * This drive cannot be used always so that
				 * users are able to select e.g. H0D1 or E0E1
				 * in devicetree.
				 */
				drive = NRF_DRIVE_S0D1;
   1086a:	2306      	movs	r3, #6
			}
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   1086c:	2200      	movs	r2, #0
   1086e:	4611      	mov	r1, r2
   10870:	5830      	ldr	r0, [r6, r0]
   10872:	f7ff fef7 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   10876:	e734      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_TWIM_SDA:
			NRF_PSEL_TWIM(reg, SDA) = NRF_GET_PIN(pins[i]);
   10878:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   1087c:	f8c8 550c 	str.w	r5, [r8, #1292]	; 0x50c
			if (drive == NRF_DRIVE_S0S1) {
   10880:	b903      	cbnz	r3, 10884 <pinctrl_configure_pins+0x1d8>
				drive = NRF_DRIVE_S0D1;
   10882:	2306      	movs	r3, #6
			}
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   10884:	2200      	movs	r2, #0
   10886:	4611      	mov	r1, r2
   10888:	5830      	ldr	r0, [r6, r0]
   1088a:	f7ff feeb 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
   1088e:	e728      	b.n	106e2 <pinctrl_configure_pins+0x36>
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
#endif /* defined(NRF_PSEL_PDM) */
#if defined(NRF_PSEL_PWM)
		case NRF_FUN_PWM_OUT0:
			NRF_PSEL_PWM(reg, OUT[0]) = NRF_GET_PIN(pins[i]);
   10890:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10894:	f8c8 5560 	str.w	r5, [r8, #1376]	; 0x560
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   10898:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
   1089c:	f002 013f 	and.w	r1, r2, #63	; 0x3f
    if (value == 0)
   108a0:	f412 5f00 	tst.w	r2, #8192	; 0x2000
   108a4:	d10f      	bne.n	108c6 <pinctrl_configure_pins+0x21a>
    *p_pin = pin_number & 0x1F;
   108a6:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   108aa:	094a      	lsrs	r2, r1, #5
   108ac:	d109      	bne.n	108c2 <pinctrl_configure_pins+0x216>
        case 0: return NRF_P0;
   108ae:	4944      	ldr	r1, [pc, #272]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   108b0:	2201      	movs	r2, #1
   108b2:	40aa      	lsls	r2, r5
    p_reg->OUTCLR = clr_mask;
   108b4:	60ca      	str	r2, [r1, #12]
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   108b6:	2201      	movs	r2, #1
   108b8:	4611      	mov	r1, r2
   108ba:	5830      	ldr	r0, [r6, r0]
   108bc:	f7ff fed2 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   108c0:	e70f      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   108c2:	4940      	ldr	r1, [pc, #256]	; (109c4 <pinctrl_configure_pins+0x318>)
   108c4:	e7f4      	b.n	108b0 <pinctrl_configure_pins+0x204>
    *p_pin = pin_number & 0x1F;
   108c6:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   108ca:	094a      	lsrs	r2, r1, #5
   108cc:	d104      	bne.n	108d8 <pinctrl_configure_pins+0x22c>
        case 0: return NRF_P0;
   108ce:	493c      	ldr	r1, [pc, #240]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   108d0:	2201      	movs	r2, #1
   108d2:	40aa      	lsls	r2, r5
    p_reg->OUTSET = set_mask;
   108d4:	608a      	str	r2, [r1, #8]
}
   108d6:	e7ee      	b.n	108b6 <pinctrl_configure_pins+0x20a>
        case 1: return NRF_P1;
   108d8:	493a      	ldr	r1, [pc, #232]	; (109c4 <pinctrl_configure_pins+0x318>)
   108da:	e7f9      	b.n	108d0 <pinctrl_configure_pins+0x224>
		case NRF_FUN_PWM_OUT1:
			NRF_PSEL_PWM(reg, OUT[1]) = NRF_GET_PIN(pins[i]);
   108dc:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   108e0:	f8c8 5564 	str.w	r5, [r8, #1380]	; 0x564
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   108e4:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
   108e8:	f002 013f 	and.w	r1, r2, #63	; 0x3f
    if (value == 0)
   108ec:	f412 5f00 	tst.w	r2, #8192	; 0x2000
   108f0:	d10f      	bne.n	10912 <pinctrl_configure_pins+0x266>
    *p_pin = pin_number & 0x1F;
   108f2:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   108f6:	094a      	lsrs	r2, r1, #5
   108f8:	d109      	bne.n	1090e <pinctrl_configure_pins+0x262>
        case 0: return NRF_P0;
   108fa:	4931      	ldr	r1, [pc, #196]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   108fc:	2201      	movs	r2, #1
   108fe:	40aa      	lsls	r2, r5
    p_reg->OUTCLR = clr_mask;
   10900:	60ca      	str	r2, [r1, #12]
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   10902:	2201      	movs	r2, #1
   10904:	4611      	mov	r1, r2
   10906:	5830      	ldr	r0, [r6, r0]
   10908:	f7ff feac 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   1090c:	e6e9      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   1090e:	492d      	ldr	r1, [pc, #180]	; (109c4 <pinctrl_configure_pins+0x318>)
   10910:	e7f4      	b.n	108fc <pinctrl_configure_pins+0x250>
    *p_pin = pin_number & 0x1F;
   10912:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   10916:	094a      	lsrs	r2, r1, #5
   10918:	d104      	bne.n	10924 <pinctrl_configure_pins+0x278>
        case 0: return NRF_P0;
   1091a:	4929      	ldr	r1, [pc, #164]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1091c:	2201      	movs	r2, #1
   1091e:	40aa      	lsls	r2, r5
    p_reg->OUTSET = set_mask;
   10920:	608a      	str	r2, [r1, #8]
}
   10922:	e7ee      	b.n	10902 <pinctrl_configure_pins+0x256>
        case 1: return NRF_P1;
   10924:	4927      	ldr	r1, [pc, #156]	; (109c4 <pinctrl_configure_pins+0x318>)
   10926:	e7f9      	b.n	1091c <pinctrl_configure_pins+0x270>
		case NRF_FUN_PWM_OUT2:
			NRF_PSEL_PWM(reg, OUT[2]) = NRF_GET_PIN(pins[i]);
   10928:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   1092c:	f8c8 5568 	str.w	r5, [r8, #1384]	; 0x568
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   10930:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
   10934:	f002 013f 	and.w	r1, r2, #63	; 0x3f
    if (value == 0)
   10938:	f412 5f00 	tst.w	r2, #8192	; 0x2000
   1093c:	d10f      	bne.n	1095e <pinctrl_configure_pins+0x2b2>
    *p_pin = pin_number & 0x1F;
   1093e:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   10942:	094a      	lsrs	r2, r1, #5
   10944:	d109      	bne.n	1095a <pinctrl_configure_pins+0x2ae>
        case 0: return NRF_P0;
   10946:	491e      	ldr	r1, [pc, #120]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   10948:	2201      	movs	r2, #1
   1094a:	40aa      	lsls	r2, r5
    p_reg->OUTCLR = clr_mask;
   1094c:	60ca      	str	r2, [r1, #12]
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   1094e:	2201      	movs	r2, #1
   10950:	4611      	mov	r1, r2
   10952:	5830      	ldr	r0, [r6, r0]
   10954:	f7ff fe86 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   10958:	e6c3      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   1095a:	491a      	ldr	r1, [pc, #104]	; (109c4 <pinctrl_configure_pins+0x318>)
   1095c:	e7f4      	b.n	10948 <pinctrl_configure_pins+0x29c>
    *p_pin = pin_number & 0x1F;
   1095e:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   10962:	094a      	lsrs	r2, r1, #5
   10964:	d104      	bne.n	10970 <pinctrl_configure_pins+0x2c4>
        case 0: return NRF_P0;
   10966:	4916      	ldr	r1, [pc, #88]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   10968:	2201      	movs	r2, #1
   1096a:	40aa      	lsls	r2, r5
    p_reg->OUTSET = set_mask;
   1096c:	608a      	str	r2, [r1, #8]
}
   1096e:	e7ee      	b.n	1094e <pinctrl_configure_pins+0x2a2>
        case 1: return NRF_P1;
   10970:	4914      	ldr	r1, [pc, #80]	; (109c4 <pinctrl_configure_pins+0x318>)
   10972:	e7f9      	b.n	10968 <pinctrl_configure_pins+0x2bc>
		case NRF_FUN_PWM_OUT3:
			NRF_PSEL_PWM(reg, OUT[3]) = NRF_GET_PIN(pins[i]);
   10974:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10978:	f8c8 556c 	str.w	r5, [r8, #1388]	; 0x56c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
   1097c:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
   10980:	f002 013f 	and.w	r1, r2, #63	; 0x3f
    if (value == 0)
   10984:	f412 5f00 	tst.w	r2, #8192	; 0x2000
   10988:	d10f      	bne.n	109aa <pinctrl_configure_pins+0x2fe>
    *p_pin = pin_number & 0x1F;
   1098a:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1098e:	094a      	lsrs	r2, r1, #5
   10990:	d109      	bne.n	109a6 <pinctrl_configure_pins+0x2fa>
        case 0: return NRF_P0;
   10992:	490b      	ldr	r1, [pc, #44]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   10994:	2201      	movs	r2, #1
   10996:	40aa      	lsls	r2, r5
    p_reg->OUTCLR = clr_mask;
   10998:	60ca      	str	r2, [r1, #12]
					   NRF_GET_INVERT(pins[i]));
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
   1099a:	2201      	movs	r2, #1
   1099c:	4611      	mov	r1, r2
   1099e:	5830      	ldr	r0, [r6, r0]
   109a0:	f7ff fe60 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   109a4:	e69d      	b.n	106e2 <pinctrl_configure_pins+0x36>
        case 1: return NRF_P1;
   109a6:	4907      	ldr	r1, [pc, #28]	; (109c4 <pinctrl_configure_pins+0x318>)
   109a8:	e7f4      	b.n	10994 <pinctrl_configure_pins+0x2e8>
    *p_pin = pin_number & 0x1F;
   109aa:	f001 051f 	and.w	r5, r1, #31
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   109ae:	094a      	lsrs	r2, r1, #5
   109b0:	d104      	bne.n	109bc <pinctrl_configure_pins+0x310>
        case 0: return NRF_P0;
   109b2:	4903      	ldr	r1, [pc, #12]	; (109c0 <pinctrl_configure_pins+0x314>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   109b4:	2201      	movs	r2, #1
   109b6:	40aa      	lsls	r2, r5
    p_reg->OUTSET = set_mask;
   109b8:	608a      	str	r2, [r1, #8]
}
   109ba:	e7ee      	b.n	1099a <pinctrl_configure_pins+0x2ee>
        case 1: return NRF_P1;
   109bc:	4901      	ldr	r1, [pc, #4]	; (109c4 <pinctrl_configure_pins+0x318>)
   109be:	e7f9      	b.n	109b4 <pinctrl_configure_pins+0x308>
   109c0:	50842500 	.word	0x50842500
   109c4:	50842800 	.word	0x50842800
					  NRF_GPIO_PIN_INPUT_CONNECT, drive);
			break;
#endif /* defined(NRF_PSEL_QDEC) */
#if defined(NRF_PSEL_QSPI)
		case NRF_FUN_QSPI_SCK:
			NRF_PSEL_QSPI(reg, SCK) = NRF_GET_PIN(pins[i]);
   109c8:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   109cc:	f8c8 5524 	str.w	r5, [r8, #1316]	; 0x524
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   109d0:	2201      	movs	r2, #1
   109d2:	2100      	movs	r1, #0
   109d4:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   109d8:	f7ff fe44 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   109dc:	e681      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_QSPI_CSN:
			NRF_PSEL_QSPI(reg, CSN) = NRF_GET_PIN(pins[i]);
   109de:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   109e2:	f8c8 5528 	str.w	r5, [r8, #1320]	; 0x528
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   109e6:	2201      	movs	r2, #1
   109e8:	2100      	movs	r1, #0
   109ea:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   109ee:	f7ff fe39 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   109f2:	e676      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_QSPI_IO0:
			NRF_PSEL_QSPI(reg, IO0) = NRF_GET_PIN(pins[i]);
   109f4:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   109f8:	f8c8 5530 	str.w	r5, [r8, #1328]	; 0x530
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   109fc:	2201      	movs	r2, #1
   109fe:	2100      	movs	r1, #0
   10a00:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   10a04:	f7ff fe2e 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   10a08:	e66b      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_QSPI_IO1:
			NRF_PSEL_QSPI(reg, IO1) = NRF_GET_PIN(pins[i]);
   10a0a:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10a0e:	f8c8 5534 	str.w	r5, [r8, #1332]	; 0x534
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   10a12:	2201      	movs	r2, #1
   10a14:	2100      	movs	r1, #0
   10a16:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   10a1a:	f7ff fe23 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   10a1e:	e660      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_QSPI_IO2:
			NRF_PSEL_QSPI(reg, IO2) = NRF_GET_PIN(pins[i]);
   10a20:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10a24:	f8c8 5538 	str.w	r5, [r8, #1336]	; 0x538
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   10a28:	2201      	movs	r2, #1
   10a2a:	2100      	movs	r1, #0
   10a2c:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   10a30:	f7ff fe18 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   10a34:	e655      	b.n	106e2 <pinctrl_configure_pins+0x36>
		case NRF_FUN_QSPI_IO3:
			NRF_PSEL_QSPI(reg, IO3) = NRF_GET_PIN(pins[i]);
   10a36:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   10a3a:	f8c8 553c 	str.w	r5, [r8, #1340]	; 0x53c
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
   10a3e:	2201      	movs	r2, #1
   10a40:	2100      	movs	r1, #0
   10a42:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   10a46:	f7ff fe0d 	bl	10664 <nrf_pin_configure>
					  NRF_GPIO_PIN_INPUT_DISCONNECT, drive);
			break;
   10a4a:	e64a      	b.n	106e2 <pinctrl_configure_pins+0x36>
		default:
			return -ENOTSUP;
		}
	}

	return 0;
   10a4c:	2000      	movs	r0, #0
   10a4e:	e001      	b.n	10a54 <pinctrl_configure_pins+0x3a8>
		switch (NRF_GET_FUN(pins[i])) {
   10a50:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   10a54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00010a58 <mbox_nrf_set_enabled>:
{
	return IPC_CONF_NUM;
}

static int mbox_nrf_set_enabled(const struct device *dev, uint32_t channel, bool enable)
{
   10a58:	b570      	push	{r4, r5, r6, lr}
   10a5a:	b088      	sub	sp, #32
   10a5c:	460c      	mov	r4, r1
   10a5e:	4615      	mov	r5, r2
	struct mbox_nrf_data *data = dev->data;
   10a60:	6906      	ldr	r6, [r0, #16]
	const struct mbox_nrf_conf *conf = dev->config;
   10a62:	6843      	ldr	r3, [r0, #4]
	return ((ch < IPC_CONF_NUM) && (conf->rx_mask & BIT(ch)));
   10a64:	290f      	cmp	r1, #15
   10a66:	d806      	bhi.n	10a76 <mbox_nrf_set_enabled+0x1e>
   10a68:	681b      	ldr	r3, [r3, #0]
   10a6a:	40cb      	lsrs	r3, r1
   10a6c:	f013 0f01 	tst.w	r3, #1
   10a70:	d12f      	bne.n	10ad2 <mbox_nrf_set_enabled+0x7a>
   10a72:	2300      	movs	r3, #0
   10a74:	e000      	b.n	10a78 <mbox_nrf_set_enabled+0x20>
   10a76:	2300      	movs	r3, #0

	if (!is_rx_channel_valid(dev, channel)) {
   10a78:	2b00      	cmp	r3, #0
   10a7a:	d067      	beq.n	10b4c <mbox_nrf_set_enabled+0xf4>
		return -EINVAL;
	}

	if ((enable == 0 && (!(data->enabled_mask & BIT(channel)))) ||
   10a7c:	b92d      	cbnz	r5, 10a8a <mbox_nrf_set_enabled+0x32>
   10a7e:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10a82:	40e3      	lsrs	r3, r4
   10a84:	f013 0f01 	tst.w	r3, #1
   10a88:	d063      	beq.n	10b52 <mbox_nrf_set_enabled+0xfa>
   10a8a:	b12d      	cbz	r5, 10a98 <mbox_nrf_set_enabled+0x40>
	    (enable != 0 &&   (data->enabled_mask & BIT(channel)))) {
   10a8c:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10a90:	40e3      	lsrs	r3, r4
   10a92:	f013 0f01 	tst.w	r3, #1
   10a96:	d15f      	bne.n	10b58 <mbox_nrf_set_enabled+0x100>
		return -EALREADY;
	}

	if (enable && (data->cb[channel] == NULL)) {
   10a98:	b115      	cbz	r5, 10aa0 <mbox_nrf_set_enabled+0x48>
   10a9a:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   10a9e:	b1d3      	cbz	r3, 10ad6 <mbox_nrf_set_enabled+0x7e>
		LOG_WRN("Enabling channel without a registered callback\n");
	}

	if (enable && data->enabled_mask == 0) {
   10aa0:	b11d      	cbz	r5, 10aaa <mbox_nrf_set_enabled+0x52>
   10aa2:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10aa6:	2b00      	cmp	r3, #0
   10aa8:	d03a      	beq.n	10b20 <mbox_nrf_set_enabled+0xc8>
		irq_enable(DT_INST_IRQN(0));
	}

	if (enable) {
   10aaa:	2d00      	cmp	r5, #0
   10aac:	d03c      	beq.n	10b28 <mbox_nrf_set_enabled+0xd0>
		data->enabled_mask |= BIT(channel);
   10aae:	2301      	movs	r3, #1
   10ab0:	fa03 f204 	lsl.w	r2, r3, r4
   10ab4:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10ab8:	4313      	orrs	r3, r2
   10aba:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
		compiler_barrier();
		nrfx_ipc_receive_event_enable(channel);
   10abe:	b2e0      	uxtb	r0, r4
   10ac0:	f001 f94e 	bl	11d60 <nrfx_ipc_receive_event_enable>
		nrfx_ipc_receive_event_disable(channel);
		compiler_barrier();
		data->enabled_mask &= ~BIT(channel);
	}

	if (data->enabled_mask == 0) {
   10ac4:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10ac8:	2b00      	cmp	r3, #0
   10aca:	d03a      	beq.n	10b42 <mbox_nrf_set_enabled+0xea>
		irq_disable(DT_INST_IRQN(0));
	}

	return 0;
   10acc:	2000      	movs	r0, #0
}
   10ace:	b008      	add	sp, #32
   10ad0:	bd70      	pop	{r4, r5, r6, pc}
	return ((ch < IPC_CONF_NUM) && (conf->rx_mask & BIT(ch)));
   10ad2:	2301      	movs	r3, #1
   10ad4:	e7d0      	b.n	10a78 <mbox_nrf_set_enabled+0x20>
		LOG_WRN("Enabling channel without a registered callback\n");
   10ad6:	4b22      	ldr	r3, [pc, #136]	; (10b60 <mbox_nrf_set_enabled+0x108>)
   10ad8:	9307      	str	r3, [sp, #28]
   10ada:	2202      	movs	r2, #2
   10adc:	f88d 2004 	strb.w	r2, [sp, #4]
   10ae0:	2300      	movs	r3, #0
   10ae2:	f88d 3005 	strb.w	r3, [sp, #5]
   10ae6:	f88d 3006 	strb.w	r3, [sp, #6]
   10aea:	f88d 3007 	strb.w	r3, [sp, #7]
   10aee:	9901      	ldr	r1, [sp, #4]
   10af0:	9106      	str	r1, [sp, #24]
   10af2:	4619      	mov	r1, r3
   10af4:	f363 0100 	bfi	r1, r3, #0, #1
   10af8:	f363 0141 	bfi	r1, r3, #1, #1
   10afc:	f363 0182 	bfi	r1, r3, #2, #1
   10b00:	f363 01c5 	bfi	r1, r3, #3, #3
   10b04:	f362 1188 	bfi	r1, r2, #6, #3
   10b08:	2208      	movs	r2, #8
   10b0a:	f362 2152 	bfi	r1, r2, #9, #10
   10b0e:	f363 41de 	bfi	r1, r3, #19, #12
   10b12:	f363 71df 	bfi	r1, r3, #31, #1
   10b16:	aa06      	add	r2, sp, #24
   10b18:	4812      	ldr	r0, [pc, #72]	; (10b64 <mbox_nrf_set_enabled+0x10c>)
   10b1a:	f7f1 fb95 	bl	2248 <z_impl_z_log_msg_static_create>
   10b1e:	e7bf      	b.n	10aa0 <mbox_nrf_set_enabled+0x48>
		irq_enable(DT_INST_IRQN(0));
   10b20:	202a      	movs	r0, #42	; 0x2a
   10b22:	f7f3 fa6f 	bl	4004 <arch_irq_enable>
   10b26:	e7c0      	b.n	10aaa <mbox_nrf_set_enabled+0x52>
		nrfx_ipc_receive_event_disable(channel);
   10b28:	b2e0      	uxtb	r0, r4
   10b2a:	f001 f921 	bl	11d70 <nrfx_ipc_receive_event_disable>
		data->enabled_mask &= ~BIT(channel);
   10b2e:	2301      	movs	r3, #1
   10b30:	fa03 f404 	lsl.w	r4, r3, r4
   10b34:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10b38:	ea23 0304 	bic.w	r3, r3, r4
   10b3c:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
   10b40:	e7c0      	b.n	10ac4 <mbox_nrf_set_enabled+0x6c>
		irq_disable(DT_INST_IRQN(0));
   10b42:	202a      	movs	r0, #42	; 0x2a
   10b44:	f7f3 fa6c 	bl	4020 <arch_irq_disable>
	return 0;
   10b48:	2000      	movs	r0, #0
   10b4a:	e7c0      	b.n	10ace <mbox_nrf_set_enabled+0x76>
		return -EINVAL;
   10b4c:	f06f 0015 	mvn.w	r0, #21
   10b50:	e7bd      	b.n	10ace <mbox_nrf_set_enabled+0x76>
		return -EALREADY;
   10b52:	f06f 0077 	mvn.w	r0, #119	; 0x77
   10b56:	e7ba      	b.n	10ace <mbox_nrf_set_enabled+0x76>
   10b58:	f06f 0077 	mvn.w	r0, #119	; 0x77
   10b5c:	e7b7      	b.n	10ace <mbox_nrf_set_enabled+0x76>
   10b5e:	bf00      	nop
   10b60:	0001fc9c 	.word	0x0001fc9c
   10b64:	0001d06c 	.word	0x0001d06c

00010b68 <mbox_nrf_send>:
{
   10b68:	b530      	push	{r4, r5, lr}
   10b6a:	b089      	sub	sp, #36	; 0x24
   10b6c:	4605      	mov	r5, r0
   10b6e:	460c      	mov	r4, r1
	if (msg) {
   10b70:	b31a      	cbz	r2, 10bba <mbox_nrf_send+0x52>
		LOG_WRN("Sending data not supported");
   10b72:	4b20      	ldr	r3, [pc, #128]	; (10bf4 <mbox_nrf_send+0x8c>)
   10b74:	9307      	str	r3, [sp, #28]
   10b76:	2202      	movs	r2, #2
   10b78:	f88d 2004 	strb.w	r2, [sp, #4]
   10b7c:	2300      	movs	r3, #0
   10b7e:	f88d 3005 	strb.w	r3, [sp, #5]
   10b82:	f88d 3006 	strb.w	r3, [sp, #6]
   10b86:	f88d 3007 	strb.w	r3, [sp, #7]
   10b8a:	9901      	ldr	r1, [sp, #4]
   10b8c:	9106      	str	r1, [sp, #24]
   10b8e:	4619      	mov	r1, r3
   10b90:	f363 0100 	bfi	r1, r3, #0, #1
   10b94:	f363 0141 	bfi	r1, r3, #1, #1
   10b98:	f363 0182 	bfi	r1, r3, #2, #1
   10b9c:	f363 01c5 	bfi	r1, r3, #3, #3
   10ba0:	f362 1188 	bfi	r1, r2, #6, #3
   10ba4:	2208      	movs	r2, #8
   10ba6:	f362 2152 	bfi	r1, r2, #9, #10
   10baa:	f363 41de 	bfi	r1, r3, #19, #12
   10bae:	f363 71df 	bfi	r1, r3, #31, #1
   10bb2:	aa06      	add	r2, sp, #24
   10bb4:	4810      	ldr	r0, [pc, #64]	; (10bf8 <mbox_nrf_send+0x90>)
   10bb6:	f7f1 fb47 	bl	2248 <z_impl_z_log_msg_static_create>
	const struct mbox_nrf_conf *conf = dev->config;
   10bba:	686b      	ldr	r3, [r5, #4]
	return ((ch < IPC_CONF_NUM) && (conf->tx_mask & BIT(ch)));
   10bbc:	2c0f      	cmp	r4, #15
   10bbe:	d806      	bhi.n	10bce <mbox_nrf_send+0x66>
   10bc0:	685b      	ldr	r3, [r3, #4]
   10bc2:	40e3      	lsrs	r3, r4
   10bc4:	f013 0f01 	tst.w	r3, #1
   10bc8:	d10f      	bne.n	10bea <mbox_nrf_send+0x82>
   10bca:	2300      	movs	r3, #0
   10bcc:	e000      	b.n	10bd0 <mbox_nrf_send+0x68>
   10bce:	2300      	movs	r3, #0
	if (!is_tx_channel_valid(dev, channel)) {
   10bd0:	b16b      	cbz	r3, 10bee <mbox_nrf_send+0x86>
	nrfx_ipc_signal(channel);
   10bd2:	b2e3      	uxtb	r3, r4
    return (nrf_ipc_task_t)(NRFX_OFFSETOF(NRF_IPC_Type, TASKS_SEND[index]));
   10bd4:	009b      	lsls	r3, r3, #2
   10bd6:	b2db      	uxtb	r3, r3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   10bd8:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
   10bdc:	f503 3328 	add.w	r3, r3, #172032	; 0x2a000
   10be0:	2201      	movs	r2, #1
   10be2:	601a      	str	r2, [r3, #0]
	return 0;
   10be4:	2000      	movs	r0, #0
}
   10be6:	b009      	add	sp, #36	; 0x24
   10be8:	bd30      	pop	{r4, r5, pc}
	return ((ch < IPC_CONF_NUM) && (conf->tx_mask & BIT(ch)));
   10bea:	2301      	movs	r3, #1
   10bec:	e7f0      	b.n	10bd0 <mbox_nrf_send+0x68>
		return -EINVAL;
   10bee:	f06f 0015 	mvn.w	r0, #21
   10bf2:	e7f8      	b.n	10be6 <mbox_nrf_send+0x7e>
   10bf4:	0001fccc 	.word	0x0001fccc
   10bf8:	0001d06c 	.word	0x0001d06c

00010bfc <mbox_dispatcher>:
{
   10bfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10c00:	b08e      	sub	sp, #56	; 0x38
   10c02:	4605      	mov	r5, r0
   10c04:	460e      	mov	r6, r1
	const struct device *dev = data->dev;
   10c06:	f8d1 9080 	ldr.w	r9, [r1, #128]	; 0x80
	while (event_mask) {
   10c0a:	e01a      	b.n	10c42 <mbox_dispatcher+0x46>
    return 32U;
   10c0c:	2320      	movs	r3, #32
   10c0e:	e020      	b.n	10c52 <mbox_dispatcher+0x56>
	return ((ch < IPC_CONF_NUM) && (conf->rx_mask & BIT(ch)));
   10c10:	2300      	movs	r3, #0
		if (!is_rx_channel_valid(dev, channel)) {
   10c12:	b36b      	cbz	r3, 10c70 <mbox_dispatcher+0x74>
		if (!(data->enabled_mask & BIT(channel))) {
   10c14:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
   10c18:	40e3      	lsrs	r3, r4
   10c1a:	f013 0f01 	tst.w	r3, #1
   10c1e:	d04c      	beq.n	10cba <mbox_dispatcher+0xbe>
		event_mask &= ~BIT(channel);
   10c20:	2301      	movs	r3, #1
   10c22:	40a3      	lsls	r3, r4
   10c24:	ea25 0503 	bic.w	r5, r5, r3
		if (data->cb[channel] != NULL) {
   10c28:	f856 a024 	ldr.w	sl, [r6, r4, lsl #2]
   10c2c:	f1ba 0f00 	cmp.w	sl, #0
   10c30:	d007      	beq.n	10c42 <mbox_dispatcher+0x46>
			data->cb[channel](dev, channel, data->user_data[channel], NULL);
   10c32:	f104 0210 	add.w	r2, r4, #16
   10c36:	2300      	movs	r3, #0
   10c38:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
   10c3c:	4621      	mov	r1, r4
   10c3e:	4648      	mov	r0, r9
   10c40:	47d0      	blx	sl
	while (event_mask) {
   10c42:	2d00      	cmp	r5, #0
   10c44:	d05e      	beq.n	10d04 <mbox_dispatcher+0x108>
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
   10c46:	fa95 f3a5 	rbit	r3, r5
  if (value == 0U)
   10c4a:	2b00      	cmp	r3, #0
   10c4c:	d0de      	beq.n	10c0c <mbox_dispatcher+0x10>
  return __builtin_clz(value);
   10c4e:	fab3 f383 	clz	r3, r3
		uint32_t channel = __CLZ(__RBIT(event_mask));
   10c52:	461c      	mov	r4, r3
	const struct mbox_nrf_conf *conf = dev->config;
   10c54:	f8d9 2004 	ldr.w	r2, [r9, #4]
	return ((ch < IPC_CONF_NUM) && (conf->rx_mask & BIT(ch)));
   10c58:	2b0f      	cmp	r3, #15
   10c5a:	d8d9      	bhi.n	10c10 <mbox_dispatcher+0x14>
   10c5c:	6812      	ldr	r2, [r2, #0]
   10c5e:	fa22 f303 	lsr.w	r3, r2, r3
   10c62:	f013 0f01 	tst.w	r3, #1
   10c66:	d101      	bne.n	10c6c <mbox_dispatcher+0x70>
   10c68:	2300      	movs	r3, #0
   10c6a:	e7d2      	b.n	10c12 <mbox_dispatcher+0x16>
   10c6c:	2301      	movs	r3, #1
   10c6e:	e7d0      	b.n	10c12 <mbox_dispatcher+0x16>
			LOG_WRN("RX event on illegal channel");
   10c70:	4b26      	ldr	r3, [pc, #152]	; (10d0c <mbox_dispatcher+0x110>)
   10c72:	9307      	str	r3, [sp, #28]
   10c74:	2202      	movs	r2, #2
   10c76:	f88d 2004 	strb.w	r2, [sp, #4]
   10c7a:	2300      	movs	r3, #0
   10c7c:	f88d 3005 	strb.w	r3, [sp, #5]
   10c80:	f88d 3006 	strb.w	r3, [sp, #6]
   10c84:	f88d 3007 	strb.w	r3, [sp, #7]
   10c88:	9901      	ldr	r1, [sp, #4]
   10c8a:	9106      	str	r1, [sp, #24]
   10c8c:	f363 0700 	bfi	r7, r3, #0, #1
   10c90:	f363 0741 	bfi	r7, r3, #1, #1
   10c94:	f363 0782 	bfi	r7, r3, #2, #1
   10c98:	f363 07c5 	bfi	r7, r3, #3, #3
   10c9c:	f362 1788 	bfi	r7, r2, #6, #3
   10ca0:	2208      	movs	r2, #8
   10ca2:	f362 2752 	bfi	r7, r2, #9, #10
   10ca6:	f363 47de 	bfi	r7, r3, #19, #12
   10caa:	f363 77df 	bfi	r7, r3, #31, #1
   10cae:	aa06      	add	r2, sp, #24
   10cb0:	4639      	mov	r1, r7
   10cb2:	4817      	ldr	r0, [pc, #92]	; (10d10 <mbox_dispatcher+0x114>)
   10cb4:	f7f1 fac8 	bl	2248 <z_impl_z_log_msg_static_create>
   10cb8:	e7ac      	b.n	10c14 <mbox_dispatcher+0x18>
			LOG_WRN("RX event on disabled channel");
   10cba:	4b16      	ldr	r3, [pc, #88]	; (10d14 <mbox_dispatcher+0x118>)
   10cbc:	930d      	str	r3, [sp, #52]	; 0x34
   10cbe:	2202      	movs	r2, #2
   10cc0:	f88d 2004 	strb.w	r2, [sp, #4]
   10cc4:	2300      	movs	r3, #0
   10cc6:	f88d 3005 	strb.w	r3, [sp, #5]
   10cca:	f88d 3006 	strb.w	r3, [sp, #6]
   10cce:	f88d 3007 	strb.w	r3, [sp, #7]
   10cd2:	9901      	ldr	r1, [sp, #4]
   10cd4:	910c      	str	r1, [sp, #48]	; 0x30
   10cd6:	f363 0800 	bfi	r8, r3, #0, #1
   10cda:	f363 0841 	bfi	r8, r3, #1, #1
   10cde:	f363 0882 	bfi	r8, r3, #2, #1
   10ce2:	f363 08c5 	bfi	r8, r3, #3, #3
   10ce6:	f362 1888 	bfi	r8, r2, #6, #3
   10cea:	2208      	movs	r2, #8
   10cec:	f362 2852 	bfi	r8, r2, #9, #10
   10cf0:	f363 48de 	bfi	r8, r3, #19, #12
   10cf4:	f363 78df 	bfi	r8, r3, #31, #1
   10cf8:	aa0c      	add	r2, sp, #48	; 0x30
   10cfa:	4641      	mov	r1, r8
   10cfc:	4804      	ldr	r0, [pc, #16]	; (10d10 <mbox_dispatcher+0x114>)
   10cfe:	f7f1 faa3 	bl	2248 <z_impl_z_log_msg_static_create>
   10d02:	e78d      	b.n	10c20 <mbox_dispatcher+0x24>
}
   10d04:	b00e      	add	sp, #56	; 0x38
   10d06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10d0a:	bf00      	nop
   10d0c:	0001fce8 	.word	0x0001fce8
   10d10:	0001d06c 	.word	0x0001d06c
   10d14:	0001fd04 	.word	0x0001fd04

00010d18 <enable_dt_channels>:

static void enable_dt_channels(const struct device *dev)
{
   10d18:	b510      	push	{r4, lr}
   10d1a:	b0ae      	sub	sp, #184	; 0xb8
	const struct mbox_nrf_conf *conf = dev->config;
   10d1c:	6844      	ldr	r4, [r0, #4]
	nrfx_ipc_config_t ch_config = { 0 };
   10d1e:	2284      	movs	r2, #132	; 0x84
   10d20:	2100      	movs	r1, #0
   10d22:	a801      	add	r0, sp, #4
   10d24:	f006 fd33 	bl	1778e <memset>

	if (conf->tx_mask >= BIT(IPC_CONF_NUM)) {
   10d28:	6863      	ldr	r3, [r4, #4]
   10d2a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   10d2e:	d206      	bcs.n	10d3e <enable_dt_channels+0x26>
		LOG_WRN("tx_mask too big (or IPC_CONF_NUM too small)");
	}

	if (conf->rx_mask >= BIT(IPC_CONF_NUM)) {
   10d30:	6823      	ldr	r3, [r4, #0]
   10d32:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   10d36:	d227      	bcs.n	10d88 <enable_dt_channels+0x70>
		LOG_WRN("rx_mask too big (or IPC_CONF_NUM too small)");
	}

	/* Enable the interrupts on .set_enabled() only */
	ch_config.receive_events_enabled = 0;
   10d38:	2300      	movs	r3, #0
   10d3a:	9321      	str	r3, [sp, #132]	; 0x84

	for (size_t ch = 0; ch < IPC_CONF_NUM; ch++) {
   10d3c:	e04a      	b.n	10dd4 <enable_dt_channels+0xbc>
		LOG_WRN("tx_mask too big (or IPC_CONF_NUM too small)");
   10d3e:	4b36      	ldr	r3, [pc, #216]	; (10e18 <enable_dt_channels+0x100>)
   10d40:	9327      	str	r3, [sp, #156]	; 0x9c
   10d42:	2202      	movs	r2, #2
   10d44:	f88d 2000 	strb.w	r2, [sp]
   10d48:	2300      	movs	r3, #0
   10d4a:	f88d 3001 	strb.w	r3, [sp, #1]
   10d4e:	f88d 3002 	strb.w	r3, [sp, #2]
   10d52:	f88d 3003 	strb.w	r3, [sp, #3]
   10d56:	9900      	ldr	r1, [sp, #0]
   10d58:	9126      	str	r1, [sp, #152]	; 0x98
   10d5a:	4619      	mov	r1, r3
   10d5c:	f363 0100 	bfi	r1, r3, #0, #1
   10d60:	f363 0141 	bfi	r1, r3, #1, #1
   10d64:	f363 0182 	bfi	r1, r3, #2, #1
   10d68:	f363 01c5 	bfi	r1, r3, #3, #3
   10d6c:	f362 1188 	bfi	r1, r2, #6, #3
   10d70:	2208      	movs	r2, #8
   10d72:	f362 2152 	bfi	r1, r2, #9, #10
   10d76:	f363 41de 	bfi	r1, r3, #19, #12
   10d7a:	f363 71df 	bfi	r1, r3, #31, #1
   10d7e:	aa26      	add	r2, sp, #152	; 0x98
   10d80:	4826      	ldr	r0, [pc, #152]	; (10e1c <enable_dt_channels+0x104>)
   10d82:	f7f1 fa61 	bl	2248 <z_impl_z_log_msg_static_create>
   10d86:	e7d3      	b.n	10d30 <enable_dt_channels+0x18>
		LOG_WRN("rx_mask too big (or IPC_CONF_NUM too small)");
   10d88:	4b25      	ldr	r3, [pc, #148]	; (10e20 <enable_dt_channels+0x108>)
   10d8a:	932d      	str	r3, [sp, #180]	; 0xb4
   10d8c:	2202      	movs	r2, #2
   10d8e:	f88d 2000 	strb.w	r2, [sp]
   10d92:	2300      	movs	r3, #0
   10d94:	f88d 3001 	strb.w	r3, [sp, #1]
   10d98:	f88d 3002 	strb.w	r3, [sp, #2]
   10d9c:	f88d 3003 	strb.w	r3, [sp, #3]
   10da0:	9900      	ldr	r1, [sp, #0]
   10da2:	912c      	str	r1, [sp, #176]	; 0xb0
   10da4:	4619      	mov	r1, r3
   10da6:	f363 0100 	bfi	r1, r3, #0, #1
   10daa:	f363 0141 	bfi	r1, r3, #1, #1
   10dae:	f363 0182 	bfi	r1, r3, #2, #1
   10db2:	f363 01c5 	bfi	r1, r3, #3, #3
   10db6:	f362 1188 	bfi	r1, r2, #6, #3
   10dba:	2208      	movs	r2, #8
   10dbc:	f362 2152 	bfi	r1, r2, #9, #10
   10dc0:	f363 41de 	bfi	r1, r3, #19, #12
   10dc4:	f363 71df 	bfi	r1, r3, #31, #1
   10dc8:	aa2c      	add	r2, sp, #176	; 0xb0
   10dca:	4814      	ldr	r0, [pc, #80]	; (10e1c <enable_dt_channels+0x104>)
   10dcc:	f7f1 fa3c 	bl	2248 <z_impl_z_log_msg_static_create>
   10dd0:	e7b2      	b.n	10d38 <enable_dt_channels+0x20>
	for (size_t ch = 0; ch < IPC_CONF_NUM; ch++) {
   10dd2:	3301      	adds	r3, #1
   10dd4:	2b0f      	cmp	r3, #15
   10dd6:	d81a      	bhi.n	10e0e <enable_dt_channels+0xf6>
		if (conf->tx_mask & BIT(ch)) {
   10dd8:	6862      	ldr	r2, [r4, #4]
   10dda:	40da      	lsrs	r2, r3
   10ddc:	f012 0f01 	tst.w	r2, #1
   10de0:	d006      	beq.n	10df0 <enable_dt_channels+0xd8>
			ch_config.send_task_config[ch] = BIT(ch);
   10de2:	2201      	movs	r2, #1
   10de4:	409a      	lsls	r2, r3
   10de6:	a92e      	add	r1, sp, #184	; 0xb8
   10de8:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   10dec:	f841 2cb4 	str.w	r2, [r1, #-180]
		}

		if (conf->rx_mask & BIT(ch)) {
   10df0:	6822      	ldr	r2, [r4, #0]
   10df2:	40da      	lsrs	r2, r3
   10df4:	f012 0f01 	tst.w	r2, #1
   10df8:	d0eb      	beq.n	10dd2 <enable_dt_channels+0xba>
			ch_config.receive_event_config[ch] = BIT(ch);
   10dfa:	2101      	movs	r1, #1
   10dfc:	4099      	lsls	r1, r3
   10dfe:	f103 0210 	add.w	r2, r3, #16
   10e02:	a82e      	add	r0, sp, #184	; 0xb8
   10e04:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   10e08:	f842 1cb4 	str.w	r1, [r2, #-180]
   10e0c:	e7e1      	b.n	10dd2 <enable_dt_channels+0xba>
		}
	}

	nrfx_ipc_config_load(&ch_config);
   10e0e:	a801      	add	r0, sp, #4
   10e10:	f000 ff80 	bl	11d14 <nrfx_ipc_config_load>
}
   10e14:	b02e      	add	sp, #184	; 0xb8
   10e16:	bd10      	pop	{r4, pc}
   10e18:	0001fd24 	.word	0x0001fd24
   10e1c:	0001d06c 	.word	0x0001d06c
   10e20:	0001fd50 	.word	0x0001fd50

00010e24 <mbox_nrf_init>:

static int mbox_nrf_init(const struct device *dev)
{
   10e24:	b510      	push	{r4, lr}
   10e26:	4604      	mov	r4, r0
	struct mbox_nrf_data *data = dev->data;
   10e28:	6902      	ldr	r2, [r0, #16]

	data->dev = dev;
   10e2a:	f8c2 0080 	str.w	r0, [r2, #128]	; 0x80

	nrfx_ipc_init(0, mbox_dispatcher, (void *) data);
   10e2e:	4907      	ldr	r1, [pc, #28]	; (10e4c <mbox_nrf_init+0x28>)
   10e30:	2000      	movs	r0, #0
   10e32:	f000 ff57 	bl	11ce4 <nrfx_ipc_init>

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   10e36:	2200      	movs	r2, #0
   10e38:	2101      	movs	r1, #1
   10e3a:	202a      	movs	r0, #42	; 0x2a
   10e3c:	f7f3 f912 	bl	4064 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	enable_dt_channels(dev);
   10e40:	4620      	mov	r0, r4
   10e42:	f7ff ff69 	bl	10d18 <enable_dt_channels>

	return 0;
}
   10e46:	2000      	movs	r0, #0
   10e48:	bd10      	pop	{r4, pc}
   10e4a:	bf00      	nop
   10e4c:	00010bfd 	.word	0x00010bfd

00010e50 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   10e50:	b510      	push	{r4, lr}
   10e52:	b088      	sub	sp, #32
	z_impl_log_panic();
   10e54:	f7f1 f91e 	bl	2094 <z_impl_log_panic>
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
   10e58:	4b14      	ldr	r3, [pc, #80]	; (10eac <k_sys_fatal_error_handler+0x5c>)
   10e5a:	9307      	str	r3, [sp, #28]
   10e5c:	2302      	movs	r3, #2
   10e5e:	f88d 3004 	strb.w	r3, [sp, #4]
   10e62:	2400      	movs	r4, #0
   10e64:	f88d 4005 	strb.w	r4, [sp, #5]
   10e68:	f88d 4006 	strb.w	r4, [sp, #6]
   10e6c:	f88d 4007 	strb.w	r4, [sp, #7]
   10e70:	9b01      	ldr	r3, [sp, #4]
   10e72:	9306      	str	r3, [sp, #24]
   10e74:	4621      	mov	r1, r4
   10e76:	f364 0100 	bfi	r1, r4, #0, #1
   10e7a:	f364 0141 	bfi	r1, r4, #1, #1
   10e7e:	f364 0182 	bfi	r1, r4, #2, #1
   10e82:	f364 01c5 	bfi	r1, r4, #3, #3
   10e86:	2301      	movs	r3, #1
   10e88:	f363 1188 	bfi	r1, r3, #6, #3
   10e8c:	2308      	movs	r3, #8
   10e8e:	f363 2152 	bfi	r1, r3, #9, #10
   10e92:	f364 41de 	bfi	r1, r4, #19, #12
   10e96:	f364 71df 	bfi	r1, r4, #31, #1
   10e9a:	4623      	mov	r3, r4
   10e9c:	aa06      	add	r2, sp, #24
   10e9e:	4804      	ldr	r0, [pc, #16]	; (10eb0 <k_sys_fatal_error_handler+0x60>)
   10ea0:	f7f1 f9d2 	bl	2248 <z_impl_z_log_msg_static_create>
		sys_arch_reboot(0);
   10ea4:	4620      	mov	r0, r4
   10ea6:	f7f4 f8dd 	bl	5064 <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
   10eaa:	bf00      	nop
   10eac:	0001fdac 	.word	0x0001fdac
   10eb0:	0001d02c 	.word	0x0001d02c

00010eb4 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
#if defined(NRF_TRUSTZONE_NONSECURE)
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_NS->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
#else
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_S->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
   10eb4:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10eb8:	f8d3 2558 	ldr.w	r2, [r3, #1368]	; 0x558
   10ebc:	f002 0203 	and.w	r2, r2, #3
   10ec0:	4b02      	ldr	r3, [pc, #8]	; (10ecc <SystemCoreClockUpdate+0x18>)
   10ec2:	40d3      	lsrs	r3, r2
   10ec4:	4a02      	ldr	r2, [pc, #8]	; (10ed0 <SystemCoreClockUpdate+0x1c>)
   10ec6:	6013      	str	r3, [r2, #0]
#endif
}
   10ec8:	4770      	bx	lr
   10eca:	bf00      	nop
   10ecc:	07a12000 	.word	0x07a12000
   10ed0:	20000424 	.word	0x20000424

00010ed4 <SystemInit>:

void SystemInit(void)
{
   10ed4:	b508      	push	{r3, lr}
            SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
        #endif

        /* Workaround for Errata 97 "ERASEPROTECT, APPROTECT, or startup problems" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_97())
   10ed6:	f009 ffa4 	bl	1ae22 <nrf53_errata_97>
   10eda:	b168      	cbz	r0, 10ef8 <SystemInit+0x24>
        {
            if (*((volatile uint32_t *)0x50004A20ul) == 0)
   10edc:	4b4e      	ldr	r3, [pc, #312]	; (11018 <SystemInit+0x144>)
   10ede:	f8d3 3a20 	ldr.w	r3, [r3, #2592]	; 0xa20
   10ee2:	b94b      	cbnz	r3, 10ef8 <SystemInit+0x24>
            {
                *((volatile uint32_t *)0x50004A20ul) = 0xDul;
   10ee4:	4b4c      	ldr	r3, [pc, #304]	; (11018 <SystemInit+0x144>)
   10ee6:	220d      	movs	r2, #13
   10ee8:	f8c3 2a20 	str.w	r2, [r3, #2592]	; 0xa20
                *((volatile uint32_t *)0x5000491Cul) = 0x1ul;
   10eec:	2201      	movs	r2, #1
   10eee:	f8c3 291c 	str.w	r2, [r3, #2332]	; 0x91c
                *((volatile uint32_t *)0x5000491Cul) = 0x0ul;
   10ef2:	2200      	movs	r2, #0
   10ef4:	f8c3 291c 	str.w	r2, [r3, #2332]	; 0x91c
{
   10ef8:	2200      	movs	r2, #0
   10efa:	e00b      	b.n	10f14 <SystemInit+0x40>
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
            #if defined ( __ICCARM__ )
                /* IAR will complain about the order of volatile pointer accesses. */
                #pragma diag_suppress=Pa082
            #endif
            *((volatile uint32_t *)NRF_FICR_S->TRIMCNF[index].ADDR) = NRF_FICR_S->TRIMCNF[index].DATA;
   10efc:	f102 0360 	add.w	r3, r2, #96	; 0x60
   10f00:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
   10f04:	f851 1033 	ldr.w	r1, [r1, r3, lsl #3]
   10f08:	00db      	lsls	r3, r3, #3
   10f0a:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
   10f0e:	685b      	ldr	r3, [r3, #4]
   10f10:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
   10f12:	3201      	adds	r2, #1
   10f14:	2a1f      	cmp	r2, #31
   10f16:	d808      	bhi.n	10f2a <SystemInit+0x56>
   10f18:	f102 0360 	add.w	r3, r2, #96	; 0x60
   10f1c:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
   10f20:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
   10f24:	f1b3 3fff 	cmp.w	r3, #4294967295
   10f28:	d1e8      	bne.n	10efc <SystemInit+0x28>
        }

        /* errata 64 must be before errata 42, as errata 42 is dependant on the changes in errata 64*/
        /* Workaround for Errata 64 "VREGMAIN has invalid configuration when CPU is running at 128 MHz" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_64())
   10f2a:	f009 ff52 	bl	1add2 <nrf53_errata_64>
   10f2e:	b130      	cbz	r0, 10f3e <SystemInit+0x6a>
        {
            *((volatile uint32_t *)0x5000470Cul) = 0x29ul;
   10f30:	4b39      	ldr	r3, [pc, #228]	; (11018 <SystemInit+0x144>)
   10f32:	2229      	movs	r2, #41	; 0x29
   10f34:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
            *((volatile uint32_t *)0x5000473Cul) = 0x3ul;
   10f38:	2203      	movs	r2, #3
   10f3a:	f8c3 273c 	str.w	r2, [r3, #1852]	; 0x73c
        }

        /* Workaround for Errata 42 "Reset value of HFCLKCTRL is invalid" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_42())
   10f3e:	f009 fefc 	bl	1ad3a <nrf53_errata_42>
   10f42:	b140      	cbz	r0, 10f56 <SystemInit+0x82>
        {
            *((volatile uint32_t *)0x50039530ul) = 0xBEEF0044ul;
   10f44:	4b35      	ldr	r3, [pc, #212]	; (1101c <SystemInit+0x148>)
   10f46:	4a36      	ldr	r2, [pc, #216]	; (11020 <SystemInit+0x14c>)
   10f48:	f8c3 2530 	str.w	r2, [r3, #1328]	; 0x530
            NRF_CLOCK_S->HFCLKCTRL = CLOCK_HFCLKCTRL_HCLK_Div2 << CLOCK_HFCLKCTRL_HCLK_Pos;
   10f4c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10f50:	2201      	movs	r2, #1
   10f52:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558
        }

        /* Workaround for Errata 46 "Higher power consumption of LFRC" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_46())
   10f56:	f009 ff04 	bl	1ad62 <nrf53_errata_46>
   10f5a:	b118      	cbz	r0, 10f64 <SystemInit+0x90>
        {
            *((volatile uint32_t *)0x5003254Cul) = 0;
   10f5c:	4b31      	ldr	r3, [pc, #196]	; (11024 <SystemInit+0x150>)
   10f5e:	2200      	movs	r2, #0
   10f60:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
        }

        /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_49())
   10f64:	f009 ff15 	bl	1ad92 <nrf53_errata_49>
   10f68:	b168      	cbz	r0, 10f86 <SystemInit+0xb2>
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
   10f6a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10f6e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   10f72:	f013 0f01 	tst.w	r3, #1
   10f76:	d006      	beq.n	10f86 <SystemInit+0xb2>
            {
                NRF_POWER_S->EVENTS_SLEEPENTER = 0;
   10f78:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10f7c:	2200      	movs	r2, #0
   10f7e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
                NRF_POWER_S->EVENTS_SLEEPEXIT = 0;
   10f82:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
            }
        }

        /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_55())
   10f86:	f009 ff18 	bl	1adba <nrf53_errata_55>
   10f8a:	b160      	cbz	r0, 10fa6 <SystemInit+0xd2>
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
   10f8c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10f90:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   10f94:	f013 0f01 	tst.w	r3, #1
   10f98:	d005      	beq.n	10fa6 <SystemInit+0xd2>
                NRF_RESET_S->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
   10f9a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10f9e:	f06f 0201 	mvn.w	r2, #1
   10fa2:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
            }
        }

        /* Workaround for Errata 69 "VREGMAIN configuration is not retained in System OFF" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_69())
   10fa6:	f009 ff28 	bl	1adfa <nrf53_errata_69>
   10faa:	b118      	cbz	r0, 10fb4 <SystemInit+0xe0>
        {
            *((volatile uint32_t *)0x5000470Cul) =0x65ul;
   10fac:	4b1a      	ldr	r3, [pc, #104]	; (11018 <SystemInit+0x144>)
   10fae:	2265      	movs	r2, #101	; 0x65
   10fb0:	f8c3 270c 	str.w	r2, [r3, #1804]	; 0x70c
        }

        if (nrf53_errata_140())
   10fb4:	f009 ff49 	bl	1ae4a <nrf53_errata_140>
   10fb8:	b120      	cbz	r0, 10fc4 <SystemInit+0xf0>
        {
            if (*(volatile uint32_t *)0x50032420 & 0x80000000)
   10fba:	4b1a      	ldr	r3, [pc, #104]	; (11024 <SystemInit+0x150>)
   10fbc:	f8d3 3420 	ldr.w	r3, [r3, #1056]	; 0x420
   10fc0:	2b00      	cmp	r3, #0
   10fc2:	db11      	blt.n	10fe8 <SystemInit+0x114>

        #endif

        /* Allow Non-Secure code to run FPU instructions.
         * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
        SCB->NSACR |= (3UL << 10);
   10fc4:	4a18      	ldr	r2, [pc, #96]	; (11028 <SystemInit+0x154>)
   10fc6:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
   10fca:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
   10fce:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_S->APPROTECT.DISABLE = NRF_UICR_S->APPROTECT;
   10fd2:	4a16      	ldr	r2, [pc, #88]	; (1102c <SystemInit+0x158>)
   10fd4:	6811      	ldr	r1, [r2, #0]
   10fd6:	4b16      	ldr	r3, [pc, #88]	; (11030 <SystemInit+0x15c>)
   10fd8:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
                /* Do nothing, allow user code to handle SECURE APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load SECURE APPROTECT soft branch from UICR.
               If UICR->SECUREAPPROTECT is disabled, CTRLAP->SECUREAPPROTECT will be disabled. */
            NRF_CTRLAP_S->SECUREAPPROTECT.DISABLE = NRF_UICR_S->SECUREAPPROTECT;
   10fdc:	69d2      	ldr	r2, [r2, #28]
   10fde:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
        __DSB();
        __ISB();
    #endif

    SystemCoreClockUpdate();
   10fe2:	f7ff ff67 	bl	10eb4 <SystemCoreClockUpdate>
}
   10fe6:	bd08      	pop	{r3, pc}
                NRF_CLOCK_S->LFCLKSRC = CLOCK_LFCLKSRC_SRC_LFSYNT;
   10fe8:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10fec:	2203      	movs	r2, #3
   10fee:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
                NRF_CLOCK_S->TASKS_LFCLKSTART = 1;
   10ff2:	2201      	movs	r2, #1
   10ff4:	609a      	str	r2, [r3, #8]
                while (NRF_CLOCK_S->EVENTS_LFCLKSTARTED == 0) {}
   10ff6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   10ffa:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   10ffe:	2b00      	cmp	r3, #0
   11000:	d0f9      	beq.n	10ff6 <SystemInit+0x122>
                NRF_CLOCK_S->EVENTS_LFCLKSTARTED = 0;
   11002:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11006:	2200      	movs	r2, #0
   11008:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
                NRF_CLOCK_S->TASKS_LFCLKSTOP = 1;
   1100c:	2201      	movs	r2, #1
   1100e:	60da      	str	r2, [r3, #12]
                NRF_CLOCK_S->LFCLKSRC = CLOCK_LFCLKSRC_SRC_LFRC;
   11010:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
   11014:	e7d6      	b.n	10fc4 <SystemInit+0xf0>
   11016:	bf00      	nop
   11018:	50004000 	.word	0x50004000
   1101c:	50039000 	.word	0x50039000
   11020:	beef0044 	.word	0xbeef0044
   11024:	50032000 	.word	0x50032000
   11028:	e000ed00 	.word	0xe000ed00
   1102c:	00ff8000 	.word	0x00ff8000
   11030:	50006000 	.word	0x50006000

00011034 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   11034:	b510      	push	{r4, lr}
    int8_t idx;
    uint32_t new_mask, prev_mask;

    do {
        prev_mask = *p_mask;
   11036:	6804      	ldr	r4, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   11038:	fab4 f384 	clz	r3, r4
   1103c:	f1c3 031f 	rsb	r3, r3, #31
   11040:	fa5f fc83 	uxtb.w	ip, r3
        if (idx < 0) {
   11044:	2b00      	cmp	r3, #0
   11046:	db12      	blt.n	1106e <nrfx_flag32_alloc+0x3a>
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   11048:	2201      	movs	r2, #1
   1104a:	fa02 f303 	lsl.w	r3, r2, r3
   1104e:	ea24 0303 	bic.w	r3, r4, r3
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   11052:	e8d0 2fef 	ldaex	r2, [r0]
   11056:	42a2      	cmp	r2, r4
   11058:	d104      	bne.n	11064 <nrfx_flag32_alloc+0x30>
   1105a:	e8c0 3fee 	stlex	lr, r3, [r0]
   1105e:	f1be 0f00 	cmp.w	lr, #0
   11062:	d1f6      	bne.n	11052 <nrfx_flag32_alloc+0x1e>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   11064:	d1e7      	bne.n	11036 <nrfx_flag32_alloc+0x2>

    *p_flag = idx;
   11066:	f881 c000 	strb.w	ip, [r1]

    return NRFX_SUCCESS;
   1106a:	4802      	ldr	r0, [pc, #8]	; (11074 <nrfx_flag32_alloc+0x40>)
}
   1106c:	bd10      	pop	{r4, pc}
            return NRFX_ERROR_NO_MEM;
   1106e:	4802      	ldr	r0, [pc, #8]	; (11078 <nrfx_flag32_alloc+0x44>)
   11070:	e7fc      	b.n	1106c <nrfx_flag32_alloc+0x38>
   11072:	bf00      	nop
   11074:	0bad0000 	.word	0x0bad0000
   11078:	0bad0002 	.word	0x0bad0002

0001107c <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   1107c:	6803      	ldr	r3, [r0, #0]
   1107e:	40cb      	lsrs	r3, r1
   11080:	f013 0f01 	tst.w	r3, #1
   11084:	d111      	bne.n	110aa <nrfx_flag32_free+0x2e>
{
   11086:	b500      	push	{lr}
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
   11088:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   1108a:	2301      	movs	r3, #1
   1108c:	408b      	lsls	r3, r1
   1108e:	4313      	orrs	r3, r2
   11090:	e8d0 cfef 	ldaex	ip, [r0]
   11094:	4594      	cmp	ip, r2
   11096:	d104      	bne.n	110a2 <nrfx_flag32_free+0x26>
   11098:	e8c0 3fee 	stlex	lr, r3, [r0]
   1109c:	f1be 0f00 	cmp.w	lr, #0
   110a0:	d1f6      	bne.n	11090 <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   110a2:	d1f1      	bne.n	11088 <nrfx_flag32_free+0xc>

    return NRFX_SUCCESS;
   110a4:	4802      	ldr	r0, [pc, #8]	; (110b0 <nrfx_flag32_free+0x34>)
}
   110a6:	f85d fb04 	ldr.w	pc, [sp], #4
        return NRFX_ERROR_INVALID_PARAM;
   110aa:	4802      	ldr	r0, [pc, #8]	; (110b4 <nrfx_flag32_free+0x38>)
}
   110ac:	4770      	bx	lr
   110ae:	bf00      	nop
   110b0:	0bad0000 	.word	0x0bad0000
   110b4:	0bad0004 	.word	0x0bad0004

000110b8 <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
   110b8:	b570      	push	{r4, r5, r6, lr}
   110ba:	b082      	sub	sp, #8
   110bc:	4605      	mov	r5, r0
    switch (domain)
   110be:	2803      	cmp	r0, #3
   110c0:	f200 809e 	bhi.w	11200 <clock_stop+0x148>
   110c4:	e8df f000 	tbb	[pc, r0]
   110c8:	31231702 	.word	0x31231702
    p_reg->INTENCLR = mask;
   110cc:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   110d0:	2202      	movs	r2, #2
   110d2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   110d6:	2200      	movs	r2, #0
   110d8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   110dc:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   110e0:	2201      	movs	r2, #1
   110e2:	60da      	str	r2, [r3, #12]
            NRFX_ASSERT(0);
            return;
    }

    bool stopped;
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
   110e4:	2301      	movs	r3, #1
   110e6:	f88d 3007 	strb.w	r3, [sp, #7]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   110ea:	429d      	cmp	r5, r3
   110ec:	d02b      	beq.n	11146 <clock_stop+0x8e>
   110ee:	2600      	movs	r6, #0
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   110f0:	f242 7410 	movw	r4, #10000	; 0x2710
   110f4:	e06e      	b.n	111d4 <clock_stop+0x11c>
    p_reg->INTENCLR = mask;
   110f6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   110fa:	2201      	movs	r2, #1
   110fc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11100:	2100      	movs	r1, #0
   11102:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   11106:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1110a:	605a      	str	r2, [r3, #4]
}
   1110c:	e7ea      	b.n	110e4 <clock_stop+0x2c>
    p_reg->INTENCLR = mask;
   1110e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11112:	f44f 7200 	mov.w	r2, #512	; 0x200
   11116:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1111a:	2200      	movs	r2, #0
   1111c:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   11120:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   11124:	2201      	movs	r2, #1
   11126:	625a      	str	r2, [r3, #36]	; 0x24
}
   11128:	e7dc      	b.n	110e4 <clock_stop+0x2c>
    p_reg->INTENCLR = mask;
   1112a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1112e:	f44f 7280 	mov.w	r2, #256	; 0x100
   11132:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11136:	2200      	movs	r2, #0
   11138:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   1113c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   11140:	2201      	movs	r2, #1
   11142:	61da      	str	r2, [r3, #28]
}
   11144:	e7ce      	b.n	110e4 <clock_stop+0x2c>
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   11146:	f10d 0607 	add.w	r6, sp, #7
   1114a:	e7d1      	b.n	110f0 <clock_stop+0x38>
            if (p_clk_src != NULL)
   1114c:	b136      	cbz	r6, 1115c <clock_stop+0xa4>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1114e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11152:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
   11156:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
   1115a:	7033      	strb	r3, [r6, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1115c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11160:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
   11164:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   11168:	d144      	bne.n	111f4 <clock_stop+0x13c>
    return false;
   1116a:	2300      	movs	r3, #0
   1116c:	e027      	b.n	111be <clock_stop+0x106>
            if (p_clk_src != NULL)
   1116e:	b136      	cbz	r6, 1117e <clock_stop+0xc6>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   11170:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11174:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
   11178:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   1117c:	7033      	strb	r3, [r6, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   1117e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11182:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
   11186:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   1118a:	d135      	bne.n	111f8 <clock_stop+0x140>
    return false;
   1118c:	2300      	movs	r3, #0
   1118e:	e016      	b.n	111be <clock_stop+0x106>
            if (p_clk_src != NULL)
   11190:	b136      	cbz	r6, 111a0 <clock_stop+0xe8>
                    (nrf_clock_hfclk_t)((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
   11192:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11196:	f8d3 345c 	ldr.w	r3, [r3, #1116]	; 0x45c
   1119a:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   1119e:	7033      	strb	r3, [r6, #0]
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
   111a0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   111a4:	f8d3 345c 	ldr.w	r3, [r3, #1116]	; 0x45c
   111a8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   111ac:	d126      	bne.n	111fc <clock_stop+0x144>
    return false;
   111ae:	2300      	movs	r3, #0
   111b0:	e005      	b.n	111be <clock_stop+0x106>
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
   111b2:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   111b6:	f8d3 3454 	ldr.w	r3, [r3, #1108]	; 0x454
   111ba:	f3c3 4300 	ubfx	r3, r3, #16, #1
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   111be:	b1fb      	cbz	r3, 11200 <clock_stop+0x148>
   111c0:	b11e      	cbz	r6, 111ca <clock_stop+0x112>
   111c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
   111c6:	2b01      	cmp	r3, #1
   111c8:	d11a      	bne.n	11200 <clock_stop+0x148>
   111ca:	2001      	movs	r0, #1
   111cc:	f009 fe4c 	bl	1ae68 <nrfx_busy_wait>
   111d0:	3c01      	subs	r4, #1
   111d2:	d015      	beq.n	11200 <clock_stop+0x148>
    switch (domain)
   111d4:	2d03      	cmp	r5, #3
   111d6:	d80b      	bhi.n	111f0 <clock_stop+0x138>
   111d8:	a301      	add	r3, pc, #4	; (adr r3, 111e0 <clock_stop+0x128>)
   111da:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   111de:	bf00      	nop
   111e0:	0001114d 	.word	0x0001114d
   111e4:	0001116f 	.word	0x0001116f
   111e8:	00011191 	.word	0x00011191
   111ec:	000111b3 	.word	0x000111b3
   111f0:	2300      	movs	r3, #0
   111f2:	e7e4      	b.n	111be <clock_stop+0x106>
                return true;
   111f4:	2301      	movs	r3, #1
   111f6:	e7e2      	b.n	111be <clock_stop+0x106>
                return true;
   111f8:	2301      	movs	r3, #1
   111fa:	e7e0      	b.n	111be <clock_stop+0x106>
                return true;
   111fc:	2301      	movs	r3, #1
   111fe:	e7de      	b.n	111be <clock_stop+0x106>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   11200:	b002      	add	sp, #8
   11202:	bd70      	pop	{r4, r5, r6, pc}

00011204 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   11204:	4b05      	ldr	r3, [pc, #20]	; (1121c <nrfx_clock_init+0x18>)
   11206:	791b      	ldrb	r3, [r3, #4]
   11208:	b92b      	cbnz	r3, 11216 <nrfx_clock_init+0x12>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
   1120a:	4b04      	ldr	r3, [pc, #16]	; (1121c <nrfx_clock_init+0x18>)
   1120c:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   1120e:	2201      	movs	r2, #1
   11210:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   11212:	4803      	ldr	r0, [pc, #12]	; (11220 <nrfx_clock_init+0x1c>)
   11214:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   11216:	4803      	ldr	r0, [pc, #12]	; (11224 <nrfx_clock_init+0x20>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   11218:	4770      	bx	lr
   1121a:	bf00      	nop
   1121c:	20002650 	.word	0x20002650
   11220:	0bad0000 	.word	0x0bad0000
   11224:	0bad000c 	.word	0x0bad000c

00011228 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   11228:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1122a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1122e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   11232:	b163      	cbz	r3, 1124e <nrfx_power_clock_irq_handler+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11234:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11238:	2000      	movs	r0, #0
   1123a:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   1123e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
   11242:	2201      	movs	r2, #1
   11244:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   11248:	4b28      	ldr	r3, [pc, #160]	; (112ec <nrfx_power_clock_irq_handler+0xc4>)
   1124a:	681b      	ldr	r3, [r3, #0]
   1124c:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1124e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11252:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   11256:	b1bb      	cbz	r3, 11288 <nrfx_power_clock_irq_handler+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11258:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1125c:	2200      	movs	r2, #0
   1125e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   11262:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   11266:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
   1126a:	f002 0203 	and.w	r2, r2, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1126e:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   11272:	2a01      	cmp	r2, #1
   11274:	d031      	beq.n	112da <nrfx_power_clock_irq_handler+0xb2>
    p_reg->INTENCLR = mask;
   11276:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1127a:	2202      	movs	r2, #2
   1127c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        else
#endif
        {
            // After the LF clock external source start invoke user callback.
            nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_LF_STARTED_MASK);
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   11280:	4b1a      	ldr	r3, [pc, #104]	; (112ec <nrfx_power_clock_irq_handler+0xc4>)
   11282:	681b      	ldr	r3, [r3, #0]
   11284:	2001      	movs	r0, #1
   11286:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   11288:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1128c:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
   11290:	b173      	cbz	r3, 112b0 <nrfx_power_clock_irq_handler+0x88>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11292:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   11296:	2200      	movs	r2, #0
   11298:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   1129c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENCLR = mask;
   112a0:	f44f 7280 	mov.w	r2, #256	; 0x100
   112a4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
   112a8:	4b10      	ldr	r3, [pc, #64]	; (112ec <nrfx_power_clock_irq_handler+0xc4>)
   112aa:	681b      	ldr	r3, [r3, #0]
   112ac:	2004      	movs	r0, #4
   112ae:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   112b0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   112b4:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
   112b8:	b173      	cbz	r3, 112d8 <nrfx_power_clock_irq_handler+0xb0>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   112ba:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   112be:	2200      	movs	r2, #0
   112c0:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   112c4:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENCLR = mask;
   112c8:	f44f 7200 	mov.w	r2, #512	; 0x200
   112cc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLK192MSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   112d0:	4b06      	ldr	r3, [pc, #24]	; (112ec <nrfx_power_clock_irq_handler+0xc4>)
   112d2:	681b      	ldr	r3, [r3, #0]
   112d4:	2005      	movs	r0, #5
   112d6:	4798      	blx	r3
    }
#endif
}
   112d8:	bd08      	pop	{r3, pc}
    p_reg->LFCLKSRC = (uint32_t)(source);
   112da:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   112de:	2202      	movs	r2, #2
   112e0:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   112e4:	2201      	movs	r2, #1
   112e6:	609a      	str	r2, [r3, #8]
}
   112e8:	e7ce      	b.n	11288 <nrfx_power_clock_irq_handler+0x60>
   112ea:	bf00      	nop
   112ec:	20002650 	.word	0x20002650

000112f0 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   112f0:	b508      	push	{r3, lr}
   112f2:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   112f4:	4801      	ldr	r0, [pc, #4]	; (112fc <nrfx_dppi_channel_alloc+0xc>)
   112f6:	f7ff fe9d 	bl	11034 <nrfx_flag32_alloc>
}
   112fa:	bd08      	pop	{r3, pc}
   112fc:	20000428 	.word	0x20000428

00011300 <nrfx_dppi_channel_free>:

nrfx_err_t nrfx_dppi_channel_free(uint8_t channel)
{
   11300:	b508      	push	{r3, lr}
   11302:	4601      	mov	r1, r0
    nrf_dppi_channels_disable(NRF_DPPIC, NRFX_BIT(channel));
   11304:	2301      	movs	r3, #1
   11306:	4083      	lsls	r3, r0
    p_reg->CHENCLR = mask;
   11308:	4a03      	ldr	r2, [pc, #12]	; (11318 <nrfx_dppi_channel_free+0x18>)
   1130a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    return nrfx_flag32_free(&m_allocated_channels, channel);
   1130e:	4803      	ldr	r0, [pc, #12]	; (1131c <nrfx_dppi_channel_free+0x1c>)
   11310:	f7ff feb4 	bl	1107c <nrfx_flag32_free>
}
   11314:	bd08      	pop	{r3, pc}
   11316:	bf00      	nop
   11318:	50017000 	.word	0x50017000
   1131c:	20000428 	.word	0x20000428

00011320 <pin_in_use>:
 *
 * @return True if pin is in use.
 */
static bool pin_in_use(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   11320:	3008      	adds	r0, #8
   11322:	4b03      	ldr	r3, [pc, #12]	; (11330 <pin_in_use+0x10>)
   11324:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   11328:	f000 0001 	and.w	r0, r0, #1
   1132c:	4770      	bx	lr
   1132e:	bf00      	nop
   11330:	2000042c 	.word	0x2000042c

00011334 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   11334:	3008      	adds	r0, #8
   11336:	4b03      	ldr	r3, [pc, #12]	; (11344 <pin_in_use_by_te+0x10>)
   11338:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   1133c:	f3c0 1040 	ubfx	r0, r0, #5, #1
   11340:	4770      	bx	lr
   11342:	bf00      	nop
   11344:	2000042c 	.word	0x2000042c

00011348 <pin_has_trigger>:
 *
 * @return True if pin has trigger.
 */
static bool pin_has_trigger(uint32_t pin)
{
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
   11348:	3008      	adds	r0, #8
   1134a:	4b04      	ldr	r3, [pc, #16]	; (1135c <pin_has_trigger+0x14>)
   1134c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   11350:	f010 001c 	ands.w	r0, r0, #28
   11354:	bf18      	it	ne
   11356:	2001      	movne	r0, #1
   11358:	4770      	bx	lr
   1135a:	bf00      	nop
   1135c:	2000042c 	.word	0x2000042c

00011360 <pin_is_output>:
 *
 * @return True if pin is output.
 */
static bool pin_is_output(uint32_t pin)
{
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   11360:	3008      	adds	r0, #8
   11362:	4b03      	ldr	r3, [pc, #12]	; (11370 <pin_is_output+0x10>)
   11364:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   11368:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1136c:	4770      	bx	lr
   1136e:	bf00      	nop
   11370:	2000042c 	.word	0x2000042c

00011374 <pin_te_get>:
}

/* Returns gpiote TE channel associated with the pin */
static uint8_t pin_te_get(nrfx_gpiote_pin_t pin)
{
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   11374:	3008      	adds	r0, #8
   11376:	4b02      	ldr	r3, [pc, #8]	; (11380 <pin_te_get+0xc>)
   11378:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   1137c:	0b40      	lsrs	r0, r0, #13
   1137e:	4770      	bx	lr
   11380:	2000042c 	.word	0x2000042c

00011384 <handler_in_use>:
}

static bool handler_in_use(int32_t handler_id)
{

    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   11384:	2200      	movs	r2, #0
   11386:	e004      	b.n	11392 <handler_in_use+0xe>
    {
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   11388:	f04f 33ff 	mov.w	r3, #4294967295
   1138c:	4283      	cmp	r3, r0
   1138e:	d00f      	beq.n	113b0 <handler_in_use+0x2c>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   11390:	3201      	adds	r2, #1
   11392:	2a2f      	cmp	r2, #47	; 0x2f
   11394:	d80a      	bhi.n	113ac <handler_in_use+0x28>
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   11396:	f102 0308 	add.w	r3, r2, #8
   1139a:	4906      	ldr	r1, [pc, #24]	; (113b4 <handler_in_use+0x30>)
   1139c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   113a0:	f413 7f80 	tst.w	r3, #256	; 0x100
   113a4:	d0f0      	beq.n	11388 <handler_in_use+0x4>
   113a6:	f3c3 2343 	ubfx	r3, r3, #9, #4
   113aa:	e7ef      	b.n	1138c <handler_in_use+0x8>
        {
            return true;
        }
    }

    return false;
   113ac:	2000      	movs	r0, #0
   113ae:	4770      	bx	lr
            return true;
   113b0:	2001      	movs	r0, #1
}
   113b2:	4770      	bx	lr
   113b4:	2000042c 	.word	0x2000042c

000113b8 <find_handler>:
    return NRFX_SUCCESS;
}

static int32_t find_handler(nrfx_gpiote_interrupt_handler_t handler, void * p_context)
{
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
   113b8:	2300      	movs	r3, #0
   113ba:	b113      	cbz	r3, 113c2 <find_handler+0xa>
        {
            return i;
        }
    }

    return -1;
   113bc:	f04f 30ff 	mov.w	r0, #4294967295
}
   113c0:	4770      	bx	lr
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   113c2:	4a07      	ldr	r2, [pc, #28]	; (113e0 <find_handler+0x28>)
   113c4:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
   113c8:	4282      	cmp	r2, r0
   113ca:	d001      	beq.n	113d0 <find_handler+0x18>
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
   113cc:	3301      	adds	r3, #1
   113ce:	e7f4      	b.n	113ba <find_handler+0x2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   113d0:	4a03      	ldr	r2, [pc, #12]	; (113e0 <find_handler+0x28>)
   113d2:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   113d6:	6852      	ldr	r2, [r2, #4]
   113d8:	428a      	cmp	r2, r1
   113da:	d1f7      	bne.n	113cc <find_handler+0x14>
            return i;
   113dc:	4618      	mov	r0, r3
   113de:	4770      	bx	lr
   113e0:	2000042c 	.word	0x2000042c

000113e4 <channel_handler_get>:
}

/* Return handler associated with given pin or null. */
static nrfx_gpiote_handler_config_t const * channel_handler_get(nrfx_gpiote_pin_t pin)
{
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   113e4:	3008      	adds	r0, #8
   113e6:	4b06      	ldr	r3, [pc, #24]	; (11400 <channel_handler_get+0x1c>)
   113e8:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   113ec:	f410 7f80 	tst.w	r0, #256	; 0x100
   113f0:	d004      	beq.n	113fc <channel_handler_get+0x18>
   113f2:	f3c0 2043 	ubfx	r0, r0, #9, #4
    if (handler_id == PIN_FLAG_NO_HANDLER)
    {
        return NULL;
    }

    return &m_cb.handlers[handler_id];
   113f6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   113fa:	4770      	bx	lr
        return NULL;
   113fc:	2000      	movs	r0, #0
}
   113fe:	4770      	bx	lr
   11400:	2000042c 	.word	0x2000042c

00011404 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   11404:	b570      	push	{r4, r5, r6, lr}
   11406:	4604      	mov	r4, r0
   11408:	460d      	mov	r5, r1
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);
   1140a:	f7ff ffeb 	bl	113e4 <channel_handler_get>

    if (handler)
   1140e:	b120      	cbz	r0, 1141a <call_handler+0x16>
    {
        handler->handler(pin, trigger, handler->p_context);
   11410:	6806      	ldr	r6, [r0, #0]
   11412:	6842      	ldr	r2, [r0, #4]
   11414:	4629      	mov	r1, r5
   11416:	4620      	mov	r0, r4
   11418:	47b0      	blx	r6
    }
    if (m_cb.global_handler.handler)
   1141a:	4b04      	ldr	r3, [pc, #16]	; (1142c <call_handler+0x28>)
   1141c:	689b      	ldr	r3, [r3, #8]
   1141e:	b123      	cbz	r3, 1142a <call_handler+0x26>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   11420:	4a02      	ldr	r2, [pc, #8]	; (1142c <call_handler+0x28>)
   11422:	68d2      	ldr	r2, [r2, #12]
   11424:	4629      	mov	r1, r5
   11426:	4620      	mov	r0, r4
   11428:	4798      	blx	r3
    }
}
   1142a:	bd70      	pop	{r4, r5, r6, pc}
   1142c:	2000042c 	.word	0x2000042c

00011430 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   11430:	f100 0208 	add.w	r2, r0, #8
   11434:	4b0e      	ldr	r3, [pc, #56]	; (11470 <release_handler+0x40>)
   11436:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   1143a:	f413 7f80 	tst.w	r3, #256	; 0x100
   1143e:	d016      	beq.n	1146e <release_handler+0x3e>
{
   11440:	b510      	push	{r4, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   11442:	f3c3 2443 	ubfx	r4, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   11446:	4610      	mov	r0, r2
   11448:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   1144c:	4a08      	ldr	r2, [pc, #32]	; (11470 <release_handler+0x40>)
   1144e:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    if (!handler_in_use(handler_id))
   11452:	4620      	mov	r0, r4
   11454:	f7ff ff96 	bl	11384 <handler_in_use>
   11458:	b100      	cbz	r0, 1145c <release_handler+0x2c>
}
   1145a:	bd10      	pop	{r4, pc}
        m_cb.handlers[handler_id].handler = NULL;
   1145c:	4804      	ldr	r0, [pc, #16]	; (11470 <release_handler+0x40>)
   1145e:	2300      	movs	r3, #0
   11460:	f840 3034 	str.w	r3, [r0, r4, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   11464:	4621      	mov	r1, r4
   11466:	3074      	adds	r0, #116	; 0x74
   11468:	f7ff fe08 	bl	1107c <nrfx_flag32_free>
        NRFX_ASSERT(err == NRFX_SUCCESS);
   1146c:	e7f5      	b.n	1145a <release_handler+0x2a>
   1146e:	4770      	bx	lr
   11470:	2000042c 	.word	0x2000042c

00011474 <pin_handler_trigger_uninit>:
{
   11474:	b510      	push	{r4, lr}
   11476:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin))
   11478:	f7ff ff5c 	bl	11334 <pin_in_use_by_te>
   1147c:	b150      	cbz	r0, 11494 <pin_handler_trigger_uninit+0x20>
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   1147e:	4620      	mov	r0, r4
   11480:	f7ff ff78 	bl	11374 <pin_te_get>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   11484:	4b08      	ldr	r3, [pc, #32]	; (114a8 <pin_handler_trigger_uninit+0x34>)
   11486:	f500 70a2 	add.w	r0, r0, #324	; 0x144
   1148a:	2200      	movs	r2, #0
   1148c:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   11490:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
    release_handler(pin);
   11494:	4620      	mov	r0, r4
   11496:	f7ff ffcb 	bl	11430 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   1149a:	3408      	adds	r4, #8
   1149c:	4b03      	ldr	r3, [pc, #12]	; (114ac <pin_handler_trigger_uninit+0x38>)
   1149e:	2200      	movs	r2, #0
   114a0:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
}
   114a4:	bd10      	pop	{r4, pc}
   114a6:	bf00      	nop
   114a8:	5000d000 	.word	0x5000d000
   114ac:	2000042c 	.word	0x2000042c

000114b0 <pin_handler_set>:
{
   114b0:	b570      	push	{r4, r5, r6, lr}
   114b2:	b082      	sub	sp, #8
   114b4:	4606      	mov	r6, r0
   114b6:	460c      	mov	r4, r1
   114b8:	4615      	mov	r5, r2
    release_handler(pin);
   114ba:	f7ff ffb9 	bl	11430 <release_handler>
    if (!handler)
   114be:	b324      	cbz	r4, 1150a <pin_handler_set+0x5a>
    handler_id = find_handler(handler, p_context);
   114c0:	4629      	mov	r1, r5
   114c2:	4620      	mov	r0, r4
   114c4:	f7ff ff78 	bl	113b8 <find_handler>
    if (handler_id < 0)
   114c8:	1e03      	subs	r3, r0, #0
   114ca:	db13      	blt.n	114f4 <pin_handler_set+0x44>
    m_cb.handlers[handler_id].handler = handler;
   114cc:	4a10      	ldr	r2, [pc, #64]	; (11510 <pin_handler_set+0x60>)
   114ce:	f842 4033 	str.w	r4, [r2, r3, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
   114d2:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
   114d6:	604d      	str	r5, [r1, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   114d8:	025b      	lsls	r3, r3, #9
   114da:	b29b      	uxth	r3, r3
   114dc:	f106 0008 	add.w	r0, r6, #8
   114e0:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
   114e4:	430b      	orrs	r3, r1
   114e6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   114ea:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    return NRFX_SUCCESS;
   114ee:	4809      	ldr	r0, [pc, #36]	; (11514 <pin_handler_set+0x64>)
}
   114f0:	b002      	add	sp, #8
   114f2:	bd70      	pop	{r4, r5, r6, pc}
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   114f4:	f10d 0107 	add.w	r1, sp, #7
   114f8:	4807      	ldr	r0, [pc, #28]	; (11518 <pin_handler_set+0x68>)
   114fa:	f7ff fd9b 	bl	11034 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   114fe:	4b05      	ldr	r3, [pc, #20]	; (11514 <pin_handler_set+0x64>)
   11500:	4298      	cmp	r0, r3
   11502:	d1f5      	bne.n	114f0 <pin_handler_set+0x40>
        handler_id = (int32_t)id;
   11504:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11508:	e7e0      	b.n	114cc <pin_handler_set+0x1c>
        return NRFX_SUCCESS;
   1150a:	4802      	ldr	r0, [pc, #8]	; (11514 <pin_handler_set+0x64>)
   1150c:	e7f0      	b.n	114f0 <pin_handler_set+0x40>
   1150e:	bf00      	nop
   11510:	2000042c 	.word	0x2000042c
   11514:	0bad0000 	.word	0x0bad0000
   11518:	200004a0 	.word	0x200004a0

0001151c <gpiote_evt_handle>:
    } while (input_read_and_check(input, pins_to_check));
}
#endif // defined(NRF_GPIO_LATCH_PRESENT)

static void gpiote_evt_handle(uint32_t mask)
{
   1151c:	b538      	push	{r3, r4, r5, lr}
   1151e:	4604      	mov	r4, r0
    while (mask)
   11520:	e018      	b.n	11554 <gpiote_evt_handle+0x38>
    {
        uint32_t ch = NRF_CTZ(mask);
   11522:	fa94 f3a4 	rbit	r3, r4
   11526:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   1152a:	2201      	movs	r2, #1
   1152c:	409a      	lsls	r2, r3
   1152e:	ea24 0402 	bic.w	r4, r4, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   11532:	4a0a      	ldr	r2, [pc, #40]	; (1155c <gpiote_evt_handle+0x40>)
   11534:	f503 73a2 	add.w	r3, r3, #324	; 0x144
   11538:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
   1153c:	f3c5 2505 	ubfx	r5, r5, #8, #6
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   11540:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
        nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, ch);
        nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, ch);

        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   11544:	f3c0 4001 	ubfx	r0, r0, #16, #2
   11548:	f009 fd4d 	bl	1afe6 <gpiote_polarity_to_trigger>
   1154c:	4601      	mov	r1, r0
   1154e:	4628      	mov	r0, r5
   11550:	f7ff ff58 	bl	11404 <call_handler>
    while (mask)
   11554:	2c00      	cmp	r4, #0
   11556:	d1e4      	bne.n	11522 <gpiote_evt_handle+0x6>
    }
}
   11558:	bd38      	pop	{r3, r4, r5, pc}
   1155a:	bf00      	nop
   1155c:	5000d000 	.word	0x5000d000

00011560 <latch_pending_read_and_check>:
{
   11560:	b082      	sub	sp, #8
   11562:	4684      	mov	ip, r0
    NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
   11564:	4b10      	ldr	r3, [pc, #64]	; (115a8 <latch_pending_read_and_check+0x48>)
   11566:	e893 0003 	ldmia.w	r3, {r0, r1}
   1156a:	ab02      	add	r3, sp, #8
   1156c:	e903 0003 	stmdb	r3, {r0, r1}
    for (i = start_port; i < (start_port + length); i++)
   11570:	4660      	mov	r0, ip
   11572:	2300      	movs	r3, #0
   11574:	e009      	b.n	1158a <latch_pending_read_and_check+0x2a>
        *p_masks = gpio_regs[i]->LATCH;
   11576:	aa02      	add	r2, sp, #8
   11578:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   1157c:	f852 2c08 	ldr.w	r2, [r2, #-8]
   11580:	6a11      	ldr	r1, [r2, #32]
   11582:	f840 1b04 	str.w	r1, [r0], #4
        gpio_regs[i]->LATCH = *p_masks;
   11586:	6211      	str	r1, [r2, #32]
    for (i = start_port; i < (start_port + length); i++)
   11588:	3301      	adds	r3, #1
   1158a:	2b01      	cmp	r3, #1
   1158c:	d9f3      	bls.n	11576 <latch_pending_read_and_check+0x16>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
   1158e:	2300      	movs	r3, #0
   11590:	2b01      	cmp	r3, #1
   11592:	d804      	bhi.n	1159e <latch_pending_read_and_check+0x3e>
        if (latch[port_idx])
   11594:	f85c 2023 	ldr.w	r2, [ip, r3, lsl #2]
   11598:	b922      	cbnz	r2, 115a4 <latch_pending_read_and_check+0x44>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
   1159a:	3301      	adds	r3, #1
   1159c:	e7f8      	b.n	11590 <latch_pending_read_and_check+0x30>
    return false;
   1159e:	2000      	movs	r0, #0
}
   115a0:	b002      	add	sp, #8
   115a2:	4770      	bx	lr
            return true;
   115a4:	2001      	movs	r0, #1
   115a6:	e7fb      	b.n	115a0 <latch_pending_read_and_check+0x40>
   115a8:	0001d1d8 	.word	0x0001d1d8

000115ac <next_sense_cond_call_handler>:
{
   115ac:	b570      	push	{r4, r5, r6, lr}
   115ae:	4604      	mov	r4, r0
   115b0:	460d      	mov	r5, r1
   115b2:	4616      	mov	r6, r2
    if (is_level(trigger))
   115b4:	4608      	mov	r0, r1
   115b6:	f009 fd18 	bl	1afea <is_level>
   115ba:	b9c0      	cbnz	r0, 115ee <next_sense_cond_call_handler+0x42>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   115bc:	2e02      	cmp	r6, #2
   115be:	d04a      	beq.n	11656 <next_sense_cond_call_handler+0xaa>
   115c0:	2002      	movs	r0, #2
    *p_pin = pin_number & 0x1F;
   115c2:	f004 021f 	and.w	r2, r4, #31
    return pin_number >> 5;
   115c6:	0961      	lsrs	r1, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   115c8:	2901      	cmp	r1, #1
   115ca:	d046      	beq.n	1165a <next_sense_cond_call_handler+0xae>
        case 0: return NRF_P0;
   115cc:	4929      	ldr	r1, [pc, #164]	; (11674 <next_sense_cond_call_handler+0xc8>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   115ce:	3280      	adds	r2, #128	; 0x80
   115d0:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    cnf &= ~to_update;
   115d4:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   115d8:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   115dc:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   115e0:	2d03      	cmp	r5, #3
   115e2:	d03e      	beq.n	11662 <next_sense_cond_call_handler+0xb6>
   115e4:	2e02      	cmp	r6, #2
   115e6:	d03a      	beq.n	1165e <next_sense_cond_call_handler+0xb2>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   115e8:	2e03      	cmp	r6, #3
   115ea:	d03f      	beq.n	1166c <next_sense_cond_call_handler+0xc0>
}
   115ec:	bd70      	pop	{r4, r5, r6, pc}
        call_handler(pin, trigger);
   115ee:	4629      	mov	r1, r5
   115f0:	4620      	mov	r0, r4
   115f2:	f7ff ff07 	bl	11404 <call_handler>
    *p_pin = pin_number & 0x1F;
   115f6:	f004 031f 	and.w	r3, r4, #31
    return pin_number >> 5;
   115fa:	0962      	lsrs	r2, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   115fc:	2a01      	cmp	r2, #1
   115fe:	d024      	beq.n	1164a <next_sense_cond_call_handler+0x9e>
        case 0: return NRF_P0;
   11600:	4a1c      	ldr	r2, [pc, #112]	; (11674 <next_sense_cond_call_handler+0xc8>)
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   11602:	3380      	adds	r3, #128	; 0x80
   11604:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11608:	f3c3 4301 	ubfx	r3, r3, #16, #2
        if (nrf_gpio_pin_sense_get(pin) == sense)
   1160c:	429e      	cmp	r6, r3
   1160e:	d1ed      	bne.n	115ec <next_sense_cond_call_handler+0x40>
    *p_pin = pin_number & 0x1F;
   11610:	f004 031f 	and.w	r3, r4, #31
    return pin_number >> 5;
   11614:	0962      	lsrs	r2, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11616:	2a01      	cmp	r2, #1
   11618:	d019      	beq.n	1164e <next_sense_cond_call_handler+0xa2>
        case 0: return NRF_P0;
   1161a:	4916      	ldr	r1, [pc, #88]	; (11674 <next_sense_cond_call_handler+0xc8>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   1161c:	3380      	adds	r3, #128	; 0x80
   1161e:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
   11622:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf;
   11626:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    *p_pin = pin_number & 0x1F;
   1162a:	f004 031f 	and.w	r3, r4, #31
    return pin_number >> 5;
   1162e:	0964      	lsrs	r4, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11630:	2c01      	cmp	r4, #1
   11632:	d00e      	beq.n	11652 <next_sense_cond_call_handler+0xa6>
        case 0: return NRF_P0;
   11634:	490f      	ldr	r1, [pc, #60]	; (11674 <next_sense_cond_call_handler+0xc8>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   11636:	3380      	adds	r3, #128	; 0x80
   11638:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
   1163c:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   11640:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   11644:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
   11648:	e7d0      	b.n	115ec <next_sense_cond_call_handler+0x40>
        case 1: return NRF_P1;
   1164a:	4a0b      	ldr	r2, [pc, #44]	; (11678 <next_sense_cond_call_handler+0xcc>)
   1164c:	e7d9      	b.n	11602 <next_sense_cond_call_handler+0x56>
   1164e:	490a      	ldr	r1, [pc, #40]	; (11678 <next_sense_cond_call_handler+0xcc>)
   11650:	e7e4      	b.n	1161c <next_sense_cond_call_handler+0x70>
   11652:	4909      	ldr	r1, [pc, #36]	; (11678 <next_sense_cond_call_handler+0xcc>)
   11654:	e7ef      	b.n	11636 <next_sense_cond_call_handler+0x8a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   11656:	2003      	movs	r0, #3
   11658:	e7b3      	b.n	115c2 <next_sense_cond_call_handler+0x16>
   1165a:	4907      	ldr	r1, [pc, #28]	; (11678 <next_sense_cond_call_handler+0xcc>)
   1165c:	e7b7      	b.n	115ce <next_sense_cond_call_handler+0x22>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   1165e:	2d01      	cmp	r5, #1
   11660:	d1c2      	bne.n	115e8 <next_sense_cond_call_handler+0x3c>
            call_handler(pin, trigger);
   11662:	4629      	mov	r1, r5
   11664:	4620      	mov	r0, r4
   11666:	f7ff fecd 	bl	11404 <call_handler>
}
   1166a:	e7bf      	b.n	115ec <next_sense_cond_call_handler+0x40>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   1166c:	2d02      	cmp	r5, #2
   1166e:	d1bd      	bne.n	115ec <next_sense_cond_call_handler+0x40>
   11670:	e7f7      	b.n	11662 <next_sense_cond_call_handler+0xb6>
   11672:	bf00      	nop
   11674:	50842500 	.word	0x50842500
   11678:	50842800 	.word	0x50842800

0001167c <port_event_handle>:
{
   1167c:	b570      	push	{r4, r5, r6, lr}
   1167e:	b084      	sub	sp, #16
    NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
   11680:	4a2d      	ldr	r2, [pc, #180]	; (11738 <port_event_handle+0xbc>)
   11682:	466b      	mov	r3, sp
   11684:	e892 0003 	ldmia.w	r2, {r0, r1}
   11688:	e883 0003 	stmia.w	r3, {r0, r1}
    for (i = start_port; i < (start_port + length); i++)
   1168c:	2300      	movs	r3, #0
   1168e:	a802      	add	r0, sp, #8
   11690:	e009      	b.n	116a6 <port_event_handle+0x2a>
        *p_masks = gpio_regs[i]->LATCH;
   11692:	aa04      	add	r2, sp, #16
   11694:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   11698:	f852 2c10 	ldr.w	r2, [r2, #-16]
   1169c:	6a11      	ldr	r1, [r2, #32]
   1169e:	f840 1b04 	str.w	r1, [r0], #4
        gpio_regs[i]->LATCH = *p_masks;
   116a2:	6211      	str	r1, [r2, #32]
    for (i = start_port; i < (start_port + length); i++)
   116a4:	3301      	adds	r3, #1
   116a6:	2b01      	cmp	r3, #1
   116a8:	d9f3      	bls.n	11692 <port_event_handle+0x16>
   116aa:	e040      	b.n	1172e <port_event_handle+0xb2>
        case 1: return NRF_P1;
   116ac:	4e23      	ldr	r6, [pc, #140]	; (1173c <port_event_handle+0xc0>)
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   116ae:	f105 0380 	add.w	r3, r5, #128	; 0x80
   116b2:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
                next_sense_cond_call_handler(pin, trigger, sense);
   116b6:	f3c2 4201 	ubfx	r2, r2, #16, #2
   116ba:	f7ff ff77 	bl	115ac <next_sense_cond_call_handler>
    reg->LATCH = (1 << pin_number);
   116be:	2301      	movs	r3, #1
   116c0:	40ab      	lsls	r3, r5
   116c2:	6233      	str	r3, [r6, #32]
            while (latch[i])
   116c4:	ab04      	add	r3, sp, #16
   116c6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   116ca:	f853 0c08 	ldr.w	r0, [r3, #-8]
   116ce:	b308      	cbz	r0, 11714 <port_event_handle+0x98>
                uint32_t pin = NRF_CTZ(latch[i]);
   116d0:	fa90 f0a0 	rbit	r0, r0
   116d4:	fab0 f080 	clz	r0, r0
                pin += 32 * i;
   116d8:	eb00 1044 	add.w	r0, r0, r4, lsl #5
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   116dc:	f100 0208 	add.w	r2, r0, #8
   116e0:	4b17      	ldr	r3, [pc, #92]	; (11740 <port_event_handle+0xc4>)
   116e2:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
   116e6:	f3c1 0182 	ubfx	r1, r1, #2, #3
 * @param[in,out] p_mask Pointer to mask with bit fields.
 */
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   116ea:	08c5      	lsrs	r5, r0, #3
    bit = BITMASK_RELBIT_GET(bit);
   116ec:	f000 0207 	and.w	r2, r0, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   116f0:	f10d 0c08 	add.w	ip, sp, #8
   116f4:	2301      	movs	r3, #1
   116f6:	fa03 f202 	lsl.w	r2, r3, r2
   116fa:	f81c 3005 	ldrb.w	r3, [ip, r5]
   116fe:	ea23 0302 	bic.w	r3, r3, r2
   11702:	f80c 3005 	strb.w	r3, [ip, r5]
    *p_pin = pin_number & 0x1F;
   11706:	f000 051f 	and.w	r5, r0, #31
    return pin_number >> 5;
   1170a:	0943      	lsrs	r3, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1170c:	2b01      	cmp	r3, #1
   1170e:	d0cd      	beq.n	116ac <port_event_handle+0x30>
        case 0: return NRF_P0;
   11710:	4e0c      	ldr	r6, [pc, #48]	; (11744 <port_event_handle+0xc8>)
   11712:	e7cc      	b.n	116ae <port_event_handle+0x32>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   11714:	3401      	adds	r4, #1
   11716:	2c01      	cmp	r4, #1
   11718:	d9d4      	bls.n	116c4 <port_event_handle+0x48>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1171a:	4b0b      	ldr	r3, [pc, #44]	; (11748 <port_event_handle+0xcc>)
   1171c:	2200      	movs	r2, #0
   1171e:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
   11722:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
    } while (latch_pending_read_and_check(latch));
   11726:	a802      	add	r0, sp, #8
   11728:	f7ff ff1a 	bl	11560 <latch_pending_read_and_check>
   1172c:	b108      	cbz	r0, 11732 <port_event_handle+0xb6>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   1172e:	2400      	movs	r4, #0
   11730:	e7f1      	b.n	11716 <port_event_handle+0x9a>
}
   11732:	b004      	add	sp, #16
   11734:	bd70      	pop	{r4, r5, r6, pc}
   11736:	bf00      	nop
   11738:	0001d1d8 	.word	0x0001d1d8
   1173c:	50842800 	.word	0x50842800
   11740:	2000042c 	.word	0x2000042c
   11744:	50842500 	.word	0x50842500
   11748:	5000d000 	.word	0x5000d000

0001174c <nrfx_gpiote_input_configure>:
{
   1174c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11750:	4604      	mov	r4, r0
   11752:	4615      	mov	r5, r2
   11754:	461e      	mov	r6, r3
    if (p_input_config)
   11756:	b361      	cbz	r1, 117b2 <nrfx_gpiote_input_configure+0x66>
   11758:	460f      	mov	r7, r1
        if (pin_is_task_output(pin))
   1175a:	f009 fc2e 	bl	1afba <pin_is_task_output>
   1175e:	2800      	cmp	r0, #0
   11760:	f040 8099 	bne.w	11896 <nrfx_gpiote_input_configure+0x14a>
    *p_pin = pin_number & 0x1F;
   11764:	f004 021f 	and.w	r2, r4, #31
    return pin_number >> 5;
   11768:	0963      	lsrs	r3, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1176a:	2b01      	cmp	r3, #1
   1176c:	d043      	beq.n	117f6 <nrfx_gpiote_input_configure+0xaa>
        case 0: return NRF_P0;
   1176e:	484e      	ldr	r0, [pc, #312]	; (118a8 <nrfx_gpiote_input_configure+0x15c>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   11770:	f102 0380 	add.w	r3, r2, #128	; 0x80
   11774:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   11778:	2f00      	cmp	r7, #0
   1177a:	d03e      	beq.n	117fa <nrfx_gpiote_input_configure+0xae>
   1177c:	210c      	movs	r1, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   1177e:	f041 0103 	orr.w	r1, r1, #3
    cnf &= ~to_update;
   11782:	ea23 0301 	bic.w	r3, r3, r1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   11786:	2f00      	cmp	r7, #0
   11788:	d039      	beq.n	117fe <nrfx_gpiote_input_configure+0xb2>
   1178a:	7839      	ldrb	r1, [r7, #0]
   1178c:	0089      	lsls	r1, r1, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   1178e:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   11790:	3280      	adds	r2, #128	; 0x80
   11792:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   11796:	4a45      	ldr	r2, [pc, #276]	; (118ac <nrfx_gpiote_input_configure+0x160>)
   11798:	f104 0108 	add.w	r1, r4, #8
   1179c:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   117a0:	f023 0302 	bic.w	r3, r3, #2
   117a4:	b29b      	uxth	r3, r3
   117a6:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   117aa:	f043 0301 	orr.w	r3, r3, #1
   117ae:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_trigger_config)
   117b2:	b1bd      	cbz	r5, 117e4 <nrfx_gpiote_input_configure+0x98>
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   117b4:	782f      	ldrb	r7, [r5, #0]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   117b6:	f8d5 8004 	ldr.w	r8, [r5, #4]
        if (pin_is_output(pin))
   117ba:	4620      	mov	r0, r4
   117bc:	f7ff fdd0 	bl	11360 <pin_is_output>
   117c0:	b1f8      	cbz	r0, 11802 <nrfx_gpiote_input_configure+0xb6>
            if (use_evt)
   117c2:	f1b8 0f00 	cmp.w	r8, #0
   117c6:	d168      	bne.n	1189a <nrfx_gpiote_input_configure+0x14e>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   117c8:	4a38      	ldr	r2, [pc, #224]	; (118ac <nrfx_gpiote_input_configure+0x160>)
   117ca:	f104 0108 	add.w	r1, r4, #8
   117ce:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   117d2:	f023 031c 	bic.w	r3, r3, #28
   117d6:	b29b      	uxth	r3, r3
   117d8:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   117dc:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
   117e0:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_handler_config)
   117e4:	2e00      	cmp	r6, #0
   117e6:	d05c      	beq.n	118a2 <nrfx_gpiote_input_configure+0x156>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   117e8:	6872      	ldr	r2, [r6, #4]
   117ea:	6831      	ldr	r1, [r6, #0]
   117ec:	4620      	mov	r0, r4
   117ee:	f7ff fe5f 	bl	114b0 <pin_handler_set>
}
   117f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        case 1: return NRF_P1;
   117f6:	482e      	ldr	r0, [pc, #184]	; (118b0 <nrfx_gpiote_input_configure+0x164>)
   117f8:	e7ba      	b.n	11770 <nrfx_gpiote_input_configure+0x24>
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   117fa:	2100      	movs	r1, #0
   117fc:	e7bf      	b.n	1177e <nrfx_gpiote_input_configure+0x32>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   117fe:	2100      	movs	r1, #0
   11800:	e7c5      	b.n	1178e <nrfx_gpiote_input_configure+0x42>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   11802:	4a2a      	ldr	r2, [pc, #168]	; (118ac <nrfx_gpiote_input_configure+0x160>)
   11804:	f104 0108 	add.w	r1, r4, #8
   11808:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   1180c:	f023 0320 	bic.w	r3, r3, #32
   11810:	04db      	lsls	r3, r3, #19
   11812:	0cdb      	lsrs	r3, r3, #19
   11814:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
            if (use_evt)
   11818:	f1b8 0f00 	cmp.w	r8, #0
   1181c:	d0d4      	beq.n	117c8 <nrfx_gpiote_input_configure+0x7c>
                if (!edge)
   1181e:	2f03      	cmp	r7, #3
   11820:	d83d      	bhi.n	1189e <nrfx_gpiote_input_configure+0x152>
                uint8_t ch = *p_trigger_config->p_in_channel;
   11822:	686b      	ldr	r3, [r5, #4]
   11824:	781d      	ldrb	r5, [r3, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   11826:	b947      	cbnz	r7, 1183a <nrfx_gpiote_input_configure+0xee>
    p_reg->CONFIG[idx] = 0;
   11828:	4b22      	ldr	r3, [pc, #136]	; (118b4 <nrfx_gpiote_input_configure+0x168>)
   1182a:	f505 75a2 	add.w	r5, r5, #324	; 0x144
   1182e:	2200      	movs	r2, #0
   11830:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
    p_reg->CONFIG[idx] = 0;
   11834:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
#endif
}
   11838:	e7c6      	b.n	117c8 <nrfx_gpiote_input_configure+0x7c>
                    nrf_gpiote_polarity_t polarity = gpiote_trigger_to_polarity(trigger);
   1183a:	4638      	mov	r0, r7
   1183c:	f009 fbd4 	bl	1afe8 <gpiote_trigger_to_polarity>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   11840:	4b1c      	ldr	r3, [pc, #112]	; (118b4 <nrfx_gpiote_input_configure+0x168>)
   11842:	f505 72a2 	add.w	r2, r5, #324	; 0x144
   11846:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   1184a:	f021 0103 	bic.w	r1, r1, #3
   1184e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   11852:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   11856:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
   1185a:	f421 7140 	bic.w	r1, r1, #768	; 0x300
   1185e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   11862:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
   11866:	0221      	lsls	r1, r4, #8
   11868:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
   1186c:	0400      	lsls	r0, r0, #16
   1186e:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   11872:	4301      	orrs	r1, r0
   11874:	ea4c 0101 	orr.w	r1, ip, r1
   11878:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   1187c:	036b      	lsls	r3, r5, #13
   1187e:	b29b      	uxth	r3, r3
   11880:	4a0a      	ldr	r2, [pc, #40]	; (118ac <nrfx_gpiote_input_configure+0x160>)
   11882:	f104 0108 	add.w	r1, r4, #8
   11886:	f832 0011 	ldrh.w	r0, [r2, r1, lsl #1]
   1188a:	4303      	orrs	r3, r0
   1188c:	f043 0320 	orr.w	r3, r3, #32
   11890:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
   11894:	e798      	b.n	117c8 <nrfx_gpiote_input_configure+0x7c>
            return NRFX_ERROR_INVALID_PARAM;
   11896:	4808      	ldr	r0, [pc, #32]	; (118b8 <nrfx_gpiote_input_configure+0x16c>)
   11898:	e7ab      	b.n	117f2 <nrfx_gpiote_input_configure+0xa6>
                return NRFX_ERROR_INVALID_PARAM;
   1189a:	4807      	ldr	r0, [pc, #28]	; (118b8 <nrfx_gpiote_input_configure+0x16c>)
   1189c:	e7a9      	b.n	117f2 <nrfx_gpiote_input_configure+0xa6>
                    return NRFX_ERROR_INVALID_PARAM;
   1189e:	4806      	ldr	r0, [pc, #24]	; (118b8 <nrfx_gpiote_input_configure+0x16c>)
   118a0:	e7a7      	b.n	117f2 <nrfx_gpiote_input_configure+0xa6>
        err = NRFX_SUCCESS;
   118a2:	4806      	ldr	r0, [pc, #24]	; (118bc <nrfx_gpiote_input_configure+0x170>)
   118a4:	e7a5      	b.n	117f2 <nrfx_gpiote_input_configure+0xa6>
   118a6:	bf00      	nop
   118a8:	50842500 	.word	0x50842500
   118ac:	2000042c 	.word	0x2000042c
   118b0:	50842800 	.word	0x50842800
   118b4:	5000d000 	.word	0x5000d000
   118b8:	0bad0004 	.word	0x0bad0004
   118bc:	0bad0000 	.word	0x0bad0000

000118c0 <nrfx_gpiote_output_configure>:
{
   118c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   118c2:	4604      	mov	r4, r0
   118c4:	4615      	mov	r5, r2
    if (p_config)
   118c6:	2900      	cmp	r1, #0
   118c8:	d053      	beq.n	11972 <nrfx_gpiote_output_configure+0xb2>
   118ca:	460e      	mov	r6, r1
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   118cc:	f009 fb84 	bl	1afd8 <pin_is_input>
   118d0:	b128      	cbz	r0, 118de <nrfx_gpiote_output_configure+0x1e>
   118d2:	4620      	mov	r0, r4
   118d4:	f7ff fd2e 	bl	11334 <pin_in_use_by_te>
   118d8:	2800      	cmp	r0, #0
   118da:	f040 80a2 	bne.w	11a22 <nrfx_gpiote_output_configure+0x162>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   118de:	4620      	mov	r0, r4
   118e0:	f7ff fd32 	bl	11348 <pin_has_trigger>
   118e4:	b118      	cbz	r0, 118ee <nrfx_gpiote_output_configure+0x2e>
   118e6:	7873      	ldrb	r3, [r6, #1]
   118e8:	2b01      	cmp	r3, #1
   118ea:	f000 809c 	beq.w	11a26 <nrfx_gpiote_output_configure+0x166>
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
   118ee:	f106 0c01 	add.w	ip, r6, #1
   118f2:	1cb7      	adds	r7, r6, #2
    *p_pin = pin_number & 0x1F;
   118f4:	f004 021f 	and.w	r2, r4, #31
    return pin_number >> 5;
   118f8:	0963      	lsrs	r3, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   118fa:	2b01      	cmp	r3, #1
   118fc:	d057      	beq.n	119ae <nrfx_gpiote_output_configure+0xee>
        case 0: return NRF_P0;
   118fe:	494d      	ldr	r1, [pc, #308]	; (11a34 <nrfx_gpiote_output_configure+0x174>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   11900:	f102 0380 	add.w	r3, r2, #128	; 0x80
   11904:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   11908:	f1bc 0f00 	cmp.w	ip, #0
   1190c:	d051      	beq.n	119b2 <nrfx_gpiote_output_configure+0xf2>
   1190e:	2302      	movs	r3, #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   11910:	f043 0301 	orr.w	r3, r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   11914:	2f00      	cmp	r7, #0
   11916:	d04e      	beq.n	119b6 <nrfx_gpiote_output_configure+0xf6>
   11918:	f04f 0e0c 	mov.w	lr, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   1191c:	ea43 030e 	orr.w	r3, r3, lr
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   11920:	2e00      	cmp	r6, #0
   11922:	d04b      	beq.n	119bc <nrfx_gpiote_output_configure+0xfc>
   11924:	f44f 6e70 	mov.w	lr, #3840	; 0xf00
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   11928:	ea43 030e 	orr.w	r3, r3, lr
    cnf &= ~to_update;
   1192c:	ea20 0003 	bic.w	r0, r0, r3
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   11930:	f1bc 0f00 	cmp.w	ip, #0
   11934:	d045      	beq.n	119c2 <nrfx_gpiote_output_configure+0x102>
   11936:	7873      	ldrb	r3, [r6, #1]
   11938:	005b      	lsls	r3, r3, #1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   1193a:	f043 0301 	orr.w	r3, r3, #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   1193e:	2f00      	cmp	r7, #0
   11940:	d041      	beq.n	119c6 <nrfx_gpiote_output_configure+0x106>
   11942:	f896 c002 	ldrb.w	ip, [r6, #2]
   11946:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   1194a:	ea43 030c 	orr.w	r3, r3, ip
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   1194e:	2e00      	cmp	r6, #0
   11950:	d03c      	beq.n	119cc <nrfx_gpiote_output_configure+0x10c>
   11952:	7836      	ldrb	r6, [r6, #0]
   11954:	0236      	lsls	r6, r6, #8
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   11956:	4333      	orrs	r3, r6
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   11958:	4303      	orrs	r3, r0
    reg->PIN_CNF[pin_number] = cnf;
   1195a:	3280      	adds	r2, #128	; 0x80
   1195c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   11960:	4a35      	ldr	r2, [pc, #212]	; (11a38 <nrfx_gpiote_output_configure+0x178>)
   11962:	f104 0108 	add.w	r1, r4, #8
   11966:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
   1196a:	f043 0303 	orr.w	r3, r3, #3
   1196e:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_task_config)
   11972:	2d00      	cmp	r5, #0
   11974:	d059      	beq.n	11a2a <nrfx_gpiote_output_configure+0x16a>
        if (pin_is_input(pin))
   11976:	4620      	mov	r0, r4
   11978:	f009 fb2e 	bl	1afd8 <pin_is_input>
   1197c:	2800      	cmp	r0, #0
   1197e:	d156      	bne.n	11a2e <nrfx_gpiote_output_configure+0x16e>
        uint32_t ch = p_task_config->task_ch;
   11980:	782b      	ldrb	r3, [r5, #0]
    p_reg->CONFIG[idx] = 0;
   11982:	4a2e      	ldr	r2, [pc, #184]	; (11a3c <nrfx_gpiote_output_configure+0x17c>)
   11984:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   11988:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
    p_reg->CONFIG[idx] = 0;
   1198c:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   11990:	4929      	ldr	r1, [pc, #164]	; (11a38 <nrfx_gpiote_output_configure+0x178>)
   11992:	f104 0008 	add.w	r0, r4, #8
   11996:	f831 2010 	ldrh.w	r2, [r1, r0, lsl #1]
   1199a:	f022 0220 	bic.w	r2, r2, #32
   1199e:	04d2      	lsls	r2, r2, #19
   119a0:	0cd2      	lsrs	r2, r2, #19
   119a2:	f821 2010 	strh.w	r2, [r1, r0, lsl #1]
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   119a6:	786a      	ldrb	r2, [r5, #1]
   119a8:	b992      	cbnz	r2, 119d0 <nrfx_gpiote_output_configure+0x110>
    return NRFX_SUCCESS;
   119aa:	4825      	ldr	r0, [pc, #148]	; (11a40 <nrfx_gpiote_output_configure+0x180>)
}
   119ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case 1: return NRF_P1;
   119ae:	4925      	ldr	r1, [pc, #148]	; (11a44 <nrfx_gpiote_output_configure+0x184>)
   119b0:	e7a6      	b.n	11900 <nrfx_gpiote_output_configure+0x40>
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   119b2:	2300      	movs	r3, #0
   119b4:	e7ac      	b.n	11910 <nrfx_gpiote_output_configure+0x50>
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   119b6:	f04f 0e00 	mov.w	lr, #0
   119ba:	e7af      	b.n	1191c <nrfx_gpiote_output_configure+0x5c>
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   119bc:	f04f 0e00 	mov.w	lr, #0
   119c0:	e7b2      	b.n	11928 <nrfx_gpiote_output_configure+0x68>
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   119c2:	2300      	movs	r3, #0
   119c4:	e7b9      	b.n	1193a <nrfx_gpiote_output_configure+0x7a>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   119c6:	f04f 0c00 	mov.w	ip, #0
   119ca:	e7be      	b.n	1194a <nrfx_gpiote_output_configure+0x8a>
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   119cc:	2600      	movs	r6, #0
   119ce:	e7c2      	b.n	11956 <nrfx_gpiote_output_configure+0x96>
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   119d0:	78af      	ldrb	r7, [r5, #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   119d2:	481a      	ldr	r0, [pc, #104]	; (11a3c <nrfx_gpiote_output_configure+0x17c>)
   119d4:	f503 75a2 	add.w	r5, r3, #324	; 0x144
   119d8:	f850 1025 	ldr.w	r1, [r0, r5, lsl #2]
   119dc:	f421 1199 	bic.w	r1, r1, #1253376	; 0x132000
   119e0:	f421 51f8 	bic.w	r1, r1, #7936	; 0x1f00
   119e4:	f840 1025 	str.w	r1, [r0, r5, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   119e8:	f850 6025 	ldr.w	r6, [r0, r5, lsl #2]
   119ec:	0221      	lsls	r1, r4, #8
   119ee:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   119f2:	0412      	lsls	r2, r2, #16
   119f4:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   119f8:	430a      	orrs	r2, r1
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   119fa:	0539      	lsls	r1, r7, #20
   119fc:	f401 1180 	and.w	r1, r1, #1048576	; 0x100000
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   11a00:	430a      	orrs	r2, r1
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   11a02:	4332      	orrs	r2, r6
   11a04:	f840 2025 	str.w	r2, [r0, r5, lsl #2]
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   11a08:	035b      	lsls	r3, r3, #13
   11a0a:	b29b      	uxth	r3, r3
   11a0c:	4a0a      	ldr	r2, [pc, #40]	; (11a38 <nrfx_gpiote_output_configure+0x178>)
   11a0e:	3408      	adds	r4, #8
   11a10:	f832 1014 	ldrh.w	r1, [r2, r4, lsl #1]
   11a14:	430b      	orrs	r3, r1
   11a16:	f043 0320 	orr.w	r3, r3, #32
   11a1a:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]
    return NRFX_SUCCESS;
   11a1e:	4808      	ldr	r0, [pc, #32]	; (11a40 <nrfx_gpiote_output_configure+0x180>)
   11a20:	e7c4      	b.n	119ac <nrfx_gpiote_output_configure+0xec>
   11a22:	4809      	ldr	r0, [pc, #36]	; (11a48 <nrfx_gpiote_output_configure+0x188>)
   11a24:	e7c2      	b.n	119ac <nrfx_gpiote_output_configure+0xec>
   11a26:	4808      	ldr	r0, [pc, #32]	; (11a48 <nrfx_gpiote_output_configure+0x188>)
   11a28:	e7c0      	b.n	119ac <nrfx_gpiote_output_configure+0xec>
   11a2a:	4805      	ldr	r0, [pc, #20]	; (11a40 <nrfx_gpiote_output_configure+0x180>)
   11a2c:	e7be      	b.n	119ac <nrfx_gpiote_output_configure+0xec>
            return NRFX_ERROR_INVALID_PARAM;
   11a2e:	4806      	ldr	r0, [pc, #24]	; (11a48 <nrfx_gpiote_output_configure+0x188>)
   11a30:	e7bc      	b.n	119ac <nrfx_gpiote_output_configure+0xec>
   11a32:	bf00      	nop
   11a34:	50842500 	.word	0x50842500
   11a38:	2000042c 	.word	0x2000042c
   11a3c:	5000d000 	.word	0x5000d000
   11a40:	0bad0000 	.word	0x0bad0000
   11a44:	50842800 	.word	0x50842800
   11a48:	0bad0004 	.word	0x0bad0004

00011a4c <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   11a4c:	4b01      	ldr	r3, [pc, #4]	; (11a54 <nrfx_gpiote_global_callback_set+0x8>)
   11a4e:	6098      	str	r0, [r3, #8]
    m_cb.global_handler.p_context = p_context;
   11a50:	60d9      	str	r1, [r3, #12]
}
   11a52:	4770      	bx	lr
   11a54:	2000042c 	.word	0x2000042c

00011a58 <nrfx_gpiote_channel_get>:
{
   11a58:	b538      	push	{r3, r4, r5, lr}
   11a5a:	4604      	mov	r4, r0
   11a5c:	460d      	mov	r5, r1
    if (pin_in_use_by_te(pin))
   11a5e:	f7ff fc69 	bl	11334 <pin_in_use_by_te>
   11a62:	b140      	cbz	r0, 11a76 <nrfx_gpiote_channel_get+0x1e>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   11a64:	f104 0008 	add.w	r0, r4, #8
   11a68:	4b04      	ldr	r3, [pc, #16]	; (11a7c <nrfx_gpiote_channel_get+0x24>)
   11a6a:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
   11a6e:	0b5b      	lsrs	r3, r3, #13
   11a70:	702b      	strb	r3, [r5, #0]
        return NRFX_SUCCESS;
   11a72:	4803      	ldr	r0, [pc, #12]	; (11a80 <nrfx_gpiote_channel_get+0x28>)
}
   11a74:	bd38      	pop	{r3, r4, r5, pc}
        return NRFX_ERROR_INVALID_PARAM;
   11a76:	4803      	ldr	r0, [pc, #12]	; (11a84 <nrfx_gpiote_channel_get+0x2c>)
   11a78:	e7fc      	b.n	11a74 <nrfx_gpiote_channel_get+0x1c>
   11a7a:	bf00      	nop
   11a7c:	2000042c 	.word	0x2000042c
   11a80:	0bad0000 	.word	0x0bad0000
   11a84:	0bad0004 	.word	0x0bad0004

00011a88 <nrfx_gpiote_init>:
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   11a88:	4b10      	ldr	r3, [pc, #64]	; (11acc <nrfx_gpiote_init+0x44>)
   11a8a:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   11a8e:	b10b      	cbz	r3, 11a94 <nrfx_gpiote_init+0xc>
        return err_code;
   11a90:	480f      	ldr	r0, [pc, #60]	; (11ad0 <nrfx_gpiote_init+0x48>)
}
   11a92:	4770      	bx	lr
{
   11a94:	b510      	push	{r4, lr}
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   11a96:	4c0d      	ldr	r4, [pc, #52]	; (11acc <nrfx_gpiote_init+0x44>)
   11a98:	2260      	movs	r2, #96	; 0x60
   11a9a:	2100      	movs	r1, #0
   11a9c:	f104 0010 	add.w	r0, r4, #16
   11aa0:	f005 fe75 	bl	1778e <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   11aa4:	200d      	movs	r0, #13
   11aa6:	f7f2 faad 	bl	4004 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   11aaa:	4b0a      	ldr	r3, [pc, #40]	; (11ad4 <nrfx_gpiote_init+0x4c>)
   11aac:	2200      	movs	r2, #0
   11aae:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
   11ab2:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   11ab6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   11aba:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   11abe:	2301      	movs	r3, #1
   11ac0:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   11ac4:	6763      	str	r3, [r4, #116]	; 0x74
    return err_code;
   11ac6:	4804      	ldr	r0, [pc, #16]	; (11ad8 <nrfx_gpiote_init+0x50>)
}
   11ac8:	bd10      	pop	{r4, pc}
   11aca:	bf00      	nop
   11acc:	2000042c 	.word	0x2000042c
   11ad0:	0bad0005 	.word	0x0bad0005
   11ad4:	5000d000 	.word	0x5000d000
   11ad8:	0bad0000 	.word	0x0bad0000

00011adc <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   11adc:	4b03      	ldr	r3, [pc, #12]	; (11aec <nrfx_gpiote_is_init+0x10>)
   11ade:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
   11ae2:	3800      	subs	r0, #0
   11ae4:	bf18      	it	ne
   11ae6:	2001      	movne	r0, #1
   11ae8:	4770      	bx	lr
   11aea:	bf00      	nop
   11aec:	2000042c 	.word	0x2000042c

00011af0 <nrfx_gpiote_channel_free>:
{
   11af0:	b508      	push	{r3, lr}
   11af2:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   11af4:	4801      	ldr	r0, [pc, #4]	; (11afc <nrfx_gpiote_channel_free+0xc>)
   11af6:	f7ff fac1 	bl	1107c <nrfx_flag32_free>
}
   11afa:	bd08      	pop	{r3, pc}
   11afc:	2000049c 	.word	0x2000049c

00011b00 <nrfx_gpiote_channel_alloc>:
{
   11b00:	b508      	push	{r3, lr}
   11b02:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   11b04:	4801      	ldr	r0, [pc, #4]	; (11b0c <nrfx_gpiote_channel_alloc+0xc>)
   11b06:	f7ff fa95 	bl	11034 <nrfx_flag32_alloc>
}
   11b0a:	bd08      	pop	{r3, pc}
   11b0c:	2000049c 	.word	0x2000049c

00011b10 <nrfx_gpiote_trigger_enable>:
{
   11b10:	b538      	push	{r3, r4, r5, lr}
   11b12:	4604      	mov	r4, r0
   11b14:	460d      	mov	r5, r1
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   11b16:	f7ff fc0d 	bl	11334 <pin_in_use_by_te>
   11b1a:	b308      	cbz	r0, 11b60 <nrfx_gpiote_trigger_enable+0x50>
   11b1c:	4620      	mov	r0, r4
   11b1e:	f009 fa5b 	bl	1afd8 <pin_is_input>
   11b22:	b1e8      	cbz	r0, 11b60 <nrfx_gpiote_trigger_enable+0x50>
        uint8_t ch = pin_te_get(pin);
   11b24:	4620      	mov	r0, r4
   11b26:	f7ff fc25 	bl	11374 <pin_te_get>
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   11b2a:	0083      	lsls	r3, r0, #2
   11b2c:	f503 7380 	add.w	r3, r3, #256	; 0x100
    return ((uint32_t)p_reg + event);
   11b30:	b29b      	uxth	r3, r3
   11b32:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
   11b36:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   11b3a:	2200      	movs	r2, #0
   11b3c:	601a      	str	r2, [r3, #0]
   11b3e:	681b      	ldr	r3, [r3, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   11b40:	4a20      	ldr	r2, [pc, #128]	; (11bc4 <nrfx_gpiote_trigger_enable+0xb4>)
   11b42:	f500 71a2 	add.w	r1, r0, #324	; 0x144
   11b46:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   11b4a:	f043 0301 	orr.w	r3, r3, #1
   11b4e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        if (int_enable)
   11b52:	b37d      	cbz	r5, 11bb4 <nrfx_gpiote_trigger_enable+0xa4>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   11b54:	2301      	movs	r3, #1
   11b56:	fa03 f000 	lsl.w	r0, r3, r0
    p_reg->INTENSET = mask;
   11b5a:	f8c2 0304 	str.w	r0, [r2, #772]	; 0x304
}
   11b5e:	e029      	b.n	11bb4 <nrfx_gpiote_trigger_enable+0xa4>
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   11b60:	f104 0308 	add.w	r3, r4, #8
   11b64:	4a18      	ldr	r2, [pc, #96]	; (11bc8 <nrfx_gpiote_trigger_enable+0xb8>)
   11b66:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   11b6a:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   11b6e:	2b04      	cmp	r3, #4
   11b70:	d010      	beq.n	11b94 <nrfx_gpiote_trigger_enable+0x84>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   11b72:	2b05      	cmp	r3, #5
   11b74:	d01f      	beq.n	11bb6 <nrfx_gpiote_trigger_enable+0xa6>
    *p_pin = pin_number & 0x1F;
   11b76:	f004 021f 	and.w	r2, r4, #31
    return pin_number >> 5;
   11b7a:	0963      	lsrs	r3, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11b7c:	2b01      	cmp	r3, #1
   11b7e:	d007      	beq.n	11b90 <nrfx_gpiote_trigger_enable+0x80>
        case 0: return NRF_P0;
   11b80:	4b12      	ldr	r3, [pc, #72]	; (11bcc <nrfx_gpiote_trigger_enable+0xbc>)
    return p_reg->IN;
   11b82:	691b      	ldr	r3, [r3, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   11b84:	40d3      	lsrs	r3, r2
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   11b86:	f013 0f01 	tst.w	r3, #1
   11b8a:	d016      	beq.n	11bba <nrfx_gpiote_trigger_enable+0xaa>
   11b8c:	2003      	movs	r0, #3
   11b8e:	e002      	b.n	11b96 <nrfx_gpiote_trigger_enable+0x86>
        case 1: return NRF_P1;
   11b90:	4b0f      	ldr	r3, [pc, #60]	; (11bd0 <nrfx_gpiote_trigger_enable+0xc0>)
   11b92:	e7f6      	b.n	11b82 <nrfx_gpiote_trigger_enable+0x72>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   11b94:	2003      	movs	r0, #3
    *p_pin = pin_number & 0x1F;
   11b96:	f004 021f 	and.w	r2, r4, #31
    return pin_number >> 5;
   11b9a:	0964      	lsrs	r4, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11b9c:	2c01      	cmp	r4, #1
   11b9e:	d00e      	beq.n	11bbe <nrfx_gpiote_trigger_enable+0xae>
        case 0: return NRF_P0;
   11ba0:	490a      	ldr	r1, [pc, #40]	; (11bcc <nrfx_gpiote_trigger_enable+0xbc>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   11ba2:	3280      	adds	r2, #128	; 0x80
   11ba4:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    cnf &= ~to_update;
   11ba8:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   11bac:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   11bb0:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
   11bb4:	bd38      	pop	{r3, r4, r5, pc}
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   11bb6:	2002      	movs	r0, #2
   11bb8:	e7ed      	b.n	11b96 <nrfx_gpiote_trigger_enable+0x86>
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   11bba:	2002      	movs	r0, #2
   11bbc:	e7eb      	b.n	11b96 <nrfx_gpiote_trigger_enable+0x86>
        case 1: return NRF_P1;
   11bbe:	4904      	ldr	r1, [pc, #16]	; (11bd0 <nrfx_gpiote_trigger_enable+0xc0>)
   11bc0:	e7ef      	b.n	11ba2 <nrfx_gpiote_trigger_enable+0x92>
   11bc2:	bf00      	nop
   11bc4:	5000d000 	.word	0x5000d000
   11bc8:	2000042c 	.word	0x2000042c
   11bcc:	50842500 	.word	0x50842500
   11bd0:	50842800 	.word	0x50842800

00011bd4 <nrfx_gpiote_trigger_disable>:
{
   11bd4:	b510      	push	{r4, lr}
   11bd6:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   11bd8:	f7ff fbac 	bl	11334 <pin_in_use_by_te>
   11bdc:	b1a0      	cbz	r0, 11c08 <nrfx_gpiote_trigger_disable+0x34>
   11bde:	4620      	mov	r0, r4
   11be0:	f009 f9fa 	bl	1afd8 <pin_is_input>
   11be4:	b180      	cbz	r0, 11c08 <nrfx_gpiote_trigger_disable+0x34>
        uint8_t ch = pin_te_get(pin);
   11be6:	4620      	mov	r0, r4
   11be8:	f7ff fbc4 	bl	11374 <pin_te_get>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   11bec:	2201      	movs	r2, #1
   11bee:	4082      	lsls	r2, r0
    p_reg->INTENCLR = mask;
   11bf0:	4b0d      	ldr	r3, [pc, #52]	; (11c28 <nrfx_gpiote_trigger_disable+0x54>)
   11bf2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   11bf6:	f500 70a2 	add.w	r0, r0, #324	; 0x144
   11bfa:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
   11bfe:	f022 0203 	bic.w	r2, r2, #3
   11c02:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
   11c06:	e00c      	b.n	11c22 <nrfx_gpiote_trigger_disable+0x4e>
    *p_pin = pin_number & 0x1F;
   11c08:	f004 031f 	and.w	r3, r4, #31
    return pin_number >> 5;
   11c0c:	0964      	lsrs	r4, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11c0e:	2c01      	cmp	r4, #1
   11c10:	d008      	beq.n	11c24 <nrfx_gpiote_trigger_disable+0x50>
        case 0: return NRF_P0;
   11c12:	4906      	ldr	r1, [pc, #24]	; (11c2c <nrfx_gpiote_trigger_disable+0x58>)
    uint32_t cnf = reg->PIN_CNF[pin_number];
   11c14:	3380      	adds	r3, #128	; 0x80
   11c16:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
   11c1a:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf;
   11c1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11c22:	bd10      	pop	{r4, pc}
        case 1: return NRF_P1;
   11c24:	4902      	ldr	r1, [pc, #8]	; (11c30 <nrfx_gpiote_trigger_disable+0x5c>)
   11c26:	e7f5      	b.n	11c14 <nrfx_gpiote_trigger_disable+0x40>
   11c28:	5000d000 	.word	0x5000d000
   11c2c:	50842500 	.word	0x50842500
   11c30:	50842800 	.word	0x50842800

00011c34 <nrfx_gpiote_pin_uninit>:
{
   11c34:	b510      	push	{r4, lr}
   11c36:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   11c38:	f7ff fb72 	bl	11320 <pin_in_use>
   11c3c:	b908      	cbnz	r0, 11c42 <nrfx_gpiote_pin_uninit+0xe>
        return NRFX_ERROR_INVALID_PARAM;
   11c3e:	480d      	ldr	r0, [pc, #52]	; (11c74 <nrfx_gpiote_pin_uninit+0x40>)
}
   11c40:	bd10      	pop	{r4, pc}
    nrfx_gpiote_trigger_disable(pin);
   11c42:	4620      	mov	r0, r4
   11c44:	f7ff ffc6 	bl	11bd4 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   11c48:	4620      	mov	r0, r4
   11c4a:	f7ff fc13 	bl	11474 <pin_handler_trigger_uninit>
    *p_pin = pin_number & 0x1F;
   11c4e:	f004 021f 	and.w	r2, r4, #31
    return pin_number >> 5;
   11c52:	0964      	lsrs	r4, r4, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11c54:	2c01      	cmp	r4, #1
   11c56:	d00b      	beq.n	11c70 <nrfx_gpiote_pin_uninit+0x3c>
        case 0: return NRF_P0;
   11c58:	4907      	ldr	r1, [pc, #28]	; (11c78 <nrfx_gpiote_pin_uninit+0x44>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   11c5a:	3280      	adds	r2, #128	; 0x80
   11c5c:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
   11c60:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   11c64:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
   11c68:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
    return NRFX_SUCCESS;
   11c6c:	4803      	ldr	r0, [pc, #12]	; (11c7c <nrfx_gpiote_pin_uninit+0x48>)
}
   11c6e:	e7e7      	b.n	11c40 <nrfx_gpiote_pin_uninit+0xc>
        case 1: return NRF_P1;
   11c70:	4903      	ldr	r1, [pc, #12]	; (11c80 <nrfx_gpiote_pin_uninit+0x4c>)
   11c72:	e7f2      	b.n	11c5a <nrfx_gpiote_pin_uninit+0x26>
   11c74:	0bad0004 	.word	0x0bad0004
   11c78:	50842500 	.word	0x50842500
   11c7c:	0bad0000 	.word	0x0bad0000
   11c80:	50842800 	.word	0x50842800

00011c84 <nrfx_gpiote_irq_handler>:

void nrfx_gpiote_irq_handler(void)
{
   11c84:	b538      	push	{r3, r4, r5, lr}
    uint32_t status = 0;
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   11c86:	2001      	movs	r0, #1
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
   11c88:	f44f 7380 	mov.w	r3, #256	; 0x100

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   11c8c:	2100      	movs	r1, #0
    uint32_t status = 0;
   11c8e:	460c      	mov	r4, r1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   11c90:	e003      	b.n	11c9a <nrfx_gpiote_irq_handler+0x16>
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
        }
        mask <<= 1;
   11c92:	0040      	lsls	r0, r0, #1
        /* Incrementing to next event, utilizing the fact that events are grouped together
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
   11c94:	3304      	adds	r3, #4
   11c96:	b29b      	uxth	r3, r3
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   11c98:	3101      	adds	r1, #1
   11c9a:	2907      	cmp	r1, #7
   11c9c:	d814      	bhi.n	11cc8 <nrfx_gpiote_irq_handler+0x44>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   11c9e:	f103 42a0 	add.w	r2, r3, #1342177280	; 0x50000000
   11ca2:	f502 4250 	add.w	r2, r2, #53248	; 0xd000
   11ca6:	6812      	ldr	r2, [r2, #0]
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   11ca8:	2a00      	cmp	r2, #0
   11caa:	d0f2      	beq.n	11c92 <nrfx_gpiote_irq_handler+0xe>
    return p_reg->INTENSET & mask;
   11cac:	4a0c      	ldr	r2, [pc, #48]	; (11ce0 <nrfx_gpiote_irq_handler+0x5c>)
   11cae:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
   11cb2:	4210      	tst	r0, r2
   11cb4:	d0ed      	beq.n	11c92 <nrfx_gpiote_irq_handler+0xe>
    return ((uint32_t)p_reg + event);
   11cb6:	f103 42a0 	add.w	r2, r3, #1342177280	; 0x50000000
   11cba:	f502 4250 	add.w	r2, r2, #53248	; 0xd000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   11cbe:	2500      	movs	r5, #0
   11cc0:	6015      	str	r5, [r2, #0]
   11cc2:	6812      	ldr	r2, [r2, #0]
            status |= mask;
   11cc4:	4304      	orrs	r4, r0
   11cc6:	e7e4      	b.n	11c92 <nrfx_gpiote_irq_handler+0xe>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   11cc8:	4b05      	ldr	r3, [pc, #20]	; (11ce0 <nrfx_gpiote_irq_handler+0x5c>)
   11cca:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   11cce:	b91b      	cbnz	r3, 11cd8 <nrfx_gpiote_irq_handler+0x54>
    {
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
   11cd0:	4620      	mov	r0, r4
   11cd2:	f7ff fc23 	bl	1151c <gpiote_evt_handle>
}
   11cd6:	bd38      	pop	{r3, r4, r5, pc}
        port_event_handle();
   11cd8:	f7ff fcd0 	bl	1167c <port_event_handle>
   11cdc:	e7f8      	b.n	11cd0 <nrfx_gpiote_irq_handler+0x4c>
   11cde:	bf00      	nop
   11ce0:	5000d000 	.word	0x5000d000

00011ce4 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   11ce4:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   11ce6:	4b08      	ldr	r3, [pc, #32]	; (11d08 <nrfx_ipc_init+0x24>)
   11ce8:	791b      	ldrb	r3, [r3, #4]
   11cea:	b10b      	cbz	r3, 11cf0 <nrfx_ipc_init+0xc>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
   11cec:	4807      	ldr	r0, [pc, #28]	; (11d0c <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
}
   11cee:	bd38      	pop	{r3, r4, r5, pc}
   11cf0:	460d      	mov	r5, r1
   11cf2:	4614      	mov	r4, r2
    NRFX_IRQ_ENABLE(IPC_IRQn);
   11cf4:	202a      	movs	r0, #42	; 0x2a
   11cf6:	f7f2 f985 	bl	4004 <arch_irq_enable>
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   11cfa:	4b03      	ldr	r3, [pc, #12]	; (11d08 <nrfx_ipc_init+0x24>)
   11cfc:	2201      	movs	r2, #1
   11cfe:	711a      	strb	r2, [r3, #4]
    m_ipc_cb.handler = handler;
   11d00:	601d      	str	r5, [r3, #0]
    m_ipc_cb.p_context = p_context;
   11d02:	609c      	str	r4, [r3, #8]
    return NRFX_SUCCESS;
   11d04:	4802      	ldr	r0, [pc, #8]	; (11d10 <nrfx_ipc_init+0x2c>)
   11d06:	e7f2      	b.n	11cee <nrfx_ipc_init+0xa>
   11d08:	20002658 	.word	0x20002658
   11d0c:	0bad000c 	.word	0x0bad000c
   11d10:	0bad0000 	.word	0x0bad0000

00011d14 <nrfx_ipc_config_load>:

void nrfx_ipc_config_load(const nrfx_ipc_config_t * p_config)
{
   11d14:	b410      	push	{r4}
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   11d16:	2300      	movs	r3, #0
   11d18:	e008      	b.n	11d2c <nrfx_ipc_config_load+0x18>
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   11d1a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    p_reg->SEND_CNF[index] = channels_mask;
   11d1e:	b2da      	uxtb	r2, r3
   11d20:	f502 72a2 	add.w	r2, r2, #324	; 0x144
   11d24:	490d      	ldr	r1, [pc, #52]	; (11d5c <nrfx_ipc_config_load+0x48>)
   11d26:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
    for (i = 0; i < IPC_CONF_NUM; ++i)
   11d2a:	3301      	adds	r3, #1
   11d2c:	2b0f      	cmp	r3, #15
   11d2e:	d9f4      	bls.n	11d1a <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   11d30:	2300      	movs	r3, #0
   11d32:	e00a      	b.n	11d4a <nrfx_ipc_config_load+0x36>
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   11d34:	f103 0210 	add.w	r2, r3, #16
   11d38:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
    p_reg->RECEIVE_CNF[index] = channels_mask;
   11d3c:	b2da      	uxtb	r2, r3
   11d3e:	f502 72b2 	add.w	r2, r2, #356	; 0x164
   11d42:	4906      	ldr	r1, [pc, #24]	; (11d5c <nrfx_ipc_config_load+0x48>)
   11d44:	f841 4022 	str.w	r4, [r1, r2, lsl #2]
    for (i = 0; i < IPC_CONF_NUM; ++i)
   11d48:	3301      	adds	r3, #1
   11d4a:	2b0f      	cmp	r3, #15
   11d4c:	d9f2      	bls.n	11d34 <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   11d4e:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
    p_reg->INTENSET = mask;
   11d52:	4b02      	ldr	r3, [pc, #8]	; (11d5c <nrfx_ipc_config_load+0x48>)
   11d54:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   11d58:	bc10      	pop	{r4}
   11d5a:	4770      	bx	lr
   11d5c:	5002a000 	.word	0x5002a000

00011d60 <nrfx_ipc_receive_event_enable>:
}

void nrfx_ipc_receive_event_enable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_enable(NRF_IPC, (1UL << event_index));
   11d60:	2301      	movs	r3, #1
   11d62:	4083      	lsls	r3, r0
   11d64:	4a01      	ldr	r2, [pc, #4]	; (11d6c <nrfx_ipc_receive_event_enable+0xc>)
   11d66:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   11d6a:	4770      	bx	lr
   11d6c:	5002a000 	.word	0x5002a000

00011d70 <nrfx_ipc_receive_event_disable>:

void nrfx_ipc_receive_event_disable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_disable(NRF_IPC, (1UL << event_index));
   11d70:	2301      	movs	r3, #1
   11d72:	4083      	lsls	r3, r0
    p_reg->INTENCLR = mask;
   11d74:	4a01      	ldr	r2, [pc, #4]	; (11d7c <nrfx_ipc_receive_event_disable+0xc>)
   11d76:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
   11d7a:	4770      	bx	lr
   11d7c:	5002a000 	.word	0x5002a000

00011d80 <nrfx_ipc_irq_handler>:
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   11d80:	b508      	push	{r3, lr}
    return p_reg->INTPEND;
   11d82:	4b0c      	ldr	r3, [pc, #48]	; (11db4 <nrfx_ipc_irq_handler+0x34>)
   11d84:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Get the information about events that fire this interrupt
    uint32_t events_map = nrf_ipc_int_pending_get(NRF_IPC);

    // Clear these events
    uint32_t bitmask = events_map;
   11d88:	4602      	mov	r2, r0
    while (bitmask)
   11d8a:	e00c      	b.n	11da6 <nrfx_ipc_irq_handler+0x26>
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   11d8c:	fa92 f3a2 	rbit	r3, r2
   11d90:	fab3 f383 	clz	r3, r3
   11d94:	2101      	movs	r1, #1
   11d96:	4099      	lsls	r1, r3
   11d98:	ea22 0201 	bic.w	r2, r2, r1
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   11d9c:	009b      	lsls	r3, r3, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11d9e:	4906      	ldr	r1, [pc, #24]	; (11db8 <nrfx_ipc_irq_handler+0x38>)
   11da0:	4419      	add	r1, r3
   11da2:	2300      	movs	r3, #0
   11da4:	600b      	str	r3, [r1, #0]
    while (bitmask)
   11da6:	2a00      	cmp	r2, #0
   11da8:	d1f0      	bne.n	11d8c <nrfx_ipc_irq_handler+0xc>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   11daa:	4b04      	ldr	r3, [pc, #16]	; (11dbc <nrfx_ipc_irq_handler+0x3c>)
   11dac:	681a      	ldr	r2, [r3, #0]
   11dae:	6899      	ldr	r1, [r3, #8]
   11db0:	4790      	blx	r2
}
   11db2:	bd08      	pop	{r3, pc}
   11db4:	5002a000 	.word	0x5002a000
   11db8:	5002a100 	.word	0x5002a100
   11dbc:	20002658 	.word	0x20002658

00011dc0 <spim_pin_uninit>:
    return err_code;
}

static void spim_pin_uninit(uint32_t pin)
{
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   11dc0:	f1b0 3fff 	cmp.w	r0, #4294967295
   11dc4:	d00e      	beq.n	11de4 <spim_pin_uninit+0x24>
    *p_pin = pin_number & 0x1F;
   11dc6:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
   11dca:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11dcc:	2801      	cmp	r0, #1
   11dce:	d00a      	beq.n	11de6 <spim_pin_uninit+0x26>
        case 0: return NRF_P0;
   11dd0:	4906      	ldr	r1, [pc, #24]	; (11dec <spim_pin_uninit+0x2c>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   11dd2:	3280      	adds	r2, #128	; 0x80
   11dd4:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
   11dd8:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   11ddc:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
   11de0:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
    {
        return;
    }

    nrf_gpio_cfg_default(pin);
}
   11de4:	4770      	bx	lr
        case 1: return NRF_P1;
   11de6:	4902      	ldr	r1, [pc, #8]	; (11df0 <spim_pin_uninit+0x30>)
   11de8:	e7f3      	b.n	11dd2 <spim_pin_uninit+0x12>
   11dea:	bf00      	nop
   11dec:	50842500 	.word	0x50842500
   11df0:	50842800 	.word	0x50842800

00011df4 <set_ss_pin_state>:
#endif

static void set_ss_pin_state(spim_control_block_t * p_cb, bool active)
{
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    if (p_cb->use_hw_ss)
   11df4:	7f82      	ldrb	r2, [r0, #30]
   11df6:	f012 0f04 	tst.w	r2, #4
   11dfa:	d11d      	bne.n	11e38 <set_ss_pin_state+0x44>
    {
        return;
    }
#endif

    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   11dfc:	7fc3      	ldrb	r3, [r0, #31]
   11dfe:	2bff      	cmp	r3, #255	; 0xff
   11e00:	d01a      	beq.n	11e38 <set_ss_pin_state+0x44>
    {
        nrf_gpio_pin_write(p_cb->ss_pin,
   11e02:	f012 0f02 	tst.w	r2, #2
   11e06:	d101      	bne.n	11e0c <set_ss_pin_state+0x18>
                           p_cb->ss_active_high ? active : !active);
   11e08:	f081 0101 	eor.w	r1, r1, #1
    if (value == 0)
   11e0c:	b959      	cbnz	r1, 11e26 <set_ss_pin_state+0x32>
    *p_pin = pin_number & 0x1F;
   11e0e:	f003 011f 	and.w	r1, r3, #31
    return pin_number >> 5;
   11e12:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11e14:	2b01      	cmp	r3, #1
   11e16:	d004      	beq.n	11e22 <set_ss_pin_state+0x2e>
        case 0: return NRF_P0;
   11e18:	4a09      	ldr	r2, [pc, #36]	; (11e40 <set_ss_pin_state+0x4c>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   11e1a:	2301      	movs	r3, #1
   11e1c:	408b      	lsls	r3, r1
    p_reg->OUTCLR = clr_mask;
   11e1e:	60d3      	str	r3, [r2, #12]
}
   11e20:	4770      	bx	lr
        case 1: return NRF_P1;
   11e22:	4a08      	ldr	r2, [pc, #32]	; (11e44 <set_ss_pin_state+0x50>)
   11e24:	e7f9      	b.n	11e1a <set_ss_pin_state+0x26>
    *p_pin = pin_number & 0x1F;
   11e26:	f003 011f 	and.w	r1, r3, #31
    return pin_number >> 5;
   11e2a:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11e2c:	2b01      	cmp	r3, #1
   11e2e:	d004      	beq.n	11e3a <set_ss_pin_state+0x46>
        case 0: return NRF_P0;
   11e30:	4a03      	ldr	r2, [pc, #12]	; (11e40 <set_ss_pin_state+0x4c>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   11e32:	2301      	movs	r3, #1
   11e34:	408b      	lsls	r3, r1
    p_reg->OUTSET = set_mask;
   11e36:	6093      	str	r3, [r2, #8]
    }
}
   11e38:	4770      	bx	lr
        case 1: return NRF_P1;
   11e3a:	4a02      	ldr	r2, [pc, #8]	; (11e44 <set_ss_pin_state+0x50>)
   11e3c:	e7f9      	b.n	11e32 <set_ss_pin_state+0x3e>
   11e3e:	bf00      	nop
   11e40:	50842500 	.word	0x50842500
   11e44:	50842800 	.word	0x50842800

00011e48 <spim_xfer>:

static nrfx_err_t spim_xfer(NRF_SPIM_Type               * p_spim,
                            spim_control_block_t        * p_cb,
                            nrfx_spim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
   11e48:	b570      	push	{r4, r5, r6, lr}
   11e4a:	4604      	mov	r4, r0
   11e4c:	460e      	mov	r6, r1
   11e4e:	461d      	mov	r5, r3
    nrfx_err_t err_code;
    // EasyDMA requires that transfer buffers are placed in Data RAM region;
    // signal error if they are not.
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   11e50:	6813      	ldr	r3, [r2, #0]
   11e52:	b123      	cbz	r3, 11e5e <spim_xfer+0x16>
   11e54:	f003 4160 	and.w	r1, r3, #3758096384	; 0xe0000000
   11e58:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   11e5c:	d106      	bne.n	11e6c <spim_xfer+0x24>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   11e5e:	6891      	ldr	r1, [r2, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   11e60:	b141      	cbz	r1, 11e74 <spim_xfer+0x2c>
   11e62:	f001 4160 	and.w	r1, r1, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   11e66:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   11e6a:	d003      	beq.n	11e74 <spim_xfer+0x2c>
    {
        p_cb->transfer_in_progress = false;
   11e6c:	2300      	movs	r3, #0
   11e6e:	7773      	strb	r3, [r6, #29]
        err_code = NRFX_ERROR_INVALID_ADDR;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
   11e70:	4818      	ldr	r0, [pc, #96]	; (11ed4 <spim_xfer+0x8c>)
        spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
    }
    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   11e72:	bd70      	pop	{r4, r5, r6, pc}
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   11e74:	6851      	ldr	r1, [r2, #4]

NRF_STATIC_INLINE void nrf_spim_tx_buffer_set(NRF_SPIM_Type * p_reg,
                                              uint8_t const * p_buffer,
                                              size_t          length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   11e76:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   11e7a:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   11e7e:	6891      	ldr	r1, [r2, #8]
   11e80:	68d3      	ldr	r3, [r2, #12]

NRF_STATIC_INLINE void nrf_spim_rx_buffer_set(NRF_SPIM_Type * p_reg,
                                              uint8_t * p_buffer,
                                              size_t    length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   11e82:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   11e86:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11e8a:	2300      	movs	r3, #0
   11e8c:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
   11e90:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
    spim_list_enable_handle(p_spim, flags);
   11e94:	4629      	mov	r1, r5
   11e96:	4620      	mov	r0, r4
   11e98:	f009 f8b5 	bl	1b006 <spim_list_enable_handle>
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   11e9c:	f015 0208 	ands.w	r2, r5, #8
   11ea0:	d101      	bne.n	11ea6 <spim_xfer+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   11ea2:	2301      	movs	r3, #1
   11ea4:	6123      	str	r3, [r4, #16]
    if (!p_cb->handler)
   11ea6:	6833      	ldr	r3, [r6, #0]
   11ea8:	b14b      	cbz	r3, 11ebe <spim_xfer+0x76>
        spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
   11eaa:	f015 0f04 	tst.w	r5, #4
   11eae:	bf0c      	ite	eq
   11eb0:	2101      	moveq	r1, #1
   11eb2:	2100      	movne	r1, #0
   11eb4:	4620      	mov	r0, r4
   11eb6:	f009 f89d 	bl	1aff4 <spim_int_enable>
    return err_code;
   11eba:	4807      	ldr	r0, [pc, #28]	; (11ed8 <spim_xfer+0x90>)
   11ebc:	e7d9      	b.n	11e72 <spim_xfer+0x2a>
        if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   11ebe:	b91a      	cbnz	r2, 11ec8 <spim_xfer+0x80>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   11ec0:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   11ec4:	2b00      	cmp	r3, #0
   11ec6:	d0fb      	beq.n	11ec0 <spim_xfer+0x78>
        set_ss_pin_state(p_cb, false);
   11ec8:	2100      	movs	r1, #0
   11eca:	4630      	mov	r0, r6
   11ecc:	f7ff ff92 	bl	11df4 <set_ss_pin_state>
    return err_code;
   11ed0:	4801      	ldr	r0, [pc, #4]	; (11ed8 <spim_xfer+0x90>)
   11ed2:	e7ce      	b.n	11e72 <spim_xfer+0x2a>
   11ed4:	0bad000a 	.word	0x0bad000a
   11ed8:	0bad0000 	.word	0x0bad0000

00011edc <configure_pins>:
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   11edc:	6800      	ldr	r0, [r0, #0]
    if (!p_config->skip_gpio_cfg)
   11ede:	7ccb      	ldrb	r3, [r1, #19]
   11ee0:	2b00      	cmp	r3, #0
   11ee2:	f040 80e4 	bne.w	120ae <configure_pins+0x1d2>
{
   11ee6:	b530      	push	{r4, r5, lr}
        pin_drive = (p_config->frequency == NRF_SPIM_FREQ_32M)
   11ee8:	688b      	ldr	r3, [r1, #8]
                    : NRF_GPIO_PIN_S0S1;
   11eea:	f1b3 5fa0 	cmp.w	r3, #335544320	; 0x14000000
   11eee:	d076      	beq.n	11fde <configure_pins+0x102>
   11ef0:	f04f 0e00 	mov.w	lr, #0
        nrf_gpio_pin_write(p_config->sck_pin,
   11ef4:	780b      	ldrb	r3, [r1, #0]
                           p_config->mode <= NRF_SPIM_MODE_1 ? 0 : 1);
   11ef6:	7b0a      	ldrb	r2, [r1, #12]
    if (value == 0)
   11ef8:	2a01      	cmp	r2, #1
   11efa:	d875      	bhi.n	11fe8 <configure_pins+0x10c>
    *p_pin = pin_number & 0x1F;
   11efc:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   11f00:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11f02:	2b01      	cmp	r3, #1
   11f04:	d06e      	beq.n	11fe4 <configure_pins+0x108>
        case 0: return NRF_P0;
   11f06:	4a76      	ldr	r2, [pc, #472]	; (120e0 <configure_pins+0x204>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   11f08:	2301      	movs	r3, #1
   11f0a:	40a3      	lsls	r3, r4
    p_reg->OUTCLR = clr_mask;
   11f0c:	60d3      	str	r3, [r2, #12]
        nrf_gpio_cfg(p_config->sck_pin,
   11f0e:	780b      	ldrb	r3, [r1, #0]
    *p_pin = pin_number & 0x1F;
   11f10:	f003 0c1f 	and.w	ip, r3, #31
    return pin_number >> 5;
   11f14:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11f16:	2b01      	cmp	r3, #1
   11f18:	d072      	beq.n	12000 <configure_pins+0x124>
        case 0: return NRF_P0;
   11f1a:	4c71      	ldr	r4, [pc, #452]	; (120e0 <configure_pins+0x204>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   11f1c:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
   11f20:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
   11f24:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   11f28:	ea4f 220e 	mov.w	r2, lr, lsl #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   11f2c:	f042 0501 	orr.w	r5, r2, #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   11f30:	432b      	orrs	r3, r5
    reg->PIN_CNF[pin_number] = cnf;
   11f32:	f844 302c 	str.w	r3, [r4, ip, lsl #2]
        if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   11f36:	784b      	ldrb	r3, [r1, #1]
   11f38:	2bff      	cmp	r3, #255	; 0xff
   11f3a:	d01a      	beq.n	11f72 <configure_pins+0x96>
    *p_pin = pin_number & 0x1F;
   11f3c:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   11f40:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11f42:	2b01      	cmp	r3, #1
   11f44:	d05e      	beq.n	12004 <configure_pins+0x128>
        case 0: return NRF_P0;
   11f46:	4d66      	ldr	r5, [pc, #408]	; (120e0 <configure_pins+0x204>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   11f48:	2301      	movs	r3, #1
   11f4a:	40a3      	lsls	r3, r4
    p_reg->OUTCLR = clr_mask;
   11f4c:	60eb      	str	r3, [r5, #12]
            nrf_gpio_cfg(p_config->mosi_pin,
   11f4e:	784b      	ldrb	r3, [r1, #1]
    *p_pin = pin_number & 0x1F;
   11f50:	f003 0c1f 	and.w	ip, r3, #31
    return pin_number >> 5;
   11f54:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11f56:	2b01      	cmp	r3, #1
   11f58:	d056      	beq.n	12008 <configure_pins+0x12c>
        case 0: return NRF_P0;
   11f5a:	4c61      	ldr	r4, [pc, #388]	; (120e0 <configure_pins+0x204>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   11f5c:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
   11f60:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
   11f64:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   11f68:	f042 0503 	orr.w	r5, r2, #3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   11f6c:	432b      	orrs	r3, r5
    reg->PIN_CNF[pin_number] = cnf;
   11f6e:	f844 302c 	str.w	r3, [r4, ip, lsl #2]
        if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   11f72:	788b      	ldrb	r3, [r1, #2]
   11f74:	2bff      	cmp	r3, #255	; 0xff
   11f76:	d149      	bne.n	1200c <configure_pins+0x130>
        if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   11f78:	78cb      	ldrb	r3, [r1, #3]
   11f7a:	2bff      	cmp	r3, #255	; 0xff
   11f7c:	d15e      	bne.n	1203c <configure_pins+0x160>
        if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   11f7e:	7bcb      	ldrb	r3, [r1, #15]
   11f80:	2bff      	cmp	r3, #255	; 0xff
   11f82:	d01b      	beq.n	11fbc <configure_pins+0xe0>
    *p_pin = pin_number & 0x1F;
   11f84:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   11f88:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11f8a:	2b01      	cmp	r3, #1
   11f8c:	f000 8085 	beq.w	1209a <configure_pins+0x1be>
        case 0: return NRF_P0;
   11f90:	4d53      	ldr	r5, [pc, #332]	; (120e0 <configure_pins+0x204>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   11f92:	2301      	movs	r3, #1
   11f94:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   11f96:	60ab      	str	r3, [r5, #8]
            nrf_gpio_cfg(p_config->dcx_pin,
   11f98:	7bcb      	ldrb	r3, [r1, #15]
    *p_pin = pin_number & 0x1F;
   11f9a:	f003 0c1f 	and.w	ip, r3, #31
    return pin_number >> 5;
   11f9e:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11fa0:	2b01      	cmp	r3, #1
   11fa2:	d07c      	beq.n	1209e <configure_pins+0x1c2>
        case 0: return NRF_P0;
   11fa4:	4c4e      	ldr	r4, [pc, #312]	; (120e0 <configure_pins+0x204>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   11fa6:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
   11faa:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
   11fae:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   11fb2:	f042 0203 	orr.w	r2, r2, #3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   11fb6:	431a      	orrs	r2, r3
    reg->PIN_CNF[pin_number] = cnf;
   11fb8:	f844 202c 	str.w	r2, [r4, ip, lsl #2]
    if (!p_config->skip_psel_cfg)
   11fbc:	7d0b      	ldrb	r3, [r1, #20]
   11fbe:	b96b      	cbnz	r3, 11fdc <configure_pins+0x100>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   11fc0:	784b      	ldrb	r3, [r1, #1]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   11fc2:	2bff      	cmp	r3, #255	; 0xff
   11fc4:	d06d      	beq.n	120a2 <configure_pins+0x1c6>
   11fc6:	461a      	mov	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   11fc8:	788b      	ldrb	r3, [r1, #2]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   11fca:	2bff      	cmp	r3, #255	; 0xff
   11fcc:	d06c      	beq.n	120a8 <configure_pins+0x1cc>
        nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   11fce:	7809      	ldrb	r1, [r1, #0]
    p_reg->PSEL.SCK  = sck_pin;
   11fd0:	f8c0 1508 	str.w	r1, [r0, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
   11fd4:	f8c0 250c 	str.w	r2, [r0, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   11fd8:	f8c0 3510 	str.w	r3, [r0, #1296]	; 0x510
}
   11fdc:	bd30      	pop	{r4, r5, pc}
                    : NRF_GPIO_PIN_S0S1;
   11fde:	f04f 0e03 	mov.w	lr, #3
   11fe2:	e787      	b.n	11ef4 <configure_pins+0x18>
        case 1: return NRF_P1;
   11fe4:	4a3f      	ldr	r2, [pc, #252]	; (120e4 <configure_pins+0x208>)
   11fe6:	e78f      	b.n	11f08 <configure_pins+0x2c>
    *p_pin = pin_number & 0x1F;
   11fe8:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   11fec:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   11fee:	2b01      	cmp	r3, #1
   11ff0:	d004      	beq.n	11ffc <configure_pins+0x120>
        case 0: return NRF_P0;
   11ff2:	4a3b      	ldr	r2, [pc, #236]	; (120e0 <configure_pins+0x204>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   11ff4:	2301      	movs	r3, #1
   11ff6:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   11ff8:	6093      	str	r3, [r2, #8]
}
   11ffa:	e788      	b.n	11f0e <configure_pins+0x32>
        case 1: return NRF_P1;
   11ffc:	4a39      	ldr	r2, [pc, #228]	; (120e4 <configure_pins+0x208>)
   11ffe:	e7f9      	b.n	11ff4 <configure_pins+0x118>
   12000:	4c38      	ldr	r4, [pc, #224]	; (120e4 <configure_pins+0x208>)
   12002:	e78b      	b.n	11f1c <configure_pins+0x40>
   12004:	4d37      	ldr	r5, [pc, #220]	; (120e4 <configure_pins+0x208>)
   12006:	e79f      	b.n	11f48 <configure_pins+0x6c>
   12008:	4c36      	ldr	r4, [pc, #216]	; (120e4 <configure_pins+0x208>)
   1200a:	e7a7      	b.n	11f5c <configure_pins+0x80>
            nrf_gpio_cfg(p_config->miso_pin,
   1200c:	f891 c00e 	ldrb.w	ip, [r1, #14]
    *p_pin = pin_number & 0x1F;
   12010:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   12014:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   12016:	2b01      	cmp	r3, #1
   12018:	d00e      	beq.n	12038 <configure_pins+0x15c>
        case 0: return NRF_P0;
   1201a:	4d31      	ldr	r5, [pc, #196]	; (120e0 <configure_pins+0x204>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   1201c:	3480      	adds	r4, #128	; 0x80
   1201e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   12022:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   12026:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   1202a:	ea4e 0e8c 	orr.w	lr, lr, ip, lsl #2
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   1202e:	ea43 030e 	orr.w	r3, r3, lr
    reg->PIN_CNF[pin_number] = cnf;
   12032:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
}
   12036:	e79f      	b.n	11f78 <configure_pins+0x9c>
        case 1: return NRF_P1;
   12038:	4d2a      	ldr	r5, [pc, #168]	; (120e4 <configure_pins+0x208>)
   1203a:	e7ef      	b.n	1201c <configure_pins+0x140>
                               p_config->ss_active_high ? 0 : 1);
   1203c:	790c      	ldrb	r4, [r1, #4]
    if (value == 0)
   1203e:	2c01      	cmp	r4, #1
   12040:	d11d      	bne.n	1207e <configure_pins+0x1a2>
    *p_pin = pin_number & 0x1F;
   12042:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   12046:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   12048:	2b01      	cmp	r3, #1
   1204a:	d016      	beq.n	1207a <configure_pins+0x19e>
        case 0: return NRF_P0;
   1204c:	4d24      	ldr	r5, [pc, #144]	; (120e0 <configure_pins+0x204>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   1204e:	2301      	movs	r3, #1
   12050:	40a3      	lsls	r3, r4
    p_reg->OUTCLR = clr_mask;
   12052:	60eb      	str	r3, [r5, #12]
            nrf_gpio_cfg(p_config->ss_pin,
   12054:	78cb      	ldrb	r3, [r1, #3]
    *p_pin = pin_number & 0x1F;
   12056:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   1205a:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1205c:	2b01      	cmp	r3, #1
   1205e:	d01a      	beq.n	12096 <configure_pins+0x1ba>
        case 0: return NRF_P0;
   12060:	4d1f      	ldr	r5, [pc, #124]	; (120e0 <configure_pins+0x204>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   12062:	3480      	adds	r4, #128	; 0x80
   12064:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   12068:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   1206c:	f042 0c03 	orr.w	ip, r2, #3
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   12070:	ea43 030c 	orr.w	r3, r3, ip
    reg->PIN_CNF[pin_number] = cnf;
   12074:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
}
   12078:	e781      	b.n	11f7e <configure_pins+0xa2>
        case 1: return NRF_P1;
   1207a:	4d1a      	ldr	r5, [pc, #104]	; (120e4 <configure_pins+0x208>)
   1207c:	e7e7      	b.n	1204e <configure_pins+0x172>
    *p_pin = pin_number & 0x1F;
   1207e:	f003 041f 	and.w	r4, r3, #31
    return pin_number >> 5;
   12082:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   12084:	2b01      	cmp	r3, #1
   12086:	d004      	beq.n	12092 <configure_pins+0x1b6>
        case 0: return NRF_P0;
   12088:	4d15      	ldr	r5, [pc, #84]	; (120e0 <configure_pins+0x204>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1208a:	2301      	movs	r3, #1
   1208c:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   1208e:	60ab      	str	r3, [r5, #8]
}
   12090:	e7e0      	b.n	12054 <configure_pins+0x178>
        case 1: return NRF_P1;
   12092:	4d14      	ldr	r5, [pc, #80]	; (120e4 <configure_pins+0x208>)
   12094:	e7f9      	b.n	1208a <configure_pins+0x1ae>
   12096:	4d13      	ldr	r5, [pc, #76]	; (120e4 <configure_pins+0x208>)
   12098:	e7e3      	b.n	12062 <configure_pins+0x186>
   1209a:	4d12      	ldr	r5, [pc, #72]	; (120e4 <configure_pins+0x208>)
   1209c:	e779      	b.n	11f92 <configure_pins+0xb6>
   1209e:	4c11      	ldr	r4, [pc, #68]	; (120e4 <configure_pins+0x208>)
   120a0:	e781      	b.n	11fa6 <configure_pins+0xca>
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   120a2:	f04f 32ff 	mov.w	r2, #4294967295
   120a6:	e78f      	b.n	11fc8 <configure_pins+0xec>
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   120a8:	f04f 33ff 	mov.w	r3, #4294967295
   120ac:	e78f      	b.n	11fce <configure_pins+0xf2>
    if (!p_config->skip_psel_cfg)
   120ae:	7d0b      	ldrb	r3, [r1, #20]
   120b0:	b9a3      	cbnz	r3, 120dc <configure_pins+0x200>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   120b2:	784b      	ldrb	r3, [r1, #1]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   120b4:	2bff      	cmp	r3, #255	; 0xff
   120b6:	d00b      	beq.n	120d0 <configure_pins+0x1f4>
   120b8:	461a      	mov	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   120ba:	788b      	ldrb	r3, [r1, #2]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   120bc:	2bff      	cmp	r3, #255	; 0xff
   120be:	d00a      	beq.n	120d6 <configure_pins+0x1fa>
        nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   120c0:	7809      	ldrb	r1, [r1, #0]
    p_reg->PSEL.SCK  = sck_pin;
   120c2:	f8c0 1508 	str.w	r1, [r0, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
   120c6:	f8c0 250c 	str.w	r2, [r0, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   120ca:	f8c0 3510 	str.w	r3, [r0, #1296]	; 0x510
   120ce:	4770      	bx	lr
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   120d0:	f04f 32ff 	mov.w	r2, #4294967295
   120d4:	e7f1      	b.n	120ba <configure_pins+0x1de>
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   120d6:	f04f 33ff 	mov.w	r3, #4294967295
   120da:	e7f1      	b.n	120c0 <configure_pins+0x1e4>
   120dc:	4770      	bx	lr
   120de:	bf00      	nop
   120e0:	50842500 	.word	0x50842500
   120e4:	50842800 	.word	0x50842800

000120e8 <nrfx_spim_init>:
{
   120e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   120ea:	460d      	mov	r5, r1
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   120ec:	7906      	ldrb	r6, [r0, #4]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   120ee:	6807      	ldr	r7, [r0, #0]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   120f0:	4939      	ldr	r1, [pc, #228]	; (121d8 <nrfx_spim_init+0xf0>)
   120f2:	eb01 1146 	add.w	r1, r1, r6, lsl #5
   120f6:	7f09      	ldrb	r1, [r1, #28]
   120f8:	2900      	cmp	r1, #0
   120fa:	d162      	bne.n	121c2 <nrfx_spim_init+0xda>
   120fc:	4604      	mov	r4, r0
    if (
   120fe:	2e00      	cmp	r6, #0
   12100:	d161      	bne.n	121c6 <nrfx_spim_init+0xde>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   12102:	68a9      	ldr	r1, [r5, #8]
   12104:	f1b1 6f20 	cmp.w	r1, #167772160	; 0xa000000
   12108:	d05f      	beq.n	121ca <nrfx_spim_init+0xe2>
   1210a:	f1b1 5fa0 	cmp.w	r1, #335544320	; 0x14000000
   1210e:	d05e      	beq.n	121ce <nrfx_spim_init+0xe6>
        ((p_config->use_hw_ss) &&
   12110:	7c69      	ldrb	r1, [r5, #17]
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   12112:	2900      	cmp	r1, #0
   12114:	d15d      	bne.n	121d2 <nrfx_spim_init+0xea>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   12116:	7be9      	ldrb	r1, [r5, #15]
         !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
   12118:	29ff      	cmp	r1, #255	; 0xff
   1211a:	d001      	beq.n	12120 <nrfx_spim_init+0x38>
        return err_code;
   1211c:	482f      	ldr	r0, [pc, #188]	; (121dc <nrfx_spim_init+0xf4>)
   1211e:	e051      	b.n	121c4 <nrfx_spim_init+0xdc>
    p_cb->handler = handler;
   12120:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 121d8 <nrfx_spim_init+0xf0>
   12124:	0170      	lsls	r0, r6, #5
   12126:	eb0c 1146 	add.w	r1, ip, r6, lsl #5
   1212a:	f84c 2000 	str.w	r2, [ip, r0]
    p_cb->p_context = p_context;
   1212e:	604b      	str	r3, [r1, #4]
    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
   12130:	7ce8      	ldrb	r0, [r5, #19]
   12132:	7f8a      	ldrb	r2, [r1, #30]
   12134:	f360 0200 	bfi	r2, r0, #0, #1
   12138:	778a      	strb	r2, [r1, #30]
    p_cb->ss_active_high = p_config->ss_active_high;
   1213a:	7928      	ldrb	r0, [r5, #4]
   1213c:	b2d2      	uxtb	r2, r2
   1213e:	f360 0241 	bfi	r2, r0, #1, #1
   12142:	778a      	strb	r2, [r1, #30]
    p_cb->use_hw_ss = p_config->use_hw_ss;
   12144:	7c68      	ldrb	r0, [r5, #17]
   12146:	b2d2      	uxtb	r2, r2
   12148:	f360 0282 	bfi	r2, r0, #2, #1
   1214c:	778a      	strb	r2, [r1, #30]
    p_cb->ss_pin = p_config->ss_pin;
   1214e:	78eb      	ldrb	r3, [r5, #3]
   12150:	77cb      	strb	r3, [r1, #31]
    configure_pins(p_instance, p_config);
   12152:	4629      	mov	r1, r5
   12154:	4620      	mov	r0, r4
   12156:	f7ff fec1 	bl	11edc <configure_pins>
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
   1215a:	7c2b      	ldrb	r3, [r5, #16]
    p_reg->IFTIMING.RXDELAY = rxdelay;
   1215c:	f8c7 3560 	str.w	r3, [r7, #1376]	; 0x560
    nrf_spim_frequency_set(p_spim, p_config->frequency);
   12160:	68ab      	ldr	r3, [r5, #8]
    p_reg->FREQUENCY = (uint32_t)frequency;
   12162:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   12166:	7b2a      	ldrb	r2, [r5, #12]
   12168:	7b6b      	ldrb	r3, [r5, #13]
NRF_STATIC_INLINE void nrf_spim_configure(NRF_SPIM_Type *      p_reg,
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   1216a:	3b00      	subs	r3, #0
   1216c:	bf18      	it	ne
   1216e:	2301      	movne	r3, #1
    switch (spi_mode)
   12170:	2a02      	cmp	r2, #2
   12172:	d020      	beq.n	121b6 <nrfx_spim_init+0xce>
   12174:	2a03      	cmp	r2, #3
   12176:	d021      	beq.n	121bc <nrfx_spim_init+0xd4>
   12178:	2a01      	cmp	r2, #1
   1217a:	d019      	beq.n	121b0 <nrfx_spim_init+0xc8>
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   1217c:	f8c7 3554 	str.w	r3, [r7, #1364]	; 0x554
    nrf_spim_orc_set(p_spim, p_config->orc);
   12180:	79ab      	ldrb	r3, [r5, #6]
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   12182:	f8c7 35c0 	str.w	r3, [r7, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   12186:	2307      	movs	r3, #7
   12188:	f8c7 3500 	str.w	r3, [r7, #1280]	; 0x500
    if (p_cb->handler)
   1218c:	0173      	lsls	r3, r6, #5
   1218e:	4a12      	ldr	r2, [pc, #72]	; (121d8 <nrfx_spim_init+0xf0>)
   12190:	58d3      	ldr	r3, [r2, r3]
   12192:	b123      	cbz	r3, 1219e <nrfx_spim_init+0xb6>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   12194:	6820      	ldr	r0, [r4, #0]
   12196:	f340 3007 	sbfx	r0, r0, #12, #8
   1219a:	f7f1 ff33 	bl	4004 <arch_irq_enable>
    p_cb->transfer_in_progress = false;
   1219e:	4b0e      	ldr	r3, [pc, #56]	; (121d8 <nrfx_spim_init+0xf0>)
   121a0:	eb03 1646 	add.w	r6, r3, r6, lsl #5
   121a4:	2300      	movs	r3, #0
   121a6:	7773      	strb	r3, [r6, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   121a8:	2301      	movs	r3, #1
   121aa:	7733      	strb	r3, [r6, #28]
    return err_code;
   121ac:	480c      	ldr	r0, [pc, #48]	; (121e0 <nrfx_spim_init+0xf8>)
   121ae:	e009      	b.n	121c4 <nrfx_spim_init+0xdc>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   121b0:	f043 0302 	orr.w	r3, r3, #2
        break;
   121b4:	e7e2      	b.n	1217c <nrfx_spim_init+0x94>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   121b6:	f043 0304 	orr.w	r3, r3, #4
        break;
   121ba:	e7df      	b.n	1217c <nrfx_spim_init+0x94>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   121bc:	f043 0306 	orr.w	r3, r3, #6
        break;
   121c0:	e7dc      	b.n	1217c <nrfx_spim_init+0x94>
        return err_code;
   121c2:	4808      	ldr	r0, [pc, #32]	; (121e4 <nrfx_spim_init+0xfc>)
}
   121c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return err_code;
   121c6:	4805      	ldr	r0, [pc, #20]	; (121dc <nrfx_spim_init+0xf4>)
   121c8:	e7fc      	b.n	121c4 <nrfx_spim_init+0xdc>
   121ca:	4804      	ldr	r0, [pc, #16]	; (121dc <nrfx_spim_init+0xf4>)
   121cc:	e7fa      	b.n	121c4 <nrfx_spim_init+0xdc>
   121ce:	4803      	ldr	r0, [pc, #12]	; (121dc <nrfx_spim_init+0xf4>)
   121d0:	e7f8      	b.n	121c4 <nrfx_spim_init+0xdc>
   121d2:	4802      	ldr	r0, [pc, #8]	; (121dc <nrfx_spim_init+0xf4>)
   121d4:	e7f6      	b.n	121c4 <nrfx_spim_init+0xdc>
   121d6:	bf00      	nop
   121d8:	20002664 	.word	0x20002664
   121dc:	0bad0003 	.word	0x0bad0003
   121e0:	0bad0000 	.word	0x0bad0000
   121e4:	0bad0005 	.word	0x0bad0005

000121e8 <nrfx_spim_uninit>:
{
   121e8:	b570      	push	{r4, r5, r6, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   121ea:	7904      	ldrb	r4, [r0, #4]
   121ec:	4b24      	ldr	r3, [pc, #144]	; (12280 <nrfx_spim_uninit+0x98>)
   121ee:	0162      	lsls	r2, r4, #5
   121f0:	eb03 1644 	add.w	r6, r3, r4, lsl #5
    NRF_SPIM_Type * p_spim = p_instance->p_reg;
   121f4:	6805      	ldr	r5, [r0, #0]
    if (p_cb->handler)
   121f6:	589b      	ldr	r3, [r3, r2]
   121f8:	b143      	cbz	r3, 1220c <nrfx_spim_uninit+0x24>
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
   121fa:	f345 3007 	sbfx	r0, r5, #12, #8
   121fe:	f7f1 ff0f 	bl	4020 <arch_irq_disable>
    p_reg->INTENCLR = mask;
   12202:	4b20      	ldr	r3, [pc, #128]	; (12284 <nrfx_spim_uninit+0x9c>)
   12204:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
        if (p_cb->transfer_in_progress)
   12208:	7f73      	ldrb	r3, [r6, #29]
   1220a:	b97b      	cbnz	r3, 1222c <nrfx_spim_uninit+0x44>
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Disabled << SPIM_ENABLE_ENABLE_Pos);
   1220c:	2300      	movs	r3, #0
   1220e:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
    if (!p_cb->skip_gpio_cfg)
   12212:	4b1b      	ldr	r3, [pc, #108]	; (12280 <nrfx_spim_uninit+0x98>)
   12214:	eb03 1344 	add.w	r3, r3, r4, lsl #5
   12218:	7f9b      	ldrb	r3, [r3, #30]
   1221a:	f013 0f01 	tst.w	r3, #1
   1221e:	d00a      	beq.n	12236 <nrfx_spim_uninit+0x4e>
    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   12220:	4b17      	ldr	r3, [pc, #92]	; (12280 <nrfx_spim_uninit+0x98>)
   12222:	eb03 1444 	add.w	r4, r3, r4, lsl #5
   12226:	2300      	movs	r3, #0
   12228:	7723      	strb	r3, [r4, #28]
}
   1222a:	bd70      	pop	{r4, r5, r6, pc}
            spim_abort(p_spim, p_cb);
   1222c:	4631      	mov	r1, r6
   1222e:	4628      	mov	r0, r5
   12230:	f008 fefe 	bl	1b030 <spim_abort>
   12234:	e7ea      	b.n	1220c <nrfx_spim_uninit+0x24>
    return p_reg->PSEL.SCK;
   12236:	f8d5 0508 	ldr.w	r0, [r5, #1288]	; 0x508
        spim_pin_uninit(nrf_spim_sck_pin_get(p_spim));
   1223a:	f7ff fdc1 	bl	11dc0 <spim_pin_uninit>
    return p_reg->PSEL.MISO;
   1223e:	f8d5 0510 	ldr.w	r0, [r5, #1296]	; 0x510
        spim_pin_uninit(nrf_spim_miso_pin_get(p_spim));
   12242:	f7ff fdbd 	bl	11dc0 <spim_pin_uninit>
    return p_reg->PSEL.MOSI;
   12246:	f8d5 050c 	ldr.w	r0, [r5, #1292]	; 0x50c
        spim_pin_uninit(nrf_spim_mosi_pin_get(p_spim));
   1224a:	f7ff fdb9 	bl	11dc0 <spim_pin_uninit>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   1224e:	4b0c      	ldr	r3, [pc, #48]	; (12280 <nrfx_spim_uninit+0x98>)
   12250:	eb03 1344 	add.w	r3, r3, r4, lsl #5
   12254:	7fdb      	ldrb	r3, [r3, #31]
   12256:	2bff      	cmp	r3, #255	; 0xff
   12258:	d0e2      	beq.n	12220 <nrfx_spim_uninit+0x38>
    *p_pin = pin_number & 0x1F;
   1225a:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
   1225e:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   12260:	2b01      	cmp	r3, #1
   12262:	d00a      	beq.n	1227a <nrfx_spim_uninit+0x92>
        case 0: return NRF_P0;
   12264:	4908      	ldr	r1, [pc, #32]	; (12288 <nrfx_spim_uninit+0xa0>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   12266:	3280      	adds	r2, #128	; 0x80
   12268:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
   1226c:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   12270:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
   12274:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
   12278:	e7d2      	b.n	12220 <nrfx_spim_uninit+0x38>
        case 1: return NRF_P1;
   1227a:	4904      	ldr	r1, [pc, #16]	; (1228c <nrfx_spim_uninit+0xa4>)
   1227c:	e7f3      	b.n	12266 <nrfx_spim_uninit+0x7e>
   1227e:	bf00      	nop
   12280:	20002664 	.word	0x20002664
   12284:	00080152 	.word	0x00080152
   12288:	50842500 	.word	0x50842500
   1228c:	50842800 	.word	0x50842800

00012290 <nrfx_spim_xfer>:

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   12290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   12294:	f890 c004 	ldrb.w	ip, [r0, #4]
   12298:	4e14      	ldr	r6, [pc, #80]	; (122ec <nrfx_spim_xfer+0x5c>)
   1229a:	eb06 164c 	add.w	r6, r6, ip, lsl #5
#endif
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   1229e:	7f73      	ldrb	r3, [r6, #29]
   122a0:	bb0b      	cbnz	r3, 122e6 <nrfx_spim_xfer+0x56>
   122a2:	4607      	mov	r7, r0
   122a4:	460d      	mov	r5, r1
   122a6:	4690      	mov	r8, r2
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   122a8:	ea4f 134c 	mov.w	r3, ip, lsl #5
   122ac:	4a0f      	ldr	r2, [pc, #60]	; (122ec <nrfx_spim_xfer+0x5c>)
   122ae:	58d3      	ldr	r3, [r2, r3]
   122b0:	b123      	cbz	r3, 122bc <nrfx_spim_xfer+0x2c>
   122b2:	f018 0f14 	tst.w	r8, #20
   122b6:	d101      	bne.n	122bc <nrfx_spim_xfer+0x2c>
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   122b8:	2201      	movs	r2, #1
   122ba:	7772      	strb	r2, [r6, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   122bc:	4c0b      	ldr	r4, [pc, #44]	; (122ec <nrfx_spim_xfer+0x5c>)
   122be:	eb04 1c4c 	add.w	ip, r4, ip, lsl #5
   122c2:	f10c 0c0c 	add.w	ip, ip, #12
   122c6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   122ca:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    set_ss_pin_state(p_cb, true);
   122ce:	2101      	movs	r1, #1
   122d0:	4630      	mov	r0, r6
   122d2:	f7ff fd8f 	bl	11df4 <set_ss_pin_state>

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   122d6:	4643      	mov	r3, r8
   122d8:	462a      	mov	r2, r5
   122da:	4631      	mov	r1, r6
   122dc:	6838      	ldr	r0, [r7, #0]
   122de:	f7ff fdb3 	bl	11e48 <spim_xfer>
}
   122e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return err_code;
   122e6:	4802      	ldr	r0, [pc, #8]	; (122f0 <nrfx_spim_xfer+0x60>)
   122e8:	e7fb      	b.n	122e2 <nrfx_spim_xfer+0x52>
   122ea:	bf00      	nop
   122ec:	20002664 	.word	0x20002664
   122f0:	0bad000b 	.word	0x0bad000b

000122f4 <nrfx_spim_3_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
   122f4:	b508      	push	{r3, lr}
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
   122f6:	4902      	ldr	r1, [pc, #8]	; (12300 <nrfx_spim_3_irq_handler+0xc>)
   122f8:	4802      	ldr	r0, [pc, #8]	; (12304 <nrfx_spim_3_irq_handler+0x10>)
   122fa:	f008 feb8 	bl	1b06e <irq_handler>
}
   122fe:	bd08      	pop	{r3, pc}
   12300:	20002664 	.word	0x20002664
   12304:	5000c000 	.word	0x5000c000

00012308 <twi_process_error>:
} twim_control_block_t;

static twim_control_block_t m_cb[NRFX_TWIM_ENABLED_COUNT];

static nrfx_err_t twi_process_error(uint32_t errorsrc)
{
   12308:	4603      	mov	r3, r0
    nrfx_err_t ret = NRFX_ERROR_INTERNAL;

    if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   1230a:	f010 0f01 	tst.w	r0, #1
   1230e:	d108      	bne.n	12322 <twi_process_error+0x1a>
    nrfx_err_t ret = NRFX_ERROR_INTERNAL;
   12310:	4806      	ldr	r0, [pc, #24]	; (1232c <twi_process_error+0x24>)
    {
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
    }

    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   12312:	f013 0f02 	tst.w	r3, #2
   12316:	d000      	beq.n	1231a <twi_process_error+0x12>
    {
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   12318:	4805      	ldr	r0, [pc, #20]	; (12330 <twi_process_error+0x28>)
    }

    if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   1231a:	f013 0f04 	tst.w	r3, #4
   1231e:	d102      	bne.n	12326 <twi_process_error+0x1e>
    {
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    }

    return ret;
}
   12320:	4770      	bx	lr
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   12322:	4804      	ldr	r0, [pc, #16]	; (12334 <twi_process_error+0x2c>)
   12324:	e7f5      	b.n	12312 <twi_process_error+0xa>
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   12326:	4804      	ldr	r0, [pc, #16]	; (12338 <twi_process_error+0x30>)
    return ret;
   12328:	e7fa      	b.n	12320 <twi_process_error+0x18>
   1232a:	bf00      	nop
   1232c:	0bad0001 	.word	0x0bad0001
   12330:	0bae0001 	.word	0x0bae0001
   12334:	0bae0000 	.word	0x0bae0000
   12338:	0bae0002 	.word	0x0bae0002

0001233c <twim_pins_configure>:

    return transfer_complete;
}

static bool twim_pins_configure(NRF_TWIM_Type * p_twim, nrfx_twim_config_t const * p_config)
{
   1233c:	4684      	mov	ip, r0
    // If both GPIO configuration and pin selection are to be skipped,
    // the pin numbers may be not specified at all, so even validation
    // of those numbers cannot be performed.
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   1233e:	7b8b      	ldrb	r3, [r1, #14]
   12340:	b113      	cbz	r3, 12348 <twim_pins_configure+0xc>
   12342:	7bc8      	ldrb	r0, [r1, #15]
   12344:	2800      	cmp	r0, #0
   12346:	d149      	bne.n	123dc <twim_pins_configure+0xa0>
    }

    nrf_gpio_pin_drive_t drive;

#if NRF_TWIM_HAS_1000_KHZ_FREQ && defined(NRF5340_XXAA)
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   12348:	688a      	ldr	r2, [r1, #8]
   1234a:	f1b2 6f7f 	cmp.w	r2, #267386880	; 0xff00000
   1234e:	d30e      	bcc.n	1236e <twim_pins_configure+0x32>

        uint32_t e0e1_pin_1 = NRF_GPIO_PIN_MAP(1, 2);
        uint32_t e0e1_pin_2 = NRF_GPIO_PIN_MAP(1, 3);

        /* Check whether provided pins have the extra high drive capabilities. */
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   12350:	680a      	ldr	r2, [r1, #0]
   12352:	2a22      	cmp	r2, #34	; 0x22
   12354:	d006      	beq.n	12364 <twim_pins_configure+0x28>
   12356:	2a23      	cmp	r2, #35	; 0x23
   12358:	d13c      	bne.n	123d4 <twim_pins_configure+0x98>
            ((p_config->scl != e0e1_pin_2) || (p_config->sda != e0e1_pin_1)))
   1235a:	684a      	ldr	r2, [r1, #4]
   1235c:	2a22      	cmp	r2, #34	; 0x22
   1235e:	d13b      	bne.n	123d8 <twim_pins_configure+0x9c>
        drive = NRF_GPIO_PIN_E0E1;
   12360:	220b      	movs	r2, #11
   12362:	e005      	b.n	12370 <twim_pins_configure+0x34>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   12364:	6848      	ldr	r0, [r1, #4]
   12366:	2823      	cmp	r0, #35	; 0x23
   12368:	d1f5      	bne.n	12356 <twim_pins_configure+0x1a>
        drive = NRF_GPIO_PIN_E0E1;
   1236a:	220b      	movs	r2, #11
   1236c:	e000      	b.n	12370 <twim_pins_configure+0x34>
        }
    }
    else
#endif
    {
        drive = NRF_GPIO_PIN_S0D1;
   1236e:	2206      	movs	r2, #6
{
   12370:	b510      	push	{r4, lr}

    /* To secure correct signal levels on the pins used by the TWI
       master when the system is in OFF mode, and when the TWI master is
       disabled, these pins must be configured in the GPIO peripheral.
    */
    if (!p_config->skip_gpio_cfg)
   12372:	bb0b      	cbnz	r3, 123b8 <twim_pins_configure+0x7c>
    {
        TWIM_PIN_INIT(p_config->scl, drive);
   12374:	680b      	ldr	r3, [r1, #0]
    *p_pin = pin_number & 0x1F;
   12376:	f003 0e1f 	and.w	lr, r3, #31
    return pin_number >> 5;
   1237a:	095b      	lsrs	r3, r3, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   1237c:	2b01      	cmp	r3, #1
   1237e:	d025      	beq.n	123cc <twim_pins_configure+0x90>
        case 0: return NRF_P0;
   12380:	4c17      	ldr	r4, [pc, #92]	; (123e0 <twim_pins_configure+0xa4>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   12382:	f10e 0e80 	add.w	lr, lr, #128	; 0x80
   12386:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
   1238a:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   1238e:	0213      	lsls	r3, r2, #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   12390:	f043 030c 	orr.w	r3, r3, #12
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   12394:	4318      	orrs	r0, r3
    reg->PIN_CNF[pin_number] = cnf;
   12396:	f844 002e 	str.w	r0, [r4, lr, lsl #2]
        TWIM_PIN_INIT(p_config->sda, drive);
   1239a:	684a      	ldr	r2, [r1, #4]
    *p_pin = pin_number & 0x1F;
   1239c:	f002 001f 	and.w	r0, r2, #31
    return pin_number >> 5;
   123a0:	0952      	lsrs	r2, r2, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   123a2:	2a01      	cmp	r2, #1
   123a4:	d014      	beq.n	123d0 <twim_pins_configure+0x94>
        case 0: return NRF_P0;
   123a6:	4c0e      	ldr	r4, [pc, #56]	; (123e0 <twim_pins_configure+0xa4>)
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   123a8:	3080      	adds	r0, #128	; 0x80
   123aa:	f854 2020 	ldr.w	r2, [r4, r0, lsl #2]
   123ae:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   123b2:	4313      	orrs	r3, r2
    reg->PIN_CNF[pin_number] = cnf;
   123b4:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
    }

    if (!p_config->skip_psel_cfg)
   123b8:	7bc8      	ldrb	r0, [r1, #15]
   123ba:	b930      	cbnz	r0, 123ca <twim_pins_configure+0x8e>
    {
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   123bc:	680a      	ldr	r2, [r1, #0]
   123be:	684b      	ldr	r3, [r1, #4]
    p_reg->PSEL.SCL = scl_pin;
   123c0:	f8cc 2508 	str.w	r2, [ip, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   123c4:	f8cc 350c 	str.w	r3, [ip, #1292]	; 0x50c
    }

    return true;
   123c8:	2001      	movs	r0, #1
}
   123ca:	bd10      	pop	{r4, pc}
        case 1: return NRF_P1;
   123cc:	4c05      	ldr	r4, [pc, #20]	; (123e4 <twim_pins_configure+0xa8>)
   123ce:	e7d8      	b.n	12382 <twim_pins_configure+0x46>
   123d0:	4c04      	ldr	r4, [pc, #16]	; (123e4 <twim_pins_configure+0xa8>)
   123d2:	e7e9      	b.n	123a8 <twim_pins_configure+0x6c>
            return false;
   123d4:	2000      	movs	r0, #0
   123d6:	4770      	bx	lr
   123d8:	2000      	movs	r0, #0
   123da:	4770      	bx	lr
}
   123dc:	4770      	bx	lr
   123de:	bf00      	nop
   123e0:	50842500 	.word	0x50842500
   123e4:	50842800 	.word	0x50842800

000123e8 <twim_xfer>:
}
static nrfx_err_t twim_xfer(twim_control_block_t        * p_cb,
                            NRF_TWIM_Type               * p_twim,
                            nrfx_twim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
   123e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   123ec:	4605      	mov	r5, r0
   123ee:	460c      	mov	r4, r1
   123f0:	4616      	mov	r6, r2
   123f2:	461f      	mov	r7, r3
    nrfx_err_t err_code = NRFX_SUCCESS;
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    p_cb->error = false;
   123f4:	2300      	movs	r3, #0
   123f6:	f880 302e 	strb.w	r3, [r0, #46]	; 0x2e

    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   123fa:	6853      	ldr	r3, [r2, #4]
   123fc:	b133      	cbz	r3, 1240c <twim_xfer+0x24>
   123fe:	68d3      	ldr	r3, [r2, #12]
   12400:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   12404:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   12408:	f040 8131 	bne.w	1266e <twim_xfer+0x286>
    p_reg->INTENCLR = mask;
   1240c:	4b9c      	ldr	r3, [pc, #624]	; (12680 <twim_xfer+0x298>)
   1240e:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    /* Block TWI interrupts to ensure that function is not interrupted by TWI interrupt. */
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    if (p_cb->busy)
   12412:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   12416:	f003 08ff 	and.w	r8, r3, #255	; 0xff
   1241a:	2b00      	cmp	r3, #0
   1241c:	d136      	bne.n	1248c <twim_xfer+0xa4>
        return err_code;
    }
    else
    {
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   1241e:	f017 0f14 	tst.w	r7, #20
   12422:	bf0c      	ite	eq
   12424:	2301      	moveq	r3, #1
   12426:	2300      	movne	r3, #0
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   12428:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    }

    p_cb->xfer_desc = *p_xfer_desc;
   1242c:	f105 0c0c 	add.w	ip, r5, #12
   12430:	46b6      	mov	lr, r6
   12432:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   12436:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   1243a:	f8de 3000 	ldr.w	r3, [lr]
   1243e:	f8cc 3000 	str.w	r3, [ip]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   12442:	f3c7 1300 	ubfx	r3, r7, #4, #1
   12446:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
    p_cb->flags = flags;
   1244a:	622f      	str	r7, [r5, #32]
    nrf_twim_address_set(p_twim, p_xfer_desc->address);
   1244c:	7873      	ldrb	r3, [r6, #1]
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   1244e:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12452:	2300      	movs	r3, #0
   12454:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   12458:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
   1245c:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
   12460:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
   12464:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
   12468:	f8d4 2160 	ldr.w	r2, [r4, #352]	; 0x160
   1246c:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   12470:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_STOPPED);
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_ERROR);
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_LASTTX);
    nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_SUSPENDED);

    twim_list_enable_handle(p_twim, flags);
   12474:	4639      	mov	r1, r7
   12476:	4620      	mov	r0, r4
   12478:	f008 fe49 	bl	1b10e <twim_list_enable_handle>
    switch (p_xfer_desc->type)
   1247c:	7833      	ldrb	r3, [r6, #0]
   1247e:	2b03      	cmp	r3, #3
   12480:	f200 80a8 	bhi.w	125d4 <twim_xfer+0x1ec>
   12484:	e8df f003 	tbb	[pc, r3]
   12488:	08379455 	.word	0x08379455
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   1248c:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   1248e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
        return err_code;
   12492:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 12684 <twim_xfer+0x29c>
   12496:	e081      	b.n	1259c <twim_xfer+0x1b4>
    {
    case NRFX_TWIM_XFER_TXTX:
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   12498:	6933      	ldr	r3, [r6, #16]
   1249a:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   1249e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   124a2:	f040 80e7 	bne.w	12674 <twim_xfer+0x28c>
}

NRF_STATIC_INLINE void nrf_twim_shorts_set(NRF_TWIM_Type * p_reg,
                                           uint32_t mask)
{
    p_reg->SHORTS = mask;
   124a6:	f44f 7380 	mov.w	r3, #256	; 0x100
   124aa:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
                             __func__,
                             NRFX_LOG_ERROR_STRING_GET(err_code));
            return err_code;
        }
        nrf_twim_shorts_set(p_twim, NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK);
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   124ae:	68f2      	ldr	r2, [r6, #12]
   124b0:	6873      	ldr	r3, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   124b2:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   124b6:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   124ba:	2300      	movs	r3, #0
   124bc:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   124c0:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   124c4:	2301      	movs	r3, #1
   124c6:	6223      	str	r3, [r4, #32]
   124c8:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   124ca:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_TXSTARTED);
        nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_RESUME);
        nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_STARTTX);
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   124ce:	2b00      	cmp	r3, #0
   124d0:	d0fb      	beq.n	124ca <twim_xfer+0xe2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   124d2:	2300      	movs	r3, #0
   124d4:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   124d8:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
        {}
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_TXSTARTED));
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_TXSTARTED);
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   124dc:	6932      	ldr	r2, [r6, #16]
   124de:	68b3      	ldr	r3, [r6, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   124e0:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   124e4:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   124e8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   124ec:	60ab      	str	r3, [r5, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   124ee:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   124f0:	f8df 9194 	ldr.w	r9, [pc, #404]	; 12688 <twim_xfer+0x2a0>
        break;
   124f4:	e032      	b.n	1255c <twim_xfer+0x174>
    case NRFX_TWIM_XFER_TXRX:
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   124f6:	68f2      	ldr	r2, [r6, #12]
   124f8:	6873      	ldr	r3, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   124fa:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   124fe:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   12502:	6933      	ldr	r3, [r6, #16]
   12504:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
   12508:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   1250c:	f040 80b5 	bne.w	1267a <twim_xfer+0x292>
            NRFX_LOG_WARNING("Function: %s, error code: %s.",
                             __func__,
                             NRFX_LOG_ERROR_STRING_GET(err_code));
            return err_code;
        }
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   12510:	68b2      	ldr	r2, [r6, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   12512:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   12516:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   1251a:	f44f 5384 	mov.w	r3, #4224	; 0x1080
   1251e:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_shorts_set(p_twim, NRF_TWIM_SHORT_LASTTX_STARTRX_MASK |
                                    NRF_TWIM_SHORT_LASTRX_STOP_MASK);
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   12522:	2302      	movs	r3, #2
   12524:	60ab      	str	r3, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12526:	2301      	movs	r3, #1
   12528:	6223      	str	r3, [r4, #32]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   1252a:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   1252c:	f8df 9158 	ldr.w	r9, [pc, #344]	; 12688 <twim_xfer+0x2a0>
}
   12530:	e014      	b.n	1255c <twim_xfer+0x174>
        nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_RESUME);
        break;
    case NRFX_TWIM_XFER_TX:
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   12532:	68f2      	ldr	r2, [r6, #12]
   12534:	6873      	ldr	r3, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   12536:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1253a:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   1253e:	f017 0f20 	tst.w	r7, #32
   12542:	d02e      	beq.n	125a2 <twim_xfer+0x1ba>
    p_reg->SHORTS = mask;
   12544:	f44f 7380 	mov.w	r3, #256	; 0x100
   12548:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        {
            nrf_twim_shorts_set(p_twim, NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK);
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   1254c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   12550:	60ab      	str	r3, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12552:	2301      	movs	r3, #1
   12554:	6223      	str	r3, [r4, #32]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   12556:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   12558:	f8df 912c 	ldr.w	r9, [pc, #300]	; 12688 <twim_xfer+0x2a0>
    default:
        err_code = NRFX_ERROR_INVALID_PARAM;
        break;
    }

    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   1255c:	f017 0f08 	tst.w	r7, #8
   12560:	d107      	bne.n	12572 <twim_xfer+0x18a>
   12562:	7832      	ldrb	r2, [r6, #0]
   12564:	2a03      	cmp	r2, #3
   12566:	d004      	beq.n	12572 <twim_xfer+0x18a>
   12568:	2201      	movs	r2, #1
   1256a:	50e2      	str	r2, [r4, r3]
    {
        nrf_twim_task_trigger(p_twim, start_task);
        if (p_xfer_desc->primary_length == 0)
   1256c:	6873      	ldr	r3, [r6, #4]
   1256e:	b903      	cbnz	r3, 12572 <twim_xfer+0x18a>
   12570:	6162      	str	r2, [r4, #20]
        {
            nrf_twim_task_trigger(p_twim, NRF_TWIM_TASK_STOP);
        }
    }

    if (p_cb->handler)
   12572:	682b      	ldr	r3, [r5, #0]
   12574:	b393      	cbz	r3, 125dc <twim_xfer+0x1f4>
    {
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   12576:	f017 0f04 	tst.w	r7, #4
   1257a:	d001      	beq.n	12580 <twim_xfer+0x198>
        {
            p_cb->int_mask = 0;
   1257c:	2300      	movs	r3, #0
   1257e:	60ab      	str	r3, [r5, #8]
        }

        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   12580:	f017 0f40 	tst.w	r7, #64	; 0x40
   12584:	d103      	bne.n	1258e <twim_xfer+0x1a6>
        {
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   12586:	68ab      	ldr	r3, [r5, #8]
   12588:	f043 0302 	orr.w	r3, r3, #2
   1258c:	60ab      	str	r3, [r5, #8]
        }

        // Interrupts for ERROR are implicitly enabled, regardless of driver configuration.
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   1258e:	68ab      	ldr	r3, [r5, #8]
   12590:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   12594:	60ab      	str	r3, [r5, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   12596:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   12598:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
                err_code = NRFX_ERROR_INTERNAL;
            }
        }
    }
    return err_code;
}
   1259c:	4648      	mov	r0, r9
   1259e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    p_reg->SHORTS = mask;
   125a2:	f44f 7300 	mov.w	r3, #512	; 0x200
   125a6:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   125aa:	2302      	movs	r3, #2
   125ac:	60ab      	str	r3, [r5, #8]
   125ae:	e7d0      	b.n	12552 <twim_xfer+0x16a>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   125b0:	68f2      	ldr	r2, [r6, #12]
   125b2:	6873      	ldr	r3, [r6, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   125b4:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   125b8:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   125bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   125c0:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   125c4:	2302      	movs	r3, #2
   125c6:	60ab      	str	r3, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   125c8:	2301      	movs	r3, #1
   125ca:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   125cc:	2300      	movs	r3, #0
    nrfx_err_t err_code = NRFX_SUCCESS;
   125ce:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 12688 <twim_xfer+0x2a0>
}
   125d2:	e7c3      	b.n	1255c <twim_xfer+0x174>
    switch (p_xfer_desc->type)
   125d4:	2308      	movs	r3, #8
   125d6:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 1268c <twim_xfer+0x2a4>
   125da:	e7bf      	b.n	1255c <twim_xfer+0x174>
        bool transmission_finished = false;
   125dc:	4643      	mov	r3, r8
   125de:	e000      	b.n	125e2 <twim_xfer+0x1fa>
        } while (!transmission_finished);
   125e0:	bb6b      	cbnz	r3, 1263e <twim_xfer+0x256>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   125e2:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   125e6:	b102      	cbz	r2, 125ea <twim_xfer+0x202>
                transmission_finished = true;
   125e8:	2301      	movs	r3, #1
   125ea:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   125ee:	b12a      	cbz	r2, 125fc <twim_xfer+0x214>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   125f0:	2300      	movs	r3, #0
   125f2:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   125f6:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   125fa:	2301      	movs	r3, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   125fc:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   12600:	2a00      	cmp	r2, #0
   12602:	d0ed      	beq.n	125e0 <twim_xfer+0x1f8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12604:	2200      	movs	r2, #0
   12606:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
   1260a:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1260e:	f8d4 2160 	ldr.w	r2, [r4, #352]	; 0x160
}

NRF_STATIC_INLINE uint32_t nrf_twim_shorts_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->SHORTS;
   12612:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   12616:	b112      	cbz	r2, 1261e <twim_xfer+0x236>
   12618:	f411 7f00 	tst.w	r1, #512	; 0x200
   1261c:	d103      	bne.n	12626 <twim_xfer+0x23e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1261e:	2301      	movs	r3, #1
   12620:	6223      	str	r3, [r4, #32]
   12622:	6163      	str	r3, [r4, #20]
                    transmission_finished = false;
   12624:	4643      	mov	r3, r8
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   12626:	2a00      	cmp	r2, #0
   12628:	d0da      	beq.n	125e0 <twim_xfer+0x1f8>
   1262a:	f411 7f80 	tst.w	r1, #256	; 0x100
   1262e:	d0d7      	beq.n	125e0 <twim_xfer+0x1f8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12630:	2300      	movs	r3, #0
   12632:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   12636:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   1263a:	4643      	mov	r3, r8
   1263c:	e7d1      	b.n	125e2 <twim_xfer+0x1fa>
    uint32_t error_source = p_reg->ERRORSRC;
   1263e:	f8d4 04c4 	ldr.w	r0, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   12642:	f8c4 04c4 	str.w	r0, [r4, #1220]	; 0x4c4
        p_cb->busy = false;
   12646:	2300      	movs	r3, #0
   12648:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
        if (errorsrc)
   1264c:	b118      	cbz	r0, 12656 <twim_xfer+0x26e>
            err_code = twi_process_error(errorsrc);
   1264e:	f7ff fe5b 	bl	12308 <twi_process_error>
   12652:	4681      	mov	r9, r0
   12654:	e7a2      	b.n	1259c <twim_xfer+0x1b4>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   12656:	f017 0f40 	tst.w	r7, #64	; 0x40
   1265a:	d19f      	bne.n	1259c <twim_xfer+0x1b4>
                !xfer_completeness_check(p_twim, p_cb))
   1265c:	4629      	mov	r1, r5
   1265e:	4620      	mov	r0, r4
   12660:	f008 fd14 	bl	1b08c <xfer_completeness_check>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   12664:	2800      	cmp	r0, #0
   12666:	d199      	bne.n	1259c <twim_xfer+0x1b4>
                err_code = NRFX_ERROR_INTERNAL;
   12668:	f8df 9024 	ldr.w	r9, [pc, #36]	; 12690 <twim_xfer+0x2a8>
   1266c:	e796      	b.n	1259c <twim_xfer+0x1b4>
        return err_code;
   1266e:	f8df 9024 	ldr.w	r9, [pc, #36]	; 12694 <twim_xfer+0x2ac>
   12672:	e793      	b.n	1259c <twim_xfer+0x1b4>
            return err_code;
   12674:	f8df 901c 	ldr.w	r9, [pc, #28]	; 12694 <twim_xfer+0x2ac>
   12678:	e790      	b.n	1259c <twim_xfer+0x1b4>
            return err_code;
   1267a:	f8df 9018 	ldr.w	r9, [pc, #24]	; 12694 <twim_xfer+0x2ac>
   1267e:	e78d      	b.n	1259c <twim_xfer+0x1b4>
   12680:	019c0202 	.word	0x019c0202
   12684:	0bad000b 	.word	0x0bad000b
   12688:	0bad0000 	.word	0x0bad0000
   1268c:	0bad0004 	.word	0x0bad0004
   12690:	0bad0001 	.word	0x0bad0001
   12694:	0bad000a 	.word	0x0bad000a

00012698 <twim_irq_handler>:
{
    return nrf_twim_event_address_get(p_instance->p_twim, NRF_TWIM_EVENT_STOPPED);
}

static void twim_irq_handler(NRF_TWIM_Type * p_twim, twim_control_block_t * p_cb)
{
   12698:	b530      	push	{r4, r5, lr}
   1269a:	b087      	sub	sp, #28
   1269c:	4604      	mov	r4, r0
   1269e:	460d      	mov	r5, r1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   126a0:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    }
#endif

    NRFX_ASSERT(p_cb->handler);

    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   126a4:	b143      	cbz	r3, 126b8 <twim_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   126a6:	2300      	movs	r3, #0
   126a8:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
   126ac:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   126b0:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
    {
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_ERROR);
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_ERROR));
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   126b4:	2b00      	cmp	r3, #0
   126b6:	d061      	beq.n	1277c <twim_irq_handler+0xe4>
   126b8:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
        }
    }

    nrfx_twim_evt_t event;

    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   126bc:	2b00      	cmp	r3, #0
   126be:	d07d      	beq.n	127bc <twim_irq_handler+0x124>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   126c0:	2300      	movs	r3, #0
   126c2:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   126c6:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    {
        NRFX_LOG_DEBUG("TWIM: Event: %s.", EVT_TO_STR_TWIM(NRF_TWIM_EVENT_STOPPED));
        nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_STOPPED);

        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   126ca:	6a2b      	ldr	r3, [r5, #32]
   126cc:	f013 0f40 	tst.w	r3, #64	; 0x40
   126d0:	d103      	bne.n	126da <twim_irq_handler+0x42>
   126d2:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   126d6:	2b00      	cmp	r3, #0
   126d8:	d067      	beq.n	127aa <twim_irq_handler+0x112>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
        }

        // Further processing of STOPPED event is valid only if NO_XFER_EVT_HANDLER
        // setting is not used.
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   126da:	6a2b      	ldr	r3, [r5, #32]
   126dc:	f013 0f04 	tst.w	r3, #4
   126e0:	d130      	bne.n	12744 <twim_irq_handler+0xac>
        {
            event.xfer_desc = p_cb->xfer_desc;
   126e2:	f10d 0c04 	add.w	ip, sp, #4
   126e6:	f105 0e0c 	add.w	lr, r5, #12
   126ea:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   126ee:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   126f2:	f8de 3000 	ldr.w	r3, [lr]
   126f6:	f8cc 3000 	str.w	r3, [ip]
   126fa:	2300      	movs	r3, #0
   126fc:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
   12700:	f8d4 2160 	ldr.w	r2, [r4, #352]	; 0x160
   12704:	f8c4 315c 	str.w	r3, [r4, #348]	; 0x15c
   12708:	f8d4 315c 	ldr.w	r3, [r4, #348]	; 0x15c
            nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_LASTTX);
            nrf_twim_event_clear(p_twim, NRF_TWIM_EVENT_LASTRX);
            if (!p_cb->repeated || p_cb->error)
   1270c:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   12710:	b113      	cbz	r3, 12718 <twim_irq_handler+0x80>
   12712:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   12716:	b1ab      	cbz	r3, 12744 <twim_irq_handler+0xac>
    p_reg->SHORTS = mask;
   12718:	2300      	movs	r3, #0
   1271a:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            {
                nrf_twim_shorts_set(p_twim, 0);
                p_cb->int_mask = 0;
   1271e:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   12720:	4b52      	ldr	r3, [pc, #328]	; (1286c <twim_irq_handler+0x1d4>)
   12722:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   12726:	0b22      	lsrs	r2, r4, #12
   12728:	f344 3307 	sbfx	r3, r4, #12, #8
  if ((int32_t)(IRQn) >= 0)
   1272c:	2b00      	cmp	r3, #0
   1272e:	db09      	blt.n	12744 <twim_irq_handler+0xac>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12730:	f002 021f 	and.w	r2, r2, #31
   12734:	095b      	lsrs	r3, r3, #5
   12736:	2101      	movs	r1, #1
   12738:	fa01 f202 	lsl.w	r2, r1, r2
   1273c:	3360      	adds	r3, #96	; 0x60
   1273e:	494c      	ldr	r1, [pc, #304]	; (12870 <twim_irq_handler+0x1d8>)
   12740:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    uint32_t error_source = p_reg->ERRORSRC;
   12744:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   12748:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
            return;
        }
    }

    uint32_t errorsrc = nrf_twim_errorsrc_get_and_clear(p_twim);
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   1274c:	f013 0f02 	tst.w	r3, #2
   12750:	d073      	beq.n	1283a <twim_irq_handler+0x1a2>
    {
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   12752:	2301      	movs	r3, #1
   12754:	f88d 3000 	strb.w	r3, [sp]
    {
        event.type = NRFX_TWIM_EVT_DONE;
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_DONE));
    }

    if (!p_cb->repeated)
   12758:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   1275c:	b90b      	cbnz	r3, 12762 <twim_irq_handler+0xca>
    {
        p_cb->busy = false;
   1275e:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    }

    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   12762:	6a2b      	ldr	r3, [r5, #32]
   12764:	f013 0f04 	tst.w	r3, #4
   12768:	d002      	beq.n	12770 <twim_irq_handler+0xd8>
   1276a:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   1276e:	b11b      	cbz	r3, 12778 <twim_irq_handler+0xe0>
    {
        p_cb->handler(&event, p_cb->p_context);
   12770:	682b      	ldr	r3, [r5, #0]
   12772:	6869      	ldr	r1, [r5, #4]
   12774:	4668      	mov	r0, sp
   12776:	4798      	blx	r3
    }
}
   12778:	b007      	add	sp, #28
   1277a:	bd30      	pop	{r4, r5, pc}
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   1277c:	688b      	ldr	r3, [r1, #8]
    p_reg->INTENCLR = mask;
   1277e:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   12782:	2302      	movs	r3, #2
   12784:	608b      	str	r3, [r1, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   12786:	688b      	ldr	r3, [r1, #8]
    p_reg->INTENSET = mask;
   12788:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1278c:	f8d0 3160 	ldr.w	r3, [r0, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   12790:	b123      	cbz	r3, 1279c <twim_irq_handler+0x104>
    return p_reg->SHORTS;
   12792:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   12796:	f413 7f00 	tst.w	r3, #512	; 0x200
   1279a:	d102      	bne.n	127a2 <twim_irq_handler+0x10a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1279c:	2301      	movs	r3, #1
   1279e:	6223      	str	r3, [r4, #32]
   127a0:	6163      	str	r3, [r4, #20]
            p_cb->error = true;
   127a2:	2301      	movs	r3, #1
   127a4:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
            return;
   127a8:	e7e6      	b.n	12778 <twim_irq_handler+0xe0>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   127aa:	4629      	mov	r1, r5
   127ac:	4620      	mov	r0, r4
   127ae:	f008 fc6d 	bl	1b08c <xfer_completeness_check>
   127b2:	f080 0001 	eor.w	r0, r0, #1
   127b6:	f885 002e 	strb.w	r0, [r5, #46]	; 0x2e
   127ba:	e78e      	b.n	126da <twim_irq_handler+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   127bc:	2300      	movs	r3, #0
   127be:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   127c2:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   127c6:	7b2b      	ldrb	r3, [r5, #12]
   127c8:	bb2b      	cbnz	r3, 12816 <twim_irq_handler+0x17e>
            event.xfer_desc = p_cb->xfer_desc;
   127ca:	f10d 0c04 	add.w	ip, sp, #4
   127ce:	f105 0e0c 	add.w	lr, r5, #12
   127d2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   127d6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   127da:	f8de 3000 	ldr.w	r3, [lr]
   127de:	f8cc 3000 	str.w	r3, [ip]
            if (!p_cb->repeated)
   127e2:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   127e6:	2b00      	cmp	r3, #0
   127e8:	d1ac      	bne.n	12744 <twim_irq_handler+0xac>
    p_reg->SHORTS = mask;
   127ea:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
                p_cb->int_mask = 0;
   127ee:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   127f0:	4b1e      	ldr	r3, [pc, #120]	; (1286c <twim_irq_handler+0x1d4>)
   127f2:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
   127f6:	0b22      	lsrs	r2, r4, #12
   127f8:	f344 3307 	sbfx	r3, r4, #12, #8
  if ((int32_t)(IRQn) >= 0)
   127fc:	2b00      	cmp	r3, #0
   127fe:	dba1      	blt.n	12744 <twim_irq_handler+0xac>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12800:	f002 021f 	and.w	r2, r2, #31
   12804:	095b      	lsrs	r3, r3, #5
   12806:	2101      	movs	r1, #1
   12808:	fa01 f202 	lsl.w	r2, r1, r2
   1280c:	3360      	adds	r3, #96	; 0x60
   1280e:	4918      	ldr	r1, [pc, #96]	; (12870 <twim_irq_handler+0x1d8>)
   12810:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   12814:	e796      	b.n	12744 <twim_irq_handler+0xac>
    p_reg->SHORTS = mask;
   12816:	f44f 7300 	mov.w	r3, #512	; 0x200
   1281a:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   1281e:	f240 2302 	movw	r3, #514	; 0x202
   12822:	60ab      	str	r3, [r5, #8]
    p_reg->INTENCLR = mask;
   12824:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   12828:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   1282c:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   1282e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12832:	2301      	movs	r3, #1
   12834:	60a3      	str	r3, [r4, #8]
   12836:	6223      	str	r3, [r4, #32]
            return;
   12838:	e79e      	b.n	12778 <twim_irq_handler+0xe0>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   1283a:	f013 0f04 	tst.w	r3, #4
   1283e:	d003      	beq.n	12848 <twim_irq_handler+0x1b0>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   12840:	2302      	movs	r3, #2
   12842:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_DATA_NACK));
   12846:	e787      	b.n	12758 <twim_irq_handler+0xc0>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   12848:	f013 0f01 	tst.w	r3, #1
   1284c:	d003      	beq.n	12856 <twim_irq_handler+0x1be>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   1284e:	2303      	movs	r3, #3
   12850:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_OVERRUN));
   12854:	e780      	b.n	12758 <twim_irq_handler+0xc0>
    else if (p_cb->error)
   12856:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   1285a:	b11b      	cbz	r3, 12864 <twim_irq_handler+0x1cc>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   1285c:	2304      	movs	r3, #4
   1285e:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_BUS_ERROR));
   12862:	e779      	b.n	12758 <twim_irq_handler+0xc0>
        event.type = NRFX_TWIM_EVT_DONE;
   12864:	2300      	movs	r3, #0
   12866:	f88d 3000 	strb.w	r3, [sp]
        NRFX_LOG_DEBUG("Event: %s.", EVT_TO_STR(NRFX_TWIM_EVT_DONE));
   1286a:	e775      	b.n	12758 <twim_irq_handler+0xc0>
   1286c:	019c0202 	.word	0x019c0202
   12870:	e000e100 	.word	0xe000e100

00012874 <nrfx_twim_init>:
{
   12874:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12876:	4604      	mov	r4, r0
   12878:	460d      	mov	r5, r1
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   1287a:	7906      	ldrb	r6, [r0, #4]
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   1287c:	6807      	ldr	r7, [r0, #0]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   1287e:	491e      	ldr	r1, [pc, #120]	; (128f8 <nrfx_twim_init+0x84>)
   12880:	2034      	movs	r0, #52	; 0x34
   12882:	fb00 1106 	mla	r1, r0, r6, r1
   12886:	f891 102d 	ldrb.w	r1, [r1, #45]	; 0x2d
   1288a:	b109      	cbz	r1, 12890 <nrfx_twim_init+0x1c>
        return err_code;
   1288c:	481b      	ldr	r0, [pc, #108]	; (128fc <nrfx_twim_init+0x88>)
}
   1288e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    p_cb->handler         = event_handler;
   12890:	f8df c064 	ldr.w	ip, [pc, #100]	; 128f8 <nrfx_twim_init+0x84>
   12894:	fb06 f000 	mul.w	r0, r6, r0
   12898:	eb0c 0100 	add.w	r1, ip, r0
   1289c:	f84c 2000 	str.w	r2, [ip, r0]
    p_cb->p_context       = p_context;
   128a0:	604b      	str	r3, [r1, #4]
    p_cb->int_mask        = 0;
   128a2:	2300      	movs	r3, #0
   128a4:	608b      	str	r3, [r1, #8]
    p_cb->repeated        = false;
   128a6:	f881 3030 	strb.w	r3, [r1, #48]	; 0x30
    p_cb->busy            = false;
   128aa:	f881 302f 	strb.w	r3, [r1, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   128ae:	7b6b      	ldrb	r3, [r5, #13]
   128b0:	f881 3032 	strb.w	r3, [r1, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   128b4:	7bab      	ldrb	r3, [r5, #14]
   128b6:	f881 3033 	strb.w	r3, [r1, #51]	; 0x33
    if (!twim_pins_configure(p_twim, p_config))
   128ba:	4629      	mov	r1, r5
   128bc:	4638      	mov	r0, r7
   128be:	f7ff fd3d 	bl	1233c <twim_pins_configure>
   128c2:	b1b0      	cbz	r0, 128f2 <nrfx_twim_init+0x7e>
    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
   128c4:	68ab      	ldr	r3, [r5, #8]
    p_reg->FREQUENCY = frequency;
   128c6:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
    if (p_cb->handler)
   128ca:	2334      	movs	r3, #52	; 0x34
   128cc:	fb06 f303 	mul.w	r3, r6, r3
   128d0:	4a09      	ldr	r2, [pc, #36]	; (128f8 <nrfx_twim_init+0x84>)
   128d2:	58d3      	ldr	r3, [r2, r3]
   128d4:	b123      	cbz	r3, 128e0 <nrfx_twim_init+0x6c>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   128d6:	6820      	ldr	r0, [r4, #0]
   128d8:	f340 3007 	sbfx	r0, r0, #12, #8
   128dc:	f7f1 fb92 	bl	4004 <arch_irq_enable>
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   128e0:	4b05      	ldr	r3, [pc, #20]	; (128f8 <nrfx_twim_init+0x84>)
   128e2:	2234      	movs	r2, #52	; 0x34
   128e4:	fb02 3606 	mla	r6, r2, r6, r3
   128e8:	2301      	movs	r3, #1
   128ea:	f886 302d 	strb.w	r3, [r6, #45]	; 0x2d
    return err_code;
   128ee:	4804      	ldr	r0, [pc, #16]	; (12900 <nrfx_twim_init+0x8c>)
   128f0:	e7cd      	b.n	1288e <nrfx_twim_init+0x1a>
        return NRFX_ERROR_INVALID_PARAM;
   128f2:	4804      	ldr	r0, [pc, #16]	; (12904 <nrfx_twim_init+0x90>)
   128f4:	e7cb      	b.n	1288e <nrfx_twim_init+0x1a>
   128f6:	bf00      	nop
   128f8:	20002684 	.word	0x20002684
   128fc:	0bad0005 	.word	0x0bad0005
   12900:	0bad0000 	.word	0x0bad0000
   12904:	0bad0004 	.word	0x0bad0004

00012908 <nrfx_twim_enable>:
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   12908:	7902      	ldrb	r2, [r0, #4]
    nrf_twim_enable(p_instance->p_twim);
   1290a:	6803      	ldr	r3, [r0, #0]
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   1290c:	2106      	movs	r1, #6
   1290e:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   12912:	4b04      	ldr	r3, [pc, #16]	; (12924 <nrfx_twim_enable+0x1c>)
   12914:	2134      	movs	r1, #52	; 0x34
   12916:	fb01 3302 	mla	r3, r1, r2, r3
   1291a:	2202      	movs	r2, #2
   1291c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
}
   12920:	4770      	bx	lr
   12922:	bf00      	nop
   12924:	20002684 	.word	0x20002684

00012928 <nrfx_twim_disable>:
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   12928:	7901      	ldrb	r1, [r0, #4]
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   1292a:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   1292c:	4b0b      	ldr	r3, [pc, #44]	; (1295c <nrfx_twim_disable+0x34>)
   1292e:	2034      	movs	r0, #52	; 0x34
   12930:	fb00 3301 	mla	r3, r0, r1, r3
   12934:	2100      	movs	r1, #0
   12936:	6099      	str	r1, [r3, #8]
    p_reg->INTENCLR = mask;
   12938:	4809      	ldr	r0, [pc, #36]	; (12960 <nrfx_twim_disable+0x38>)
   1293a:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   1293e:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
   12942:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
   12946:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   1294a:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1294e:	2201      	movs	r2, #1
   12950:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    p_cb->busy = false;
   12954:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
}
   12958:	4770      	bx	lr
   1295a:	bf00      	nop
   1295c:	20002684 	.word	0x20002684
   12960:	019c0202 	.word	0x019c0202

00012964 <nrfx_twim_xfer>:
{
   12964:	b510      	push	{r4, lr}
   12966:	4613      	mov	r3, r2
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   12968:	f890 c004 	ldrb.w	ip, [r0, #4]
    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   1296c:	460a      	mov	r2, r1
   1296e:	6801      	ldr	r1, [r0, #0]
   12970:	4c03      	ldr	r4, [pc, #12]	; (12980 <nrfx_twim_xfer+0x1c>)
   12972:	2034      	movs	r0, #52	; 0x34
   12974:	fb00 400c 	mla	r0, r0, ip, r4
   12978:	f7ff fd36 	bl	123e8 <twim_xfer>
}
   1297c:	bd10      	pop	{r4, pc}
   1297e:	bf00      	nop
   12980:	20002684 	.word	0x20002684

00012984 <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   12984:	b508      	push	{r3, lr}
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
   12986:	4902      	ldr	r1, [pc, #8]	; (12990 <nrfx_twim_1_irq_handler+0xc>)
   12988:	4802      	ldr	r0, [pc, #8]	; (12994 <nrfx_twim_1_irq_handler+0x10>)
   1298a:	f7ff fe85 	bl	12698 <twim_irq_handler>
}
   1298e:	bd08      	pop	{r3, pc}
   12990:	20002684 	.word	0x20002684
   12994:	50009000 	.word	0x50009000

00012998 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
   12998:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    *p_pin = pin_number & 0x1F;
   1299c:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
   129a0:	0940      	lsrs	r0, r0, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   129a2:	2801      	cmp	r0, #1
   129a4:	d039      	beq.n	12a1a <nrfx_twi_twim_bus_recover+0x82>
        case 0: return NRF_P0;
   129a6:	4e29      	ldr	r6, [pc, #164]	; (12a4c <nrfx_twi_twim_bus_recover+0xb4>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   129a8:	2501      	movs	r5, #1
   129aa:	4095      	lsls	r5, r2
    p_reg->OUTSET = set_mask;
   129ac:	60b5      	str	r5, [r6, #8]
    *p_pin = pin_number & 0x1F;
   129ae:	f001 081f 	and.w	r8, r1, #31
    return pin_number >> 5;
   129b2:	0949      	lsrs	r1, r1, #5
    switch (nrf_gpio_pin_port_number_extract(p_pin))
   129b4:	2901      	cmp	r1, #1
   129b6:	d032      	beq.n	12a1e <nrfx_twi_twim_bus_recover+0x86>
        case 0: return NRF_P0;
   129b8:	4f24      	ldr	r7, [pc, #144]	; (12a4c <nrfx_twi_twim_bus_recover+0xb4>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   129ba:	f04f 0901 	mov.w	r9, #1
   129be:	fa09 f908 	lsl.w	r9, r9, r8
    p_reg->OUTSET = set_mask;
   129c2:	f8c7 9008 	str.w	r9, [r7, #8]
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   129c6:	3280      	adds	r2, #128	; 0x80
   129c8:	f856 1022 	ldr.w	r1, [r6, r2, lsl #2]
   129cc:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   129d0:	f240 600d 	movw	r0, #1549	; 0x60d
   129d4:	4301      	orrs	r1, r0
    reg->PIN_CNF[pin_number] = cnf;
   129d6:	f846 1022 	str.w	r1, [r6, r2, lsl #2]
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   129da:	f108 0280 	add.w	r2, r8, #128	; 0x80
   129de:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   129e2:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   129e6:	4303      	orrs	r3, r0
    reg->PIN_CNF[pin_number] = cnf;
   129e8:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
    nrf_gpio_pin_set(scl_pin);
    nrf_gpio_pin_set(sda_pin);

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
   129ec:	2004      	movs	r0, #4
   129ee:	f008 fa3b 	bl	1ae68 <nrfx_busy_wait>

    for (uint8_t i = 0; i < 9; i++)
   129f2:	2400      	movs	r4, #0
   129f4:	2c08      	cmp	r4, #8
   129f6:	d814      	bhi.n	12a22 <nrfx_twi_twim_bus_recover+0x8a>
    return p_reg->IN;
   129f8:	693b      	ldr	r3, [r7, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   129fa:	fa23 f308 	lsr.w	r3, r3, r8
    {
        if (nrf_gpio_pin_read(sda_pin))
   129fe:	f013 0f01 	tst.w	r3, #1
   12a02:	d10e      	bne.n	12a22 <nrfx_twi_twim_bus_recover+0x8a>
    p_reg->OUTCLR = clr_mask;
   12a04:	60f5      	str	r5, [r6, #12]
        }
        else
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
   12a06:	2004      	movs	r0, #4
   12a08:	f008 fa2e 	bl	1ae68 <nrfx_busy_wait>
    p_reg->OUTSET = set_mask;
   12a0c:	60b5      	str	r5, [r6, #8]
            nrf_gpio_pin_set(scl_pin);
            NRFX_DELAY_US(4);
   12a0e:	2004      	movs	r0, #4
   12a10:	f008 fa2a 	bl	1ae68 <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   12a14:	3401      	adds	r4, #1
   12a16:	b2e4      	uxtb	r4, r4
   12a18:	e7ec      	b.n	129f4 <nrfx_twi_twim_bus_recover+0x5c>
        case 1: return NRF_P1;
   12a1a:	4e0d      	ldr	r6, [pc, #52]	; (12a50 <nrfx_twi_twim_bus_recover+0xb8>)
   12a1c:	e7c4      	b.n	129a8 <nrfx_twi_twim_bus_recover+0x10>
   12a1e:	4f0c      	ldr	r7, [pc, #48]	; (12a50 <nrfx_twi_twim_bus_recover+0xb8>)
   12a20:	e7cb      	b.n	129ba <nrfx_twi_twim_bus_recover+0x22>
    p_reg->OUTCLR = clr_mask;
   12a22:	f8c7 900c 	str.w	r9, [r7, #12]
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
   12a26:	2004      	movs	r0, #4
   12a28:	f008 fa1e 	bl	1ae68 <nrfx_busy_wait>
    p_reg->OUTSET = set_mask;
   12a2c:	f8c7 9008 	str.w	r9, [r7, #8]
    nrf_gpio_pin_set(sda_pin);
    NRFX_DELAY_US(4);
   12a30:	2004      	movs	r0, #4
   12a32:	f008 fa19 	bl	1ae68 <nrfx_busy_wait>
    return p_reg->IN;
   12a36:	693b      	ldr	r3, [r7, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   12a38:	fa23 f808 	lsr.w	r8, r3, r8

    if (nrf_gpio_pin_read(sda_pin))
   12a3c:	f018 0f01 	tst.w	r8, #1
   12a40:	d002      	beq.n	12a48 <nrfx_twi_twim_bus_recover+0xb0>
    {
        return NRFX_SUCCESS;
   12a42:	4804      	ldr	r0, [pc, #16]	; (12a54 <nrfx_twi_twim_bus_recover+0xbc>)
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
   12a44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return NRFX_ERROR_INTERNAL;
   12a48:	4803      	ldr	r0, [pc, #12]	; (12a58 <nrfx_twi_twim_bus_recover+0xc0>)
   12a4a:	e7fb      	b.n	12a44 <nrfx_twi_twim_bus_recover+0xac>
   12a4c:	50842500 	.word	0x50842500
   12a50:	50842800 	.word	0x50842800
   12a54:	0bad0000 	.word	0x0bad0000
   12a58:	0bad0001 	.word	0x0bad0001

00012a5c <metal_generic_dev_open>:
	return 0;
}

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
   12a5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12a5e:	460d      	mov	r5, r1
   12a60:	4617      	mov	r7, r2
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
   12a62:	4b0c      	ldr	r3, [pc, #48]	; (12a94 <metal_generic_dev_open+0x38>)
   12a64:	699c      	ldr	r4, [r3, #24]
   12a66:	e000      	b.n	12a6a <metal_generic_dev_open+0xe>
   12a68:	6824      	ldr	r4, [r4, #0]
   12a6a:	4b0b      	ldr	r3, [pc, #44]	; (12a98 <metal_generic_dev_open+0x3c>)
   12a6c:	429c      	cmp	r4, r3
   12a6e:	d00d      	beq.n	12a8c <metal_generic_dev_open+0x30>
		dev = metal_container_of(node, struct metal_device, node);
   12a70:	f1a4 0644 	sub.w	r6, r4, #68	; 0x44
		if (strcmp(dev->name, dev_name) == 0) {
   12a74:	4629      	mov	r1, r5
   12a76:	f854 0c44 	ldr.w	r0, [r4, #-68]
   12a7a:	f004 fe29 	bl	176d0 <strcmp>
   12a7e:	2800      	cmp	r0, #0
   12a80:	d1f2      	bne.n	12a68 <metal_generic_dev_open+0xc>
			*device = dev;
   12a82:	603e      	str	r6, [r7, #0]
			return metal_generic_dev_sys_open(dev);
   12a84:	4630      	mov	r0, r6
   12a86:	f008 fc7a 	bl	1b37e <metal_generic_dev_sys_open>
   12a8a:	e001      	b.n	12a90 <metal_generic_dev_open+0x34>
		}
	}

	return -ENODEV;
   12a8c:	f06f 0012 	mvn.w	r0, #18
}
   12a90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12a92:	bf00      	nop
   12a94:	200026b8 	.word	0x200026b8
   12a98:	200026d0 	.word	0x200026d0

00012a9c <metal_bus_find>:
{
   12a9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12a9e:	4605      	mov	r5, r0
   12aa0:	460f      	mov	r7, r1
	metal_list_for_each(&_metal.common.bus_list, node) {
   12aa2:	4b0c      	ldr	r3, [pc, #48]	; (12ad4 <metal_bus_find+0x38>)
   12aa4:	689c      	ldr	r4, [r3, #8]
   12aa6:	e000      	b.n	12aaa <metal_bus_find+0xe>
   12aa8:	6824      	ldr	r4, [r4, #0]
   12aaa:	4b0b      	ldr	r3, [pc, #44]	; (12ad8 <metal_bus_find+0x3c>)
   12aac:	429c      	cmp	r4, r3
   12aae:	d00d      	beq.n	12acc <metal_bus_find+0x30>
		bus = metal_container_of(node, struct metal_bus, node);
   12ab0:	f1a4 0624 	sub.w	r6, r4, #36	; 0x24
		if (strcmp(bus->name, name) == 0 && result) {
   12ab4:	4629      	mov	r1, r5
   12ab6:	f854 0c24 	ldr.w	r0, [r4, #-36]
   12aba:	f004 fe09 	bl	176d0 <strcmp>
   12abe:	4603      	mov	r3, r0
   12ac0:	2800      	cmp	r0, #0
   12ac2:	d1f1      	bne.n	12aa8 <metal_bus_find+0xc>
   12ac4:	2f00      	cmp	r7, #0
   12ac6:	d0ef      	beq.n	12aa8 <metal_bus_find+0xc>
			*result = bus;
   12ac8:	603e      	str	r6, [r7, #0]
			return 0;
   12aca:	e001      	b.n	12ad0 <metal_bus_find+0x34>
	return -ENOENT;
   12acc:	f06f 0301 	mvn.w	r3, #1
}
   12ad0:	4618      	mov	r0, r3
   12ad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12ad4:	200026b8 	.word	0x200026b8
   12ad8:	200026c0 	.word	0x200026c0

00012adc <metal_bus_register>:
	if (!bus || !bus->name || !strlen(bus->name))
   12adc:	b380      	cbz	r0, 12b40 <metal_bus_register+0x64>
{
   12ade:	b510      	push	{r4, lr}
   12ae0:	4604      	mov	r4, r0
	if (!bus || !bus->name || !strlen(bus->name))
   12ae2:	6800      	ldr	r0, [r0, #0]
   12ae4:	b310      	cbz	r0, 12b2c <metal_bus_register+0x50>
   12ae6:	f004 fde0 	bl	176aa <strlen>
   12aea:	b1f8      	cbz	r0, 12b2c <metal_bus_register+0x50>
	if (metal_bus_find(bus->name, NULL) == 0)
   12aec:	2100      	movs	r1, #0
   12aee:	6820      	ldr	r0, [r4, #0]
   12af0:	f7ff ffd4 	bl	12a9c <metal_bus_find>
   12af4:	b1e8      	cbz	r0, 12b32 <metal_bus_register+0x56>
	metal_list_init(&bus->devices);
   12af6:	f104 031c 	add.w	r3, r4, #28
#define METAL_DECLARE_LIST(name)			\
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
	list->prev = list;
   12afa:	6223      	str	r3, [r4, #32]
	list->next = list;
   12afc:	61e3      	str	r3, [r4, #28]
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
   12afe:	f104 0224 	add.w	r2, r4, #36	; 0x24
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
	new_node->prev = node->prev;
   12b02:	4b11      	ldr	r3, [pc, #68]	; (12b48 <metal_bus_register+0x6c>)
   12b04:	68d9      	ldr	r1, [r3, #12]
   12b06:	62a1      	str	r1, [r4, #40]	; 0x28
	new_node->next = node;
   12b08:	f103 0008 	add.w	r0, r3, #8
   12b0c:	6260      	str	r0, [r4, #36]	; 0x24
	new_node->next->prev = new_node;
   12b0e:	60da      	str	r2, [r3, #12]
	new_node->prev->next = new_node;
   12b10:	600a      	str	r2, [r1, #0]
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
   12b12:	781b      	ldrb	r3, [r3, #0]
   12b14:	2b06      	cmp	r3, #6
   12b16:	d90f      	bls.n	12b38 <metal_bus_register+0x5c>
   12b18:	f1a0 0308 	sub.w	r3, r0, #8
   12b1c:	685b      	ldr	r3, [r3, #4]
   12b1e:	b16b      	cbz	r3, 12b3c <metal_bus_register+0x60>
   12b20:	6822      	ldr	r2, [r4, #0]
   12b22:	490a      	ldr	r1, [pc, #40]	; (12b4c <metal_bus_register+0x70>)
   12b24:	2007      	movs	r0, #7
   12b26:	4798      	blx	r3
	return 0;
   12b28:	2000      	movs	r0, #0
   12b2a:	e006      	b.n	12b3a <metal_bus_register+0x5e>
		return -EINVAL;
   12b2c:	f06f 0015 	mvn.w	r0, #21
   12b30:	e003      	b.n	12b3a <metal_bus_register+0x5e>
		return -EEXIST;
   12b32:	f06f 0010 	mvn.w	r0, #16
   12b36:	e000      	b.n	12b3a <metal_bus_register+0x5e>
	return 0;
   12b38:	2000      	movs	r0, #0
}
   12b3a:	bd10      	pop	{r4, pc}
	return 0;
   12b3c:	2000      	movs	r0, #0
   12b3e:	e7fc      	b.n	12b3a <metal_bus_register+0x5e>
		return -EINVAL;
   12b40:	f06f 0015 	mvn.w	r0, #21
}
   12b44:	4770      	bx	lr
   12b46:	bf00      	nop
   12b48:	200026b8 	.word	0x200026b8
   12b4c:	0001fdcc 	.word	0x0001fdcc

00012b50 <metal_register_generic_device>:
{
   12b50:	b510      	push	{r4, lr}
   12b52:	4604      	mov	r4, r0
	if (!device->name || !strlen(device->name) ||
   12b54:	6800      	ldr	r0, [r0, #0]
   12b56:	b198      	cbz	r0, 12b80 <metal_register_generic_device+0x30>
   12b58:	f004 fda7 	bl	176aa <strlen>
   12b5c:	b180      	cbz	r0, 12b80 <metal_register_generic_device+0x30>
	    device->num_regions > METAL_MAX_DEVICE_REGIONS)
   12b5e:	68a3      	ldr	r3, [r4, #8]
	if (!device->name || !strlen(device->name) ||
   12b60:	2b01      	cmp	r3, #1
   12b62:	d80d      	bhi.n	12b80 <metal_register_generic_device+0x30>
	device->bus = &metal_generic_bus;
   12b64:	4b08      	ldr	r3, [pc, #32]	; (12b88 <metal_register_generic_device+0x38>)
   12b66:	6063      	str	r3, [r4, #4]
	metal_list_add_tail(&_metal.common.generic_device_list,
   12b68:	f104 0144 	add.w	r1, r4, #68	; 0x44
	new_node->prev = node->prev;
   12b6c:	4b07      	ldr	r3, [pc, #28]	; (12b8c <metal_register_generic_device+0x3c>)
   12b6e:	69da      	ldr	r2, [r3, #28]
   12b70:	64a2      	str	r2, [r4, #72]	; 0x48
	new_node->next = node;
   12b72:	f103 0018 	add.w	r0, r3, #24
   12b76:	6460      	str	r0, [r4, #68]	; 0x44
	new_node->next->prev = new_node;
   12b78:	61d9      	str	r1, [r3, #28]
	new_node->prev->next = new_node;
   12b7a:	6011      	str	r1, [r2, #0]
	return 0;
   12b7c:	2000      	movs	r0, #0
}
   12b7e:	bd10      	pop	{r4, pc}
		return -EINVAL;
   12b80:	f06f 0015 	mvn.w	r0, #21
   12b84:	e7fb      	b.n	12b7e <metal_register_generic_device+0x2e>
   12b86:	bf00      	nop
   12b88:	200004a8 	.word	0x200004a8
   12b8c:	200026b8 	.word	0x200026b8

00012b90 <metal_init>:

#include <string.h>
#include <metal/sys.h>

int metal_init(const struct metal_init_params *params)
{
   12b90:	b538      	push	{r3, r4, r5, lr}
   12b92:	4605      	mov	r5, r0
	int error = 0;

	memset(&_metal, 0, sizeof(_metal));
   12b94:	4c0c      	ldr	r4, [pc, #48]	; (12bc8 <metal_init+0x38>)
   12b96:	2220      	movs	r2, #32
   12b98:	2100      	movs	r1, #0
   12b9a:	4620      	mov	r0, r4
   12b9c:	f004 fdf7 	bl	1778e <memset>

	_metal.common.log_handler   = params->log_handler;
   12ba0:	682b      	ldr	r3, [r5, #0]
   12ba2:	6063      	str	r3, [r4, #4]
	_metal.common.log_level     = params->log_level;
   12ba4:	792a      	ldrb	r2, [r5, #4]
   12ba6:	4623      	mov	r3, r4
   12ba8:	f803 2b08 	strb.w	r2, [r3], #8
	list->prev = list;
   12bac:	60e3      	str	r3, [r4, #12]
	list->next = list;
   12bae:	60a3      	str	r3, [r4, #8]
	list->prev = list;
   12bb0:	f104 0310 	add.w	r3, r4, #16
   12bb4:	6163      	str	r3, [r4, #20]
	list->next = list;
   12bb6:	6123      	str	r3, [r4, #16]
	list->prev = list;
   12bb8:	f104 0318 	add.w	r3, r4, #24
   12bbc:	61e3      	str	r3, [r4, #28]
	list->next = list;
   12bbe:	61a3      	str	r3, [r4, #24]

	metal_list_init(&_metal.common.bus_list);
	metal_list_init(&_metal.common.generic_shmem_list);
	metal_list_init(&_metal.common.generic_device_list);

	error = metal_sys_init(params);
   12bc0:	4628      	mov	r0, r5
   12bc2:	f000 f803 	bl	12bcc <metal_sys_init>
	if (error)
		return error;

	return error;
}
   12bc6:	bd38      	pop	{r3, r4, r5, pc}
   12bc8:	200026b8 	.word	0x200026b8

00012bcc <metal_sys_init>:
#include <metal/utilities.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
   12bcc:	b508      	push	{r3, lr}
	metal_bus_register(&metal_generic_bus);
   12bce:	4802      	ldr	r0, [pc, #8]	; (12bd8 <metal_sys_init+0xc>)
   12bd0:	f7ff ff84 	bl	12adc <metal_bus_register>
	return 0;
}
   12bd4:	2000      	movs	r0, #0
   12bd6:	bd08      	pop	{r3, pc}
   12bd8:	200004a8 	.word	0x200004a8

00012bdc <metal_zephyr_log_handler>:
	"metal: debug:     ",
};

void metal_zephyr_log_handler(enum metal_log_level level,
			      const char *format, ...)
{
   12bdc:	b40e      	push	{r1, r2, r3}
   12bde:	b500      	push	{lr}
   12be0:	b082      	sub	sp, #8
	va_list args;

	if (level <= METAL_LOG_EMERGENCY || level > METAL_LOG_DEBUG)
   12be2:	1e43      	subs	r3, r0, #1
   12be4:	b2db      	uxtb	r3, r3
   12be6:	2b06      	cmp	r3, #6
   12be8:	d900      	bls.n	12bec <metal_zephyr_log_handler+0x10>
		level = METAL_LOG_EMERGENCY;
   12bea:	2000      	movs	r0, #0
	printk("%s", level_strs[level]);
   12bec:	4b07      	ldr	r3, [pc, #28]	; (12c0c <metal_zephyr_log_handler+0x30>)
   12bee:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
   12bf2:	4807      	ldr	r0, [pc, #28]	; (12c10 <metal_zephyr_log_handler+0x34>)
   12bf4:	f002 fd83 	bl	156fe <printk>

	va_start(args, format);
   12bf8:	a904      	add	r1, sp, #16
   12bfa:	9101      	str	r1, [sp, #4]
	vprintk(format, args);
   12bfc:	9803      	ldr	r0, [sp, #12]
   12bfe:	f7ee f989 	bl	f14 <vprintk>
	va_end(args);
}
   12c02:	b002      	add	sp, #8
   12c04:	f85d eb04 	ldr.w	lr, [sp], #4
   12c08:	b003      	add	sp, #12
   12c0a:	4770      	bx	lr
   12c0c:	0001fe80 	.word	0x0001fe80
   12c10:	0001e054 	.word	0x0001e054

00012c14 <virtio_create_virtqueues>:
}

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback callbacks[])
{
   12c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12c18:	b085      	sub	sp, #20
   12c1a:	469a      	mov	sl, r3
   12c1c:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
	struct vring_alloc_info *vring_alloc;
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
   12c20:	6a83      	ldr	r3, [r0, #40]	; 0x28
	if (nvqs > num_vrings)
   12c22:	4293      	cmp	r3, r2
   12c24:	d344      	bcc.n	12cb0 <virtio_create_virtqueues+0x9c>
   12c26:	4605      	mov	r5, r0
   12c28:	4691      	mov	r9, r2
		return ERROR_VQUEUE_INVLD_PARAM;
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
   12c2a:	2400      	movs	r4, #0
   12c2c:	e024      	b.n	12c78 <virtio_create_virtqueues+0x64>
			struct metal_io_region *io = vring_info->io;

			offset = metal_io_virt_to_offset(io,
							 vring_alloc->vaddr);
			metal_io_block_set(io, offset, 0,
					   vring_size(vring_alloc->num_descs,
   12c2e:	f8b2 c00c 	ldrh.w	ip, [r2, #12]
						      vring_alloc->align));
   12c32:	6892      	ldr	r2, [r2, #8]
static inline int vring_size(unsigned int num, unsigned long align)
{
	int size;

	size = num * sizeof(struct vring_desc);
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
   12c34:	f10c 0303 	add.w	r3, ip, #3
   12c38:	005b      	lsls	r3, r3, #1
   12c3a:	eb03 130c 	add.w	r3, r3, ip, lsl #4
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
   12c3e:	4413      	add	r3, r2
   12c40:	3b01      	subs	r3, #1
   12c42:	4252      	negs	r2, r2
   12c44:	4013      	ands	r3, r2
	size += sizeof(struct vring_used) +
   12c46:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
			metal_io_block_set(io, offset, 0,
   12c4a:	3306      	adds	r3, #6
   12c4c:	2200      	movs	r2, #0
   12c4e:	f008 fb52 	bl	1b2f6 <metal_io_block_set>
		}
#endif
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
				       callbacks[i], vdev->func->notify,
   12c52:	6a2b      	ldr	r3, [r5, #32]
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
   12c54:	f856 2008 	ldr.w	r2, [r6, r8]
   12c58:	9202      	str	r2, [sp, #8]
   12c5a:	6a1b      	ldr	r3, [r3, #32]
   12c5c:	9301      	str	r3, [sp, #4]
   12c5e:	f85b 3024 	ldr.w	r3, [fp, r4, lsl #2]
   12c62:	9300      	str	r3, [sp, #0]
   12c64:	463b      	mov	r3, r7
   12c66:	f85a 2024 	ldr.w	r2, [sl, r4, lsl #2]
   12c6a:	b2a1      	uxth	r1, r4
   12c6c:	4628      	mov	r0, r5
   12c6e:	f008 fc90 	bl	1b592 <virtqueue_create>
				       vring_info->vq);
		if (ret)
   12c72:	4603      	mov	r3, r0
   12c74:	b9c0      	cbnz	r0, 12ca8 <virtio_create_virtqueues+0x94>
	for (i = 0; i < nvqs; i++) {
   12c76:	3401      	adds	r4, #1
   12c78:	454c      	cmp	r4, r9
   12c7a:	d214      	bcs.n	12ca6 <virtio_create_virtqueues+0x92>
		vring_info = &vdev->vrings_info[i];
   12c7c:	6aee      	ldr	r6, [r5, #44]	; 0x2c
   12c7e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   12c82:	ea4f 08c2 	mov.w	r8, r2, lsl #3
   12c86:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
		vring_alloc = &vring_info->info;
   12c8a:	1d17      	adds	r7, r2, #4
		if (vdev->role == VIRTIO_DEV_DRIVER) {
   12c8c:	69ab      	ldr	r3, [r5, #24]
   12c8e:	2b00      	cmp	r3, #0
   12c90:	d1df      	bne.n	12c52 <virtio_create_virtqueues+0x3e>
			struct metal_io_region *io = vring_info->io;
   12c92:	6950      	ldr	r0, [r2, #20]
			offset = metal_io_virt_to_offset(io,
   12c94:	6853      	ldr	r3, [r2, #4]
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
   12c96:	6801      	ldr	r1, [r0, #0]
   12c98:	1a59      	subs	r1, r3, r1

	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   12c9a:	6883      	ldr	r3, [r0, #8]
   12c9c:	4299      	cmp	r1, r3
   12c9e:	d3c6      	bcc.n	12c2e <virtio_create_virtqueues+0x1a>
   12ca0:	f04f 31ff 	mov.w	r1, #4294967295
   12ca4:	e7c3      	b.n	12c2e <virtio_create_virtqueues+0x1a>
			return ret;
	}
	return 0;
   12ca6:	2300      	movs	r3, #0
}
   12ca8:	4618      	mov	r0, r3
   12caa:	b005      	add	sp, #20
   12cac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return ERROR_VQUEUE_INVLD_PARAM;
   12cb0:	4b00      	ldr	r3, [pc, #0]	; (12cb4 <virtio_create_virtqueues+0xa0>)
   12cb2:	e7f9      	b.n	12ca8 <virtio_create_virtqueues+0x94>
   12cb4:	fffff440 	.word	0xfffff440

00012cb8 <virtqueue_add_consumed_buffer>:
				  uint32_t len)
{
	struct vring_used_elem *used_desc = NULL;
	uint16_t used_idx;

	if (head_idx > vq->vq_nentries) {
   12cb8:	8943      	ldrh	r3, [r0, #10]
   12cba:	428b      	cmp	r3, r1
   12cbc:	d318      	bcc.n	12cf0 <virtqueue_add_consumed_buffer+0x38>
{
   12cbe:	b410      	push	{r4}
	}

	VQUEUE_BUSY(vq);

	/* CACHE: used is never written by master, so it's safe to directly access it */
	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
   12cc0:	6a04      	ldr	r4, [r0, #32]
   12cc2:	f9b4 c002 	ldrsh.w	ip, [r4, #2]
   12cc6:	3b01      	subs	r3, #1
   12cc8:	b21b      	sxth	r3, r3
   12cca:	ea0c 0303 	and.w	r3, ip, r3
   12cce:	b29b      	uxth	r3, r3
	used_desc = &vq->vq_ring.used->ring[used_idx];
	used_desc->id = head_idx;
   12cd0:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
   12cd4:	6059      	str	r1, [r3, #4]
	used_desc->len = len;
   12cd6:	609a      	str	r2, [r3, #8]

	/* We still need to flush it because this is read by master */
	VRING_FLUSH(vq->vq_ring.used->ring[used_idx]);

	atomic_thread_fence(memory_order_seq_cst);
   12cd8:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.used->idx++;
   12cdc:	6a02      	ldr	r2, [r0, #32]
   12cde:	8853      	ldrh	r3, [r2, #2]
   12ce0:	3301      	adds	r3, #1
   12ce2:	8053      	strh	r3, [r2, #2]

	/* Used.idx is read by master, so we need to flush it */
	VRING_FLUSH(vq->vq_ring.used->idx);

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
   12ce4:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
   12ce6:	3301      	adds	r3, #1
   12ce8:	84c3      	strh	r3, [r0, #38]	; 0x26

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
   12cea:	2000      	movs	r0, #0
}
   12cec:	bc10      	pop	{r4}
   12cee:	4770      	bx	lr
		return ERROR_VRING_NO_BUFF;
   12cf0:	4800      	ldr	r0, [pc, #0]	; (12cf4 <virtqueue_add_consumed_buffer+0x3c>)
}
   12cf2:	4770      	bx	lr
   12cf4:	fffff441 	.word	0xfffff441

00012cf8 <rpmsg_is_address_set>:
 * return - TRUE/FALSE
 */
static int rpmsg_is_address_set(unsigned long *bitmap, int size, int addr)
{
	addr -= RPMSG_RESERVED_ADDRESSES;
	if (addr >= 0 && addr < size)
   12cf8:	f5b2 6280 	subs.w	r2, r2, #1024	; 0x400
   12cfc:	d40b      	bmi.n	12d16 <rpmsg_is_address_set+0x1e>
   12cfe:	428a      	cmp	r2, r1
   12d00:	da0b      	bge.n	12d1a <rpmsg_is_address_set+0x22>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
   12d02:	0953      	lsrs	r3, r2, #5
   12d04:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
   12d08:	f002 021f 	and.w	r2, r2, #31
   12d0c:	fa20 f202 	lsr.w	r2, r0, r2
   12d10:	f002 0001 	and.w	r0, r2, #1
		return metal_bitmap_is_bit_set(bitmap, addr);
   12d14:	4770      	bx	lr
	else
		return RPMSG_ERR_PARAM;
   12d16:	4802      	ldr	r0, [pc, #8]	; (12d20 <rpmsg_is_address_set+0x28>)
   12d18:	4770      	bx	lr
   12d1a:	4801      	ldr	r0, [pc, #4]	; (12d20 <rpmsg_is_address_set+0x28>)
}
   12d1c:	4770      	bx	lr
   12d1e:	bf00      	nop
   12d20:	fffff82d 	.word	0xfffff82d

00012d24 <rpmsg_set_address>:
 * return - none
 */
static int rpmsg_set_address(unsigned long *bitmap, int size, int addr)
{
	addr -= RPMSG_RESERVED_ADDRESSES;
	if (addr >= 0 && addr < size) {
   12d24:	f5b2 6280 	subs.w	r2, r2, #1024	; 0x400
   12d28:	d40e      	bmi.n	12d48 <rpmsg_set_address+0x24>
   12d2a:	428a      	cmp	r2, r1
   12d2c:	da0e      	bge.n	12d4c <rpmsg_set_address+0x28>
	bitmap[bit / METAL_BITS_PER_ULONG] |=
   12d2e:	0951      	lsrs	r1, r2, #5
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
   12d30:	f002 021f 	and.w	r2, r2, #31
   12d34:	2301      	movs	r3, #1
   12d36:	fa03 f202 	lsl.w	r2, r3, r2
	bitmap[bit / METAL_BITS_PER_ULONG] |=
   12d3a:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
   12d3e:	4313      	orrs	r3, r2
   12d40:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		metal_bitmap_set_bit(bitmap, addr);
		return RPMSG_SUCCESS;
   12d44:	2000      	movs	r0, #0
   12d46:	4770      	bx	lr
	} else {
		return RPMSG_ERR_PARAM;
   12d48:	4801      	ldr	r0, [pc, #4]	; (12d50 <rpmsg_set_address+0x2c>)
   12d4a:	4770      	bx	lr
   12d4c:	4800      	ldr	r0, [pc, #0]	; (12d50 <rpmsg_set_address+0x2c>)
	}
}
   12d4e:	4770      	bx	lr
   12d50:	fffff82d 	.word	0xfffff82d

00012d54 <rpmsg_send_offchannel_raw>:
			      uint32_t dst, const void *data, int len,
			      int wait)
{
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
   12d54:	b1a0      	cbz	r0, 12d80 <rpmsg_send_offchannel_raw+0x2c>
{
   12d56:	b510      	push	{r4, lr}
   12d58:	b082      	sub	sp, #8
	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
   12d5a:	6a00      	ldr	r0, [r0, #32]
   12d5c:	b190      	cbz	r0, 12d84 <rpmsg_send_offchannel_raw+0x30>
   12d5e:	b19b      	cbz	r3, 12d88 <rpmsg_send_offchannel_raw+0x34>
   12d60:	f1b2 3fff 	cmp.w	r2, #4294967295
   12d64:	d012      	beq.n	12d8c <rpmsg_send_offchannel_raw+0x38>
		return RPMSG_ERR_PARAM;

	rdev = ept->rdev;

	if (rdev->ops.send_offchannel_raw)
   12d66:	6f44      	ldr	r4, [r0, #116]	; 0x74
   12d68:	b194      	cbz	r4, 12d90 <rpmsg_send_offchannel_raw+0x3c>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
   12d6a:	f8dd c014 	ldr.w	ip, [sp, #20]
   12d6e:	f8cd c004 	str.w	ip, [sp, #4]
   12d72:	f8dd c010 	ldr.w	ip, [sp, #16]
   12d76:	f8cd c000 	str.w	ip, [sp]
   12d7a:	47a0      	blx	r4
						     len, wait);

	return RPMSG_ERR_PARAM;
}
   12d7c:	b002      	add	sp, #8
   12d7e:	bd10      	pop	{r4, pc}
		return RPMSG_ERR_PARAM;
   12d80:	4804      	ldr	r0, [pc, #16]	; (12d94 <rpmsg_send_offchannel_raw+0x40>)
}
   12d82:	4770      	bx	lr
		return RPMSG_ERR_PARAM;
   12d84:	4803      	ldr	r0, [pc, #12]	; (12d94 <rpmsg_send_offchannel_raw+0x40>)
   12d86:	e7f9      	b.n	12d7c <rpmsg_send_offchannel_raw+0x28>
   12d88:	4802      	ldr	r0, [pc, #8]	; (12d94 <rpmsg_send_offchannel_raw+0x40>)
   12d8a:	e7f7      	b.n	12d7c <rpmsg_send_offchannel_raw+0x28>
   12d8c:	4801      	ldr	r0, [pc, #4]	; (12d94 <rpmsg_send_offchannel_raw+0x40>)
   12d8e:	e7f5      	b.n	12d7c <rpmsg_send_offchannel_raw+0x28>
	return RPMSG_ERR_PARAM;
   12d90:	4800      	ldr	r0, [pc, #0]	; (12d94 <rpmsg_send_offchannel_raw+0x40>)
   12d92:	e7f3      	b.n	12d7c <rpmsg_send_offchannel_raw+0x28>
   12d94:	fffff82d 	.word	0xfffff82d

00012d98 <rpmsg_send_offchannel_nocopy>:
int rpmsg_send_offchannel_nocopy(struct rpmsg_endpoint *ept, uint32_t src,
				 uint32_t dst, const void *data, int len)
{
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
   12d98:	b188      	cbz	r0, 12dbe <rpmsg_send_offchannel_nocopy+0x26>
{
   12d9a:	b510      	push	{r4, lr}
   12d9c:	b082      	sub	sp, #8
	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
   12d9e:	6a00      	ldr	r0, [r0, #32]
   12da0:	b178      	cbz	r0, 12dc2 <rpmsg_send_offchannel_nocopy+0x2a>
   12da2:	b183      	cbz	r3, 12dc6 <rpmsg_send_offchannel_nocopy+0x2e>
   12da4:	f1b2 3fff 	cmp.w	r2, #4294967295
   12da8:	d00f      	beq.n	12dca <rpmsg_send_offchannel_nocopy+0x32>
		return RPMSG_ERR_PARAM;

	rdev = ept->rdev;

	if (rdev->ops.send_offchannel_nocopy)
   12daa:	f8d0 4084 	ldr.w	r4, [r0, #132]	; 0x84
   12dae:	b174      	cbz	r4, 12dce <rpmsg_send_offchannel_nocopy+0x36>
		return rdev->ops.send_offchannel_nocopy(rdev, src, dst,
   12db0:	f8dd c010 	ldr.w	ip, [sp, #16]
   12db4:	f8cd c000 	str.w	ip, [sp]
   12db8:	47a0      	blx	r4
							data, len);

	return RPMSG_ERR_PARAM;
}
   12dba:	b002      	add	sp, #8
   12dbc:	bd10      	pop	{r4, pc}
		return RPMSG_ERR_PARAM;
   12dbe:	4805      	ldr	r0, [pc, #20]	; (12dd4 <rpmsg_send_offchannel_nocopy+0x3c>)
}
   12dc0:	4770      	bx	lr
		return RPMSG_ERR_PARAM;
   12dc2:	4804      	ldr	r0, [pc, #16]	; (12dd4 <rpmsg_send_offchannel_nocopy+0x3c>)
   12dc4:	e7f9      	b.n	12dba <rpmsg_send_offchannel_nocopy+0x22>
   12dc6:	4803      	ldr	r0, [pc, #12]	; (12dd4 <rpmsg_send_offchannel_nocopy+0x3c>)
   12dc8:	e7f7      	b.n	12dba <rpmsg_send_offchannel_nocopy+0x22>
   12dca:	4802      	ldr	r0, [pc, #8]	; (12dd4 <rpmsg_send_offchannel_nocopy+0x3c>)
   12dcc:	e7f5      	b.n	12dba <rpmsg_send_offchannel_nocopy+0x22>
	return RPMSG_ERR_PARAM;
   12dce:	4801      	ldr	r0, [pc, #4]	; (12dd4 <rpmsg_send_offchannel_nocopy+0x3c>)
   12dd0:	e7f3      	b.n	12dba <rpmsg_send_offchannel_nocopy+0x22>
   12dd2:	bf00      	nop
   12dd4:	fffff82d 	.word	0xfffff82d

00012dd8 <rpmsg_register_endpoint>:
			     struct rpmsg_endpoint *ept,
			     const char *name,
			     uint32_t src, uint32_t dest,
			     rpmsg_ept_cb cb,
			     rpmsg_ns_unbind_cb ns_unbind_cb)
{
   12dd8:	b570      	push	{r4, r5, r6, lr}
   12dda:	4605      	mov	r5, r0
   12ddc:	460c      	mov	r4, r1
   12dde:	461e      	mov	r6, r3
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
   12de0:	4611      	mov	r1, r2
   12de2:	b1a2      	cbz	r2, 12e0e <rpmsg_register_endpoint+0x36>
   12de4:	2220      	movs	r2, #32
   12de6:	4620      	mov	r0, r4
   12de8:	f004 fc45 	bl	17676 <strncpy>
	ept->addr = src;
   12dec:	6266      	str	r6, [r4, #36]	; 0x24
	ept->dest_addr = dest;
   12dee:	9b04      	ldr	r3, [sp, #16]
   12df0:	62a3      	str	r3, [r4, #40]	; 0x28
	ept->cb = cb;
   12df2:	9b05      	ldr	r3, [sp, #20]
   12df4:	62e3      	str	r3, [r4, #44]	; 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
   12df6:	9b06      	ldr	r3, [sp, #24]
   12df8:	6323      	str	r3, [r4, #48]	; 0x30
	ept->rdev = rdev;
   12dfa:	6225      	str	r5, [r4, #32]
	metal_list_add_tail(&rdev->endpoints, &ept->node);
   12dfc:	f104 0334 	add.w	r3, r4, #52	; 0x34
	new_node->prev = node->prev;
   12e00:	686a      	ldr	r2, [r5, #4]
   12e02:	63a2      	str	r2, [r4, #56]	; 0x38
	new_node->next = node;
   12e04:	6365      	str	r5, [r4, #52]	; 0x34
	new_node->next->prev = new_node;
   12e06:	606b      	str	r3, [r5, #4]
	new_node->prev->next = new_node;
   12e08:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   12e0a:	6013      	str	r3, [r2, #0]
}
   12e0c:	bd70      	pop	{r4, r5, r6, pc}
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
   12e0e:	4901      	ldr	r1, [pc, #4]	; (12e14 <rpmsg_register_endpoint+0x3c>)
   12e10:	e7e8      	b.n	12de4 <rpmsg_register_endpoint+0xc>
   12e12:	bf00      	nop
   12e14:	0001d410 	.word	0x0001d410

00012e18 <rpmsg_create_ept>:

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
   12e18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12e1c:	b084      	sub	sp, #16
	int status = RPMSG_SUCCESS;
	uint32_t addr = src;

	if (!ept)
   12e1e:	2800      	cmp	r0, #0
   12e20:	d05f      	beq.n	12ee2 <rpmsg_create_ept+0xca>
   12e22:	460f      	mov	r7, r1
   12e24:	4691      	mov	r9, r2
   12e26:	461c      	mov	r4, r3
   12e28:	4680      	mov	r8, r0
		return RPMSG_ERR_PARAM;

	metal_mutex_acquire(&rdev->lock);
   12e2a:	f101 0658 	add.w	r6, r1, #88	; 0x58
   12e2e:	f04f 32ff 	mov.w	r2, #4294967295
   12e32:	f04f 33ff 	mov.w	r3, #4294967295
   12e36:	4630      	mov	r0, r6
   12e38:	f000 fed2 	bl	13be0 <z_impl_k_sem_take>
	if (src == RPMSG_ADDR_ANY) {
   12e3c:	f1b4 3fff 	cmp.w	r4, #4294967295
   12e40:	d012      	beq.n	12e68 <rpmsg_create_ept+0x50>
		addr = rpmsg_get_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE);
		if (addr == RPMSG_ADDR_ANY) {
			status = RPMSG_ERR_ADDR;
			goto ret_status;
		}
	} else if (src >= RPMSG_RESERVED_ADDRESSES) {
   12e42:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   12e46:	d320      	bcc.n	12e8a <rpmsg_create_ept+0x72>
		status = rpmsg_is_address_set(rdev->bitmap,
   12e48:	f107 0a48 	add.w	sl, r7, #72	; 0x48
   12e4c:	4622      	mov	r2, r4
   12e4e:	2180      	movs	r1, #128	; 0x80
   12e50:	4650      	mov	r0, sl
   12e52:	f7ff ff51 	bl	12cf8 <rpmsg_is_address_set>
					      RPMSG_ADDR_BMP_SIZE, src);
		if (!status) {
   12e56:	4605      	mov	r5, r0
   12e58:	b188      	cbz	r0, 12e7e <rpmsg_create_ept+0x66>
			/* Mark the address as used in the address bitmap. */
			rpmsg_set_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
					  src);
		} else if (status > 0) {
   12e5a:	2800      	cmp	r0, #0
   12e5c:	dd00      	ble.n	12e60 <rpmsg_create_ept+0x48>
			status = RPMSG_ERR_ADDR;
   12e5e:	4d22      	ldr	r5, [pc, #136]	; (12ee8 <rpmsg_create_ept+0xd0>)
	z_impl_k_sem_give(sem);
   12e60:	4630      	mov	r0, r6
   12e62:	f000 fe95 	bl	13b90 <z_impl_k_sem_give>
		rpmsg_unregister_endpoint(ept);
	return status;

ret_status:
	metal_mutex_release(&rdev->lock);
	return status;
   12e66:	e02c      	b.n	12ec2 <rpmsg_create_ept+0xaa>
		addr = rpmsg_get_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE);
   12e68:	2180      	movs	r1, #128	; 0x80
   12e6a:	f107 0048 	add.w	r0, r7, #72	; 0x48
   12e6e:	f008 fcc4 	bl	1b7fa <rpmsg_get_address>
   12e72:	4604      	mov	r4, r0
		if (addr == RPMSG_ADDR_ANY) {
   12e74:	f1b0 3fff 	cmp.w	r0, #4294967295
   12e78:	d031      	beq.n	12ede <rpmsg_create_ept+0xc6>
	int status = RPMSG_SUCCESS;
   12e7a:	2500      	movs	r5, #0
   12e7c:	e006      	b.n	12e8c <rpmsg_create_ept+0x74>
			rpmsg_set_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
   12e7e:	4622      	mov	r2, r4
   12e80:	2180      	movs	r1, #128	; 0x80
   12e82:	4650      	mov	r0, sl
   12e84:	f7ff ff4e 	bl	12d24 <rpmsg_set_address>
   12e88:	e000      	b.n	12e8c <rpmsg_create_ept+0x74>
	int status = RPMSG_SUCCESS;
   12e8a:	2500      	movs	r5, #0
	rpmsg_register_endpoint(rdev, ept, name, addr, dest, cb, unbind_cb);
   12e8c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12e8e:	9302      	str	r3, [sp, #8]
   12e90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   12e92:	9301      	str	r3, [sp, #4]
   12e94:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12e96:	9300      	str	r3, [sp, #0]
   12e98:	4623      	mov	r3, r4
   12e9a:	464a      	mov	r2, r9
   12e9c:	4641      	mov	r1, r8
   12e9e:	4638      	mov	r0, r7
   12ea0:	f7ff ff9a 	bl	12dd8 <rpmsg_register_endpoint>
   12ea4:	4630      	mov	r0, r6
   12ea6:	f000 fe73 	bl	13b90 <z_impl_k_sem_give>
	if (ept->name[0] && rdev->support_ns &&
   12eaa:	f898 3000 	ldrb.w	r3, [r8]
   12eae:	b13b      	cbz	r3, 12ec0 <rpmsg_create_ept+0xa8>
   12eb0:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
   12eb4:	b123      	cbz	r3, 12ec0 <rpmsg_create_ept+0xa8>
	    ept->dest_addr == RPMSG_ADDR_ANY)
   12eb6:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
	if (ept->name[0] && rdev->support_ns &&
   12eba:	f1b3 3fff 	cmp.w	r3, #4294967295
   12ebe:	d004      	beq.n	12eca <rpmsg_create_ept+0xb2>
	if (status)
   12ec0:	b94d      	cbnz	r5, 12ed6 <rpmsg_create_ept+0xbe>
}
   12ec2:	4628      	mov	r0, r5
   12ec4:	b004      	add	sp, #16
   12ec6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
   12eca:	2100      	movs	r1, #0
   12ecc:	4640      	mov	r0, r8
   12ece:	f008 fcf0 	bl	1b8b2 <rpmsg_send_ns_message>
   12ed2:	4605      	mov	r5, r0
   12ed4:	e7f4      	b.n	12ec0 <rpmsg_create_ept+0xa8>
		rpmsg_unregister_endpoint(ept);
   12ed6:	4640      	mov	r0, r8
   12ed8:	f008 fcc6 	bl	1b868 <rpmsg_unregister_endpoint>
   12edc:	e7f1      	b.n	12ec2 <rpmsg_create_ept+0xaa>
			status = RPMSG_ERR_ADDR;
   12ede:	4d02      	ldr	r5, [pc, #8]	; (12ee8 <rpmsg_create_ept+0xd0>)
   12ee0:	e7be      	b.n	12e60 <rpmsg_create_ept+0x48>
		return RPMSG_ERR_PARAM;
   12ee2:	4d02      	ldr	r5, [pc, #8]	; (12eec <rpmsg_create_ept+0xd4>)
   12ee4:	e7ed      	b.n	12ec2 <rpmsg_create_ept+0xaa>
   12ee6:	bf00      	nop
   12ee8:	fffff829 	.word	0xfffff829
   12eec:	fffff82d 	.word	0xfffff82d

00012ef0 <_rpmsg_virtio_get_buffer_size>:
 *
 * @return - buffer size
 *
 */
static int _rpmsg_virtio_get_buffer_size(struct rpmsg_virtio_device *rvdev)
{
   12ef0:	b508      	push	{r3, lr}
   12ef2:	4603      	mov	r3, r0
	return rvdev->vdev->role;
   12ef4:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
   12ef8:	6992      	ldr	r2, [r2, #24]
	unsigned int role = rpmsg_virtio_get_role(rvdev);
	int length = 0;

#ifndef VIRTIO_DEVICE_ONLY
	if (role == RPMSG_HOST) {
   12efa:	b93a      	cbnz	r2, 12f0c <_rpmsg_virtio_get_buffer_size+0x1c>
		/*
		 * If device role is Master then buffers are provided by us,
		 * so just provide the macro.
		 */
		length = rvdev->config.h2r_buf_size - sizeof(struct rpmsg_hdr);
   12efc:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
   12f00:	3810      	subs	r0, #16
	}
#endif /*!VIRTIO_DEVICE_ONLY*/

#ifndef VIRTIO_DRIVER_ONLY
	if (role == RPMSG_REMOTE) {
   12f02:	2a01      	cmp	r2, #1
   12f04:	d004      	beq.n	12f10 <_rpmsg_virtio_get_buffer_size+0x20>
		    (int)virtqueue_get_desc_size(rvdev->svq) -
		    sizeof(struct rpmsg_hdr);
	}
#endif /*!VIRTIO_DRIVER_ONLY*/

	if (length <= 0) {
   12f06:	2800      	cmp	r0, #0
   12f08:	dd08      	ble.n	12f1c <_rpmsg_virtio_get_buffer_size+0x2c>
		length = RPMSG_ERR_NO_BUFF;
	}

	return length;
}
   12f0a:	bd08      	pop	{r3, pc}
	int length = 0;
   12f0c:	2000      	movs	r0, #0
   12f0e:	e7f8      	b.n	12f02 <_rpmsg_virtio_get_buffer_size+0x12>
		    (int)virtqueue_get_desc_size(rvdev->svq) -
   12f10:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
   12f14:	f008 fc55 	bl	1b7c2 <virtqueue_get_desc_size>
   12f18:	3810      	subs	r0, #16
   12f1a:	e7f4      	b.n	12f06 <_rpmsg_virtio_get_buffer_size+0x16>
		length = RPMSG_ERR_NO_BUFF;
   12f1c:	4800      	ldr	r0, [pc, #0]	; (12f20 <_rpmsg_virtio_get_buffer_size+0x30>)
	return length;
   12f1e:	e7f4      	b.n	12f0a <_rpmsg_virtio_get_buffer_size+0x1a>
   12f20:	fffff82e 	.word	0xfffff82e

00012f24 <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int len, int wait)
{
   12f24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12f28:	b084      	sub	sp, #16
   12f2a:	4604      	mov	r4, r0
   12f2c:	460e      	mov	r6, r1
   12f2e:	4690      	mov	r8, r2
   12f30:	4699      	mov	r9, r3
   12f32:	9f0c      	ldr	r7, [sp, #48]	; 0x30

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);

	/* Get the payload buffer. */
	buffer = rpmsg_virtio_get_tx_payload_buffer(rdev, &buff_len, wait);
   12f34:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   12f36:	a903      	add	r1, sp, #12
   12f38:	f008 ff08 	bl	1bd4c <rpmsg_virtio_get_tx_payload_buffer>
	if (!buffer)
   12f3c:	b1e8      	cbz	r0, 12f7a <rpmsg_virtio_send_offchannel_raw+0x56>
   12f3e:	4682      	mov	sl, r0
		return RPMSG_ERR_NO_BUFF;

	/* Copy data to rpmsg buffer. */
	if (len > (int)buff_len)
   12f40:	9d03      	ldr	r5, [sp, #12]
   12f42:	42bd      	cmp	r5, r7
   12f44:	db00      	blt.n	12f48 <rpmsg_virtio_send_offchannel_raw+0x24>
   12f46:	463d      	mov	r5, r7
		len = buff_len;
	io = rvdev->shbuf_io;
   12f48:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
   12f4c:	6801      	ldr	r1, [r0, #0]
   12f4e:	ebaa 0101 	sub.w	r1, sl, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   12f52:	6883      	ldr	r3, [r0, #8]
   12f54:	4299      	cmp	r1, r3
   12f56:	d20d      	bcs.n	12f74 <rpmsg_virtio_send_offchannel_raw+0x50>
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
   12f58:	462b      	mov	r3, r5
   12f5a:	464a      	mov	r2, r9
   12f5c:	f008 f98a 	bl	1b274 <metal_io_block_write>
				      data, len);
	RPMSG_ASSERT(status == len, "failed to write buffer\r\n");

	return rpmsg_virtio_send_offchannel_nocopy(rdev, src, dst, buffer, len);
   12f60:	9500      	str	r5, [sp, #0]
   12f62:	4653      	mov	r3, sl
   12f64:	4642      	mov	r2, r8
   12f66:	4631      	mov	r1, r6
   12f68:	4620      	mov	r0, r4
   12f6a:	f008 fe09 	bl	1bb80 <rpmsg_virtio_send_offchannel_nocopy>
}
   12f6e:	b004      	add	sp, #16
   12f70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12f74:	f04f 31ff 	mov.w	r1, #4294967295
   12f78:	e7ee      	b.n	12f58 <rpmsg_virtio_send_offchannel_raw+0x34>
		return RPMSG_ERR_NO_BUFF;
   12f7a:	4801      	ldr	r0, [pc, #4]	; (12f80 <rpmsg_virtio_send_offchannel_raw+0x5c>)
   12f7c:	e7f7      	b.n	12f6e <rpmsg_virtio_send_offchannel_raw+0x4a>
   12f7e:	bf00      	nop
   12f80:	fffff82e 	.word	0xfffff82e

00012f84 <rpmsg_virtio_get_buffer_size>:

	return RPMSG_SUCCESS;
}

int rpmsg_virtio_get_buffer_size(struct rpmsg_device *rdev)
{
   12f84:	b538      	push	{r3, r4, r5, lr}
	int size;
	struct rpmsg_virtio_device *rvdev;

	if (!rdev)
   12f86:	b190      	cbz	r0, 12fae <rpmsg_virtio_get_buffer_size+0x2a>
   12f88:	4604      	mov	r4, r0
		return RPMSG_ERR_PARAM;
	metal_mutex_acquire(&rdev->lock);
   12f8a:	f100 0558 	add.w	r5, r0, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   12f8e:	f04f 32ff 	mov.w	r2, #4294967295
   12f92:	f04f 33ff 	mov.w	r3, #4294967295
   12f96:	4628      	mov	r0, r5
   12f98:	f000 fe22 	bl	13be0 <z_impl_k_sem_take>
	rvdev = (struct rpmsg_virtio_device *)rdev;
	size = _rpmsg_virtio_get_buffer_size(rvdev);
   12f9c:	4620      	mov	r0, r4
   12f9e:	f7ff ffa7 	bl	12ef0 <_rpmsg_virtio_get_buffer_size>
   12fa2:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   12fa4:	4628      	mov	r0, r5
   12fa6:	f000 fdf3 	bl	13b90 <z_impl_k_sem_give>
	metal_mutex_release(&rdev->lock);
	return size;
}
   12faa:	4620      	mov	r0, r4
   12fac:	bd38      	pop	{r3, r4, r5, pc}
		return RPMSG_ERR_PARAM;
   12fae:	4c01      	ldr	r4, [pc, #4]	; (12fb4 <rpmsg_virtio_get_buffer_size+0x30>)
   12fb0:	e7fb      	b.n	12faa <rpmsg_virtio_get_buffer_size+0x26>
   12fb2:	bf00      	nop
   12fb4:	fffff82d 	.word	0xfffff82d

00012fb8 <rpmsg_init_vdev_with_config>:
				struct virtio_device *vdev,
				rpmsg_ns_bind_cb ns_bind_cb,
				struct metal_io_region *shm_io,
				struct rpmsg_virtio_shm_pool *shpool,
				const struct rpmsg_virtio_config *config)
{
   12fb8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12fbc:	b08a      	sub	sp, #40	; 0x28
   12fbe:	4604      	mov	r4, r0
   12fc0:	460e      	mov	r6, r1
   12fc2:	4617      	mov	r7, r2
   12fc4:	461d      	mov	r5, r3
   12fc6:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
	vq_callback callback[RPMSG_NUM_VRINGS];
	int status;
	unsigned int i, role;

	rdev = &rvdev->rdev;
	memset(rdev, 0, sizeof(*rdev));
   12fca:	228c      	movs	r2, #140	; 0x8c
   12fcc:	2100      	movs	r1, #0
   12fce:	f004 fbde 	bl	1778e <memset>
	metal_mutex_init(&rdev->lock);
   12fd2:	f104 0058 	add.w	r0, r4, #88	; 0x58
	return z_impl_k_sem_init(sem, initial_count, limit);
   12fd6:	2201      	movs	r2, #1
   12fd8:	4611      	mov	r1, r2
   12fda:	f009 f91b 	bl	1c214 <z_impl_k_sem_init>
	rvdev->vdev = vdev;
   12fde:	f8c4 6094 	str.w	r6, [r4, #148]	; 0x94
	rdev->ns_bind_cb = ns_bind_cb;
   12fe2:	6727      	str	r7, [r4, #112]	; 0x70
	vdev->priv = rvdev;
   12fe4:	6274      	str	r4, [r6, #36]	; 0x24
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
   12fe6:	4b68      	ldr	r3, [pc, #416]	; (13188 <rpmsg_init_vdev_with_config+0x1d0>)
   12fe8:	6763      	str	r3, [r4, #116]	; 0x74
	rdev->ops.hold_rx_buffer = rpmsg_virtio_hold_rx_buffer;
   12fea:	4b68      	ldr	r3, [pc, #416]	; (1318c <rpmsg_init_vdev_with_config+0x1d4>)
   12fec:	67a3      	str	r3, [r4, #120]	; 0x78
	rdev->ops.release_rx_buffer = rpmsg_virtio_release_rx_buffer;
   12fee:	4b68      	ldr	r3, [pc, #416]	; (13190 <rpmsg_init_vdev_with_config+0x1d8>)
   12ff0:	67e3      	str	r3, [r4, #124]	; 0x7c
	rdev->ops.get_tx_payload_buffer = rpmsg_virtio_get_tx_payload_buffer;
   12ff2:	4b68      	ldr	r3, [pc, #416]	; (13194 <rpmsg_init_vdev_with_config+0x1dc>)
   12ff4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	rdev->ops.send_offchannel_nocopy = rpmsg_virtio_send_offchannel_nocopy;
   12ff8:	4b67      	ldr	r3, [pc, #412]	; (13198 <rpmsg_init_vdev_with_config+0x1e0>)
   12ffa:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
   12ffe:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   13002:	699f      	ldr	r7, [r3, #24]
	role = rpmsg_virtio_get_role(rvdev);

#ifndef VIRTIO_DEVICE_ONLY
	if (role == RPMSG_HOST) {
   13004:	b957      	cbnz	r7, 1301c <rpmsg_init_vdev_with_config+0x64>
		/*
		 * The virtio configuration contains only options applicable to
		 * a virtio driver, implying rpmsg host role.
		 */
		if (config == NULL) {
   13006:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   13008:	2b00      	cmp	r3, #0
   1300a:	f000 80b4 	beq.w	13176 <rpmsg_init_vdev_with_config+0x1be>
			return RPMSG_ERR_PARAM;
		}
		rvdev->config = *config;
   1300e:	f104 038c 	add.w	r3, r4, #140	; 0x8c
   13012:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   13014:	e892 0003 	ldmia.w	r2, {r0, r1}
   13018:	e883 0003 	stmia.w	r3, {r0, r1}
	(void)config;
#endif /*!VIRTIO_DEVICE_ONLY*/


#ifndef VIRTIO_DRIVER_ONLY
	if (role == RPMSG_REMOTE) {
   1301c:	2f01      	cmp	r7, #1
   1301e:	d03a      	beq.n	13096 <rpmsg_init_vdev_with_config+0xde>
	return rvdev->vdev->func->get_features(rvdev->vdev);
   13020:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   13024:	6a03      	ldr	r3, [r0, #32]
   13026:	689b      	ldr	r3, [r3, #8]
   13028:	4798      	blx	r3
		/* wait synchro with the master */
		rpmsg_virtio_wait_remote_ready(rvdev);
	}
#endif /*!VIRTIO_DRIVER_ONLY*/
	vdev->features = rpmsg_virtio_get_features(rvdev);
   1302a:	6130      	str	r0, [r6, #16]
   1302c:	2300      	movs	r3, #0
   1302e:	6173      	str	r3, [r6, #20]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
   13030:	f000 0001 	and.w	r0, r0, #1
   13034:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88

#ifndef VIRTIO_DEVICE_ONLY
	if (role == RPMSG_HOST) {
   13038:	b9d7      	cbnz	r7, 13070 <rpmsg_init_vdev_with_config+0xb8>
		/*
		 * Since device is RPMSG Remote so we need to manage the
		 * shared buffers. Create shared memory pool to handle buffers.
		 */
		if (!shpool)
   1303a:	f1b8 0f00 	cmp.w	r8, #0
   1303e:	f000 809d 	beq.w	1317c <rpmsg_init_vdev_with_config+0x1c4>
			return RPMSG_ERR_PARAM;
		if (!shpool->size)
   13042:	f8d8 3008 	ldr.w	r3, [r8, #8]
   13046:	2b00      	cmp	r3, #0
   13048:	f000 809b 	beq.w	13182 <rpmsg_init_vdev_with_config+0x1ca>
			return RPMSG_ERR_NO_BUFF;
		rvdev->shpool = shpool;
   1304c:	f8c4 80a4 	str.w	r8, [r4, #164]	; 0xa4

		vq_names[0] = "rx_vq";
   13050:	4b52      	ldr	r3, [pc, #328]	; (1319c <rpmsg_init_vdev_with_config+0x1e4>)
   13052:	9308      	str	r3, [sp, #32]
		vq_names[1] = "tx_vq";
   13054:	4b52      	ldr	r3, [pc, #328]	; (131a0 <rpmsg_init_vdev_with_config+0x1e8>)
   13056:	9309      	str	r3, [sp, #36]	; 0x24
		callback[0] = rpmsg_virtio_rx_callback;
   13058:	4b52      	ldr	r3, [pc, #328]	; (131a4 <rpmsg_init_vdev_with_config+0x1ec>)
   1305a:	9306      	str	r3, [sp, #24]
		callback[1] = rpmsg_virtio_tx_callback;
   1305c:	4b52      	ldr	r3, [pc, #328]	; (131a8 <rpmsg_init_vdev_with_config+0x1f0>)
   1305e:	9307      	str	r3, [sp, #28]
		rvdev->rvq  = vdev->vrings_info[0].vq;
   13060:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   13062:	681b      	ldr	r3, [r3, #0]
   13064:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
		rvdev->svq  = vdev->vrings_info[1].vq;
   13068:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   1306a:	699b      	ldr	r3, [r3, #24]
   1306c:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	}
#endif /*!VIRTIO_DEVICE_ONLY*/

#ifndef VIRTIO_DRIVER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
   13070:	2f01      	cmp	r7, #1
   13072:	d014      	beq.n	1309e <rpmsg_init_vdev_with_config+0xe6>
		callback[1] = rpmsg_virtio_rx_callback;
		rvdev->rvq  = vdev->vrings_info[1].vq;
		rvdev->svq  = vdev->vrings_info[0].vq;
	}
#endif /*!VIRTIO_DRIVER_ONLY*/
	rvdev->shbuf_io = shm_io;
   13074:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
   13078:	ab06      	add	r3, sp, #24
   1307a:	9300      	str	r3, [sp, #0]
   1307c:	ab08      	add	r3, sp, #32
   1307e:	2202      	movs	r2, #2
   13080:	2100      	movs	r1, #0
   13082:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   13086:	f7ff fdc5 	bl	12c14 <virtio_create_virtqueues>

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
   1308a:	4682      	mov	sl, r0
   1308c:	b1c0      	cbz	r0, 130c0 <rpmsg_init_vdev_with_config+0x108>
	if (role == RPMSG_HOST)
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
#endif /*!VIRTIO_DEVICE_ONLY*/

	return status;
}
   1308e:	4650      	mov	r0, sl
   13090:	b00a      	add	sp, #40	; 0x28
   13092:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		rpmsg_virtio_wait_remote_ready(rvdev);
   13096:	4620      	mov	r0, r4
   13098:	f008 fc94 	bl	1b9c4 <rpmsg_virtio_wait_remote_ready>
   1309c:	e7c0      	b.n	13020 <rpmsg_init_vdev_with_config+0x68>
		vq_names[0] = "tx_vq";
   1309e:	4b40      	ldr	r3, [pc, #256]	; (131a0 <rpmsg_init_vdev_with_config+0x1e8>)
   130a0:	9308      	str	r3, [sp, #32]
		vq_names[1] = "rx_vq";
   130a2:	4b3e      	ldr	r3, [pc, #248]	; (1319c <rpmsg_init_vdev_with_config+0x1e4>)
   130a4:	9309      	str	r3, [sp, #36]	; 0x24
		callback[0] = rpmsg_virtio_tx_callback;
   130a6:	4b40      	ldr	r3, [pc, #256]	; (131a8 <rpmsg_init_vdev_with_config+0x1f0>)
   130a8:	9306      	str	r3, [sp, #24]
		callback[1] = rpmsg_virtio_rx_callback;
   130aa:	4b3e      	ldr	r3, [pc, #248]	; (131a4 <rpmsg_init_vdev_with_config+0x1ec>)
   130ac:	9307      	str	r3, [sp, #28]
		rvdev->rvq  = vdev->vrings_info[1].vq;
   130ae:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   130b0:	699b      	ldr	r3, [r3, #24]
   130b2:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
		rvdev->svq  = vdev->vrings_info[0].vq;
   130b6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   130b8:	681b      	ldr	r3, [r3, #0]
   130ba:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
   130be:	e7d9      	b.n	13074 <rpmsg_init_vdev_with_config+0xbc>
	virtqueue_disable_cb(rvdev->svq);
   130c0:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   130c4:	f008 fb3d 	bl	1b742 <virtqueue_disable_cb>
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
   130c8:	2300      	movs	r3, #0
   130ca:	e006      	b.n	130da <rpmsg_init_vdev_with_config+0x122>
		vq = vdev->vrings_info[i].vq;
   130cc:	6af2      	ldr	r2, [r6, #44]	; 0x2c
   130ce:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   130d2:	f852 2031 	ldr.w	r2, [r2, r1, lsl #3]
		vq->shm_io = shm_io;
   130d6:	6295      	str	r5, [r2, #40]	; 0x28
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
   130d8:	3301      	adds	r3, #1
   130da:	2b01      	cmp	r3, #1
   130dc:	d9f6      	bls.n	130cc <rpmsg_init_vdev_with_config+0x114>
	if (role == RPMSG_HOST) {
   130de:	bb7f      	cbnz	r7, 13140 <rpmsg_init_vdev_with_config+0x188>
		vqbuf.len = rvdev->config.r2h_buf_size;
   130e0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   130e4:	9305      	str	r3, [sp, #20]
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
   130e6:	46b9      	mov	r9, r7
   130e8:	e012      	b.n	13110 <rpmsg_init_vdev_with_config+0x158>
			metal_io_block_set(shm_io,
   130ea:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   130ee:	2200      	movs	r2, #0
   130f0:	4628      	mov	r0, r5
   130f2:	f008 f900 	bl	1b2f6 <metal_io_block_set>
				virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1,
   130f6:	9600      	str	r6, [sp, #0]
   130f8:	2301      	movs	r3, #1
   130fa:	2200      	movs	r2, #0
   130fc:	a904      	add	r1, sp, #16
   130fe:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
   13102:	f008 fa59 	bl	1b5b8 <virtqueue_add_buffer>
			if (status != RPMSG_SUCCESS) {
   13106:	4682      	mov	sl, r0
   13108:	2800      	cmp	r0, #0
   1310a:	d1c0      	bne.n	1308e <rpmsg_init_vdev_with_config+0xd6>
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
   1310c:	f109 0901 	add.w	r9, r9, #1
   13110:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   13114:	895b      	ldrh	r3, [r3, #10]
   13116:	454b      	cmp	r3, r9
   13118:	d912      	bls.n	13140 <rpmsg_init_vdev_with_config+0x188>
			buffer = rpmsg_virtio_shm_pool_get_buffer(shpool,
   1311a:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
   1311e:	4640      	mov	r0, r8
   13120:	f008 fddb 	bl	1bcda <rpmsg_virtio_shm_pool_get_buffer>
			if (!buffer) {
   13124:	4606      	mov	r6, r0
   13126:	b140      	cbz	r0, 1313a <rpmsg_init_vdev_with_config+0x182>
			vqbuf.buf = buffer;
   13128:	9004      	str	r0, [sp, #16]
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
   1312a:	6829      	ldr	r1, [r5, #0]
   1312c:	1a41      	subs	r1, r0, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   1312e:	68ab      	ldr	r3, [r5, #8]
   13130:	4299      	cmp	r1, r3
   13132:	d3da      	bcc.n	130ea <rpmsg_init_vdev_with_config+0x132>
   13134:	f04f 31ff 	mov.w	r1, #4294967295
   13138:	e7d7      	b.n	130ea <rpmsg_init_vdev_with_config+0x132>
				return RPMSG_ERR_NO_BUFF;
   1313a:	f8df a070 	ldr.w	sl, [pc, #112]	; 131ac <rpmsg_init_vdev_with_config+0x1f4>
   1313e:	e7a6      	b.n	1308e <rpmsg_init_vdev_with_config+0xd6>
	list->prev = list;
   13140:	6064      	str	r4, [r4, #4]
	list->next = list;
   13142:	6024      	str	r4, [r4, #0]
	if (rdev->support_ns) {
   13144:	f894 3088 	ldrb.w	r3, [r4, #136]	; 0x88
   13148:	b943      	cbnz	r3, 1315c <rpmsg_init_vdev_with_config+0x1a4>
	if (role == RPMSG_HOST)
   1314a:	2f00      	cmp	r7, #0
   1314c:	d19f      	bne.n	1308e <rpmsg_init_vdev_with_config+0xd6>
	rvdev->vdev->func->set_status(rvdev->vdev, status);
   1314e:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   13152:	6a03      	ldr	r3, [r0, #32]
   13154:	685b      	ldr	r3, [r3, #4]
   13156:	2104      	movs	r1, #4
   13158:	4798      	blx	r3
}
   1315a:	e798      	b.n	1308e <rpmsg_init_vdev_with_config+0xd6>
		rpmsg_register_endpoint(rdev, &rdev->ns_ept, "NS",
   1315c:	2300      	movs	r3, #0
   1315e:	9302      	str	r3, [sp, #8]
   13160:	4b13      	ldr	r3, [pc, #76]	; (131b0 <rpmsg_init_vdev_with_config+0x1f8>)
   13162:	9301      	str	r3, [sp, #4]
   13164:	2335      	movs	r3, #53	; 0x35
   13166:	9300      	str	r3, [sp, #0]
   13168:	4a12      	ldr	r2, [pc, #72]	; (131b4 <rpmsg_init_vdev_with_config+0x1fc>)
   1316a:	f104 0108 	add.w	r1, r4, #8
   1316e:	4620      	mov	r0, r4
   13170:	f7ff fe32 	bl	12dd8 <rpmsg_register_endpoint>
   13174:	e7e9      	b.n	1314a <rpmsg_init_vdev_with_config+0x192>
			return RPMSG_ERR_PARAM;
   13176:	f8df a040 	ldr.w	sl, [pc, #64]	; 131b8 <rpmsg_init_vdev_with_config+0x200>
   1317a:	e788      	b.n	1308e <rpmsg_init_vdev_with_config+0xd6>
			return RPMSG_ERR_PARAM;
   1317c:	f8df a038 	ldr.w	sl, [pc, #56]	; 131b8 <rpmsg_init_vdev_with_config+0x200>
   13180:	e785      	b.n	1308e <rpmsg_init_vdev_with_config+0xd6>
			return RPMSG_ERR_NO_BUFF;
   13182:	f8df a028 	ldr.w	sl, [pc, #40]	; 131ac <rpmsg_init_vdev_with_config+0x1f4>
   13186:	e782      	b.n	1308e <rpmsg_init_vdev_with_config+0xd6>
   13188:	00012f25 	.word	0x00012f25
   1318c:	0001b9f1 	.word	0x0001b9f1
   13190:	0001bb43 	.word	0x0001bb43
   13194:	0001bd4d 	.word	0x0001bd4d
   13198:	0001bb81 	.word	0x0001bb81
   1319c:	0001fea0 	.word	0x0001fea0
   131a0:	0001fea8 	.word	0x0001fea8
   131a4:	0001bc0d 	.word	0x0001bc0d
   131a8:	0001b9ff 	.word	0x0001b9ff
   131ac:	fffff82e 	.word	0xfffff82e
   131b0:	0001ba01 	.word	0x0001ba01
   131b4:	0001feb0 	.word	0x0001feb0
   131b8:	fffff82d 	.word	0xfffff82d

000131bc <rpmsg_init_vdev>:
{
   131bc:	b510      	push	{r4, lr}
   131be:	b084      	sub	sp, #16
   131c0:	4684      	mov	ip, r0
   131c2:	468e      	mov	lr, r1
			   shpool, RPMSG_VIRTIO_DEFAULT_CONFIG);
   131c4:	4906      	ldr	r1, [pc, #24]	; (131e0 <rpmsg_init_vdev+0x24>)
   131c6:	ac02      	add	r4, sp, #8
   131c8:	c903      	ldmia	r1, {r0, r1}
   131ca:	e884 0003 	stmia.w	r4, {r0, r1}
	return rpmsg_init_vdev_with_config(rvdev, vdev, ns_bind_cb, shm_io,
   131ce:	9401      	str	r4, [sp, #4]
   131d0:	9906      	ldr	r1, [sp, #24]
   131d2:	9100      	str	r1, [sp, #0]
   131d4:	4671      	mov	r1, lr
   131d6:	4660      	mov	r0, ip
   131d8:	f7ff feee 	bl	12fb8 <rpmsg_init_vdev_with_config>
}
   131dc:	b004      	add	sp, #16
   131de:	bd10      	pop	{r4, pc}
   131e0:	0001d1e0 	.word	0x0001d1e0

000131e4 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	const struct device *dev = __device_start;
   131e4:	4b03      	ldr	r3, [pc, #12]	; (131f4 <z_device_state_init+0x10>)

	while (dev < __device_end) {
   131e6:	e000      	b.n	131ea <z_device_state_init+0x6>
		z_object_init(dev);
		++dev;
   131e8:	3318      	adds	r3, #24
	while (dev < __device_end) {
   131ea:	4a03      	ldr	r2, [pc, #12]	; (131f8 <z_device_state_init+0x14>)
   131ec:	4293      	cmp	r3, r2
   131ee:	d3fb      	bcc.n	131e8 <z_device_state_init+0x4>
	}
}
   131f0:	4770      	bx	lr
   131f2:	bf00      	nop
   131f4:	0001cc14 	.word	0x0001cc14
   131f8:	0001cd04 	.word	0x0001cd04

000131fc <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
   131fc:	b570      	push	{r4, r5, r6, lr}
   131fe:	4606      	mov	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   13200:	4b11      	ldr	r3, [pc, #68]	; (13248 <z_sys_init_run_level+0x4c>)
   13202:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   13206:	e009      	b.n	1321c <z_sys_init_run_level+0x20>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
   13208:	4240      	negs	r0, r0
   1320a:	e017      	b.n	1323c <z_sys_init_run_level+0x40>
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
   1320c:	68eb      	ldr	r3, [r5, #12]
   1320e:	7018      	strb	r0, [r3, #0]
			}
			dev->state->initialized = true;
   13210:	68ea      	ldr	r2, [r5, #12]
   13212:	7853      	ldrb	r3, [r2, #1]
   13214:	f043 0301 	orr.w	r3, r3, #1
   13218:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   1321a:	3408      	adds	r4, #8
   1321c:	1c73      	adds	r3, r6, #1
   1321e:	4a0a      	ldr	r2, [pc, #40]	; (13248 <z_sys_init_run_level+0x4c>)
   13220:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13224:	42a3      	cmp	r3, r4
   13226:	d90d      	bls.n	13244 <z_sys_init_run_level+0x48>
		const struct device *dev = entry->dev;
   13228:	6865      	ldr	r5, [r4, #4]
		int rc = entry->init(dev);
   1322a:	6823      	ldr	r3, [r4, #0]
   1322c:	4628      	mov	r0, r5
   1322e:	4798      	blx	r3
		if (dev != NULL) {
   13230:	2d00      	cmp	r5, #0
   13232:	d0f2      	beq.n	1321a <z_sys_init_run_level+0x1e>
			if (rc != 0) {
   13234:	2800      	cmp	r0, #0
   13236:	d0eb      	beq.n	13210 <z_sys_init_run_level+0x14>
				if (rc < 0) {
   13238:	2800      	cmp	r0, #0
   1323a:	dbe5      	blt.n	13208 <z_sys_init_run_level+0xc>
				if (rc > UINT8_MAX) {
   1323c:	28ff      	cmp	r0, #255	; 0xff
   1323e:	dde5      	ble.n	1320c <z_sys_init_run_level+0x10>
					rc = UINT8_MAX;
   13240:	20ff      	movs	r0, #255	; 0xff
   13242:	e7e3      	b.n	1320c <z_sys_init_run_level+0x10>
		}
	}
}
   13244:	bd70      	pop	{r4, r5, r6, pc}
   13246:	bf00      	nop
   13248:	0001feb4 	.word	0x0001feb4

0001324c <reason_to_str>:
	return thread_name;
}

static const char *reason_to_str(unsigned int reason)
{
	switch (reason) {
   1324c:	2804      	cmp	r0, #4
   1324e:	d80c      	bhi.n	1326a <reason_to_str+0x1e>
   13250:	e8df f000 	tbb	[pc, r0]
   13254:	07050d03 	.word	0x07050d03
   13258:	09          	.byte	0x09
   13259:	00          	.byte	0x00
   1325a:	4806      	ldr	r0, [pc, #24]	; (13274 <reason_to_str+0x28>)
   1325c:	4770      	bx	lr
	case K_ERR_CPU_EXCEPTION:
		return "CPU exception";
	case K_ERR_SPURIOUS_IRQ:
		return "Unhandled interrupt";
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
   1325e:	4806      	ldr	r0, [pc, #24]	; (13278 <reason_to_str+0x2c>)
   13260:	4770      	bx	lr
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
   13262:	4806      	ldr	r0, [pc, #24]	; (1327c <reason_to_str+0x30>)
   13264:	4770      	bx	lr
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
   13266:	4806      	ldr	r0, [pc, #24]	; (13280 <reason_to_str+0x34>)
   13268:	4770      	bx	lr
	default:
		return "Unknown error";
   1326a:	4806      	ldr	r0, [pc, #24]	; (13284 <reason_to_str+0x38>)
   1326c:	4770      	bx	lr
		return "Unhandled interrupt";
   1326e:	4806      	ldr	r0, [pc, #24]	; (13288 <reason_to_str+0x3c>)
	}
}
   13270:	4770      	bx	lr
   13272:	bf00      	nop
   13274:	0001ff1c 	.word	0x0001ff1c
   13278:	0001fef0 	.word	0x0001fef0
   1327c:	0001ff00 	.word	0x0001ff00
   13280:	0001ff0c 	.word	0x0001ff0c
   13284:	0001fecc 	.word	0x0001fecc
   13288:	0001fedc 	.word	0x0001fedc

0001328c <thread_name_get>:
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   1328c:	b130      	cbz	r0, 1329c <thread_name_get+0x10>
{
   1328e:	b508      	push	{r3, lr}
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
   13290:	f008 fe83 	bl	1bf9a <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
   13294:	b120      	cbz	r0, 132a0 <thread_name_get+0x14>
   13296:	7803      	ldrb	r3, [r0, #0]
   13298:	b123      	cbz	r3, 132a4 <thread_name_get+0x18>
}
   1329a:	bd08      	pop	{r3, pc}
		thread_name = "unknown";
   1329c:	4802      	ldr	r0, [pc, #8]	; (132a8 <thread_name_get+0x1c>)
}
   1329e:	4770      	bx	lr
		thread_name = "unknown";
   132a0:	4801      	ldr	r0, [pc, #4]	; (132a8 <thread_name_get+0x1c>)
   132a2:	e7fa      	b.n	1329a <thread_name_get+0xe>
   132a4:	4800      	ldr	r0, [pc, #0]	; (132a8 <thread_name_get+0x1c>)
	return thread_name;
   132a6:	e7f8      	b.n	1329a <thread_name_get+0xe>
   132a8:	0001dff0 	.word	0x0001dff0

000132ac <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   132ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   132b0:	b089      	sub	sp, #36	; 0x24
   132b2:	af00      	add	r7, sp, #0
   132b4:	4606      	mov	r6, r0
   132b6:	460c      	mov	r4, r1
	__asm__ volatile(
   132b8:	f04f 0320 	mov.w	r3, #32
   132bc:	f3ef 8811 	mrs	r8, BASEPRI
   132c0:	f383 8812 	msr	BASEPRI_MAX, r3
   132c4:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   132c8:	f001 fa5a 	bl	14780 <z_impl_z_current_get>
   132cc:	4605      	mov	r5, r0
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   132ce:	4630      	mov	r0, r6
   132d0:	f7ff ffbc 	bl	1324c <reason_to_str>
   132d4:	2303      	movs	r3, #3
   132d6:	713b      	strb	r3, [r7, #4]
   132d8:	46e9      	mov	r9, sp
   132da:	b08a      	sub	sp, #40	; 0x28
   132dc:	466b      	mov	r3, sp
   132de:	f113 0210 	adds.w	r2, r3, #16
   132e2:	f000 80ad 	beq.w	13440 <z_fatal_error+0x194>
   132e6:	f04f 0c15 	mov.w	ip, #21
   132ea:	b122      	cbz	r2, 132f6 <z_fatal_error+0x4a>
   132ec:	f1bc 0f04 	cmp.w	ip, #4
   132f0:	dd01      	ble.n	132f6 <z_fatal_error+0x4a>
   132f2:	4974      	ldr	r1, [pc, #464]	; (134c4 <z_fatal_error+0x218>)
   132f4:	6159      	str	r1, [r3, #20]
   132f6:	b11a      	cbz	r2, 13300 <z_fatal_error+0x54>
   132f8:	f1bc 0f08 	cmp.w	ip, #8
   132fc:	dd00      	ble.n	13300 <z_fatal_error+0x54>
   132fe:	619e      	str	r6, [r3, #24]
   13300:	2103      	movs	r1, #3
   13302:	7039      	strb	r1, [r7, #0]
   13304:	b11a      	cbz	r2, 1330e <z_fatal_error+0x62>
   13306:	f1bc 0f0c 	cmp.w	ip, #12
   1330a:	dd00      	ble.n	1330e <z_fatal_error+0x62>
   1330c:	61d8      	str	r0, [r3, #28]
   1330e:	b122      	cbz	r2, 1331a <z_fatal_error+0x6e>
   13310:	f1bc 0f10 	cmp.w	ip, #16
   13314:	dd01      	ble.n	1331a <z_fatal_error+0x6e>
   13316:	2100      	movs	r1, #0
   13318:	6219      	str	r1, [r3, #32]
   1331a:	b12a      	cbz	r2, 13328 <z_fatal_error+0x7c>
   1331c:	f103 0124 	add.w	r1, r3, #36	; 0x24
   13320:	2000      	movs	r0, #0
   13322:	2800      	cmp	r0, #0
   13324:	f000 808f 	beq.w	13446 <z_fatal_error+0x19a>
   13328:	f1bc 0f14 	cmp.w	ip, #20
   1332c:	f340 8094 	ble.w	13458 <z_fatal_error+0x1ac>
   13330:	f04f 0c15 	mov.w	ip, #21
   13334:	b142      	cbz	r2, 13348 <z_fatal_error+0x9c>
   13336:	2105      	movs	r1, #5
   13338:	7139      	strb	r1, [r7, #4]
   1333a:	2100      	movs	r1, #0
   1333c:	7179      	strb	r1, [r7, #5]
   1333e:	71b9      	strb	r1, [r7, #6]
   13340:	2101      	movs	r1, #1
   13342:	71f9      	strb	r1, [r7, #7]
   13344:	6878      	ldr	r0, [r7, #4]
   13346:	6118      	str	r0, [r3, #16]
   13348:	2100      	movs	r1, #0
   1334a:	f36f 0100 	bfc	r1, #0, #1
   1334e:	f36f 0141 	bfc	r1, #1, #1
   13352:	f36f 0182 	bfc	r1, #2, #1
   13356:	f36f 01c5 	bfc	r1, #3, #3
   1335a:	2301      	movs	r3, #1
   1335c:	f363 1188 	bfi	r1, r3, #6, #3
   13360:	f3cc 0c09 	ubfx	ip, ip, #0, #10
   13364:	f36c 2152 	bfi	r1, ip, #9, #10
   13368:	f36f 41de 	bfc	r1, #19, #12
   1336c:	f36f 71df 	bfc	r1, #31, #1
   13370:	2300      	movs	r3, #0
   13372:	4855      	ldr	r0, [pc, #340]	; (134c8 <z_fatal_error+0x21c>)
   13374:	f7ee ff68 	bl	2248 <z_impl_z_log_msg_static_create>
   13378:	46cd      	mov	sp, r9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   1337a:	b124      	cbz	r4, 13386 <z_fatal_error+0xda>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   1337c:	69e3      	ldr	r3, [r4, #28]
   1337e:	f3c3 0308 	ubfx	r3, r3, #0, #9
   13382:	2b00      	cmp	r3, #0
   13384:	d16b      	bne.n	1345e <z_fatal_error+0x1b2>
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   13386:	4628      	mov	r0, r5
   13388:	f7ff ff80 	bl	1328c <thread_name_get>
   1338c:	2303      	movs	r3, #3
   1338e:	713b      	strb	r3, [r7, #4]
   13390:	46e9      	mov	r9, sp
   13392:	b08a      	sub	sp, #40	; 0x28
   13394:	466b      	mov	r3, sp
   13396:	f113 0210 	adds.w	r2, r3, #16
   1339a:	f000 8083 	beq.w	134a4 <z_fatal_error+0x1f8>
   1339e:	f04f 0c11 	mov.w	ip, #17
   133a2:	b122      	cbz	r2, 133ae <z_fatal_error+0x102>
   133a4:	f1bc 0f04 	cmp.w	ip, #4
   133a8:	dd01      	ble.n	133ae <z_fatal_error+0x102>
   133aa:	4948      	ldr	r1, [pc, #288]	; (134cc <z_fatal_error+0x220>)
   133ac:	6159      	str	r1, [r3, #20]
   133ae:	b11a      	cbz	r2, 133b8 <z_fatal_error+0x10c>
   133b0:	f1bc 0f08 	cmp.w	ip, #8
   133b4:	dd00      	ble.n	133b8 <z_fatal_error+0x10c>
   133b6:	619d      	str	r5, [r3, #24]
   133b8:	2103      	movs	r1, #3
   133ba:	7039      	strb	r1, [r7, #0]
   133bc:	b11a      	cbz	r2, 133c6 <z_fatal_error+0x11a>
   133be:	f1bc 0f0c 	cmp.w	ip, #12
   133c2:	dd00      	ble.n	133c6 <z_fatal_error+0x11a>
   133c4:	61d8      	str	r0, [r3, #28]
   133c6:	b122      	cbz	r2, 133d2 <z_fatal_error+0x126>
   133c8:	f103 0120 	add.w	r1, r3, #32
   133cc:	2000      	movs	r0, #0
   133ce:	2800      	cmp	r0, #0
   133d0:	d06b      	beq.n	134aa <z_fatal_error+0x1fe>
   133d2:	f1bc 0f10 	cmp.w	ip, #16
   133d6:	dd71      	ble.n	134bc <z_fatal_error+0x210>
   133d8:	f04f 0c11 	mov.w	ip, #17
   133dc:	b142      	cbz	r2, 133f0 <z_fatal_error+0x144>
   133de:	2104      	movs	r1, #4
   133e0:	7139      	strb	r1, [r7, #4]
   133e2:	2100      	movs	r1, #0
   133e4:	7179      	strb	r1, [r7, #5]
   133e6:	71b9      	strb	r1, [r7, #6]
   133e8:	2101      	movs	r1, #1
   133ea:	71f9      	strb	r1, [r7, #7]
   133ec:	6878      	ldr	r0, [r7, #4]
   133ee:	6118      	str	r0, [r3, #16]
   133f0:	2100      	movs	r1, #0
   133f2:	f36f 0100 	bfc	r1, #0, #1
   133f6:	f36f 0141 	bfc	r1, #1, #1
   133fa:	f36f 0182 	bfc	r1, #2, #1
   133fe:	f36f 01c5 	bfc	r1, #3, #3
   13402:	2301      	movs	r3, #1
   13404:	f363 1188 	bfi	r1, r3, #6, #3
   13408:	f3cc 0c09 	ubfx	ip, ip, #0, #10
   1340c:	f36c 2152 	bfi	r1, ip, #9, #10
   13410:	f36f 41de 	bfc	r1, #19, #12
   13414:	f36f 71df 	bfc	r1, #31, #1
   13418:	2300      	movs	r3, #0
   1341a:	482b      	ldr	r0, [pc, #172]	; (134c8 <z_fatal_error+0x21c>)
   1341c:	f7ee ff14 	bl	2248 <z_impl_z_log_msg_static_create>
   13420:	46cd      	mov	sp, r9

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
   13422:	4621      	mov	r1, r4
   13424:	4630      	mov	r0, r6
   13426:	f7fd fd13 	bl	10e50 <k_sys_fatal_error_handler>
	__asm__ volatile(
   1342a:	f388 8811 	msr	BASEPRI, r8
   1342e:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   13432:	4628      	mov	r0, r5
   13434:	f7f1 fe66 	bl	5104 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   13438:	3724      	adds	r7, #36	; 0x24
   1343a:	46bd      	mov	sp, r7
   1343c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   13440:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
   13444:	e751      	b.n	132ea <z_fatal_error+0x3e>
   13446:	f107 0e20 	add.w	lr, r7, #32
   1344a:	4486      	add	lr, r0
   1344c:	f81e ec20 	ldrb.w	lr, [lr, #-32]
   13450:	f801 eb01 	strb.w	lr, [r1], #1
   13454:	3001      	adds	r0, #1
   13456:	e764      	b.n	13322 <z_fatal_error+0x76>
   13458:	f06f 0c1b 	mvn.w	ip, #27
   1345c:	e76a      	b.n	13334 <z_fatal_error+0x88>
		LOG_ERR("Fault during interrupt handling\n");
   1345e:	4b1c      	ldr	r3, [pc, #112]	; (134d0 <z_fatal_error+0x224>)
   13460:	61fb      	str	r3, [r7, #28]
   13462:	2302      	movs	r3, #2
   13464:	713b      	strb	r3, [r7, #4]
   13466:	2300      	movs	r3, #0
   13468:	717b      	strb	r3, [r7, #5]
   1346a:	71bb      	strb	r3, [r7, #6]
   1346c:	71fb      	strb	r3, [r7, #7]
   1346e:	687a      	ldr	r2, [r7, #4]
   13470:	61ba      	str	r2, [r7, #24]
   13472:	4619      	mov	r1, r3
   13474:	f363 0100 	bfi	r1, r3, #0, #1
   13478:	f363 0141 	bfi	r1, r3, #1, #1
   1347c:	f363 0182 	bfi	r1, r3, #2, #1
   13480:	f363 01c5 	bfi	r1, r3, #3, #3
   13484:	2201      	movs	r2, #1
   13486:	f362 1188 	bfi	r1, r2, #6, #3
   1348a:	2208      	movs	r2, #8
   1348c:	f362 2152 	bfi	r1, r2, #9, #10
   13490:	f363 41de 	bfi	r1, r3, #19, #12
   13494:	f363 71df 	bfi	r1, r3, #31, #1
   13498:	f107 0218 	add.w	r2, r7, #24
   1349c:	480a      	ldr	r0, [pc, #40]	; (134c8 <z_fatal_error+0x21c>)
   1349e:	f7ee fed3 	bl	2248 <z_impl_z_log_msg_static_create>
   134a2:	e770      	b.n	13386 <z_fatal_error+0xda>
	LOG_ERR("Current thread: %p (%s)", thread,
   134a4:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
   134a8:	e77b      	b.n	133a2 <z_fatal_error+0xf6>
   134aa:	f107 0e20 	add.w	lr, r7, #32
   134ae:	4486      	add	lr, r0
   134b0:	f81e ec20 	ldrb.w	lr, [lr, #-32]
   134b4:	f801 eb01 	strb.w	lr, [r1], #1
   134b8:	3001      	adds	r0, #1
   134ba:	e788      	b.n	133ce <z_fatal_error+0x122>
   134bc:	f06f 0c1b 	mvn.w	ip, #27
   134c0:	e78c      	b.n	133dc <z_fatal_error+0x130>
   134c2:	bf00      	nop
   134c4:	0001ff2c 	.word	0x0001ff2c
   134c8:	0001d084 	.word	0x0001d084
   134cc:	0001ff78 	.word	0x0001ff78
   134d0:	0001ff54 	.word	0x0001ff54

000134d4 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
   134d4:	b510      	push	{r4, lr}
   134d6:	b086      	sub	sp, #24
	struct k_thread *thread = &z_idle_threads[i];
   134d8:	4c11      	ldr	r4, [pc, #68]	; (13520 <init_idle_thread+0x4c>)
   134da:	23b8      	movs	r3, #184	; 0xb8
   134dc:	fb03 4400 	mla	r4, r3, r0, r4
	k_thread_stack_t *stack = z_idle_stacks[i];
   134e0:	eb00 0c80 	add.w	ip, r0, r0, lsl #2
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   134e4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   134e8:	4b0e      	ldr	r3, [pc, #56]	; (13524 <init_idle_thread+0x50>)
   134ea:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
	z_setup_new_thread(thread, stack,
   134ee:	4b0e      	ldr	r3, [pc, #56]	; (13528 <init_idle_thread+0x54>)
   134f0:	9305      	str	r3, [sp, #20]
   134f2:	2301      	movs	r3, #1
   134f4:	9304      	str	r3, [sp, #16]
   134f6:	230f      	movs	r3, #15
   134f8:	9303      	str	r3, [sp, #12]
   134fa:	2300      	movs	r3, #0
   134fc:	9302      	str	r3, [sp, #8]
   134fe:	9301      	str	r3, [sp, #4]
   13500:	9000      	str	r0, [sp, #0]
   13502:	4b0a      	ldr	r3, [pc, #40]	; (1352c <init_idle_thread+0x58>)
   13504:	f44f 72a0 	mov.w	r2, #320	; 0x140
   13508:	4909      	ldr	r1, [pc, #36]	; (13530 <init_idle_thread+0x5c>)
   1350a:	eb01 118c 	add.w	r1, r1, ip, lsl #6
   1350e:	4620      	mov	r0, r4
   13510:	f000 f970 	bl	137f4 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   13514:	7b63      	ldrb	r3, [r4, #13]
   13516:	f023 0304 	bic.w	r3, r3, #4
   1351a:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   1351c:	b006      	add	sp, #24
   1351e:	bd10      	pop	{r4, pc}
   13520:	20001988 	.word	0x20001988
   13524:	200026d8 	.word	0x200026d8
   13528:	0001ff90 	.word	0x0001ff90
   1352c:	00013951 	.word	0x00013951
   13530:	200042b8 	.word	0x200042b8

00013534 <bg_thread_main>:
{
   13534:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   13536:	4b0a      	ldr	r3, [pc, #40]	; (13560 <bg_thread_main+0x2c>)
   13538:	2201      	movs	r2, #1
   1353a:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   1353c:	2002      	movs	r0, #2
   1353e:	f7ff fe5d 	bl	131fc <z_sys_init_run_level>
	boot_banner();
   13542:	f001 fe9b 	bl	1527c <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   13546:	2003      	movs	r0, #3
   13548:	f7ff fe58 	bl	131fc <z_sys_init_run_level>
	z_init_static_threads();
   1354c:	f000 f9b6 	bl	138bc <z_init_static_threads>
	main();
   13550:	f7ed faf4 	bl	b3c <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   13554:	4a03      	ldr	r2, [pc, #12]	; (13564 <bg_thread_main+0x30>)
   13556:	7b13      	ldrb	r3, [r2, #12]
   13558:	f023 0301 	bic.w	r3, r3, #1
   1355c:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   1355e:	bd08      	pop	{r3, pc}
   13560:	20002900 	.word	0x20002900
   13564:	20001a40 	.word	0x20001a40

00013568 <switch_to_main_thread>:
	return stack_ptr;
}

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
   13568:	b508      	push	{r3, lr}
   1356a:	4601      	mov	r1, r0
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   1356c:	4a01      	ldr	r2, [pc, #4]	; (13574 <switch_to_main_thread+0xc>)
   1356e:	4802      	ldr	r0, [pc, #8]	; (13578 <switch_to_main_thread+0x10>)
   13570:	f7f0 fe2a 	bl	41c8 <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   13574:	00013535 	.word	0x00013535
   13578:	20001a40 	.word	0x20001a40

0001357c <z_bss_zero>:
{
   1357c:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
   1357e:	4803      	ldr	r0, [pc, #12]	; (1358c <z_bss_zero+0x10>)
   13580:	4a03      	ldr	r2, [pc, #12]	; (13590 <z_bss_zero+0x14>)
   13582:	1a12      	subs	r2, r2, r0
   13584:	2100      	movs	r1, #0
   13586:	f008 fc2f 	bl	1bde8 <z_early_memset>
}
   1358a:	bd08      	pop	{r3, pc}
   1358c:	200007b8 	.word	0x200007b8
   13590:	20002904 	.word	0x20002904

00013594 <z_init_cpu>:
{
   13594:	b510      	push	{r4, lr}
   13596:	4604      	mov	r4, r0
	init_idle_thread(id);
   13598:	f7ff ff9c 	bl	134d4 <init_idle_thread>
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
   1359c:	490a      	ldr	r1, [pc, #40]	; (135c8 <z_init_cpu+0x34>)
   1359e:	23b8      	movs	r3, #184	; 0xb8
   135a0:	fb03 1104 	mla	r1, r3, r4, r1
   135a4:	4a09      	ldr	r2, [pc, #36]	; (135cc <z_init_cpu+0x38>)
   135a6:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   135aa:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   135ae:	60d9      	str	r1, [r3, #12]
	_kernel.cpus[id].id = id;
   135b0:	751c      	strb	r4, [r3, #20]
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   135b2:	4b07      	ldr	r3, [pc, #28]	; (135d0 <z_init_cpu+0x3c>)
   135b4:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
   135b8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
	_kernel.cpus[id].irq_stack =
   135bc:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   135c0:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
   135c4:	6063      	str	r3, [r4, #4]
}
   135c6:	bd10      	pop	{r4, pc}
   135c8:	20001988 	.word	0x20001988
   135cc:	200026d8 	.word	0x200026d8
   135d0:	200043f8 	.word	0x200043f8

000135d4 <prepare_multithreading>:
{
   135d4:	b570      	push	{r4, r5, r6, lr}
   135d6:	b086      	sub	sp, #24
	z_sched_init();
   135d8:	f001 f80a 	bl	145f0 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
   135dc:	4d10      	ldr	r5, [pc, #64]	; (13620 <prepare_multithreading+0x4c>)
   135de:	4b11      	ldr	r3, [pc, #68]	; (13624 <prepare_multithreading+0x50>)
   135e0:	61dd      	str	r5, [r3, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   135e2:	4b11      	ldr	r3, [pc, #68]	; (13628 <prepare_multithreading+0x54>)
   135e4:	9305      	str	r3, [sp, #20]
   135e6:	2301      	movs	r3, #1
   135e8:	9304      	str	r3, [sp, #16]
   135ea:	2400      	movs	r4, #0
   135ec:	9403      	str	r4, [sp, #12]
   135ee:	9402      	str	r4, [sp, #8]
   135f0:	9401      	str	r4, [sp, #4]
   135f2:	9400      	str	r4, [sp, #0]
   135f4:	4b0d      	ldr	r3, [pc, #52]	; (1362c <prepare_multithreading+0x58>)
   135f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
   135fa:	490d      	ldr	r1, [pc, #52]	; (13630 <prepare_multithreading+0x5c>)
   135fc:	4628      	mov	r0, r5
   135fe:	f000 f8f9 	bl	137f4 <z_setup_new_thread>
   13602:	4606      	mov	r6, r0
   13604:	7b6b      	ldrb	r3, [r5, #13]
   13606:	f023 0304 	bic.w	r3, r3, #4
   1360a:	736b      	strb	r3, [r5, #13]
	z_ready_thread(&z_main_thread);
   1360c:	4628      	mov	r0, r5
   1360e:	f008 ffc2 	bl	1c596 <z_ready_thread>
	z_init_cpu(0);
   13612:	4620      	mov	r0, r4
   13614:	f7ff ffbe 	bl	13594 <z_init_cpu>
}
   13618:	4630      	mov	r0, r6
   1361a:	b006      	add	sp, #24
   1361c:	bd70      	pop	{r4, r5, r6, pc}
   1361e:	bf00      	nop
   13620:	20001a40 	.word	0x20001a40
   13624:	200026d8 	.word	0x200026d8
   13628:	0001d370 	.word	0x0001d370
   1362c:	00013535 	.word	0x00013535
   13630:	20003eb8 	.word	0x20003eb8

00013634 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   13634:	b500      	push	{lr}
   13636:	b0af      	sub	sp, #188	; 0xbc
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   13638:	4b1f      	ldr	r3, [pc, #124]	; (136b8 <z_cstart+0x84>)
	uint32_t msp =
   1363a:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   1363e:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   13642:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   13646:	4c1d      	ldr	r4, [pc, #116]	; (136bc <z_cstart+0x88>)
   13648:	23e0      	movs	r3, #224	; 0xe0
   1364a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
   1364e:	2500      	movs	r5, #0
   13650:	77e5      	strb	r5, [r4, #31]
   13652:	7625      	strb	r5, [r4, #24]
   13654:	7665      	strb	r5, [r4, #25]
   13656:	76a5      	strb	r5, [r4, #26]
   13658:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   1365c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1365e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   13662:	6263      	str	r3, [r4, #36]	; 0x24
   13664:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   13668:	f7f1 fc98 	bl	4f9c <z_arm_fault_init>
	z_arm_cpu_idle_init();
   1366c:	f7f0 fb8a 	bl	3d84 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   13670:	f04f 33ff 	mov.w	r3, #4294967295
   13674:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   13676:	62e3      	str	r3, [r4, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   13678:	f7f1 ffb6 	bl	55e8 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   1367c:	f7f1 fd5c 	bl	5138 <z_arm_configure_static_mpu_regions>
	gcov_static_init();

	/* perform any architecture-specific initialization */
	arch_kernel_init();

	LOG_CORE_INIT();
   13680:	f7ee fcae 	bl	1fe0 <log_core_init>
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
   13684:	2401      	movs	r4, #1
   13686:	f88d 400d 	strb.w	r4, [sp, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
   1368a:	f88d 400c 	strb.w	r4, [sp, #12]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
   1368e:	9527      	str	r5, [sp, #156]	; 0x9c
	dummy_thread->stack_info.size = 0U;
   13690:	9528      	str	r5, [sp, #160]	; 0xa0
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif
#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
	k_thread_system_pool_assign(dummy_thread);
   13692:	4668      	mov	r0, sp
   13694:	f001 fdd6 	bl	15244 <k_thread_system_pool_assign>
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
   13698:	4b09      	ldr	r3, [pc, #36]	; (136c0 <z_cstart+0x8c>)
   1369a:	f8c3 d008 	str.w	sp, [r3, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   1369e:	f7ff fda1 	bl	131e4 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   136a2:	4628      	mov	r0, r5
   136a4:	f7ff fdaa 	bl	131fc <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   136a8:	4620      	mov	r0, r4
   136aa:	f7ff fda7 	bl	131fc <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
   136ae:	f7ff ff91 	bl	135d4 <prepare_multithreading>
   136b2:	f7ff ff59 	bl	13568 <switch_to_main_thread>
   136b6:	bf00      	nop
   136b8:	200043f8 	.word	0x200043f8
   136bc:	e000ed00 	.word	0xe000ed00
   136c0:	200026d8 	.word	0x200026d8

000136c4 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   136c4:	b510      	push	{r4, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   136c6:	4c06      	ldr	r4, [pc, #24]	; (136e0 <statics_init+0x1c>)
   136c8:	e005      	b.n	136d6 <statics_init+0x12>
		}

		if (do_clear)
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   136ca:	68a2      	ldr	r2, [r4, #8]
   136cc:	6861      	ldr	r1, [r4, #4]
   136ce:	4620      	mov	r0, r4
   136d0:	f008 fb92 	bl	1bdf8 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   136d4:	3414      	adds	r4, #20
   136d6:	4b03      	ldr	r3, [pc, #12]	; (136e4 <statics_init+0x20>)
   136d8:	429c      	cmp	r4, r3
   136da:	d3f6      	bcc.n	136ca <statics_init+0x6>
		}
	}
	return 0;
}
   136dc:	2000      	movs	r0, #0
   136de:	bd10      	pop	{r4, pc}
   136e0:	200005c0 	.word	0x200005c0
   136e4:	200005d4 	.word	0x200005d4

000136e8 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(const struct device *dev)
{
   136e8:	b510      	push	{r4, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   136ea:	4c06      	ldr	r4, [pc, #24]	; (13704 <init_mem_slab_module+0x1c>)
	int rc = 0;
   136ec:	2000      	movs	r0, #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   136ee:	e000      	b.n	136f2 <init_mem_slab_module+0xa>
   136f0:	341c      	adds	r4, #28
   136f2:	4b05      	ldr	r3, [pc, #20]	; (13708 <init_mem_slab_module+0x20>)
   136f4:	429c      	cmp	r4, r3
   136f6:	d204      	bcs.n	13702 <init_mem_slab_module+0x1a>
		rc = create_free_list(slab);
   136f8:	4620      	mov	r0, r4
   136fa:	f008 fbeb 	bl	1bed4 <create_free_list>
		if (rc < 0) {
   136fe:	2800      	cmp	r0, #0
   13700:	daf6      	bge.n	136f0 <init_mem_slab_module+0x8>
		z_object_init(slab);
	}

out:
	return rc;
}
   13702:	bd10      	pop	{r4, pc}
   13704:	2000056c 	.word	0x2000056c
   13708:	200005c0 	.word	0x200005c0

0001370c <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   1370c:	b530      	push	{r4, r5, lr}
   1370e:	b083      	sub	sp, #12
   13710:	460d      	mov	r5, r1
	__asm__ volatile(
   13712:	f04f 0420 	mov.w	r4, #32
   13716:	f3ef 8111 	mrs	r1, BASEPRI
   1371a:	f384 8812 	msr	BASEPRI_MAX, r4
   1371e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   13722:	6944      	ldr	r4, [r0, #20]
   13724:	b16c      	cbz	r4, 13742 <k_mem_slab_alloc+0x36>
		/* take a free block */
		*mem = slab->free_list;
   13726:	602c      	str	r4, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
   13728:	6943      	ldr	r3, [r0, #20]
   1372a:	681b      	ldr	r3, [r3, #0]
   1372c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   1372e:	6983      	ldr	r3, [r0, #24]
   13730:	3301      	adds	r3, #1
   13732:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   13734:	2000      	movs	r0, #0
	__asm__ volatile(
   13736:	f381 8811 	msr	BASEPRI, r1
   1373a:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
   1373e:	b003      	add	sp, #12
   13740:	bd30      	pop	{r4, r5, pc}
   13742:	f100 0c08 	add.w	ip, r0, #8
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   13746:	ea53 0402 	orrs.w	r4, r3, r2
   1374a:	d104      	bne.n	13756 <k_mem_slab_alloc+0x4a>
		*mem = NULL;
   1374c:	2300      	movs	r3, #0
   1374e:	602b      	str	r3, [r5, #0]
		result = -ENOMEM;
   13750:	f06f 000b 	mvn.w	r0, #11
   13754:	e7ef      	b.n	13736 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   13756:	9200      	str	r2, [sp, #0]
   13758:	9301      	str	r3, [sp, #4]
   1375a:	4602      	mov	r2, r0
   1375c:	4660      	mov	r0, ip
   1375e:	f000 fe1b 	bl	14398 <z_pend_curr>
		if (result == 0) {
   13762:	2800      	cmp	r0, #0
   13764:	d1eb      	bne.n	1373e <k_mem_slab_alloc+0x32>
			*mem = _current->base.swap_data;
   13766:	4b02      	ldr	r3, [pc, #8]	; (13770 <k_mem_slab_alloc+0x64>)
   13768:	689b      	ldr	r3, [r3, #8]
   1376a:	695b      	ldr	r3, [r3, #20]
   1376c:	602b      	str	r3, [r5, #0]
		return result;
   1376e:	e7e6      	b.n	1373e <k_mem_slab_alloc+0x32>
   13770:	200026d8 	.word	0x200026d8

00013774 <z_thread_monitor_exit>:
	__asm__ volatile(
   13774:	f04f 0320 	mov.w	r3, #32
   13778:	f3ef 8111 	mrs	r1, BASEPRI
   1377c:	f383 8812 	msr	BASEPRI_MAX, r3
   13780:	f3bf 8f6f 	isb	sy
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
   13784:	4b0a      	ldr	r3, [pc, #40]	; (137b0 <z_thread_monitor_exit+0x3c>)
   13786:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13788:	4283      	cmp	r3, r0
   1378a:	d104      	bne.n	13796 <z_thread_monitor_exit+0x22>
		_kernel.threads = _kernel.threads->next_thread;
   1378c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
   1378e:	4b08      	ldr	r3, [pc, #32]	; (137b0 <z_thread_monitor_exit+0x3c>)
   13790:	629a      	str	r2, [r3, #40]	; 0x28
   13792:	e007      	b.n	137a4 <z_thread_monitor_exit+0x30>
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while ((prev_thread != NULL) &&
			(thread != prev_thread->next_thread)) {
			prev_thread = prev_thread->next_thread;
   13794:	4613      	mov	r3, r2
		while ((prev_thread != NULL) &&
   13796:	b113      	cbz	r3, 1379e <z_thread_monitor_exit+0x2a>
			(thread != prev_thread->next_thread)) {
   13798:	6f5a      	ldr	r2, [r3, #116]	; 0x74
		while ((prev_thread != NULL) &&
   1379a:	4282      	cmp	r2, r0
   1379c:	d1fa      	bne.n	13794 <z_thread_monitor_exit+0x20>
		}
		if (prev_thread != NULL) {
   1379e:	b10b      	cbz	r3, 137a4 <z_thread_monitor_exit+0x30>
			prev_thread->next_thread = thread->next_thread;
   137a0:	6f42      	ldr	r2, [r0, #116]	; 0x74
   137a2:	675a      	str	r2, [r3, #116]	; 0x74
	__asm__ volatile(
   137a4:	f381 8811 	msr	BASEPRI, r1
   137a8:	f3bf 8f6f 	isb	sy
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
   137ac:	4770      	bx	lr
   137ae:	bf00      	nop
   137b0:	200026d8 	.word	0x200026d8

000137b4 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
   137b4:	b510      	push	{r4, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
   137b6:	4604      	mov	r4, r0
   137b8:	b140      	cbz	r0, 137cc <z_impl_k_thread_name_set+0x18>
		thread = _current;
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN - 1);
   137ba:	221f      	movs	r2, #31
   137bc:	f104 0078 	add.w	r0, r4, #120	; 0x78
   137c0:	f003 ff59 	bl	17676 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
   137c4:	2000      	movs	r0, #0
   137c6:	f884 0097 	strb.w	r0, [r4, #151]	; 0x97

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
   137ca:	bd10      	pop	{r4, pc}
		thread = _current;
   137cc:	4b01      	ldr	r3, [pc, #4]	; (137d4 <z_impl_k_thread_name_set+0x20>)
   137ce:	689c      	ldr	r4, [r3, #8]
   137d0:	e7f3      	b.n	137ba <z_impl_k_thread_name_set+0x6>
   137d2:	bf00      	nop
   137d4:	200026d8 	.word	0x200026d8

000137d8 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
   137d8:	b508      	push	{r3, lr}
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   137da:	ea53 0102 	orrs.w	r1, r3, r2
   137de:	d102      	bne.n	137e6 <schedule_new_thread+0xe>
	z_impl_k_thread_start(thread);
   137e0:	f008 fbdd 	bl	1bf9e <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
   137e4:	bd08      	pop	{r3, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   137e6:	4902      	ldr	r1, [pc, #8]	; (137f0 <schedule_new_thread+0x18>)
   137e8:	3018      	adds	r0, #24
   137ea:	f001 f87d 	bl	148e8 <z_add_timeout>
   137ee:	e7f9      	b.n	137e4 <schedule_new_thread+0xc>
   137f0:	0001c5cf 	.word	0x0001c5cf

000137f4 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   137f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   137f8:	b085      	sub	sp, #20
   137fa:	4604      	mov	r4, r0
   137fc:	460f      	mov	r7, r1
   137fe:	4615      	mov	r5, r2
   13800:	461e      	mov	r6, r3
   13802:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
   13806:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
   1380a:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
   1380e:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   13812:	f100 0358 	add.w	r3, r0, #88	; 0x58
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   13816:	6583      	str	r3, [r0, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
   13818:	65c3      	str	r3, [r0, #92]	; 0x5c
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->join_queue);

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
   1381a:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1381c:	2204      	movs	r2, #4
   1381e:	9911      	ldr	r1, [sp, #68]	; 0x44
   13820:	f008 fbc1 	bl	1bfa6 <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
   13824:	462a      	mov	r2, r5
   13826:	4639      	mov	r1, r7
   13828:	4620      	mov	r0, r4
   1382a:	f008 fba4 	bl	1bf76 <setup_thread_stack>
   1382e:	4605      	mov	r5, r0
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   13830:	f8cd 8008 	str.w	r8, [sp, #8]
   13834:	f8cd 9004 	str.w	r9, [sp, #4]
   13838:	f8cd a000 	str.w	sl, [sp]
   1383c:	4633      	mov	r3, r6
   1383e:	4602      	mov	r2, r0
   13840:	4639      	mov	r1, r7
   13842:	4620      	mov	r0, r4
   13844:	f7f0 fc9e 	bl	4184 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
   13848:	2300      	movs	r3, #0
   1384a:	6563      	str	r3, [r4, #84]	; 0x54
#ifdef CONFIG_THREAD_CUSTOM_DATA
	/* Initialize custom data field (value is opaque to kernel) */
	new_thread->custom_data = NULL;
#endif
#ifdef CONFIG_THREAD_MONITOR
	new_thread->entry.pEntry = entry;
   1384c:	6666      	str	r6, [r4, #100]	; 0x64
	new_thread->entry.parameter1 = p1;
   1384e:	f8c4 a068 	str.w	sl, [r4, #104]	; 0x68
	new_thread->entry.parameter2 = p2;
   13852:	f8c4 906c 	str.w	r9, [r4, #108]	; 0x6c
	new_thread->entry.parameter3 = p3;
   13856:	f8c4 8070 	str.w	r8, [r4, #112]	; 0x70
	__asm__ volatile(
   1385a:	f04f 0320 	mov.w	r3, #32
   1385e:	f3ef 8211 	mrs	r2, BASEPRI
   13862:	f383 8812 	msr	BASEPRI_MAX, r3
   13866:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	new_thread->next_thread = _kernel.threads;
   1386a:	4b13      	ldr	r3, [pc, #76]	; (138b8 <z_setup_new_thread+0xc4>)
   1386c:	6a99      	ldr	r1, [r3, #40]	; 0x28
   1386e:	6761      	str	r1, [r4, #116]	; 0x74
	_kernel.threads = new_thread;
   13870:	629c      	str	r4, [r3, #40]	; 0x28
	__asm__ volatile(
   13872:	f382 8811 	msr	BASEPRI, r2
   13876:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
#ifdef CONFIG_THREAD_NAME
	if (name != NULL) {
   1387a:	f1bb 0f00 	cmp.w	fp, #0
   1387e:	d013      	beq.n	138a8 <z_setup_new_thread+0xb4>
		strncpy(new_thread->name, name,
   13880:	221f      	movs	r2, #31
   13882:	4659      	mov	r1, fp
   13884:	f104 0078 	add.w	r0, r4, #120	; 0x78
   13888:	f003 fef5 	bl	17676 <strncpy>
			CONFIG_THREAD_MAX_NAME_LEN - 1);
		/* Ensure NULL termination, truncate if longer */
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
   1388c:	2300      	movs	r3, #0
   1388e:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
		new_thread->base.cpu_mask = -1; /* allow all cpus */
	}
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   13892:	4b09      	ldr	r3, [pc, #36]	; (138b8 <z_setup_new_thread+0xc4>)
   13894:	689b      	ldr	r3, [r3, #8]
   13896:	b15b      	cbz	r3, 138b0 <z_setup_new_thread+0xbc>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   13898:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
   1389c:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
#endif

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);

	return stack_ptr;
}
   138a0:	4628      	mov	r0, r5
   138a2:	b005      	add	sp, #20
   138a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		new_thread->name[0] = '\0';
   138a8:	2300      	movs	r3, #0
   138aa:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
   138ae:	e7f0      	b.n	13892 <z_setup_new_thread+0x9e>
		new_thread->resource_pool = NULL;
   138b0:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
		return stack_ptr;
   138b4:	e7f4      	b.n	138a0 <z_setup_new_thread+0xac>
   138b6:	bf00      	nop
   138b8:	200026d8 	.word	0x200026d8

000138bc <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   138bc:	b530      	push	{r4, r5, lr}
   138be:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   138c0:	4c21      	ldr	r4, [pc, #132]	; (13948 <z_init_static_threads+0x8c>)
   138c2:	e014      	b.n	138ee <z_init_static_threads+0x32>
		z_setup_new_thread(
   138c4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   138c6:	9305      	str	r3, [sp, #20]
   138c8:	6a23      	ldr	r3, [r4, #32]
   138ca:	9304      	str	r3, [sp, #16]
   138cc:	69e3      	ldr	r3, [r4, #28]
   138ce:	9303      	str	r3, [sp, #12]
   138d0:	69a3      	ldr	r3, [r4, #24]
   138d2:	9302      	str	r3, [sp, #8]
   138d4:	6963      	ldr	r3, [r4, #20]
   138d6:	9301      	str	r3, [sp, #4]
   138d8:	6923      	ldr	r3, [r4, #16]
   138da:	9300      	str	r3, [sp, #0]
   138dc:	68e3      	ldr	r3, [r4, #12]
   138de:	68a2      	ldr	r2, [r4, #8]
   138e0:	6861      	ldr	r1, [r4, #4]
   138e2:	6820      	ldr	r0, [r4, #0]
   138e4:	f7ff ff86 	bl	137f4 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
   138e8:	6823      	ldr	r3, [r4, #0]
   138ea:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   138ec:	3430      	adds	r4, #48	; 0x30
   138ee:	4b17      	ldr	r3, [pc, #92]	; (1394c <z_init_static_threads+0x90>)
   138f0:	429c      	cmp	r4, r3
   138f2:	d3e7      	bcc.n	138c4 <z_init_static_threads+0x8>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   138f4:	f000 fbe4 	bl	140c0 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   138f8:	4c13      	ldr	r4, [pc, #76]	; (13948 <z_init_static_threads+0x8c>)
   138fa:	e000      	b.n	138fe <z_init_static_threads+0x42>
   138fc:	3430      	adds	r4, #48	; 0x30
   138fe:	4b13      	ldr	r3, [pc, #76]	; (1394c <z_init_static_threads+0x90>)
   13900:	429c      	cmp	r4, r3
   13902:	d21c      	bcs.n	1393e <z_init_static_threads+0x82>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   13904:	6a60      	ldr	r0, [r4, #36]	; 0x24
   13906:	f1b0 3fff 	cmp.w	r0, #4294967295
   1390a:	d0f7      	beq.n	138fc <z_init_static_threads+0x40>
			schedule_new_thread(thread_data->init_thread,
   1390c:	6825      	ldr	r5, [r4, #0]
					    K_MSEC(thread_data->init_delay));
   1390e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   13912:	17c1      	asrs	r1, r0, #31
   13914:	03c9      	lsls	r1, r1, #15
   13916:	ea41 4150 	orr.w	r1, r1, r0, lsr #17
   1391a:	03c0      	lsls	r0, r0, #15
   1391c:	f240 33e7 	movw	r3, #999	; 0x3e7
   13920:	18c0      	adds	r0, r0, r3
   13922:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   13926:	f04f 0300 	mov.w	r3, #0
   1392a:	f141 0100 	adc.w	r1, r1, #0
   1392e:	f7ec fc11 	bl	154 <__aeabi_uldivmod>
   13932:	4602      	mov	r2, r0
   13934:	460b      	mov	r3, r1
			schedule_new_thread(thread_data->init_thread,
   13936:	4628      	mov	r0, r5
   13938:	f7ff ff4e 	bl	137d8 <schedule_new_thread>
   1393c:	e7de      	b.n	138fc <z_init_static_threads+0x40>
		}
	}
	k_sched_unlock();
   1393e:	f000 fde1 	bl	14504 <k_sched_unlock>
}
   13942:	b007      	add	sp, #28
   13944:	bd30      	pop	{r4, r5, pc}
   13946:	bf00      	nop
   13948:	2000056c 	.word	0x2000056c
   1394c:	2000056c 	.word	0x2000056c

00013950 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   13950:	b508      	push	{r3, lr}
   13952:	e001      	b.n	13958 <idle+0x8>
	arch_cpu_idle();
   13954:	f7f0 fa1c 	bl	3d90 <arch_cpu_idle>
	__asm__ volatile(
   13958:	f04f 0220 	mov.w	r2, #32
   1395c:	f3ef 8311 	mrs	r3, BASEPRI
   13960:	f382 8812 	msr	BASEPRI_MAX, r2
   13964:	f3bf 8f6f 	isb	sy
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   13968:	f008 ff87 	bl	1c87a <z_get_next_timeout_expiry>
   1396c:	4b05      	ldr	r3, [pc, #20]	; (13984 <idle+0x34>)
   1396e:	6198      	str	r0, [r3, #24]
	return !z_sys_post_kernel;
   13970:	4b05      	ldr	r3, [pc, #20]	; (13988 <idle+0x38>)
   13972:	781b      	ldrb	r3, [r3, #0]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   13974:	2b00      	cmp	r3, #0
   13976:	d0ed      	beq.n	13954 <idle+0x4>
   13978:	f7ef fb3e 	bl	2ff8 <pm_system_suspend>
   1397c:	2800      	cmp	r0, #0
   1397e:	d1eb      	bne.n	13958 <idle+0x8>
   13980:	e7e8      	b.n	13954 <idle+0x4>
   13982:	bf00      	nop
   13984:	200026d8 	.word	0x200026d8
   13988:	20002900 	.word	0x20002900

0001398c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   1398c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   13990:	b083      	sub	sp, #12
   13992:	4604      	mov	r4, r0
   13994:	461d      	mov	r5, r3
   13996:	f04f 0320 	mov.w	r3, #32
   1399a:	f3ef 8711 	mrs	r7, BASEPRI
   1399e:	f383 8812 	msr	BASEPRI_MAX, r3
   139a2:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   139a6:	68c1      	ldr	r1, [r0, #12]
   139a8:	b999      	cbnz	r1, 139d2 <z_impl_k_mutex_lock+0x46>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
   139aa:	2900      	cmp	r1, #0
   139ac:	d14f      	bne.n	13a4e <z_impl_k_mutex_lock+0xc2>
   139ae:	4b3a      	ldr	r3, [pc, #232]	; (13a98 <z_impl_k_mutex_lock+0x10c>)
   139b0:	689b      	ldr	r3, [r3, #8]
   139b2:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   139b6:	6123      	str	r3, [r4, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
   139b8:	3101      	adds	r1, #1
   139ba:	60e1      	str	r1, [r4, #12]
		mutex->owner = _current;
   139bc:	4b36      	ldr	r3, [pc, #216]	; (13a98 <z_impl_k_mutex_lock+0x10c>)
   139be:	689b      	ldr	r3, [r3, #8]
   139c0:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   139c2:	f387 8811 	msr	BASEPRI, r7
   139c6:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
   139ca:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   139cc:	b003      	add	sp, #12
   139ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   139d2:	4616      	mov	r6, r2
	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   139d4:	6882      	ldr	r2, [r0, #8]
   139d6:	4b30      	ldr	r3, [pc, #192]	; (13a98 <z_impl_k_mutex_lock+0x10c>)
   139d8:	689b      	ldr	r3, [r3, #8]
   139da:	429a      	cmp	r2, r3
   139dc:	d0e5      	beq.n	139aa <z_impl_k_mutex_lock+0x1e>
	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   139de:	ea55 0106 	orrs.w	r1, r5, r6
   139e2:	bf0c      	ite	eq
   139e4:	f04f 0801 	moveq.w	r8, #1
   139e8:	f04f 0800 	movne.w	r8, #0
   139ec:	d031      	beq.n	13a52 <z_impl_k_mutex_lock+0xc6>
					    mutex->owner->base.prio);
   139ee:	f992 900e 	ldrsb.w	r9, [r2, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
   139f2:	4649      	mov	r1, r9
   139f4:	f993 000e 	ldrsb.w	r0, [r3, #14]
   139f8:	f008 fb08 	bl	1c00c <new_prio_for_inheritance>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   139fc:	4581      	cmp	r9, r0
   139fe:	dc2f      	bgt.n	13a60 <z_impl_k_mutex_lock+0xd4>
	bool resched = false;
   13a00:	f04f 0900 	mov.w	r9, #0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   13a04:	9600      	str	r6, [sp, #0]
   13a06:	9501      	str	r5, [sp, #4]
   13a08:	4622      	mov	r2, r4
   13a0a:	4639      	mov	r1, r7
   13a0c:	4823      	ldr	r0, [pc, #140]	; (13a9c <z_impl_k_mutex_lock+0x110>)
   13a0e:	f000 fcc3 	bl	14398 <z_pend_curr>
	if (got_mutex == 0) {
   13a12:	2800      	cmp	r0, #0
   13a14:	d0da      	beq.n	139cc <z_impl_k_mutex_lock+0x40>
	__asm__ volatile(
   13a16:	f04f 0320 	mov.w	r3, #32
   13a1a:	f3ef 8511 	mrs	r5, BASEPRI
   13a1e:	f383 8812 	msr	BASEPRI_MAX, r3
   13a22:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   13a26:	6823      	ldr	r3, [r4, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   13a28:	429c      	cmp	r4, r3
   13a2a:	d01f      	beq.n	13a6c <z_impl_k_mutex_lock+0xe0>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   13a2c:	b1f3      	cbz	r3, 13a6c <z_impl_k_mutex_lock+0xe0>
   13a2e:	6921      	ldr	r1, [r4, #16]
   13a30:	f993 000e 	ldrsb.w	r0, [r3, #14]
   13a34:	f008 faea 	bl	1c00c <new_prio_for_inheritance>
   13a38:	4601      	mov	r1, r0
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   13a3a:	4620      	mov	r0, r4
   13a3c:	f008 faf1 	bl	1c022 <adjust_owner_prio>
   13a40:	b9b0      	cbnz	r0, 13a70 <z_impl_k_mutex_lock+0xe4>
   13a42:	f1b9 0f00 	cmp.w	r9, #0
   13a46:	d015      	beq.n	13a74 <z_impl_k_mutex_lock+0xe8>
   13a48:	f04f 0801 	mov.w	r8, #1
   13a4c:	e012      	b.n	13a74 <z_impl_k_mutex_lock+0xe8>
					_current->base.prio :
   13a4e:	6923      	ldr	r3, [r4, #16]
   13a50:	e7b1      	b.n	139b6 <z_impl_k_mutex_lock+0x2a>
	__asm__ volatile(
   13a52:	f387 8811 	msr	BASEPRI, r7
   13a56:	f3bf 8f6f 	isb	sy
		return -EBUSY;
   13a5a:	f06f 000f 	mvn.w	r0, #15
   13a5e:	e7b5      	b.n	139cc <z_impl_k_mutex_lock+0x40>
		resched = adjust_owner_prio(mutex, new_prio);
   13a60:	4601      	mov	r1, r0
   13a62:	4620      	mov	r0, r4
   13a64:	f008 fadd 	bl	1c022 <adjust_owner_prio>
   13a68:	4681      	mov	r9, r0
   13a6a:	e7cb      	b.n	13a04 <z_impl_k_mutex_lock+0x78>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   13a6c:	6921      	ldr	r1, [r4, #16]
   13a6e:	e7e4      	b.n	13a3a <z_impl_k_mutex_lock+0xae>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   13a70:	f04f 0801 	mov.w	r8, #1
	if (resched) {
   13a74:	f1b8 0f00 	cmp.w	r8, #0
   13a78:	d106      	bne.n	13a88 <z_impl_k_mutex_lock+0xfc>
   13a7a:	f385 8811 	msr	BASEPRI, r5
   13a7e:	f3bf 8f6f 	isb	sy
	return -EAGAIN;
   13a82:	f06f 000a 	mvn.w	r0, #10
   13a86:	e7a1      	b.n	139cc <z_impl_k_mutex_lock+0x40>
		z_reschedule(&lock, key);
   13a88:	4629      	mov	r1, r5
   13a8a:	4804      	ldr	r0, [pc, #16]	; (13a9c <z_impl_k_mutex_lock+0x110>)
   13a8c:	f000 fafc 	bl	14088 <z_reschedule>
	return -EAGAIN;
   13a90:	f06f 000a 	mvn.w	r0, #10
   13a94:	e79a      	b.n	139cc <z_impl_k_mutex_lock+0x40>
   13a96:	bf00      	nop
   13a98:	200026d8 	.word	0x200026d8
   13a9c:	20002704 	.word	0x20002704

00013aa0 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   13aa0:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   13aa2:	6883      	ldr	r3, [r0, #8]
   13aa4:	b383      	cbz	r3, 13b08 <z_impl_k_mutex_unlock+0x68>
   13aa6:	4604      	mov	r4, r0
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   13aa8:	4a1a      	ldr	r2, [pc, #104]	; (13b14 <z_impl_k_mutex_unlock+0x74>)
   13aaa:	6892      	ldr	r2, [r2, #8]
   13aac:	4293      	cmp	r3, r2
   13aae:	d12e      	bne.n	13b0e <z_impl_k_mutex_unlock+0x6e>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   13ab0:	68c3      	ldr	r3, [r0, #12]
   13ab2:	2b01      	cmp	r3, #1
   13ab4:	d903      	bls.n	13abe <z_impl_k_mutex_unlock+0x1e>
		mutex->lock_count--;
   13ab6:	3b01      	subs	r3, #1
   13ab8:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
   13aba:	2000      	movs	r0, #0
}
   13abc:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   13abe:	f04f 0320 	mov.w	r3, #32
   13ac2:	f3ef 8511 	mrs	r5, BASEPRI
   13ac6:	f383 8812 	msr	BASEPRI_MAX, r3
   13aca:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   13ace:	6901      	ldr	r1, [r0, #16]
   13ad0:	f008 faa7 	bl	1c022 <adjust_owner_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   13ad4:	4620      	mov	r0, r4
   13ad6:	f008 fe25 	bl	1c724 <z_unpend_first_thread>
	mutex->owner = new_owner;
   13ada:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   13adc:	b168      	cbz	r0, 13afa <z_impl_k_mutex_unlock+0x5a>
		mutex->owner_orig_prio = new_owner->base.prio;
   13ade:	f990 300e 	ldrsb.w	r3, [r0, #14]
   13ae2:	6123      	str	r3, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   13ae4:	2400      	movs	r4, #0
   13ae6:	f8c0 40b0 	str.w	r4, [r0, #176]	; 0xb0
		z_ready_thread(new_owner);
   13aea:	f008 fd54 	bl	1c596 <z_ready_thread>
		z_reschedule(&lock, key);
   13aee:	4629      	mov	r1, r5
   13af0:	4809      	ldr	r0, [pc, #36]	; (13b18 <z_impl_k_mutex_unlock+0x78>)
   13af2:	f000 fac9 	bl	14088 <z_reschedule>
	return 0;
   13af6:	4620      	mov	r0, r4
   13af8:	e7e0      	b.n	13abc <z_impl_k_mutex_unlock+0x1c>
		mutex->lock_count = 0U;
   13afa:	2000      	movs	r0, #0
   13afc:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   13afe:	f385 8811 	msr	BASEPRI, r5
   13b02:	f3bf 8f6f 	isb	sy
   13b06:	e7d9      	b.n	13abc <z_impl_k_mutex_unlock+0x1c>
		return -EINVAL;
   13b08:	f06f 0015 	mvn.w	r0, #21
   13b0c:	e7d6      	b.n	13abc <z_impl_k_mutex_unlock+0x1c>
		return -EPERM;
   13b0e:	f04f 30ff 	mov.w	r0, #4294967295
   13b12:	e7d3      	b.n	13abc <z_impl_k_mutex_unlock+0x1c>
   13b14:	200026d8 	.word	0x200026d8
   13b18:	20002704 	.word	0x20002704

00013b1c <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   13b1c:	b510      	push	{r4, lr}
   13b1e:	b082      	sub	sp, #8
   13b20:	4601      	mov	r1, r0
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   13b22:	4684      	mov	ip, r0
	__asm__ volatile(
   13b24:	f04f 0020 	mov.w	r0, #32
   13b28:	f3ef 8411 	mrs	r4, BASEPRI
   13b2c:	f380 8812 	msr	BASEPRI_MAX, r0
   13b30:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
   13b34:	f85c 0b08 	ldr.w	r0, [ip], #8
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   13b38:	b188      	cbz	r0, 13b5e <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   13b3a:	6803      	ldr	r3, [r0, #0]
   13b3c:	f023 0303 	bic.w	r3, r3, #3
	list->head = node;
   13b40:	600b      	str	r3, [r1, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_tail(sys_sflist_t *list)
{
	return list->tail;
   13b42:	684a      	ldr	r2, [r1, #4]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   13b44:	4290      	cmp	r0, r2
   13b46:	d008      	beq.n	13b5a <z_impl_k_queue_get+0x3e>
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   13b48:	2101      	movs	r1, #1
   13b4a:	f008 faf2 	bl	1c132 <z_queue_node_peek>
	__asm__ volatile(
   13b4e:	f384 8811 	msr	BASEPRI, r4
   13b52:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   13b56:	b002      	add	sp, #8
   13b58:	bd10      	pop	{r4, pc}
	list->tail = node;
   13b5a:	604b      	str	r3, [r1, #4]
}
   13b5c:	e7f4      	b.n	13b48 <z_impl_k_queue_get+0x2c>
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   13b5e:	ea53 0102 	orrs.w	r1, r3, r2
   13b62:	d00b      	beq.n	13b7c <z_impl_k_queue_get+0x60>
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   13b64:	9200      	str	r2, [sp, #0]
   13b66:	9301      	str	r3, [sp, #4]
   13b68:	4662      	mov	r2, ip
   13b6a:	4621      	mov	r1, r4
   13b6c:	4660      	mov	r0, ip
   13b6e:	f000 fc13 	bl	14398 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   13b72:	b948      	cbnz	r0, 13b88 <z_impl_k_queue_get+0x6c>
   13b74:	4b05      	ldr	r3, [pc, #20]	; (13b8c <z_impl_k_queue_get+0x70>)
   13b76:	689b      	ldr	r3, [r3, #8]
   13b78:	6958      	ldr	r0, [r3, #20]
   13b7a:	e7ec      	b.n	13b56 <z_impl_k_queue_get+0x3a>
   13b7c:	f384 8811 	msr	BASEPRI, r4
   13b80:	f3bf 8f6f 	isb	sy
		return NULL;
   13b84:	2000      	movs	r0, #0
   13b86:	e7e6      	b.n	13b56 <z_impl_k_queue_get+0x3a>
	return (ret != 0) ? NULL : _current->base.swap_data;
   13b88:	2000      	movs	r0, #0
   13b8a:	e7e4      	b.n	13b56 <z_impl_k_queue_get+0x3a>
   13b8c:	200026d8 	.word	0x200026d8

00013b90 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   13b90:	b538      	push	{r3, r4, r5, lr}
   13b92:	4604      	mov	r4, r0
	__asm__ volatile(
   13b94:	f04f 0320 	mov.w	r3, #32
   13b98:	f3ef 8511 	mrs	r5, BASEPRI
   13b9c:	f383 8812 	msr	BASEPRI_MAX, r3
   13ba0:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   13ba4:	f008 fdbe 	bl	1c724 <z_unpend_first_thread>

	if (thread != NULL) {
   13ba8:	b148      	cbz	r0, 13bbe <z_impl_k_sem_give+0x2e>
   13baa:	2200      	movs	r2, #0
   13bac:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   13bb0:	f008 fcf1 	bl	1c596 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   13bb4:	4629      	mov	r1, r5
   13bb6:	4809      	ldr	r0, [pc, #36]	; (13bdc <z_impl_k_sem_give+0x4c>)
   13bb8:	f000 fa66 	bl	14088 <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   13bbc:	bd38      	pop	{r3, r4, r5, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   13bbe:	68a3      	ldr	r3, [r4, #8]
   13bc0:	68e2      	ldr	r2, [r4, #12]
   13bc2:	4293      	cmp	r3, r2
   13bc4:	d008      	beq.n	13bd8 <z_impl_k_sem_give+0x48>
   13bc6:	2201      	movs	r2, #1
   13bc8:	4413      	add	r3, r2
   13bca:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   13bcc:	2102      	movs	r1, #2
   13bce:	f104 0010 	add.w	r0, r4, #16
   13bd2:	f008 ff7c 	bl	1cace <z_handle_obj_poll_events>
}
   13bd6:	e7ed      	b.n	13bb4 <z_impl_k_sem_give+0x24>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   13bd8:	2200      	movs	r2, #0
   13bda:	e7f5      	b.n	13bc8 <z_impl_k_sem_give+0x38>
   13bdc:	20002704 	.word	0x20002704

00013be0 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   13be0:	b510      	push	{r4, lr}
   13be2:	b082      	sub	sp, #8
   13be4:	f04f 0420 	mov.w	r4, #32
   13be8:	f3ef 8111 	mrs	r1, BASEPRI
   13bec:	f384 8812 	msr	BASEPRI_MAX, r4
   13bf0:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   13bf4:	6884      	ldr	r4, [r0, #8]
   13bf6:	b144      	cbz	r4, 13c0a <z_impl_k_sem_take+0x2a>
		sem->count--;
   13bf8:	3c01      	subs	r4, #1
   13bfa:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
   13bfc:	f381 8811 	msr	BASEPRI, r1
   13c00:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   13c04:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   13c06:	b002      	add	sp, #8
   13c08:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   13c0a:	ea53 0402 	orrs.w	r4, r3, r2
   13c0e:	d006      	beq.n	13c1e <z_impl_k_sem_take+0x3e>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   13c10:	9200      	str	r2, [sp, #0]
   13c12:	9301      	str	r3, [sp, #4]
   13c14:	4602      	mov	r2, r0
   13c16:	4805      	ldr	r0, [pc, #20]	; (13c2c <z_impl_k_sem_take+0x4c>)
   13c18:	f000 fbbe 	bl	14398 <z_pend_curr>
	return ret;
   13c1c:	e7f3      	b.n	13c06 <z_impl_k_sem_take+0x26>
   13c1e:	f381 8811 	msr	BASEPRI, r1
   13c22:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   13c26:	f06f 000f 	mvn.w	r0, #15
   13c2a:	e7ec      	b.n	13c06 <z_impl_k_sem_take+0x26>
   13c2c:	20002704 	.word	0x20002704

00013c30 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
   13c30:	b510      	push	{r4, lr}
   13c32:	b084      	sub	sp, #16
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
   13c34:	4b08      	ldr	r3, [pc, #32]	; (13c58 <k_sys_work_q_init+0x28>)
   13c36:	9302      	str	r3, [sp, #8]
   13c38:	2400      	movs	r4, #0
   13c3a:	f88d 400c 	strb.w	r4, [sp, #12]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   13c3e:	ab02      	add	r3, sp, #8
   13c40:	9300      	str	r3, [sp, #0]
   13c42:	f04f 33ff 	mov.w	r3, #4294967295
   13c46:	f44f 6280 	mov.w	r2, #1024	; 0x400
   13c4a:	4904      	ldr	r1, [pc, #16]	; (13c5c <k_sys_work_q_init+0x2c>)
   13c4c:	4804      	ldr	r0, [pc, #16]	; (13c60 <k_sys_work_q_init+0x30>)
   13c4e:	f000 f96f 	bl	13f30 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   13c52:	4620      	mov	r0, r4
   13c54:	b004      	add	sp, #16
   13c56:	bd10      	pop	{r4, pc}
   13c58:	0001ff9c 	.word	0x0001ff9c
   13c5c:	20004bf8 	.word	0x20004bf8
   13c60:	20001af8 	.word	0x20001af8

00013c64 <submit_to_queue_locked>:
 * @retval -EINVAL if no queue is provided
 * @retval -ENODEV if the queue is not started
 */
static int submit_to_queue_locked(struct k_work *work,
				  struct k_work_q **queuep)
{
   13c64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13c66:	460d      	mov	r5, r1
	return (*flagp & BIT(bit)) != 0U;
   13c68:	68c3      	ldr	r3, [r0, #12]
	int ret = 0;

	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   13c6a:	f013 0f02 	tst.w	r3, #2
   13c6e:	d15c      	bne.n	13d2a <submit_to_queue_locked+0xc6>
   13c70:	4604      	mov	r4, r0
		/* Disallowed */
		ret = -EBUSY;
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   13c72:	f013 0f04 	tst.w	r3, #4
   13c76:	d15d      	bne.n	13d34 <submit_to_queue_locked+0xd0>
		/* Not currently queued */
		ret = 1;

		/* If no queue specified resubmit to last queue.
		 */
		if (*queuep == NULL) {
   13c78:	680b      	ldr	r3, [r1, #0]
   13c7a:	2b00      	cmp	r3, #0
   13c7c:	d038      	beq.n	13cf0 <submit_to_queue_locked+0x8c>
	return (*flagp & BIT(bit)) != 0U;
   13c7e:	68e3      	ldr	r3, [r4, #12]

		/* If the work is currently running we have to use the
		 * queue it's running on to prevent handler
		 * re-entrancy.
		 */
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   13c80:	f013 0f01 	tst.w	r3, #1
   13c84:	d037      	beq.n	13cf6 <submit_to_queue_locked+0x92>
			__ASSERT_NO_MSG(work->queue != NULL);
			*queuep = work->queue;
   13c86:	68a3      	ldr	r3, [r4, #8]
   13c88:	602b      	str	r3, [r5, #0]
			ret = 2;
   13c8a:	2702      	movs	r7, #2
		}

		int rc = queue_submit_locked(*queuep, work);
   13c8c:	682e      	ldr	r6, [r5, #0]
	if (queue == NULL) {
   13c8e:	2e00      	cmp	r6, #0
   13c90:	d03f      	beq.n	13d12 <submit_to_queue_locked+0xae>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   13c92:	4b29      	ldr	r3, [pc, #164]	; (13d38 <submit_to_queue_locked+0xd4>)
   13c94:	689b      	ldr	r3, [r3, #8]
   13c96:	42b3      	cmp	r3, r6
   13c98:	d02f      	beq.n	13cfa <submit_to_queue_locked+0x96>
   13c9a:	2300      	movs	r3, #0
   13c9c:	461a      	mov	r2, r3
	return (*flagp & BIT(bit)) != 0U;
   13c9e:	f8d6 30d0 	ldr.w	r3, [r6, #208]	; 0xd0
   13ca2:	f3c3 0180 	ubfx	r1, r3, #2, #1
   13ca6:	f3c3 00c0 	ubfx	r0, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   13caa:	f013 0f01 	tst.w	r3, #1
   13cae:	d033      	beq.n	13d18 <submit_to_queue_locked+0xb4>
	} else if (draining && !chained) {
   13cb0:	b101      	cbz	r1, 13cb4 <submit_to_queue_locked+0x50>
   13cb2:	b3a2      	cbz	r2, 13d1e <submit_to_queue_locked+0xba>
	} else if (plugged && !draining) {
   13cb4:	b100      	cbz	r0, 13cb8 <submit_to_queue_locked+0x54>
   13cb6:	b3a9      	cbz	r1, 13d24 <submit_to_queue_locked+0xc0>
	parent->next = child;
   13cb8:	2300      	movs	r3, #0
   13cba:	6023      	str	r3, [r4, #0]
	return list->tail;
   13cbc:	f8d6 30bc 	ldr.w	r3, [r6, #188]	; 0xbc
Z_GENLIST_APPEND(slist, snode)
   13cc0:	b313      	cbz	r3, 13d08 <submit_to_queue_locked+0xa4>
	parent->next = child;
   13cc2:	601c      	str	r4, [r3, #0]
	list->tail = node;
   13cc4:	f8c6 40bc 	str.w	r4, [r6, #188]	; 0xbc
	if (queue != NULL) {
   13cc8:	b12e      	cbz	r6, 13cd6 <submit_to_queue_locked+0x72>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   13cca:	2200      	movs	r2, #0
   13ccc:	4611      	mov	r1, r2
   13cce:	f106 00c0 	add.w	r0, r6, #192	; 0xc0
   13cd2:	f008 fd66 	bl	1c7a2 <z_sched_wake>
		ret = 1;
   13cd6:	2001      	movs	r0, #1

		if (rc < 0) {
   13cd8:	2800      	cmp	r0, #0
   13cda:	db06      	blt.n	13cea <submit_to_queue_locked+0x86>
	*flagp |= BIT(bit);
   13cdc:	68e3      	ldr	r3, [r4, #12]
   13cde:	f043 0304 	orr.w	r3, r3, #4
   13ce2:	60e3      	str	r3, [r4, #12]
			ret = rc;
		} else {
			flag_set(&work->flags, K_WORK_QUEUED_BIT);
			work->queue = *queuep;
   13ce4:	682b      	ldr	r3, [r5, #0]
   13ce6:	60a3      	str	r3, [r4, #8]
   13ce8:	4638      	mov	r0, r7
		}
	} else {
		/* Already queued, do nothing. */
	}

	if (ret <= 0) {
   13cea:	2800      	cmp	r0, #0
   13cec:	dc21      	bgt.n	13d32 <submit_to_queue_locked+0xce>
   13cee:	e01e      	b.n	13d2e <submit_to_queue_locked+0xca>
			*queuep = work->queue;
   13cf0:	6883      	ldr	r3, [r0, #8]
   13cf2:	600b      	str	r3, [r1, #0]
   13cf4:	e7c3      	b.n	13c7e <submit_to_queue_locked+0x1a>
		ret = 1;
   13cf6:	2701      	movs	r7, #1
   13cf8:	e7c8      	b.n	13c8c <submit_to_queue_locked+0x28>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   13cfa:	f008 f948 	bl	1bf8e <k_is_in_isr>
   13cfe:	b908      	cbnz	r0, 13d04 <submit_to_queue_locked+0xa0>
   13d00:	2301      	movs	r3, #1
   13d02:	e7cb      	b.n	13c9c <submit_to_queue_locked+0x38>
   13d04:	2300      	movs	r3, #0
   13d06:	e7c9      	b.n	13c9c <submit_to_queue_locked+0x38>
   13d08:	f8c6 40bc 	str.w	r4, [r6, #188]	; 0xbc
	list->head = node;
   13d0c:	f8c6 40b8 	str.w	r4, [r6, #184]	; 0xb8
}
   13d10:	e7da      	b.n	13cc8 <submit_to_queue_locked+0x64>
		return -EINVAL;
   13d12:	f06f 0015 	mvn.w	r0, #21
   13d16:	e7df      	b.n	13cd8 <submit_to_queue_locked+0x74>
		ret = -ENODEV;
   13d18:	f06f 0012 	mvn.w	r0, #18
   13d1c:	e7dc      	b.n	13cd8 <submit_to_queue_locked+0x74>
		ret = -EBUSY;
   13d1e:	f06f 000f 	mvn.w	r0, #15
   13d22:	e7d9      	b.n	13cd8 <submit_to_queue_locked+0x74>
		ret = -EBUSY;
   13d24:	f06f 000f 	mvn.w	r0, #15
   13d28:	e7d6      	b.n	13cd8 <submit_to_queue_locked+0x74>
		ret = -EBUSY;
   13d2a:	f06f 000f 	mvn.w	r0, #15
		*queuep = NULL;
   13d2e:	2300      	movs	r3, #0
   13d30:	602b      	str	r3, [r5, #0]
	}

	return ret;
}
   13d32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int ret = 0;
   13d34:	2000      	movs	r0, #0
   13d36:	e7fa      	b.n	13d2e <submit_to_queue_locked+0xca>
   13d38:	200026d8 	.word	0x200026d8

00013d3c <cancel_sync_locked>:
 *
 * @retval false if work was idle on entry.  The caller need not wait.
 */
static bool cancel_sync_locked(struct k_work *work,
			       struct z_work_canceller *canceller)
{
   13d3c:	b570      	push	{r4, r5, r6, lr}
	return (*flagp & BIT(bit)) != 0U;
   13d3e:	68c5      	ldr	r5, [r0, #12]
   13d40:	f015 0f02 	tst.w	r5, #2
   13d44:	f3c5 0540 	ubfx	r5, r5, #1, #1

	/* If something's still running then we have to wait for
	 * completion, which is indicated when finish_cancel() gets
	 * invoked.
	 */
	if (ret) {
   13d48:	d101      	bne.n	13d4e <cancel_sync_locked+0x12>
		init_work_cancel(canceller, work);
	}

	return ret;
}
   13d4a:	4628      	mov	r0, r5
   13d4c:	bd70      	pop	{r4, r5, r6, pc}
   13d4e:	4604      	mov	r4, r0
   13d50:	460e      	mov	r6, r1
	k_sem_init(&canceler->sem, 0, 1);
   13d52:	f101 0008 	add.w	r0, r1, #8
	return z_impl_k_sem_init(sem, initial_count, limit);
   13d56:	2201      	movs	r2, #1
   13d58:	2100      	movs	r1, #0
   13d5a:	f008 fa5b 	bl	1c214 <z_impl_k_sem_init>
	canceler->work = work;
   13d5e:	6074      	str	r4, [r6, #4]
	parent->next = child;
   13d60:	2300      	movs	r3, #0
   13d62:	6033      	str	r3, [r6, #0]
	return list->tail;
   13d64:	4b05      	ldr	r3, [pc, #20]	; (13d7c <cancel_sync_locked+0x40>)
   13d66:	685b      	ldr	r3, [r3, #4]
Z_GENLIST_APPEND(slist, snode)
   13d68:	b11b      	cbz	r3, 13d72 <cancel_sync_locked+0x36>
	parent->next = child;
   13d6a:	601e      	str	r6, [r3, #0]
	list->tail = node;
   13d6c:	4b03      	ldr	r3, [pc, #12]	; (13d7c <cancel_sync_locked+0x40>)
   13d6e:	605e      	str	r6, [r3, #4]
}
   13d70:	e7eb      	b.n	13d4a <cancel_sync_locked+0xe>
   13d72:	4b02      	ldr	r3, [pc, #8]	; (13d7c <cancel_sync_locked+0x40>)
   13d74:	605e      	str	r6, [r3, #4]
	list->head = node;
   13d76:	601e      	str	r6, [r3, #0]
}
   13d78:	e7e7      	b.n	13d4a <cancel_sync_locked+0xe>
   13d7a:	bf00      	nop
   13d7c:	20002704 	.word	0x20002704

00013d80 <schedule_for_queue_locked>:
 * @retval 1 to indicate successfully scheduled.
 */
static int schedule_for_queue_locked(struct k_work_q **queuep,
				     struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   13d80:	b508      	push	{r3, lr}
   13d82:	4684      	mov	ip, r0
   13d84:	4608      	mov	r0, r1
	int ret = 1;
	struct k_work *work = &dwork->work;

	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   13d86:	ea53 0102 	orrs.w	r1, r3, r2
   13d8a:	d00c      	beq.n	13da6 <schedule_for_queue_locked+0x26>
	*flagp |= BIT(bit);
   13d8c:	68c1      	ldr	r1, [r0, #12]
   13d8e:	f041 0108 	orr.w	r1, r1, #8
   13d92:	60c1      	str	r1, [r0, #12]
		return submit_to_queue_locked(work, queuep);
	}

	flag_set(&work->flags, K_WORK_DELAYED_BIT);
	dwork->queue = *queuep;
   13d94:	f8dc 1000 	ldr.w	r1, [ip]
   13d98:	6281      	str	r1, [r0, #40]	; 0x28

	/* Add timeout */
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   13d9a:	4905      	ldr	r1, [pc, #20]	; (13db0 <schedule_for_queue_locked+0x30>)
   13d9c:	3010      	adds	r0, #16
   13d9e:	f000 fda3 	bl	148e8 <z_add_timeout>

	return ret;
   13da2:	2001      	movs	r0, #1
}
   13da4:	bd08      	pop	{r3, pc}
		return submit_to_queue_locked(work, queuep);
   13da6:	4661      	mov	r1, ip
   13da8:	f7ff ff5c 	bl	13c64 <submit_to_queue_locked>
   13dac:	e7fa      	b.n	13da4 <schedule_for_queue_locked+0x24>
   13dae:	bf00      	nop
   13db0:	0001c2ad 	.word	0x0001c2ad

00013db4 <finalize_cancel_locked>:
{
   13db4:	b570      	push	{r4, r5, r6, lr}
   13db6:	4605      	mov	r5, r0
	*flagp &= ~BIT(bit);
   13db8:	68c3      	ldr	r3, [r0, #12]
   13dba:	f023 0302 	bic.w	r3, r3, #2
   13dbe:	60c3      	str	r3, [r0, #12]
	return list->head;
   13dc0:	4b1a      	ldr	r3, [pc, #104]	; (13e2c <finalize_cancel_locked+0x78>)
   13dc2:	681b      	ldr	r3, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   13dc4:	b1fb      	cbz	r3, 13e06 <finalize_cancel_locked+0x52>
   13dc6:	461c      	mov	r4, r3
Z_GENLIST_PEEK_NEXT(slist, snode)
   13dc8:	b103      	cbz	r3, 13dcc <finalize_cancel_locked+0x18>
	return node->next;
   13dca:	681c      	ldr	r4, [r3, #0]
   13dcc:	2600      	movs	r6, #0
   13dce:	e01f      	b.n	13e10 <finalize_cancel_locked+0x5c>
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   13dd0:	461a      	mov	r2, r3
Z_GENLIST_REMOVE(slist, snode)
   13dd2:	b166      	cbz	r6, 13dee <finalize_cancel_locked+0x3a>
	return node->next;
   13dd4:	6819      	ldr	r1, [r3, #0]
	parent->next = child;
   13dd6:	6031      	str	r1, [r6, #0]
	return list->tail;
   13dd8:	4914      	ldr	r1, [pc, #80]	; (13e2c <finalize_cancel_locked+0x78>)
   13dda:	6849      	ldr	r1, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   13ddc:	428b      	cmp	r3, r1
   13dde:	d00f      	beq.n	13e00 <finalize_cancel_locked+0x4c>
	parent->next = child;
   13de0:	2100      	movs	r1, #0
   13de2:	6011      	str	r1, [r2, #0]
			k_sem_give(&wc->sem);
   13de4:	f103 0008 	add.w	r0, r3, #8
	z_impl_k_sem_give(sem);
   13de8:	f7ff fed2 	bl	13b90 <z_impl_k_sem_give>
}
   13dec:	e015      	b.n	13e1a <finalize_cancel_locked+0x66>
	return node->next;
   13dee:	6818      	ldr	r0, [r3, #0]
	list->head = node;
   13df0:	490e      	ldr	r1, [pc, #56]	; (13e2c <finalize_cancel_locked+0x78>)
   13df2:	6008      	str	r0, [r1, #0]
	return list->tail;
   13df4:	6849      	ldr	r1, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   13df6:	428b      	cmp	r3, r1
   13df8:	d1f2      	bne.n	13de0 <finalize_cancel_locked+0x2c>
	list->tail = node;
   13dfa:	490c      	ldr	r1, [pc, #48]	; (13e2c <finalize_cancel_locked+0x78>)
   13dfc:	6048      	str	r0, [r1, #4]
}
   13dfe:	e7ef      	b.n	13de0 <finalize_cancel_locked+0x2c>
	list->tail = node;
   13e00:	490a      	ldr	r1, [pc, #40]	; (13e2c <finalize_cancel_locked+0x78>)
   13e02:	604e      	str	r6, [r1, #4]
}
   13e04:	e7ec      	b.n	13de0 <finalize_cancel_locked+0x2c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   13e06:	461c      	mov	r4, r3
   13e08:	e7e0      	b.n	13dcc <finalize_cancel_locked+0x18>
   13e0a:	4622      	mov	r2, r4
   13e0c:	4623      	mov	r3, r4
   13e0e:	4614      	mov	r4, r2
   13e10:	b153      	cbz	r3, 13e28 <finalize_cancel_locked+0x74>
		if (wc->work == work) {
   13e12:	685a      	ldr	r2, [r3, #4]
   13e14:	42aa      	cmp	r2, r5
   13e16:	d0db      	beq.n	13dd0 <finalize_cancel_locked+0x1c>
			prev = &wc->node;
   13e18:	461e      	mov	r6, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   13e1a:	2c00      	cmp	r4, #0
   13e1c:	d0f5      	beq.n	13e0a <finalize_cancel_locked+0x56>
   13e1e:	4622      	mov	r2, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
   13e20:	2c00      	cmp	r4, #0
   13e22:	d0f3      	beq.n	13e0c <finalize_cancel_locked+0x58>
	return node->next;
   13e24:	6822      	ldr	r2, [r4, #0]
   13e26:	e7f1      	b.n	13e0c <finalize_cancel_locked+0x58>
}
   13e28:	bd70      	pop	{r4, r5, r6, pc}
   13e2a:	bf00      	nop
   13e2c:	20002704 	.word	0x20002704

00013e30 <work_queue_main>:
{
   13e30:	b5f0      	push	{r4, r5, r6, r7, lr}
   13e32:	b085      	sub	sp, #20
   13e34:	4605      	mov	r5, r0
	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
   13e36:	e016      	b.n	13e66 <work_queue_main+0x36>
	return (*flagp & BIT(bit)) != 0U;
   13e38:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
	*flagp &= ~BIT(bit);
   13e3c:	f023 0204 	bic.w	r2, r3, #4
   13e40:	f8c5 20d0 	str.w	r2, [r5, #208]	; 0xd0
		} else if (flag_test_and_clear(&queue->flags,
   13e44:	f013 0f04 	tst.w	r3, #4
   13e48:	d159      	bne.n	13efe <work_queue_main+0xce>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   13e4a:	2300      	movs	r3, #0
   13e4c:	9302      	str	r3, [sp, #8]
   13e4e:	f04f 32ff 	mov.w	r2, #4294967295
   13e52:	f04f 33ff 	mov.w	r3, #4294967295
   13e56:	e9cd 2300 	strd	r2, r3, [sp]
   13e5a:	f105 02c0 	add.w	r2, r5, #192	; 0xc0
   13e5e:	4631      	mov	r1, r6
   13e60:	482e      	ldr	r0, [pc, #184]	; (13f1c <work_queue_main+0xec>)
   13e62:	f000 fccb 	bl	147fc <z_sched_wait>
	__asm__ volatile(
   13e66:	f04f 0320 	mov.w	r3, #32
   13e6a:	f3ef 8611 	mrs	r6, BASEPRI
   13e6e:	f383 8812 	msr	BASEPRI_MAX, r3
   13e72:	f3bf 8f6f 	isb	sy
	return list->head;
   13e76:	f8d5 40b8 	ldr.w	r4, [r5, #184]	; 0xb8
Z_GENLIST_GET(slist, snode)
   13e7a:	2c00      	cmp	r4, #0
   13e7c:	d0dc      	beq.n	13e38 <work_queue_main+0x8>
	return node->next;
   13e7e:	6823      	ldr	r3, [r4, #0]
	list->head = node;
   13e80:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
	return list->tail;
   13e84:	f8d5 20bc 	ldr.w	r2, [r5, #188]	; 0xbc
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   13e88:	4294      	cmp	r4, r2
   13e8a:	d035      	beq.n	13ef8 <work_queue_main+0xc8>
	*flagp |= BIT(bit);
   13e8c:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
   13e90:	f043 0302 	orr.w	r3, r3, #2
   13e94:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
   13e98:	68e3      	ldr	r3, [r4, #12]
   13e9a:	f043 0301 	orr.w	r3, r3, #1
   13e9e:	60e3      	str	r3, [r4, #12]
	*flagp &= ~BIT(bit);
   13ea0:	f023 0304 	bic.w	r3, r3, #4
   13ea4:	60e3      	str	r3, [r4, #12]
			handler = work->handler;
   13ea6:	6863      	ldr	r3, [r4, #4]
		if (work == NULL) {
   13ea8:	2c00      	cmp	r4, #0
   13eaa:	d0ce      	beq.n	13e4a <work_queue_main+0x1a>
	__asm__ volatile(
   13eac:	f386 8811 	msr	BASEPRI, r6
   13eb0:	f3bf 8f6f 	isb	sy
		handler(work);
   13eb4:	4620      	mov	r0, r4
   13eb6:	4798      	blx	r3
	__asm__ volatile(
   13eb8:	f04f 0320 	mov.w	r3, #32
   13ebc:	f3ef 8611 	mrs	r6, BASEPRI
   13ec0:	f383 8812 	msr	BASEPRI_MAX, r3
   13ec4:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
   13ec8:	68e3      	ldr	r3, [r4, #12]
   13eca:	f023 0301 	bic.w	r3, r3, #1
   13ece:	60e3      	str	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   13ed0:	f013 0f02 	tst.w	r3, #2
   13ed4:	d11e      	bne.n	13f14 <work_queue_main+0xe4>
	*flagp &= ~BIT(bit);
   13ed6:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
   13eda:	f023 0302 	bic.w	r3, r3, #2
   13ede:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	return (*flagp & BIT(bit)) != 0U;
   13ee2:	f3c3 2300 	ubfx	r3, r3, #8, #1
	__asm__ volatile(
   13ee6:	f386 8811 	msr	BASEPRI, r6
   13eea:	f3bf 8f6f 	isb	sy
		if (yield) {
   13eee:	2b00      	cmp	r3, #0
   13ef0:	d1b9      	bne.n	13e66 <work_queue_main+0x36>
	z_impl_k_yield();
   13ef2:	f000 fb89 	bl	14608 <z_impl_k_yield>
}
   13ef6:	e7b6      	b.n	13e66 <work_queue_main+0x36>
	list->tail = node;
   13ef8:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
}
   13efc:	e7c6      	b.n	13e8c <work_queue_main+0x5c>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   13efe:	f105 07c8 	add.w	r7, r5, #200	; 0xc8
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   13f02:	2200      	movs	r2, #0
   13f04:	2101      	movs	r1, #1
   13f06:	4638      	mov	r0, r7
   13f08:	f008 fc4b 	bl	1c7a2 <z_sched_wake>
   13f0c:	2800      	cmp	r0, #0
   13f0e:	d1f8      	bne.n	13f02 <work_queue_main+0xd2>
		k_work_handler_t handler = NULL;
   13f10:	2300      	movs	r3, #0
   13f12:	e7c9      	b.n	13ea8 <work_queue_main+0x78>
			finalize_cancel_locked(work);
   13f14:	4620      	mov	r0, r4
   13f16:	f7ff ff4d 	bl	13db4 <finalize_cancel_locked>
   13f1a:	e7dc      	b.n	13ed6 <work_queue_main+0xa6>
   13f1c:	20002704 	.word	0x20002704

00013f20 <k_work_submit>:
{
   13f20:	b508      	push	{r3, lr}
   13f22:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
   13f24:	4801      	ldr	r0, [pc, #4]	; (13f2c <k_work_submit+0xc>)
   13f26:	f008 fa11 	bl	1c34c <k_work_submit_to_queue>
}
   13f2a:	bd08      	pop	{r3, pc}
   13f2c:	20001af8 	.word	0x20001af8

00013f30 <k_work_queue_start>:
{
   13f30:	b5f0      	push	{r4, r5, r6, r7, lr}
   13f32:	b089      	sub	sp, #36	; 0x24
   13f34:	4604      	mov	r4, r0
   13f36:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	list->head = NULL;
   13f38:	2000      	movs	r0, #0
   13f3a:	f8c4 00b8 	str.w	r0, [r4, #184]	; 0xb8
	list->tail = NULL;
   13f3e:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
   13f42:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
	list->head = (sys_dnode_t *)list;
   13f46:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	list->tail = (sys_dnode_t *)list;
   13f4a:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
   13f4e:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
	list->head = (sys_dnode_t *)list;
   13f52:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
	list->tail = (sys_dnode_t *)list;
   13f56:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
	if ((cfg != NULL) && cfg->no_yield) {
   13f5a:	b1fd      	cbz	r5, 13f9c <k_work_queue_start+0x6c>
   13f5c:	7928      	ldrb	r0, [r5, #4]
   13f5e:	b9f8      	cbnz	r0, 13fa0 <k_work_queue_start+0x70>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   13f60:	2001      	movs	r0, #1
	*flagp = flags;
   13f62:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   13f66:	f04f 36ff 	mov.w	r6, #4294967295
   13f6a:	f04f 37ff 	mov.w	r7, #4294967295
   13f6e:	e9cd 6706 	strd	r6, r7, [sp, #24]
   13f72:	2000      	movs	r0, #0
   13f74:	9004      	str	r0, [sp, #16]
   13f76:	9303      	str	r3, [sp, #12]
   13f78:	9002      	str	r0, [sp, #8]
   13f7a:	9001      	str	r0, [sp, #4]
   13f7c:	9400      	str	r4, [sp, #0]
   13f7e:	4b0a      	ldr	r3, [pc, #40]	; (13fa8 <k_work_queue_start+0x78>)
   13f80:	4620      	mov	r0, r4
   13f82:	f008 f81b 	bl	1bfbc <z_impl_k_thread_create>
	if ((cfg != NULL) && (cfg->name != NULL)) {
   13f86:	b125      	cbz	r5, 13f92 <k_work_queue_start+0x62>
   13f88:	6829      	ldr	r1, [r5, #0]
   13f8a:	b111      	cbz	r1, 13f92 <k_work_queue_start+0x62>
	return z_impl_k_thread_name_set(thread, str);
   13f8c:	4620      	mov	r0, r4
   13f8e:	f7ff fc11 	bl	137b4 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   13f92:	4620      	mov	r0, r4
   13f94:	f008 f803 	bl	1bf9e <z_impl_k_thread_start>
}
   13f98:	b009      	add	sp, #36	; 0x24
   13f9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint32_t flags = K_WORK_QUEUE_STARTED;
   13f9c:	2001      	movs	r0, #1
   13f9e:	e7e0      	b.n	13f62 <k_work_queue_start+0x32>
		flags |= K_WORK_QUEUE_NO_YIELD;
   13fa0:	f240 1001 	movw	r0, #257	; 0x101
   13fa4:	e7dd      	b.n	13f62 <k_work_queue_start+0x32>
   13fa6:	bf00      	nop
   13fa8:	00013e31 	.word	0x00013e31

00013fac <k_work_schedule>:
	return ret;
}

int k_work_schedule(struct k_work_delayable *dwork,
				   k_timeout_t delay)
{
   13fac:	b508      	push	{r3, lr}
   13fae:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, schedule, dwork, delay);

	int ret = k_work_schedule_for_queue(&k_sys_work_q, dwork, delay);
   13fb0:	4801      	ldr	r0, [pc, #4]	; (13fb8 <k_work_schedule+0xc>)
   13fb2:	f008 f9ff 	bl	1c3b4 <k_work_schedule_for_queue>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule, dwork, delay, ret);

	return ret;
}
   13fb6:	bd08      	pop	{r3, pc}
   13fb8:	20001af8 	.word	0x20001af8

00013fbc <k_work_reschedule>:
	return ret;
}

int k_work_reschedule(struct k_work_delayable *dwork,
				     k_timeout_t delay)
{
   13fbc:	b508      	push	{r3, lr}
   13fbe:	4601      	mov	r1, r0
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, reschedule, dwork, delay);

	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
   13fc0:	4801      	ldr	r0, [pc, #4]	; (13fc8 <k_work_reschedule+0xc>)
   13fc2:	f008 fa11 	bl	1c3e8 <k_work_reschedule_for_queue>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, reschedule, dwork, delay, ret);

	return ret;
}
   13fc6:	bd08      	pop	{r3, pc}
   13fc8:	20001af8 	.word	0x20001af8

00013fcc <add_thread_timeout>:
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   13fcc:	f1b3 3fff 	cmp.w	r3, #4294967295
   13fd0:	bf08      	it	eq
   13fd2:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   13fd6:	d100      	bne.n	13fda <add_thread_timeout+0xe>
   13fd8:	4770      	bx	lr
{
   13fda:	b508      	push	{r3, lr}
   13fdc:	4902      	ldr	r1, [pc, #8]	; (13fe8 <add_thread_timeout+0x1c>)
   13fde:	3018      	adds	r0, #24
   13fe0:	f000 fc82 	bl	148e8 <z_add_timeout>
		z_add_thread_timeout(thread, timeout);
	}
}
   13fe4:	bd08      	pop	{r3, pc}
   13fe6:	bf00      	nop
   13fe8:	0001c5cf 	.word	0x0001c5cf

00013fec <z_reset_time_slice>:
{
   13fec:	b510      	push	{r4, lr}
	int ret = slice_ticks;
   13fee:	4b07      	ldr	r3, [pc, #28]	; (1400c <z_reset_time_slice+0x20>)
   13ff0:	681c      	ldr	r4, [r3, #0]
	if (slice_time(curr) != 0) {
   13ff2:	b904      	cbnz	r4, 13ff6 <z_reset_time_slice+0xa>
}
   13ff4:	bd10      	pop	{r4, pc}
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
   13ff6:	f7fc fb2b 	bl	10650 <sys_clock_elapsed>
   13ffa:	4404      	add	r4, r0
   13ffc:	4b04      	ldr	r3, [pc, #16]	; (14010 <z_reset_time_slice+0x24>)
   13ffe:	611c      	str	r4, [r3, #16]
		z_set_timeout_expiry(slice_time(curr), false);
   14000:	2100      	movs	r1, #0
   14002:	4b02      	ldr	r3, [pc, #8]	; (1400c <z_reset_time_slice+0x20>)
   14004:	6818      	ldr	r0, [r3, #0]
   14006:	f008 fc4f 	bl	1c8a8 <z_set_timeout_expiry>
}
   1400a:	e7f3      	b.n	13ff4 <z_reset_time_slice+0x8>
   1400c:	20002714 	.word	0x20002714
   14010:	200026d8 	.word	0x200026d8

00014014 <k_sched_time_slice_set>:
{
   14014:	b570      	push	{r4, r5, r6, lr}
   14016:	4604      	mov	r4, r0
   14018:	460d      	mov	r5, r1
	LOCKED(&sched_spinlock) {
   1401a:	2300      	movs	r3, #0
	__asm__ volatile(
   1401c:	f04f 0220 	mov.w	r2, #32
   14020:	f3ef 8611 	mrs	r6, BASEPRI
   14024:	f382 8812 	msr	BASEPRI_MAX, r2
   14028:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   1402c:	e00e      	b.n	1404c <k_sched_time_slice_set+0x38>
			slice_ticks = MAX(2, slice_ticks);
   1402e:	2802      	cmp	r0, #2
   14030:	bfb8      	it	lt
   14032:	2002      	movlt	r0, #2
   14034:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   14036:	4b11      	ldr	r3, [pc, #68]	; (1407c <k_sched_time_slice_set+0x68>)
   14038:	601d      	str	r5, [r3, #0]
		z_reset_time_slice(_current);
   1403a:	4b11      	ldr	r3, [pc, #68]	; (14080 <k_sched_time_slice_set+0x6c>)
   1403c:	6898      	ldr	r0, [r3, #8]
   1403e:	f7ff ffd5 	bl	13fec <z_reset_time_slice>
	__asm__ volatile(
   14042:	f386 8811 	msr	BASEPRI, r6
   14046:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1404a:	2301      	movs	r3, #1
   1404c:	b9a3      	cbnz	r3, 14078 <k_sched_time_slice_set+0x64>
		_current_cpu->slice_ticks = 0;
   1404e:	4b0c      	ldr	r3, [pc, #48]	; (14080 <k_sched_time_slice_set+0x6c>)
   14050:	2200      	movs	r2, #0
   14052:	611a      	str	r2, [r3, #16]
			return (uint32_t)((t * to_hz + off) / from_hz);
   14054:	0c61      	lsrs	r1, r4, #17
   14056:	03e3      	lsls	r3, r4, #15
   14058:	f240 30e7 	movw	r0, #999	; 0x3e7
   1405c:	1818      	adds	r0, r3, r0
   1405e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   14062:	f04f 0300 	mov.w	r3, #0
   14066:	f141 0100 	adc.w	r1, r1, #0
   1406a:	f7ec f873 	bl	154 <__aeabi_uldivmod>
		slice_ticks = k_ms_to_ticks_ceil32(slice);
   1406e:	4b05      	ldr	r3, [pc, #20]	; (14084 <k_sched_time_slice_set+0x70>)
   14070:	6018      	str	r0, [r3, #0]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   14072:	2c00      	cmp	r4, #0
   14074:	dcdb      	bgt.n	1402e <k_sched_time_slice_set+0x1a>
   14076:	e7de      	b.n	14036 <k_sched_time_slice_set+0x22>
}
   14078:	bd70      	pop	{r4, r5, r6, pc}
   1407a:	bf00      	nop
   1407c:	20002710 	.word	0x20002710
   14080:	200026d8 	.word	0x200026d8
   14084:	20002714 	.word	0x20002714

00014088 <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   14088:	b508      	push	{r3, lr}
	if (resched(key.key) && need_swap()) {
   1408a:	4608      	mov	r0, r1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1408c:	b921      	cbnz	r1, 14098 <z_reschedule+0x10>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1408e:	f3ef 8305 	mrs	r3, IPSR
   14092:	b913      	cbnz	r3, 1409a <z_reschedule+0x12>
   14094:	2101      	movs	r1, #1
   14096:	e000      	b.n	1409a <z_reschedule+0x12>
   14098:	2100      	movs	r1, #0
	if (resched(key.key) && need_swap()) {
   1409a:	f011 0f01 	tst.w	r1, #1
   1409e:	d007      	beq.n	140b0 <z_reschedule+0x28>
	new_thread = _kernel.ready_q.cache;
   140a0:	4b06      	ldr	r3, [pc, #24]	; (140bc <z_reschedule+0x34>)
   140a2:	69da      	ldr	r2, [r3, #28]
	return new_thread != _current;
   140a4:	689b      	ldr	r3, [r3, #8]
	if (resched(key.key) && need_swap()) {
   140a6:	429a      	cmp	r2, r3
   140a8:	d002      	beq.n	140b0 <z_reschedule+0x28>
	ret = arch_swap(key);
   140aa:	f7f0 f811 	bl	40d0 <arch_swap>
		z_swap(lock, key);
   140ae:	e003      	b.n	140b8 <z_reschedule+0x30>
   140b0:	f380 8811 	msr	BASEPRI, r0
   140b4:	f3bf 8f6f 	isb	sy
	} else {
		k_spin_unlock(lock, key);
		signal_pending_ipi();
	}
}
   140b8:	bd08      	pop	{r3, pc}
   140ba:	bf00      	nop
   140bc:	200026d8 	.word	0x200026d8

000140c0 <k_sched_lock>:
	}
}

void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
   140c0:	2300      	movs	r3, #0
	__asm__ volatile(
   140c2:	f04f 0220 	mov.w	r2, #32
   140c6:	f3ef 8111 	mrs	r1, BASEPRI
   140ca:	f382 8812 	msr	BASEPRI_MAX, r2
   140ce:	f3bf 8f6f 	isb	sy
   140d2:	e009      	b.n	140e8 <k_sched_lock+0x28>
	--_current->base.sched_locked;
   140d4:	4b06      	ldr	r3, [pc, #24]	; (140f0 <k_sched_lock+0x30>)
   140d6:	689a      	ldr	r2, [r3, #8]
   140d8:	7bd3      	ldrb	r3, [r2, #15]
   140da:	3b01      	subs	r3, #1
   140dc:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   140de:	f381 8811 	msr	BASEPRI, r1
   140e2:	f3bf 8f6f 	isb	sy
   140e6:	2301      	movs	r3, #1
   140e8:	2b00      	cmp	r3, #0
   140ea:	d0f3      	beq.n	140d4 <k_sched_lock+0x14>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   140ec:	4770      	bx	lr
   140ee:	bf00      	nop
   140f0:	200026d8 	.word	0x200026d8

000140f4 <update_cache>:
{
   140f4:	b538      	push	{r3, r4, r5, lr}
   140f6:	4604      	mov	r4, r0
	return _priq_run_best(curr_cpu_runq());
   140f8:	4810      	ldr	r0, [pc, #64]	; (1413c <update_cache+0x48>)
   140fa:	f008 fa45 	bl	1c588 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   140fe:	4605      	mov	r5, r0
   14100:	b170      	cbz	r0, 14120 <update_cache+0x2c>
	if (preempt_ok != 0) {
   14102:	b984      	cbnz	r4, 14126 <update_cache+0x32>
	if (z_is_thread_prevented_from_running(_current)) {
   14104:	4b0e      	ldr	r3, [pc, #56]	; (14140 <update_cache+0x4c>)
   14106:	689b      	ldr	r3, [r3, #8]
	uint8_t state = thread->base.thread_state;
   14108:	7b5a      	ldrb	r2, [r3, #13]
   1410a:	f012 0f1f 	tst.w	r2, #31
   1410e:	d10a      	bne.n	14126 <update_cache+0x32>
	return node->next != NULL;
   14110:	69aa      	ldr	r2, [r5, #24]
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   14112:	b942      	cbnz	r2, 14126 <update_cache+0x32>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   14114:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
   14116:	2a7f      	cmp	r2, #127	; 0x7f
   14118:	d905      	bls.n	14126 <update_cache+0x32>
		_kernel.ready_q.cache = _current;
   1411a:	4a09      	ldr	r2, [pc, #36]	; (14140 <update_cache+0x4c>)
   1411c:	61d3      	str	r3, [r2, #28]
   1411e:	e00b      	b.n	14138 <update_cache+0x44>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   14120:	4b07      	ldr	r3, [pc, #28]	; (14140 <update_cache+0x4c>)
   14122:	68dd      	ldr	r5, [r3, #12]
   14124:	e7ed      	b.n	14102 <update_cache+0xe>
		if (thread != _current) {
   14126:	4b06      	ldr	r3, [pc, #24]	; (14140 <update_cache+0x4c>)
   14128:	689b      	ldr	r3, [r3, #8]
   1412a:	42ab      	cmp	r3, r5
   1412c:	d002      	beq.n	14134 <update_cache+0x40>
			z_reset_time_slice(thread);
   1412e:	4628      	mov	r0, r5
   14130:	f7ff ff5c 	bl	13fec <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   14134:	4b02      	ldr	r3, [pc, #8]	; (14140 <update_cache+0x4c>)
   14136:	61dd      	str	r5, [r3, #28]
}
   14138:	bd38      	pop	{r3, r4, r5, pc}
   1413a:	bf00      	nop
   1413c:	200026f8 	.word	0x200026f8
   14140:	200026d8 	.word	0x200026d8

00014144 <move_thread_to_end_of_prio_q>:
{
   14144:	b538      	push	{r3, r4, r5, lr}
   14146:	4605      	mov	r5, r0
	return (thread->base.thread_state & state) != 0U;
   14148:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
   1414a:	f990 300d 	ldrsb.w	r3, [r0, #13]
   1414e:	2b00      	cmp	r3, #0
   14150:	db28      	blt.n	141a4 <move_thread_to_end_of_prio_q+0x60>
	thread->base.thread_state |= _THREAD_QUEUED;
   14152:	7b6b      	ldrb	r3, [r5, #13]
   14154:	f063 037f 	orn	r3, r3, #127	; 0x7f
   14158:	736b      	strb	r3, [r5, #13]
	return list->head == list;
   1415a:	4b1a      	ldr	r3, [pc, #104]	; (141c4 <move_thread_to_end_of_prio_q+0x80>)
   1415c:	f853 4f20 	ldr.w	r4, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14160:	429c      	cmp	r4, r3
   14162:	d02d      	beq.n	141c0 <move_thread_to_end_of_prio_q+0x7c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   14164:	b16c      	cbz	r4, 14182 <move_thread_to_end_of_prio_q+0x3e>
		if (z_sched_prio_cmp(thread, t) > 0) {
   14166:	4621      	mov	r1, r4
   14168:	4628      	mov	r0, r5
   1416a:	f008 f9a2 	bl	1c4b2 <z_sched_prio_cmp>
   1416e:	2800      	cmp	r0, #0
   14170:	dc20      	bgt.n	141b4 <move_thread_to_end_of_prio_q+0x70>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   14172:	b134      	cbz	r4, 14182 <move_thread_to_end_of_prio_q+0x3e>
	return (node == list->tail) ? NULL : node->next;
   14174:	4b13      	ldr	r3, [pc, #76]	; (141c4 <move_thread_to_end_of_prio_q+0x80>)
   14176:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   14178:	429c      	cmp	r4, r3
   1417a:	d002      	beq.n	14182 <move_thread_to_end_of_prio_q+0x3e>
   1417c:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1417e:	2c00      	cmp	r4, #0
   14180:	d1f0      	bne.n	14164 <move_thread_to_end_of_prio_q+0x20>
 * @param node the element to append
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;
   14182:	4b10      	ldr	r3, [pc, #64]	; (141c4 <move_thread_to_end_of_prio_q+0x80>)
   14184:	6a5a      	ldr	r2, [r3, #36]	; 0x24

	node->next = list;
   14186:	f103 0120 	add.w	r1, r3, #32
   1418a:	6029      	str	r1, [r5, #0]
	node->prev = tail;
   1418c:	606a      	str	r2, [r5, #4]

	tail->next = node;
   1418e:	6015      	str	r5, [r2, #0]
	list->tail = node;
   14190:	625d      	str	r5, [r3, #36]	; 0x24
	update_cache(thread == _current);
   14192:	4b0c      	ldr	r3, [pc, #48]	; (141c4 <move_thread_to_end_of_prio_q+0x80>)
   14194:	6898      	ldr	r0, [r3, #8]
   14196:	42a8      	cmp	r0, r5
   14198:	bf14      	ite	ne
   1419a:	2000      	movne	r0, #0
   1419c:	2001      	moveq	r0, #1
   1419e:	f7ff ffa9 	bl	140f4 <update_cache>
}
   141a2:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
   141a4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   141a8:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
   141aa:	4601      	mov	r1, r0
   141ac:	4806      	ldr	r0, [pc, #24]	; (141c8 <move_thread_to_end_of_prio_q+0x84>)
   141ae:	f008 f9bf 	bl	1c530 <z_priq_dumb_remove>
}
   141b2:	e7ce      	b.n	14152 <move_thread_to_end_of_prio_q+0xe>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   141b4:	6863      	ldr	r3, [r4, #4]

	node->prev = prev;
   141b6:	606b      	str	r3, [r5, #4]
	node->next = successor;
   141b8:	602c      	str	r4, [r5, #0]
	prev->next = node;
   141ba:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   141bc:	6065      	str	r5, [r4, #4]
}
   141be:	e7e8      	b.n	14192 <move_thread_to_end_of_prio_q+0x4e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   141c0:	2400      	movs	r4, #0
   141c2:	e7cf      	b.n	14164 <move_thread_to_end_of_prio_q+0x20>
   141c4:	200026d8 	.word	0x200026d8
   141c8:	200026f8 	.word	0x200026f8

000141cc <slice_expired_locked>:
{
   141cc:	b538      	push	{r3, r4, r5, lr}
   141ce:	4604      	mov	r4, r0
	struct k_thread *curr = _current;
   141d0:	4b07      	ldr	r3, [pc, #28]	; (141f0 <slice_expired_locked+0x24>)
   141d2:	689d      	ldr	r5, [r3, #8]
	uint8_t state = thread->base.thread_state;
   141d4:	7b6b      	ldrb	r3, [r5, #13]
	if (!z_is_thread_prevented_from_running(curr)) {
   141d6:	f013 0f1f 	tst.w	r3, #31
   141da:	d004      	beq.n	141e6 <slice_expired_locked+0x1a>
	z_reset_time_slice(curr);
   141dc:	4628      	mov	r0, r5
   141de:	f7ff ff05 	bl	13fec <z_reset_time_slice>
}
   141e2:	4620      	mov	r0, r4
   141e4:	bd38      	pop	{r3, r4, r5, pc}
		move_thread_to_end_of_prio_q(curr);
   141e6:	4628      	mov	r0, r5
   141e8:	f7ff ffac 	bl	14144 <move_thread_to_end_of_prio_q>
   141ec:	e7f6      	b.n	141dc <slice_expired_locked+0x10>
   141ee:	bf00      	nop
   141f0:	200026d8 	.word	0x200026d8

000141f4 <z_time_slice>:
{
   141f4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   141f6:	f04f 0320 	mov.w	r3, #32
   141fa:	f3ef 8411 	mrs	r4, BASEPRI
   141fe:	f383 8812 	msr	BASEPRI_MAX, r3
   14202:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   14206:	4b22      	ldr	r3, [pc, #136]	; (14290 <z_time_slice+0x9c>)
   14208:	689b      	ldr	r3, [r3, #8]
   1420a:	4a22      	ldr	r2, [pc, #136]	; (14294 <z_time_slice+0xa0>)
   1420c:	6812      	ldr	r2, [r2, #0]
   1420e:	4293      	cmp	r3, r2
   14210:	d018      	beq.n	14244 <z_time_slice+0x50>
   14212:	4621      	mov	r1, r4
	pending_current = NULL;
   14214:	4a1f      	ldr	r2, [pc, #124]	; (14294 <z_time_slice+0xa0>)
   14216:	2500      	movs	r5, #0
   14218:	6015      	str	r5, [r2, #0]
	int ret = slice_ticks;
   1421a:	4a1f      	ldr	r2, [pc, #124]	; (14298 <z_time_slice+0xa4>)
   1421c:	6812      	ldr	r2, [r2, #0]
	if (slice_time(_current) && sliceable(_current)) {
   1421e:	b372      	cbz	r2, 1427e <z_time_slice+0x8a>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
   14220:	89da      	ldrh	r2, [r3, #14]
		&& !z_is_idle_thread_object(thread);
   14222:	2a7f      	cmp	r2, #127	; 0x7f
   14224:	d816      	bhi.n	14254 <z_time_slice+0x60>
   14226:	7b5a      	ldrb	r2, [r3, #13]
		&& !z_is_thread_prevented_from_running(thread)
   14228:	f012 0f1f 	tst.w	r2, #31
   1422c:	d11c      	bne.n	14268 <z_time_slice+0x74>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   1422e:	f993 500e 	ldrsb.w	r5, [r3, #14]
   14232:	4a1a      	ldr	r2, [pc, #104]	; (1429c <z_time_slice+0xa8>)
   14234:	6812      	ldr	r2, [r2, #0]
   14236:	4295      	cmp	r5, r2
   14238:	db18      	blt.n	1426c <z_time_slice+0x78>
		&& !z_is_idle_thread_object(thread);
   1423a:	4a19      	ldr	r2, [pc, #100]	; (142a0 <z_time_slice+0xac>)
   1423c:	4293      	cmp	r3, r2
   1423e:	d017      	beq.n	14270 <z_time_slice+0x7c>
   14240:	2301      	movs	r3, #1
   14242:	e008      	b.n	14256 <z_time_slice+0x62>
		z_reset_time_slice(_current);
   14244:	4618      	mov	r0, r3
   14246:	f7ff fed1 	bl	13fec <z_reset_time_slice>
	__asm__ volatile(
   1424a:	f384 8811 	msr	BASEPRI, r4
   1424e:	f3bf 8f6f 	isb	sy
		return;
   14252:	e01b      	b.n	1428c <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
   14254:	2300      	movs	r3, #0
	if (slice_time(_current) && sliceable(_current)) {
   14256:	b193      	cbz	r3, 1427e <z_time_slice+0x8a>
		if (ticks >= _current_cpu->slice_ticks) {
   14258:	4b0d      	ldr	r3, [pc, #52]	; (14290 <z_time_slice+0x9c>)
   1425a:	691b      	ldr	r3, [r3, #16]
   1425c:	4283      	cmp	r3, r0
   1425e:	dd09      	ble.n	14274 <z_time_slice+0x80>
			_current_cpu->slice_ticks -= ticks;
   14260:	1a18      	subs	r0, r3, r0
   14262:	4b0b      	ldr	r3, [pc, #44]	; (14290 <z_time_slice+0x9c>)
   14264:	6118      	str	r0, [r3, #16]
   14266:	e00d      	b.n	14284 <z_time_slice+0x90>
		&& !z_is_idle_thread_object(thread);
   14268:	2300      	movs	r3, #0
   1426a:	e7f4      	b.n	14256 <z_time_slice+0x62>
   1426c:	2300      	movs	r3, #0
   1426e:	e7f2      	b.n	14256 <z_time_slice+0x62>
   14270:	2300      	movs	r3, #0
   14272:	e7f0      	b.n	14256 <z_time_slice+0x62>
			key = slice_expired_locked(key);
   14274:	4620      	mov	r0, r4
   14276:	f7ff ffa9 	bl	141cc <slice_expired_locked>
   1427a:	4601      	mov	r1, r0
   1427c:	e002      	b.n	14284 <z_time_slice+0x90>
		_current_cpu->slice_ticks = 0;
   1427e:	4b04      	ldr	r3, [pc, #16]	; (14290 <z_time_slice+0x9c>)
   14280:	2200      	movs	r2, #0
   14282:	611a      	str	r2, [r3, #16]
   14284:	f381 8811 	msr	BASEPRI, r1
   14288:	f3bf 8f6f 	isb	sy
}
   1428c:	bd38      	pop	{r3, r4, r5, pc}
   1428e:	bf00      	nop
   14290:	200026d8 	.word	0x200026d8
   14294:	2000270c 	.word	0x2000270c
   14298:	20002714 	.word	0x20002714
   1429c:	20002710 	.word	0x20002710
   142a0:	20001988 	.word	0x20001988

000142a4 <ready_thread>:
{
   142a4:	b538      	push	{r3, r4, r5, lr}
	return (thread->base.thread_state & state) != 0U;
   142a6:	7b43      	ldrb	r3, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   142a8:	f990 200d 	ldrsb.w	r2, [r0, #13]
   142ac:	2a00      	cmp	r2, #0
   142ae:	db2d      	blt.n	1430c <ready_thread+0x68>
   142b0:	4604      	mov	r4, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   142b2:	f013 0f1f 	tst.w	r3, #31
   142b6:	d105      	bne.n	142c4 <ready_thread+0x20>
	return node->next != NULL;
   142b8:	6982      	ldr	r2, [r0, #24]
   142ba:	b10a      	cbz	r2, 142c0 <ready_thread+0x1c>
   142bc:	2200      	movs	r2, #0
   142be:	e002      	b.n	142c6 <ready_thread+0x22>
   142c0:	2201      	movs	r2, #1
   142c2:	e000      	b.n	142c6 <ready_thread+0x22>
   142c4:	2200      	movs	r2, #0
   142c6:	b30a      	cbz	r2, 1430c <ready_thread+0x68>
	thread->base.thread_state |= _THREAD_QUEUED;
   142c8:	f063 037f 	orn	r3, r3, #127	; 0x7f
   142cc:	7363      	strb	r3, [r4, #13]
	return list->head == list;
   142ce:	4b14      	ldr	r3, [pc, #80]	; (14320 <ready_thread+0x7c>)
   142d0:	f853 5f20 	ldr.w	r5, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   142d4:	429d      	cmp	r5, r3
   142d6:	d020      	beq.n	1431a <ready_thread+0x76>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   142d8:	b16d      	cbz	r5, 142f6 <ready_thread+0x52>
		if (z_sched_prio_cmp(thread, t) > 0) {
   142da:	4629      	mov	r1, r5
   142dc:	4620      	mov	r0, r4
   142de:	f008 f8e8 	bl	1c4b2 <z_sched_prio_cmp>
   142e2:	2800      	cmp	r0, #0
   142e4:	dc13      	bgt.n	1430e <ready_thread+0x6a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   142e6:	b135      	cbz	r5, 142f6 <ready_thread+0x52>
	return (node == list->tail) ? NULL : node->next;
   142e8:	4b0d      	ldr	r3, [pc, #52]	; (14320 <ready_thread+0x7c>)
   142ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   142ec:	429d      	cmp	r5, r3
   142ee:	d002      	beq.n	142f6 <ready_thread+0x52>
   142f0:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   142f2:	2d00      	cmp	r5, #0
   142f4:	d1f0      	bne.n	142d8 <ready_thread+0x34>
	sys_dnode_t *const tail = list->tail;
   142f6:	4b0a      	ldr	r3, [pc, #40]	; (14320 <ready_thread+0x7c>)
   142f8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
   142fa:	f103 0120 	add.w	r1, r3, #32
   142fe:	6021      	str	r1, [r4, #0]
	node->prev = tail;
   14300:	6062      	str	r2, [r4, #4]
	tail->next = node;
   14302:	6014      	str	r4, [r2, #0]
	list->tail = node;
   14304:	625c      	str	r4, [r3, #36]	; 0x24
		update_cache(0);
   14306:	2000      	movs	r0, #0
   14308:	f7ff fef4 	bl	140f4 <update_cache>
}
   1430c:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const prev = successor->prev;
   1430e:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
   14310:	6063      	str	r3, [r4, #4]
	node->next = successor;
   14312:	6025      	str	r5, [r4, #0]
	prev->next = node;
   14314:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   14316:	606c      	str	r4, [r5, #4]
}
   14318:	e7f5      	b.n	14306 <ready_thread+0x62>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1431a:	2500      	movs	r5, #0
   1431c:	e7dc      	b.n	142d8 <ready_thread+0x34>
   1431e:	bf00      	nop
   14320:	200026d8 	.word	0x200026d8

00014324 <z_sched_start>:
{
   14324:	b510      	push	{r4, lr}
	__asm__ volatile(
   14326:	f04f 0320 	mov.w	r3, #32
   1432a:	f3ef 8411 	mrs	r4, BASEPRI
   1432e:	f383 8812 	msr	BASEPRI_MAX, r3
   14332:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   14336:	7b43      	ldrb	r3, [r0, #13]
	if (z_has_thread_started(thread)) {
   14338:	f013 0f04 	tst.w	r3, #4
   1433c:	d104      	bne.n	14348 <z_sched_start+0x24>
	__asm__ volatile(
   1433e:	f384 8811 	msr	BASEPRI, r4
   14342:	f3bf 8f6f 	isb	sy
}
   14346:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   14348:	f023 0304 	bic.w	r3, r3, #4
   1434c:	7343      	strb	r3, [r0, #13]
	ready_thread(thread);
   1434e:	f7ff ffa9 	bl	142a4 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   14352:	4621      	mov	r1, r4
   14354:	4801      	ldr	r0, [pc, #4]	; (1435c <z_sched_start+0x38>)
   14356:	f7ff fe97 	bl	14088 <z_reschedule>
   1435a:	e7f4      	b.n	14346 <z_sched_start+0x22>
   1435c:	20002710 	.word	0x20002710

00014360 <unready_thread>:
{
   14360:	b510      	push	{r4, lr}
   14362:	4604      	mov	r4, r0
	return (thread->base.thread_state & state) != 0U;
   14364:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
   14366:	f990 300d 	ldrsb.w	r3, [r0, #13]
   1436a:	2b00      	cmp	r3, #0
   1436c:	db08      	blt.n	14380 <unready_thread+0x20>
	update_cache(thread == _current);
   1436e:	4b08      	ldr	r3, [pc, #32]	; (14390 <unready_thread+0x30>)
   14370:	6898      	ldr	r0, [r3, #8]
   14372:	42a0      	cmp	r0, r4
   14374:	bf14      	ite	ne
   14376:	2000      	movne	r0, #0
   14378:	2001      	moveq	r0, #1
   1437a:	f7ff febb 	bl	140f4 <update_cache>
}
   1437e:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
   14380:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   14384:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
   14386:	4601      	mov	r1, r0
   14388:	4802      	ldr	r0, [pc, #8]	; (14394 <unready_thread+0x34>)
   1438a:	f008 f8d1 	bl	1c530 <z_priq_dumb_remove>
}
   1438e:	e7ee      	b.n	1436e <unready_thread+0xe>
   14390:	200026d8 	.word	0x200026d8
   14394:	200026f8 	.word	0x200026f8

00014398 <z_pend_curr>:
{
   14398:	b510      	push	{r4, lr}
   1439a:	460c      	mov	r4, r1
   1439c:	4611      	mov	r1, r2
	pending_current = _current;
   1439e:	4b06      	ldr	r3, [pc, #24]	; (143b8 <z_pend_curr+0x20>)
   143a0:	6898      	ldr	r0, [r3, #8]
   143a2:	4b06      	ldr	r3, [pc, #24]	; (143bc <z_pend_curr+0x24>)
   143a4:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   143a6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   143aa:	f008 f972 	bl	1c692 <pend>
   143ae:	4620      	mov	r0, r4
   143b0:	f7ef fe8e 	bl	40d0 <arch_swap>
}
   143b4:	bd10      	pop	{r4, pc}
   143b6:	bf00      	nop
   143b8:	200026d8 	.word	0x200026d8
   143bc:	2000270c 	.word	0x2000270c

000143c0 <z_set_prio>:
{
   143c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   143c4:	4604      	mov	r4, r0
   143c6:	460e      	mov	r6, r1
	LOCKED(&sched_spinlock) {
   143c8:	2300      	movs	r3, #0
	__asm__ volatile(
   143ca:	f04f 0220 	mov.w	r2, #32
   143ce:	f3ef 8811 	mrs	r8, BASEPRI
   143d2:	f382 8812 	msr	BASEPRI_MAX, r2
   143d6:	f3bf 8f6f 	isb	sy
	bool need_sched = 0;
   143da:	461f      	mov	r7, r3
   143dc:	e008      	b.n	143f0 <z_set_prio+0x30>
		if (need_sched) {
   143de:	f012 0701 	ands.w	r7, r2, #1
   143e2:	d111      	bne.n	14408 <z_set_prio+0x48>
			thread->base.prio = prio;
   143e4:	73a6      	strb	r6, [r4, #14]
	__asm__ volatile(
   143e6:	f388 8811 	msr	BASEPRI, r8
   143ea:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   143ee:	2301      	movs	r3, #1
   143f0:	461a      	mov	r2, r3
   143f2:	2b00      	cmp	r3, #0
   143f4:	d13d      	bne.n	14472 <z_set_prio+0xb2>
	uint8_t state = thread->base.thread_state;
   143f6:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   143f8:	f013 0f1f 	tst.w	r3, #31
   143fc:	d1ef      	bne.n	143de <z_set_prio+0x1e>
	return node->next != NULL;
   143fe:	69a1      	ldr	r1, [r4, #24]
   14400:	2900      	cmp	r1, #0
   14402:	d1ec      	bne.n	143de <z_set_prio+0x1e>
   14404:	2201      	movs	r2, #1
   14406:	e7ea      	b.n	143de <z_set_prio+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   14408:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1440c:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
   1440e:	f8df 9068 	ldr.w	r9, [pc, #104]	; 14478 <z_set_prio+0xb8>
   14412:	4621      	mov	r1, r4
   14414:	4648      	mov	r0, r9
   14416:	f008 f88b 	bl	1c530 <z_priq_dumb_remove>
				thread->base.prio = prio;
   1441a:	73a6      	strb	r6, [r4, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   1441c:	7b63      	ldrb	r3, [r4, #13]
   1441e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   14422:	7363      	strb	r3, [r4, #13]
	return list->head == list;
   14424:	f8d9 5000 	ldr.w	r5, [r9]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14428:	454d      	cmp	r5, r9
   1442a:	d020      	beq.n	1446e <z_set_prio+0xae>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1442c:	b16d      	cbz	r5, 1444a <z_set_prio+0x8a>
		if (z_sched_prio_cmp(thread, t) > 0) {
   1442e:	4629      	mov	r1, r5
   14430:	4620      	mov	r0, r4
   14432:	f008 f83e 	bl	1c4b2 <z_sched_prio_cmp>
   14436:	2800      	cmp	r0, #0
   14438:	dc13      	bgt.n	14462 <z_set_prio+0xa2>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1443a:	b135      	cbz	r5, 1444a <z_set_prio+0x8a>
	return (node == list->tail) ? NULL : node->next;
   1443c:	4b0f      	ldr	r3, [pc, #60]	; (1447c <z_set_prio+0xbc>)
   1443e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   14440:	429d      	cmp	r5, r3
   14442:	d002      	beq.n	1444a <z_set_prio+0x8a>
   14444:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   14446:	2d00      	cmp	r5, #0
   14448:	d1f0      	bne.n	1442c <z_set_prio+0x6c>
	sys_dnode_t *const tail = list->tail;
   1444a:	4b0c      	ldr	r3, [pc, #48]	; (1447c <z_set_prio+0xbc>)
   1444c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
   1444e:	f103 0120 	add.w	r1, r3, #32
   14452:	6021      	str	r1, [r4, #0]
	node->prev = tail;
   14454:	6062      	str	r2, [r4, #4]
	tail->next = node;
   14456:	6014      	str	r4, [r2, #0]
	list->tail = node;
   14458:	625c      	str	r4, [r3, #36]	; 0x24
			update_cache(1);
   1445a:	2001      	movs	r0, #1
   1445c:	f7ff fe4a 	bl	140f4 <update_cache>
   14460:	e7c1      	b.n	143e6 <z_set_prio+0x26>
	sys_dnode_t *const prev = successor->prev;
   14462:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
   14464:	6063      	str	r3, [r4, #4]
	node->next = successor;
   14466:	6025      	str	r5, [r4, #0]
	prev->next = node;
   14468:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   1446a:	606c      	str	r4, [r5, #4]
}
   1446c:	e7f5      	b.n	1445a <z_set_prio+0x9a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1446e:	2500      	movs	r5, #0
   14470:	e7dc      	b.n	1442c <z_set_prio+0x6c>
}
   14472:	4638      	mov	r0, r7
   14474:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   14478:	200026f8 	.word	0x200026f8
   1447c:	200026d8 	.word	0x200026d8

00014480 <z_impl_k_thread_suspend>:
{
   14480:	b538      	push	{r3, r4, r5, lr}
   14482:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   14484:	3018      	adds	r0, #24
   14486:	f008 f9da 	bl	1c83e <z_abort_timeout>
	LOCKED(&sched_spinlock) {
   1448a:	2300      	movs	r3, #0
	__asm__ volatile(
   1448c:	f04f 0220 	mov.w	r2, #32
   14490:	f3ef 8511 	mrs	r5, BASEPRI
   14494:	f382 8812 	msr	BASEPRI_MAX, r2
   14498:	f3bf 8f6f 	isb	sy
   1449c:	e010      	b.n	144c0 <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1449e:	7b63      	ldrb	r3, [r4, #13]
   144a0:	f043 0310 	orr.w	r3, r3, #16
   144a4:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   144a6:	4b15      	ldr	r3, [pc, #84]	; (144fc <z_impl_k_thread_suspend+0x7c>)
   144a8:	6898      	ldr	r0, [r3, #8]
   144aa:	42a0      	cmp	r0, r4
   144ac:	bf14      	ite	ne
   144ae:	2000      	movne	r0, #0
   144b0:	2001      	moveq	r0, #1
   144b2:	f7ff fe1f 	bl	140f4 <update_cache>
	__asm__ volatile(
   144b6:	f385 8811 	msr	BASEPRI, r5
   144ba:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   144be:	2301      	movs	r3, #1
   144c0:	b963      	cbnz	r3, 144dc <z_impl_k_thread_suspend+0x5c>
	return (thread->base.thread_state & state) != 0U;
   144c2:	7b62      	ldrb	r2, [r4, #13]
		if (z_is_thread_queued(thread)) {
   144c4:	f994 300d 	ldrsb.w	r3, [r4, #13]
   144c8:	2b00      	cmp	r3, #0
   144ca:	dae8      	bge.n	1449e <z_impl_k_thread_suspend+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   144cc:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   144d0:	7362      	strb	r2, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
   144d2:	4621      	mov	r1, r4
   144d4:	480a      	ldr	r0, [pc, #40]	; (14500 <z_impl_k_thread_suspend+0x80>)
   144d6:	f008 f82b 	bl	1c530 <z_priq_dumb_remove>
}
   144da:	e7e0      	b.n	1449e <z_impl_k_thread_suspend+0x1e>
	if (thread == _current) {
   144dc:	4b07      	ldr	r3, [pc, #28]	; (144fc <z_impl_k_thread_suspend+0x7c>)
   144de:	689b      	ldr	r3, [r3, #8]
   144e0:	42a3      	cmp	r3, r4
   144e2:	d000      	beq.n	144e6 <z_impl_k_thread_suspend+0x66>
}
   144e4:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   144e6:	f04f 0320 	mov.w	r3, #32
   144ea:	f3ef 8011 	mrs	r0, BASEPRI
   144ee:	f383 8812 	msr	BASEPRI_MAX, r3
   144f2:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   144f6:	f008 f806 	bl	1c506 <z_reschedule_irqlock>
   144fa:	e7f3      	b.n	144e4 <z_impl_k_thread_suspend+0x64>
   144fc:	200026d8 	.word	0x200026d8
   14500:	200026f8 	.word	0x200026f8

00014504 <k_sched_unlock>:

void k_sched_unlock(void)
{
   14504:	b510      	push	{r4, lr}
	LOCKED(&sched_spinlock) {
   14506:	2300      	movs	r3, #0
   14508:	f04f 0220 	mov.w	r2, #32
   1450c:	f3ef 8411 	mrs	r4, BASEPRI
   14510:	f382 8812 	msr	BASEPRI_MAX, r2
   14514:	f3bf 8f6f 	isb	sy
   14518:	e00c      	b.n	14534 <k_sched_unlock+0x30>
		__ASSERT(_current->base.sched_locked != 0U, "");
		__ASSERT(!arch_is_in_isr(), "");

		++_current->base.sched_locked;
   1451a:	4b0d      	ldr	r3, [pc, #52]	; (14550 <k_sched_unlock+0x4c>)
   1451c:	689a      	ldr	r2, [r3, #8]
   1451e:	7bd3      	ldrb	r3, [r2, #15]
   14520:	3301      	adds	r3, #1
   14522:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   14524:	2000      	movs	r0, #0
   14526:	f7ff fde5 	bl	140f4 <update_cache>
	__asm__ volatile(
   1452a:	f384 8811 	msr	BASEPRI, r4
   1452e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   14532:	2301      	movs	r3, #1
   14534:	2b00      	cmp	r3, #0
   14536:	d0f0      	beq.n	1451a <k_sched_unlock+0x16>
	__asm__ volatile(
   14538:	f04f 0320 	mov.w	r3, #32
   1453c:	f3ef 8011 	mrs	r0, BASEPRI
   14540:	f383 8812 	msr	BASEPRI_MAX, r3
   14544:	f3bf 8f6f 	isb	sy
   14548:	f007 ffdd 	bl	1c506 <z_reschedule_irqlock>
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
}
   1454c:	bd10      	pop	{r4, pc}
   1454e:	bf00      	nop
   14550:	200026d8 	.word	0x200026d8

00014554 <end_thread>:
#ifdef CONFIG_CMSIS_RTOS_V1
extern void z_thread_cmsis_status_mask_clear(struct k_thread *thread);
#endif

static void end_thread(struct k_thread *thread)
{
   14554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
   14556:	7b43      	ldrb	r3, [r0, #13]
   14558:	f013 0f08 	tst.w	r3, #8
   1455c:	d145      	bne.n	145ea <end_thread+0x96>
   1455e:	4605      	mov	r5, r0
		thread->base.thread_state |= _THREAD_DEAD;
   14560:	f043 0308 	orr.w	r3, r3, #8
   14564:	7343      	strb	r3, [r0, #13]
		thread->base.thread_state &= ~_THREAD_ABORTING;
   14566:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   1456a:	7343      	strb	r3, [r0, #13]
		if (z_is_thread_queued(thread)) {
   1456c:	f013 0f80 	tst.w	r3, #128	; 0x80
   14570:	d12d      	bne.n	145ce <end_thread+0x7a>
			dequeue_thread(thread);
		}
		if (thread->base.pended_on != NULL) {
   14572:	68ab      	ldr	r3, [r5, #8]
   14574:	b15b      	cbz	r3, 1458e <end_thread+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   14576:	4628      	mov	r0, r5
   14578:	f007 ff99 	bl	1c4ae <pended_on_thread>
   1457c:	4629      	mov	r1, r5
   1457e:	f007 ffd7 	bl	1c530 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   14582:	7b6b      	ldrb	r3, [r5, #13]
   14584:	f023 0302 	bic.w	r3, r3, #2
   14588:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
   1458a:	2300      	movs	r3, #0
   1458c:	60ab      	str	r3, [r5, #8]
   1458e:	f105 0018 	add.w	r0, r5, #24
   14592:	f008 f954 	bl	1c83e <z_abort_timeout>
			unpend_thread_no_timeout(thread);
		}
		(void)z_abort_thread_timeout(thread);
		unpend_all(&thread->join_queue);
   14596:	f105 0758 	add.w	r7, r5, #88	; 0x58
	return list->head == list;
   1459a:	683c      	ldr	r4, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1459c:	42bc      	cmp	r4, r7
   1459e:	d01e      	beq.n	145de <end_thread+0x8a>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   145a0:	b1ec      	cbz	r4, 145de <end_thread+0x8a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   145a2:	4620      	mov	r0, r4
   145a4:	f007 ff83 	bl	1c4ae <pended_on_thread>
   145a8:	4621      	mov	r1, r4
   145aa:	f007 ffc1 	bl	1c530 <z_priq_dumb_remove>
   145ae:	7b63      	ldrb	r3, [r4, #13]
   145b0:	f023 0302 	bic.w	r3, r3, #2
   145b4:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   145b6:	2600      	movs	r6, #0
   145b8:	60a6      	str	r6, [r4, #8]
   145ba:	f104 0018 	add.w	r0, r4, #24
   145be:	f008 f93e 	bl	1c83e <z_abort_timeout>
   145c2:	f8c4 60b0 	str.w	r6, [r4, #176]	; 0xb0
		ready_thread(thread);
   145c6:	4620      	mov	r0, r4
   145c8:	f7ff fe6c 	bl	142a4 <ready_thread>
   145cc:	e7e5      	b.n	1459a <end_thread+0x46>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   145ce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   145d2:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
   145d4:	4601      	mov	r1, r0
   145d6:	4805      	ldr	r0, [pc, #20]	; (145ec <end_thread+0x98>)
   145d8:	f007 ffaa 	bl	1c530 <z_priq_dumb_remove>
}
   145dc:	e7c9      	b.n	14572 <end_thread+0x1e>
		update_cache(1);
   145de:	2001      	movs	r0, #1
   145e0:	f7ff fd88 	bl	140f4 <update_cache>

		SYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);

		z_thread_monitor_exit(thread);
   145e4:	4628      	mov	r0, r5
   145e6:	f7ff f8c5 	bl	13774 <z_thread_monitor_exit>
		z_thread_perms_all_clear(thread);
		z_object_uninit(thread->stack_obj);
		z_object_uninit(thread);
#endif
	}
}
   145ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   145ec:	200026f8 	.word	0x200026f8

000145f0 <z_sched_init>:
{
   145f0:	b508      	push	{r3, lr}
	init_ready_q(&_kernel.ready_q);
   145f2:	4804      	ldr	r0, [pc, #16]	; (14604 <z_sched_init+0x14>)
   145f4:	f008 f8d1 	bl	1c79a <init_ready_q>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   145f8:	2100      	movs	r1, #0
   145fa:	4608      	mov	r0, r1
   145fc:	f7ff fd0a 	bl	14014 <k_sched_time_slice_set>
}
   14600:	bd08      	pop	{r3, pc}
   14602:	bf00      	nop
   14604:	200026f4 	.word	0x200026f4

00014608 <z_impl_k_yield>:
{
   14608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1460a:	f04f 0320 	mov.w	r3, #32
   1460e:	f3ef 8611 	mrs	r6, BASEPRI
   14612:	f383 8812 	msr	BASEPRI_MAX, r3
   14616:	f3bf 8f6f 	isb	sy
		dequeue_thread(_current);
   1461a:	4c1c      	ldr	r4, [pc, #112]	; (1468c <z_impl_k_yield+0x84>)
   1461c:	68a1      	ldr	r1, [r4, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   1461e:	7b4b      	ldrb	r3, [r1, #13]
   14620:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   14624:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
   14626:	f104 0720 	add.w	r7, r4, #32
   1462a:	4638      	mov	r0, r7
   1462c:	f007 ff80 	bl	1c530 <z_priq_dumb_remove>
	queue_thread(_current);
   14630:	68a5      	ldr	r5, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   14632:	7b6b      	ldrb	r3, [r5, #13]
   14634:	f063 037f 	orn	r3, r3, #127	; 0x7f
   14638:	736b      	strb	r3, [r5, #13]
	return list->head == list;
   1463a:	6a24      	ldr	r4, [r4, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1463c:	42bc      	cmp	r4, r7
   1463e:	d023      	beq.n	14688 <z_impl_k_yield+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   14640:	b16c      	cbz	r4, 1465e <z_impl_k_yield+0x56>
		if (z_sched_prio_cmp(thread, t) > 0) {
   14642:	4621      	mov	r1, r4
   14644:	4628      	mov	r0, r5
   14646:	f007 ff34 	bl	1c4b2 <z_sched_prio_cmp>
   1464a:	2800      	cmp	r0, #0
   1464c:	dc16      	bgt.n	1467c <z_impl_k_yield+0x74>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1464e:	b134      	cbz	r4, 1465e <z_impl_k_yield+0x56>
	return (node == list->tail) ? NULL : node->next;
   14650:	4b0e      	ldr	r3, [pc, #56]	; (1468c <z_impl_k_yield+0x84>)
   14652:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   14654:	429c      	cmp	r4, r3
   14656:	d002      	beq.n	1465e <z_impl_k_yield+0x56>
   14658:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1465a:	2c00      	cmp	r4, #0
   1465c:	d1f0      	bne.n	14640 <z_impl_k_yield+0x38>
	sys_dnode_t *const tail = list->tail;
   1465e:	4b0b      	ldr	r3, [pc, #44]	; (1468c <z_impl_k_yield+0x84>)
   14660:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
   14662:	f103 0120 	add.w	r1, r3, #32
   14666:	6029      	str	r1, [r5, #0]
	node->prev = tail;
   14668:	606a      	str	r2, [r5, #4]
	tail->next = node;
   1466a:	6015      	str	r5, [r2, #0]
	list->tail = node;
   1466c:	625d      	str	r5, [r3, #36]	; 0x24
	update_cache(1);
   1466e:	2001      	movs	r0, #1
   14670:	f7ff fd40 	bl	140f4 <update_cache>
   14674:	4630      	mov	r0, r6
   14676:	f7ef fd2b 	bl	40d0 <arch_swap>
}
   1467a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	sys_dnode_t *const prev = successor->prev;
   1467c:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
   1467e:	606b      	str	r3, [r5, #4]
	node->next = successor;
   14680:	602c      	str	r4, [r5, #0]
	prev->next = node;
   14682:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   14684:	6065      	str	r5, [r4, #4]
}
   14686:	e7f2      	b.n	1466e <z_impl_k_yield+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   14688:	2400      	movs	r4, #0
   1468a:	e7d9      	b.n	14640 <z_impl_k_yield+0x38>
   1468c:	200026d8 	.word	0x200026d8

00014690 <z_tick_sleep>:
{
   14690:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (ticks == 0) {
   14694:	ea50 0301 	orrs.w	r3, r0, r1
   14698:	d038      	beq.n	1470c <z_tick_sleep+0x7c>
   1469a:	4604      	mov	r4, r0
   1469c:	460e      	mov	r6, r1
	if (Z_TICK_ABS(ticks) <= 0) {
   1469e:	f06f 0301 	mvn.w	r3, #1
   146a2:	1a1b      	subs	r3, r3, r0
   146a4:	f04f 32ff 	mov.w	r2, #4294967295
   146a8:	eb62 0201 	sbc.w	r2, r2, r1
   146ac:	2b01      	cmp	r3, #1
   146ae:	f172 0300 	sbcs.w	r3, r2, #0
   146b2:	db2f      	blt.n	14714 <z_tick_sleep+0x84>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   146b4:	f06f 0501 	mvn.w	r5, #1
   146b8:	1a2d      	subs	r5, r5, r0
   146ba:	f04f 0320 	mov.w	r3, #32
   146be:	f3ef 8811 	mrs	r8, BASEPRI
   146c2:	f383 8812 	msr	BASEPRI_MAX, r3
   146c6:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   146ca:	4f14      	ldr	r7, [pc, #80]	; (1471c <z_tick_sleep+0x8c>)
   146cc:	68b8      	ldr	r0, [r7, #8]
   146ce:	4b14      	ldr	r3, [pc, #80]	; (14720 <z_tick_sleep+0x90>)
   146d0:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   146d2:	f7ff fe45 	bl	14360 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   146d6:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   146d8:	4622      	mov	r2, r4
   146da:	4633      	mov	r3, r6
   146dc:	4911      	ldr	r1, [pc, #68]	; (14724 <z_tick_sleep+0x94>)
   146de:	3018      	adds	r0, #24
   146e0:	f000 f902 	bl	148e8 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   146e4:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   146e6:	7b53      	ldrb	r3, [r2, #13]
   146e8:	f043 0310 	orr.w	r3, r3, #16
   146ec:	7353      	strb	r3, [r2, #13]
   146ee:	4640      	mov	r0, r8
   146f0:	f7ef fcee 	bl	40d0 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   146f4:	f008 f903 	bl	1c8fe <sys_clock_tick_get_32>
   146f8:	1a28      	subs	r0, r5, r0
   146fa:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   146fe:	2801      	cmp	r0, #1
   14700:	f173 0300 	sbcs.w	r3, r3, #0
   14704:	da00      	bge.n	14708 <z_tick_sleep+0x78>
	return 0;
   14706:	2000      	movs	r0, #0
}
   14708:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	z_impl_k_yield();
   1470c:	f7ff ff7c 	bl	14608 <z_impl_k_yield>
		return 0;
   14710:	2000      	movs	r0, #0
   14712:	e7f9      	b.n	14708 <z_tick_sleep+0x78>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   14714:	f008 f8f3 	bl	1c8fe <sys_clock_tick_get_32>
   14718:	1905      	adds	r5, r0, r4
   1471a:	e7ce      	b.n	146ba <z_tick_sleep+0x2a>
   1471c:	200026d8 	.word	0x200026d8
   14720:	2000270c 	.word	0x2000270c
   14724:	0001c5cf 	.word	0x0001c5cf

00014728 <z_impl_k_sleep>:
{
   14728:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1472a:	f1b1 3fff 	cmp.w	r1, #4294967295
   1472e:	bf08      	it	eq
   14730:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   14734:	d01a      	beq.n	1476c <z_impl_k_sleep+0x44>
	ticks = z_tick_sleep(ticks);
   14736:	f7ff ffab 	bl	14690 <z_tick_sleep>
   1473a:	4684      	mov	ip, r0
	int32_t ret = k_ticks_to_ms_floor64(ticks);
   1473c:	17c2      	asrs	r2, r0, #31
			return ((t * to_hz + off) / from_hz);
   1473e:	0151      	lsls	r1, r2, #5
   14740:	ea41 61d0 	orr.w	r1, r1, r0, lsr #27
   14744:	0143      	lsls	r3, r0, #5
   14746:	1a1b      	subs	r3, r3, r0
   14748:	eb61 0102 	sbc.w	r1, r1, r2
   1474c:	0088      	lsls	r0, r1, #2
   1474e:	ea40 7093 	orr.w	r0, r0, r3, lsr #30
   14752:	009b      	lsls	r3, r3, #2
   14754:	eb13 030c 	adds.w	r3, r3, ip
   14758:	eb42 0000 	adc.w	r0, r2, r0
   1475c:	00c0      	lsls	r0, r0, #3
   1475e:	ea40 7053 	orr.w	r0, r0, r3, lsr #29
   14762:	f3c3 3310 	ubfx	r3, r3, #12, #17
   14766:	ea43 4040 	orr.w	r0, r3, r0, lsl #17
}
   1476a:	bd08      	pop	{r3, pc}
		k_thread_suspend(_current);
   1476c:	4b03      	ldr	r3, [pc, #12]	; (1477c <z_impl_k_sleep+0x54>)
   1476e:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   14770:	f7ff fe86 	bl	14480 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
   14774:	f04f 30ff 	mov.w	r0, #4294967295
   14778:	e7f7      	b.n	1476a <z_impl_k_sleep+0x42>
   1477a:	bf00      	nop
   1477c:	200026d8 	.word	0x200026d8

00014780 <z_impl_z_current_get>:
}
   14780:	4b01      	ldr	r3, [pc, #4]	; (14788 <z_impl_z_current_get+0x8>)
   14782:	6898      	ldr	r0, [r3, #8]
   14784:	4770      	bx	lr
   14786:	bf00      	nop
   14788:	200026d8 	.word	0x200026d8

0001478c <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
   1478c:	b538      	push	{r3, r4, r5, lr}
   1478e:	f04f 0320 	mov.w	r3, #32
   14792:	f3ef 8511 	mrs	r5, BASEPRI
   14796:	f383 8812 	msr	BASEPRI_MAX, r3
   1479a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
   1479e:	7b03      	ldrb	r3, [r0, #12]
   147a0:	f013 0f01 	tst.w	r3, #1
   147a4:	d109      	bne.n	147ba <z_thread_abort+0x2e>
   147a6:	4604      	mov	r4, r0
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
		return;
	}

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   147a8:	7b43      	ldrb	r3, [r0, #13]
   147aa:	f013 0f08 	tst.w	r3, #8
   147ae:	d00f      	beq.n	147d0 <z_thread_abort+0x44>
	__asm__ volatile(
   147b0:	f385 8811 	msr	BASEPRI, r5
   147b4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		return;
   147b8:	e009      	b.n	147ce <z_thread_abort+0x42>
   147ba:	f385 8811 	msr	BASEPRI, r5
   147be:	f3bf 8f6f 	isb	sy
		k_panic();
   147c2:	4040      	eors	r0, r0
   147c4:	f380 8811 	msr	BASEPRI, r0
   147c8:	f04f 0004 	mov.w	r0, #4
   147cc:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   147ce:	bd38      	pop	{r3, r4, r5, pc}
	end_thread(thread);
   147d0:	f7ff fec0 	bl	14554 <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
   147d4:	4b08      	ldr	r3, [pc, #32]	; (147f8 <z_thread_abort+0x6c>)
   147d6:	689b      	ldr	r3, [r3, #8]
   147d8:	42a3      	cmp	r3, r4
   147da:	d004      	beq.n	147e6 <z_thread_abort+0x5a>
   147dc:	f385 8811 	msr	BASEPRI, r5
   147e0:	f3bf 8f6f 	isb	sy
   147e4:	e7f3      	b.n	147ce <z_thread_abort+0x42>
   147e6:	f3ef 8305 	mrs	r3, IPSR
   147ea:	2b00      	cmp	r3, #0
   147ec:	d1f6      	bne.n	147dc <z_thread_abort+0x50>
   147ee:	4628      	mov	r0, r5
   147f0:	f7ef fc6e 	bl	40d0 <arch_swap>
	return ret;
   147f4:	e7f2      	b.n	147dc <z_thread_abort+0x50>
   147f6:	bf00      	nop
   147f8:	200026d8 	.word	0x200026d8

000147fc <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   147fc:	e92d 4810 	stmdb	sp!, {r4, fp, lr}
   14800:	b083      	sub	sp, #12
   14802:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   14804:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   14808:	e9cd bc00 	strd	fp, ip, [sp]
   1480c:	f7ff fdc4 	bl	14398 <z_pend_curr>

	if (data != NULL) {
   14810:	b11c      	cbz	r4, 1481a <z_sched_wait+0x1e>
		*data = _current->base.swap_data;
   14812:	4b03      	ldr	r3, [pc, #12]	; (14820 <z_sched_wait+0x24>)
   14814:	689b      	ldr	r3, [r3, #8]
   14816:	695b      	ldr	r3, [r3, #20]
   14818:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   1481a:	b003      	add	sp, #12
   1481c:	e8bd 8810 	ldmia.w	sp!, {r4, fp, pc}
   14820:	200026d8 	.word	0x200026d8

00014824 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   14824:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
   14826:	4806      	ldr	r0, [pc, #24]	; (14840 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
   14828:	4a06      	ldr	r2, [pc, #24]	; (14844 <z_data_copy+0x20>)
   1482a:	1a12      	subs	r2, r2, r0
   1482c:	4906      	ldr	r1, [pc, #24]	; (14848 <z_data_copy+0x24>)
   1482e:	f007 fadf 	bl	1bdf0 <z_early_memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
   14832:	4a06      	ldr	r2, [pc, #24]	; (1484c <z_data_copy+0x28>)
   14834:	4906      	ldr	r1, [pc, #24]	; (14850 <z_data_copy+0x2c>)
   14836:	4807      	ldr	r0, [pc, #28]	; (14854 <z_data_copy+0x30>)
   14838:	f007 fada 	bl	1bdf0 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   1483c:	bd08      	pop	{r3, pc}
   1483e:	bf00      	nop
   14840:	20000000 	.word	0x20000000
   14844:	200007b8 	.word	0x200007b8
   14848:	0002006c 	.word	0x0002006c
   1484c:	00000000 	.word	0x00000000
   14850:	0002006c 	.word	0x0002006c
   14854:	20000000 	.word	0x20000000

00014858 <first>:
	return list->head == list;
   14858:	4b03      	ldr	r3, [pc, #12]	; (14868 <first+0x10>)
   1485a:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1485c:	4298      	cmp	r0, r3
   1485e:	d000      	beq.n	14862 <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
   14860:	4770      	bx	lr
   14862:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
   14864:	e7fc      	b.n	14860 <first+0x8>
   14866:	bf00      	nop
   14868:	200004d4 	.word	0x200004d4

0001486c <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1486c:	b130      	cbz	r0, 1487c <next+0x10>
	return (node == list->tail) ? NULL : node->next;
   1486e:	4a04      	ldr	r2, [pc, #16]	; (14880 <next+0x14>)
   14870:	6852      	ldr	r2, [r2, #4]
   14872:	4290      	cmp	r0, r2
   14874:	d001      	beq.n	1487a <next+0xe>
   14876:	6800      	ldr	r0, [r0, #0]
   14878:	4770      	bx	lr
   1487a:	2000      	movs	r0, #0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
   1487c:	4770      	bx	lr
   1487e:	bf00      	nop
   14880:	200004d4 	.word	0x200004d4

00014884 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
   14884:	b508      	push	{r3, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   14886:	4b04      	ldr	r3, [pc, #16]	; (14898 <elapsed+0x14>)
   14888:	681b      	ldr	r3, [r3, #0]
   1488a:	b10b      	cbz	r3, 14890 <elapsed+0xc>
   1488c:	2000      	movs	r0, #0
}
   1488e:	bd08      	pop	{r3, pc}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   14890:	f7fb fede 	bl	10650 <sys_clock_elapsed>
   14894:	e7fb      	b.n	1488e <elapsed+0xa>
   14896:	bf00      	nop
   14898:	20002718 	.word	0x20002718

0001489c <next_timeout>:

static int32_t next_timeout(void)
{
   1489c:	b510      	push	{r4, lr}
	struct _timeout *to = first();
   1489e:	f7ff ffdb 	bl	14858 <first>
   148a2:	4604      	mov	r4, r0
	int32_t ticks_elapsed = elapsed();
   148a4:	f7ff ffee 	bl	14884 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
   148a8:	b17c      	cbz	r4, 148ca <next_timeout+0x2e>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   148aa:	6923      	ldr	r3, [r4, #16]
   148ac:	6962      	ldr	r2, [r4, #20]
   148ae:	1a1b      	subs	r3, r3, r0
   148b0:	eb62 70e0 	sbc.w	r0, r2, r0, asr #31
	if ((to == NULL) ||
   148b4:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   148b8:	f170 0200 	sbcs.w	r2, r0, #0
   148bc:	da08      	bge.n	148d0 <next_timeout+0x34>
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
   148be:	2800      	cmp	r0, #0
   148c0:	db01      	blt.n	148c6 <next_timeout+0x2a>
   148c2:	4618      	mov	r0, r3
   148c4:	e006      	b.n	148d4 <next_timeout+0x38>
   148c6:	2300      	movs	r3, #0
   148c8:	e7fb      	b.n	148c2 <next_timeout+0x26>
		ret = MAX_WAIT;
   148ca:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   148ce:	e001      	b.n	148d4 <next_timeout+0x38>
   148d0:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   148d4:	4b03      	ldr	r3, [pc, #12]	; (148e4 <next_timeout+0x48>)
   148d6:	691b      	ldr	r3, [r3, #16]
   148d8:	b113      	cbz	r3, 148e0 <next_timeout+0x44>
   148da:	4283      	cmp	r3, r0
   148dc:	da00      	bge.n	148e0 <next_timeout+0x44>
		ret = _current_cpu->slice_ticks;
   148de:	4618      	mov	r0, r3
	}
#endif
	return ret;
}
   148e0:	bd10      	pop	{r4, pc}
   148e2:	bf00      	nop
   148e4:	200026d8 	.word	0x200026d8

000148e8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   148e8:	f1b3 3fff 	cmp.w	r3, #4294967295
   148ec:	bf08      	it	eq
   148ee:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   148f2:	d07d      	beq.n	149f0 <z_add_timeout+0x108>
{
   148f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   148f8:	4604      	mov	r4, r0
   148fa:	4692      	mov	sl, r2
   148fc:	461d      	mov	r5, r3
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   148fe:	6081      	str	r1, [r0, #8]

	LOCKED(&timeout_lock) {
   14900:	2300      	movs	r3, #0
	__asm__ volatile(
   14902:	f04f 0220 	mov.w	r2, #32
   14906:	f3ef 8711 	mrs	r7, BASEPRI
   1490a:	f382 8812 	msr	BASEPRI_MAX, r2
   1490e:	f3bf 8f6f 	isb	sy
   14912:	e021      	b.n	14958 <z_add_timeout+0x70>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;

			to->dticks = MAX(1, ticks);
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   14914:	f11a 0801 	adds.w	r8, sl, #1
   14918:	f145 0900 	adc.w	r9, r5, #0
   1491c:	f7ff ffb2 	bl	14884 <elapsed>
   14920:	eb18 0300 	adds.w	r3, r8, r0
   14924:	eb49 70e0 	adc.w	r0, r9, r0, asr #31
   14928:	6123      	str	r3, [r4, #16]
   1492a:	6160      	str	r0, [r4, #20]
   1492c:	e036      	b.n	1499c <z_add_timeout+0xb4>
		}

		for (t = first(); t != NULL; t = next(t)) {
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
   1492e:	1a51      	subs	r1, r2, r1
   14930:	eb66 0303 	sbc.w	r3, r6, r3
   14934:	6101      	str	r1, [r0, #16]
   14936:	6143      	str	r3, [r0, #20]
	sys_dnode_t *const prev = successor->prev;
   14938:	6843      	ldr	r3, [r0, #4]
	node->prev = prev;
   1493a:	6063      	str	r3, [r4, #4]
	node->next = successor;
   1493c:	6020      	str	r0, [r4, #0]
	prev->next = node;
   1493e:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   14940:	6044      	str	r4, [r0, #4]
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
   14942:	2800      	cmp	r0, #0
   14944:	d03e      	beq.n	149c4 <z_add_timeout+0xdc>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   14946:	f7ff ff87 	bl	14858 <first>
   1494a:	4284      	cmp	r4, r0
   1494c:	d041      	beq.n	149d2 <z_add_timeout+0xea>
	__asm__ volatile(
   1494e:	f387 8811 	msr	BASEPRI, r7
   14952:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   14956:	2301      	movs	r3, #1
   14958:	2b00      	cmp	r3, #0
   1495a:	d147      	bne.n	149ec <z_add_timeout+0x104>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   1495c:	4653      	mov	r3, sl
   1495e:	f06f 0101 	mvn.w	r1, #1
   14962:	ebb1 010a 	subs.w	r1, r1, sl
   14966:	f04f 30ff 	mov.w	r0, #4294967295
   1496a:	eb60 0205 	sbc.w	r2, r0, r5
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   1496e:	2a00      	cmp	r2, #0
   14970:	dbd0      	blt.n	14914 <z_add_timeout+0x2c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   14972:	4a20      	ldr	r2, [pc, #128]	; (149f4 <z_add_timeout+0x10c>)
   14974:	6811      	ldr	r1, [r2, #0]
   14976:	6852      	ldr	r2, [r2, #4]
   14978:	185b      	adds	r3, r3, r1
   1497a:	eb42 0205 	adc.w	r2, r2, r5
   1497e:	f06f 0101 	mvn.w	r1, #1
   14982:	1acb      	subs	r3, r1, r3
   14984:	eb60 0202 	sbc.w	r2, r0, r2
			to->dticks = MAX(1, ticks);
   14988:	4618      	mov	r0, r3
   1498a:	4611      	mov	r1, r2
   1498c:	2b01      	cmp	r3, #1
   1498e:	f172 0300 	sbcs.w	r3, r2, #0
   14992:	da01      	bge.n	14998 <z_add_timeout+0xb0>
   14994:	2001      	movs	r0, #1
   14996:	2100      	movs	r1, #0
   14998:	6120      	str	r0, [r4, #16]
   1499a:	6161      	str	r1, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
   1499c:	f7ff ff5c 	bl	14858 <first>
   149a0:	2800      	cmp	r0, #0
   149a2:	d0ce      	beq.n	14942 <z_add_timeout+0x5a>
			if (t->dticks > to->dticks) {
   149a4:	6902      	ldr	r2, [r0, #16]
   149a6:	6946      	ldr	r6, [r0, #20]
   149a8:	6921      	ldr	r1, [r4, #16]
   149aa:	6963      	ldr	r3, [r4, #20]
   149ac:	4291      	cmp	r1, r2
   149ae:	eb73 0c06 	sbcs.w	ip, r3, r6
   149b2:	dbbc      	blt.n	1492e <z_add_timeout+0x46>
			to->dticks -= t->dticks;
   149b4:	1a89      	subs	r1, r1, r2
   149b6:	eb63 0306 	sbc.w	r3, r3, r6
   149ba:	6121      	str	r1, [r4, #16]
   149bc:	6163      	str	r3, [r4, #20]
		for (t = first(); t != NULL; t = next(t)) {
   149be:	f7ff ff55 	bl	1486c <next>
   149c2:	e7ed      	b.n	149a0 <z_add_timeout+0xb8>
	sys_dnode_t *const tail = list->tail;
   149c4:	4b0c      	ldr	r3, [pc, #48]	; (149f8 <z_add_timeout+0x110>)
   149c6:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   149c8:	6023      	str	r3, [r4, #0]
	node->prev = tail;
   149ca:	6062      	str	r2, [r4, #4]
	tail->next = node;
   149cc:	6014      	str	r4, [r2, #0]
	list->tail = node;
   149ce:	605c      	str	r4, [r3, #4]
}
   149d0:	e7b9      	b.n	14946 <z_add_timeout+0x5e>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   149d2:	f7ff ff63 	bl	1489c <next_timeout>

			if (next_time == 0 ||
   149d6:	4603      	mov	r3, r0
   149d8:	b118      	cbz	r0, 149e2 <z_add_timeout+0xfa>
			    _current_cpu->slice_ticks != next_time) {
   149da:	4a08      	ldr	r2, [pc, #32]	; (149fc <z_add_timeout+0x114>)
   149dc:	6912      	ldr	r2, [r2, #16]
			if (next_time == 0 ||
   149de:	4282      	cmp	r2, r0
   149e0:	d0b5      	beq.n	1494e <z_add_timeout+0x66>
				sys_clock_set_timeout(next_time, false);
   149e2:	2100      	movs	r1, #0
   149e4:	4618      	mov	r0, r3
   149e6:	f7fb fe01 	bl	105ec <sys_clock_set_timeout>
   149ea:	e7b0      	b.n	1494e <z_add_timeout+0x66>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   149ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   149f0:	4770      	bx	lr
   149f2:	bf00      	nop
   149f4:	20001bd0 	.word	0x20001bd0
   149f8:	200004d4 	.word	0x200004d4
   149fc:	200026d8 	.word	0x200026d8

00014a00 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   14a00:	b570      	push	{r4, r5, r6, lr}
   14a02:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   14a04:	f7ff fbf6 	bl	141f4 <z_time_slice>
	__asm__ volatile(
   14a08:	f04f 0320 	mov.w	r3, #32
   14a0c:	f3ef 8611 	mrs	r6, BASEPRI
   14a10:	f383 8812 	msr	BASEPRI_MAX, r3
   14a14:	f3bf 8f6f 	isb	sy
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
   14a18:	4b28      	ldr	r3, [pc, #160]	; (14abc <sys_clock_announce+0xbc>)
   14a1a:	601c      	str	r4, [r3, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
   14a1c:	e021      	b.n	14a62 <sys_clock_announce+0x62>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
   14a1e:	4a28      	ldr	r2, [pc, #160]	; (14ac0 <sys_clock_announce+0xc0>)
   14a20:	6813      	ldr	r3, [r2, #0]
   14a22:	6851      	ldr	r1, [r2, #4]
   14a24:	195b      	adds	r3, r3, r5
   14a26:	eb41 71e5 	adc.w	r1, r1, r5, asr #31
   14a2a:	6013      	str	r3, [r2, #0]
   14a2c:	6051      	str	r1, [r2, #4]
		t->dticks = 0;
   14a2e:	2200      	movs	r2, #0
   14a30:	2300      	movs	r3, #0
   14a32:	e9c4 2304 	strd	r2, r3, [r4, #16]
		remove_timeout(t);
   14a36:	4620      	mov	r0, r4
   14a38:	f007 feea 	bl	1c810 <remove_timeout>
	__asm__ volatile(
   14a3c:	f386 8811 	msr	BASEPRI, r6
   14a40:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
   14a44:	68a3      	ldr	r3, [r4, #8]
   14a46:	4620      	mov	r0, r4
   14a48:	4798      	blx	r3
	__asm__ volatile(
   14a4a:	f04f 0320 	mov.w	r3, #32
   14a4e:	f3ef 8611 	mrs	r6, BASEPRI
   14a52:	f383 8812 	msr	BASEPRI_MAX, r3
   14a56:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
   14a5a:	4a18      	ldr	r2, [pc, #96]	; (14abc <sys_clock_announce+0xbc>)
   14a5c:	6813      	ldr	r3, [r2, #0]
   14a5e:	1b5b      	subs	r3, r3, r5
   14a60:	6013      	str	r3, [r2, #0]
	while (first() != NULL && first()->dticks <= announce_remaining) {
   14a62:	f7ff fef9 	bl	14858 <first>
   14a66:	4604      	mov	r4, r0
   14a68:	b140      	cbz	r0, 14a7c <sys_clock_announce+0x7c>
   14a6a:	6905      	ldr	r5, [r0, #16]
   14a6c:	6942      	ldr	r2, [r0, #20]
   14a6e:	4b13      	ldr	r3, [pc, #76]	; (14abc <sys_clock_announce+0xbc>)
   14a70:	681b      	ldr	r3, [r3, #0]
   14a72:	17d9      	asrs	r1, r3, #31
   14a74:	42ab      	cmp	r3, r5
   14a76:	eb71 0302 	sbcs.w	r3, r1, r2
   14a7a:	dad0      	bge.n	14a1e <sys_clock_announce+0x1e>
	}

	if (first() != NULL) {
   14a7c:	b144      	cbz	r4, 14a90 <sys_clock_announce+0x90>
		first()->dticks -= announce_remaining;
   14a7e:	4b0f      	ldr	r3, [pc, #60]	; (14abc <sys_clock_announce+0xbc>)
   14a80:	6819      	ldr	r1, [r3, #0]
   14a82:	6923      	ldr	r3, [r4, #16]
   14a84:	6962      	ldr	r2, [r4, #20]
   14a86:	1a5b      	subs	r3, r3, r1
   14a88:	eb62 72e1 	sbc.w	r2, r2, r1, asr #31
   14a8c:	6123      	str	r3, [r4, #16]
   14a8e:	6162      	str	r2, [r4, #20]
	}

	curr_tick += announce_remaining;
   14a90:	4a0b      	ldr	r2, [pc, #44]	; (14ac0 <sys_clock_announce+0xc0>)
   14a92:	4d0a      	ldr	r5, [pc, #40]	; (14abc <sys_clock_announce+0xbc>)
   14a94:	6828      	ldr	r0, [r5, #0]
   14a96:	6813      	ldr	r3, [r2, #0]
   14a98:	6851      	ldr	r1, [r2, #4]
   14a9a:	181b      	adds	r3, r3, r0
   14a9c:	eb41 71e0 	adc.w	r1, r1, r0, asr #31
   14aa0:	6013      	str	r3, [r2, #0]
   14aa2:	6051      	str	r1, [r2, #4]
	announce_remaining = 0;
   14aa4:	2400      	movs	r4, #0
   14aa6:	602c      	str	r4, [r5, #0]

	sys_clock_set_timeout(next_timeout(), false);
   14aa8:	f7ff fef8 	bl	1489c <next_timeout>
   14aac:	4621      	mov	r1, r4
   14aae:	f7fb fd9d 	bl	105ec <sys_clock_set_timeout>
	__asm__ volatile(
   14ab2:	f386 8811 	msr	BASEPRI, r6
   14ab6:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   14aba:	bd70      	pop	{r4, r5, r6, pc}
   14abc:	20002718 	.word	0x20002718
   14ac0:	20001bd0 	.word	0x20001bd0

00014ac4 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   14ac4:	b510      	push	{r4, lr}
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
   14ac6:	2200      	movs	r2, #0
	__asm__ volatile(
   14ac8:	f04f 0320 	mov.w	r3, #32
   14acc:	f3ef 8411 	mrs	r4, BASEPRI
   14ad0:	f383 8812 	msr	BASEPRI_MAX, r3
   14ad4:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;
   14ad8:	4613      	mov	r3, r2
   14ada:	4611      	mov	r1, r2
   14adc:	e00c      	b.n	14af8 <sys_clock_tick_get+0x34>
		t = curr_tick + elapsed();
   14ade:	f7ff fed1 	bl	14884 <elapsed>
   14ae2:	4a07      	ldr	r2, [pc, #28]	; (14b00 <sys_clock_tick_get+0x3c>)
   14ae4:	6813      	ldr	r3, [r2, #0]
   14ae6:	6851      	ldr	r1, [r2, #4]
   14ae8:	18c3      	adds	r3, r0, r3
   14aea:	eb41 71e0 	adc.w	r1, r1, r0, asr #31
	__asm__ volatile(
   14aee:	f384 8811 	msr	BASEPRI, r4
   14af2:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   14af6:	2201      	movs	r2, #1
   14af8:	2a00      	cmp	r2, #0
   14afa:	d0f0      	beq.n	14ade <sys_clock_tick_get+0x1a>
	}
	return t;
}
   14afc:	4618      	mov	r0, r3
   14afe:	bd10      	pop	{r4, pc}
   14b00:	20001bd0 	.word	0x20001bd0

00014b04 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   14b04:	b570      	push	{r4, r5, r6, lr}
   14b06:	4604      	mov	r4, r0
	__asm__ volatile(
   14b08:	f04f 0320 	mov.w	r3, #32
   14b0c:	f3ef 8611 	mrs	r6, BASEPRI
   14b10:	f383 8812 	msr	BASEPRI_MAX, r3
   14b14:	f3bf 8f6f 	isb	sy
   14b18:	4635      	mov	r5, r6

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   14b1a:	6a82      	ldr	r2, [r0, #40]	; 0x28
   14b1c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   14b1e:	ea52 0103 	orrs.w	r1, r2, r3
   14b22:	d005      	beq.n	14b30 <z_timer_expiration_handler+0x2c>
   14b24:	f1b3 3fff 	cmp.w	r3, #4294967295
   14b28:	bf08      	it	eq
   14b2a:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   14b2e:	d128      	bne.n	14b82 <z_timer_expiration_handler+0x7e>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
			      next);
	}

	/* update timer's status */
	timer->status += 1U;
   14b30:	6b23      	ldr	r3, [r4, #48]	; 0x30
   14b32:	3301      	adds	r3, #1
   14b34:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   14b36:	6a23      	ldr	r3, [r4, #32]
   14b38:	b173      	cbz	r3, 14b58 <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   14b3a:	f386 8811 	msr	BASEPRI, r6
   14b3e:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   14b42:	6a23      	ldr	r3, [r4, #32]
   14b44:	4620      	mov	r0, r4
   14b46:	4798      	blx	r3
	__asm__ volatile(
   14b48:	f04f 0320 	mov.w	r3, #32
   14b4c:	f3ef 8511 	mrs	r5, BASEPRI
   14b50:	f383 8812 	msr	BASEPRI_MAX, r3
   14b54:	f3bf 8f6f 	isb	sy
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   14b58:	f104 0318 	add.w	r3, r4, #24
	return list->head == list;
   14b5c:	69a4      	ldr	r4, [r4, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14b5e:	42a3      	cmp	r3, r4
   14b60:	d038      	beq.n	14bd4 <z_timer_expiration_handler+0xd0>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   14b62:	2c00      	cmp	r4, #0
   14b64:	d036      	beq.n	14bd4 <z_timer_expiration_handler+0xd0>
		k_spin_unlock(&lock, key);
		return;
	}

	z_unpend_thread_no_timeout(thread);
   14b66:	4620      	mov	r0, r4
   14b68:	f007 fcad 	bl	1c4c6 <z_unpend_thread_no_timeout>
   14b6c:	2300      	movs	r3, #0
   14b6e:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
	__asm__ volatile(
   14b72:	f385 8811 	msr	BASEPRI, r5
   14b76:	f3bf 8f6f 	isb	sy

	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
   14b7a:	4620      	mov	r0, r4
   14b7c:	f007 fd0b 	bl	1c596 <z_ready_thread>
}
   14b80:	bd70      	pop	{r4, r5, r6, pc}
	return z_impl_k_uptime_ticks();
   14b82:	f007 fec0 	bl	1c906 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
   14b86:	3001      	adds	r0, #1
   14b88:	f141 0100 	adc.w	r1, r1, #0
   14b8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   14b8e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   14b90:	18c0      	adds	r0, r0, r3
   14b92:	eb41 0102 	adc.w	r1, r1, r2
   14b96:	2801      	cmp	r0, #1
   14b98:	f171 0300 	sbcs.w	r3, r1, #0
   14b9c:	da08      	bge.n	14bb0 <z_timer_expiration_handler+0xac>
   14b9e:	f06f 0201 	mvn.w	r2, #1
   14ba2:	f04f 33ff 	mov.w	r3, #4294967295
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   14ba6:	490e      	ldr	r1, [pc, #56]	; (14be0 <z_timer_expiration_handler+0xdc>)
   14ba8:	4620      	mov	r0, r4
   14baa:	f7ff fe9d 	bl	148e8 <z_add_timeout>
   14bae:	e7bf      	b.n	14b30 <z_timer_expiration_handler+0x2c>
   14bb0:	f007 fea9 	bl	1c906 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1
   14bb4:	3001      	adds	r0, #1
   14bb6:	f141 0300 	adc.w	r3, r1, #0
   14bba:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   14bbc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   14bbe:	1880      	adds	r0, r0, r2
   14bc0:	eb43 0301 	adc.w	r3, r3, r1
   14bc4:	f06f 0201 	mvn.w	r2, #1
   14bc8:	1a12      	subs	r2, r2, r0
   14bca:	f04f 31ff 	mov.w	r1, #4294967295
   14bce:	eb61 0303 	sbc.w	r3, r1, r3
   14bd2:	e7e8      	b.n	14ba6 <z_timer_expiration_handler+0xa2>
   14bd4:	f385 8811 	msr	BASEPRI, r5
   14bd8:	f3bf 8f6f 	isb	sy
		return;
   14bdc:	e7d0      	b.n	14b80 <z_timer_expiration_handler+0x7c>
   14bde:	bf00      	nop
   14be0:	00014b05 	.word	0x00014b05

00014be4 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   14be4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14be8:	9f06      	ldr	r7, [sp, #24]
   14bea:	f8dd 801c 	ldr.w	r8, [sp, #28]
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   14bee:	f1b3 3fff 	cmp.w	r3, #4294967295
   14bf2:	bf08      	it	eq
   14bf4:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   14bf8:	d02f      	beq.n	14c5a <z_impl_k_timer_start+0x76>
   14bfa:	4605      	mov	r5, r0
   14bfc:	4614      	mov	r4, r2
   14bfe:	461e      	mov	r6, r3
   14c00:	4611      	mov	r1, r2
   14c02:	4618      	mov	r0, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   14c04:	f1b8 3fff 	cmp.w	r8, #4294967295
   14c08:	bf08      	it	eq
   14c0a:	f1b7 3fff 	cmpeq.w	r7, #4294967295
   14c0e:	d00d      	beq.n	14c2c <z_impl_k_timer_start+0x48>
   14c10:	ea57 0c08 	orrs.w	ip, r7, r8
   14c14:	d00a      	beq.n	14c2c <z_impl_k_timer_start+0x48>
	    Z_TICK_ABS(period.ticks) < 0) {
   14c16:	f06f 0c01 	mvn.w	ip, #1
   14c1a:	ebbc 0c07 	subs.w	ip, ip, r7
   14c1e:	f04f 3cff 	mov.w	ip, #4294967295
   14c22:	eb6c 0c08 	sbc.w	ip, ip, r8
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   14c26:	f1bc 0f00 	cmp.w	ip, #0
   14c2a:	db18      	blt.n	14c5e <z_impl_k_timer_start+0x7a>
		period.ticks = MAX(period.ticks - 1, 1);
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   14c2c:	f06f 0301 	mvn.w	r3, #1
   14c30:	1a5b      	subs	r3, r3, r1
   14c32:	f04f 33ff 	mov.w	r3, #4294967295
   14c36:	eb63 0300 	sbc.w	r3, r3, r0
   14c3a:	2b00      	cmp	r3, #0
   14c3c:	db1a      	blt.n	14c74 <z_impl_k_timer_start+0x90>
		duration.ticks = MAX(duration.ticks - 1, 0);
	}

	(void)z_abort_timeout(&timer->timeout);
   14c3e:	4628      	mov	r0, r5
   14c40:	f007 fdfd 	bl	1c83e <z_abort_timeout>
	timer->period = period;
   14c44:	62af      	str	r7, [r5, #40]	; 0x28
   14c46:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
	timer->status = 0U;
   14c4a:	2300      	movs	r3, #0
   14c4c:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   14c4e:	4622      	mov	r2, r4
   14c50:	4633      	mov	r3, r6
   14c52:	490e      	ldr	r1, [pc, #56]	; (14c8c <z_impl_k_timer_start+0xa8>)
   14c54:	4628      	mov	r0, r5
   14c56:	f7ff fe47 	bl	148e8 <z_add_timeout>
		     duration);
}
   14c5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		period.ticks = MAX(period.ticks - 1, 1);
   14c5e:	2f02      	cmp	r7, #2
   14c60:	f178 0300 	sbcs.w	r3, r8, #0
   14c64:	da02      	bge.n	14c6c <z_impl_k_timer_start+0x88>
   14c66:	2702      	movs	r7, #2
   14c68:	f04f 0800 	mov.w	r8, #0
   14c6c:	3f01      	subs	r7, #1
   14c6e:	f148 38ff 	adc.w	r8, r8, #4294967295
   14c72:	e7db      	b.n	14c2c <z_impl_k_timer_start+0x48>
		duration.ticks = MAX(duration.ticks - 1, 0);
   14c74:	460c      	mov	r4, r1
   14c76:	4606      	mov	r6, r0
   14c78:	2901      	cmp	r1, #1
   14c7a:	f170 0300 	sbcs.w	r3, r0, #0
   14c7e:	da01      	bge.n	14c84 <z_impl_k_timer_start+0xa0>
   14c80:	2401      	movs	r4, #1
   14c82:	2600      	movs	r6, #0
   14c84:	3c01      	subs	r4, #1
   14c86:	f146 36ff 	adc.w	r6, r6, #4294967295
   14c8a:	e7d8      	b.n	14c3e <z_impl_k_timer_start+0x5a>
   14c8c:	00014b05 	.word	0x00014b05

00014c90 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
   14c90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14c94:	b087      	sub	sp, #28
   14c96:	4682      	mov	sl, r0
   14c98:	460f      	mov	r7, r1
   14c9a:	4693      	mov	fp, r2
   14c9c:	9300      	str	r3, [sp, #0]
	int events_registered = 0;

	for (int ii = 0; ii < num_events; ii++) {
   14c9e:	2500      	movs	r5, #0
	int events_registered = 0;
   14ca0:	9501      	str	r5, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
   14ca2:	e02f      	b.n	14d04 <register_events+0x74>
		if (k_sem_count_get(event->sem) > 0U) {
   14ca4:	6923      	ldr	r3, [r4, #16]
	return sem->count;
   14ca6:	689b      	ldr	r3, [r3, #8]
   14ca8:	b1cb      	cbz	r3, 14cde <register_events+0x4e>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   14caa:	f04f 0902 	mov.w	r9, #2
			return true;
   14cae:	2301      	movs	r3, #1
   14cb0:	e015      	b.n	14cde <register_events+0x4e>
		if (!k_queue_is_empty(event->queue)) {
   14cb2:	6923      	ldr	r3, [r4, #16]
	return list->head;
   14cb4:	681b      	ldr	r3, [r3, #0]
   14cb6:	b193      	cbz	r3, 14cde <register_events+0x4e>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   14cb8:	f04f 0904 	mov.w	r9, #4
			return true;
   14cbc:	2301      	movs	r3, #1
   14cbe:	e00e      	b.n	14cde <register_events+0x4e>
		if (event->signal->signaled != 0U) {
   14cc0:	6923      	ldr	r3, [r4, #16]
   14cc2:	689b      	ldr	r3, [r3, #8]
   14cc4:	b15b      	cbz	r3, 14cde <register_events+0x4e>
			*state = K_POLL_STATE_SIGNALED;
   14cc6:	f04f 0901 	mov.w	r9, #1
			return true;
   14cca:	464b      	mov	r3, r9
   14ccc:	e007      	b.n	14cde <register_events+0x4e>
		if (event->msgq->used_msgs > 0) {
   14cce:	6923      	ldr	r3, [r4, #16]
   14cd0:	6a1b      	ldr	r3, [r3, #32]
   14cd2:	b123      	cbz	r3, 14cde <register_events+0x4e>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
   14cd4:	f04f 0910 	mov.w	r9, #16
			return true;
   14cd8:	2301      	movs	r3, #1
   14cda:	e000      	b.n	14cde <register_events+0x4e>
	switch (event->type) {
   14cdc:	2300      	movs	r3, #0
		k_spinlock_key_t key;
		uint32_t state;

		key = k_spin_lock(&lock);
		if (is_condition_met(&events[ii], &state)) {
   14cde:	2b00      	cmp	r3, #0
   14ce0:	d03a      	beq.n	14d58 <register_events+0xc8>
	event->poller = NULL;
   14ce2:	2100      	movs	r1, #0
   14ce4:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   14ce6:	68e3      	ldr	r3, [r4, #12]
   14ce8:	f3c3 3245 	ubfx	r2, r3, #13, #6
   14cec:	ea49 0202 	orr.w	r2, r9, r2
   14cf0:	f362 3352 	bfi	r3, r2, #13, #6
   14cf4:	60e3      	str	r3, [r4, #12]
			set_event_ready(&events[ii], state);
			poller->is_polling = false;
   14cf6:	f88b 1000 	strb.w	r1, [fp]
   14cfa:	f386 8811 	msr	BASEPRI, r6
   14cfe:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   14d02:	3501      	adds	r5, #1
   14d04:	42bd      	cmp	r5, r7
   14d06:	f280 81b9 	bge.w	1507c <register_events+0x3ec>
	__asm__ volatile(
   14d0a:	f04f 0320 	mov.w	r3, #32
   14d0e:	f3ef 8611 	mrs	r6, BASEPRI
   14d12:	f383 8812 	msr	BASEPRI_MAX, r3
   14d16:	f3bf 8f6f 	isb	sy
		if (is_condition_met(&events[ii], &state)) {
   14d1a:	eb05 0485 	add.w	r4, r5, r5, lsl #2
   14d1e:	ea4f 0884 	mov.w	r8, r4, lsl #2
   14d22:	eb0a 0484 	add.w	r4, sl, r4, lsl #2
	switch (event->type) {
   14d26:	7b63      	ldrb	r3, [r4, #13]
   14d28:	f003 031f 	and.w	r3, r3, #31
   14d2c:	3b01      	subs	r3, #1
   14d2e:	2b07      	cmp	r3, #7
   14d30:	d8d4      	bhi.n	14cdc <register_events+0x4c>
   14d32:	a201      	add	r2, pc, #4	; (adr r2, 14d38 <register_events+0xa8>)
   14d34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   14d38:	00014cc1 	.word	0x00014cc1
   14d3c:	00014ca5 	.word	0x00014ca5
   14d40:	00014cdd 	.word	0x00014cdd
   14d44:	00014cb3 	.word	0x00014cb3
   14d48:	00014cdd 	.word	0x00014cdd
   14d4c:	00014cdd 	.word	0x00014cdd
   14d50:	00014cdd 	.word	0x00014cdd
   14d54:	00014ccf 	.word	0x00014ccf
		} else if (!just_check && poller->is_polling) {
   14d58:	9b00      	ldr	r3, [sp, #0]
   14d5a:	2b00      	cmp	r3, #0
   14d5c:	d1cd      	bne.n	14cfa <register_events+0x6a>
   14d5e:	f89b 3000 	ldrb.w	r3, [fp]
   14d62:	2b00      	cmp	r3, #0
   14d64:	d0c9      	beq.n	14cfa <register_events+0x6a>
	switch (event->type) {
   14d66:	7b63      	ldrb	r3, [r4, #13]
   14d68:	f003 031f 	and.w	r3, r3, #31
   14d6c:	3b01      	subs	r3, #1
   14d6e:	2b07      	cmp	r3, #7
   14d70:	d848      	bhi.n	14e04 <register_events+0x174>
   14d72:	e8df f013 	tbh	[pc, r3, lsl #1]
   14d76:	00cb      	.short	0x00cb
   14d78:	00470008 	.word	0x00470008
   14d7c:	0047006d 	.word	0x0047006d
   14d80:	00470047 	.word	0x00470047
   14d84:	0125      	.short	0x0125
		add_event(&event->sem->poll_events, event, poller);
   14d86:	6923      	ldr	r3, [r4, #16]
   14d88:	9304      	str	r3, [sp, #16]
   14d8a:	f103 0210 	add.w	r2, r3, #16
   14d8e:	9202      	str	r2, [sp, #8]
	return list->head == list;
   14d90:	691b      	ldr	r3, [r3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   14d92:	429a      	cmp	r2, r3
   14d94:	d02f      	beq.n	14df6 <register_events+0x166>
   14d96:	6853      	ldr	r3, [r2, #4]
	if ((pending == NULL) ||
   14d98:	2b00      	cmp	r3, #0
   14d9a:	d02c      	beq.n	14df6 <register_events+0x166>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   14d9c:	6898      	ldr	r0, [r3, #8]
   14d9e:	f007 fe0f 	bl	1c9c0 <poller_thread>
   14da2:	9005      	str	r0, [sp, #20]
   14da4:	4658      	mov	r0, fp
   14da6:	f007 fe0b 	bl	1c9c0 <poller_thread>
   14daa:	4601      	mov	r1, r0
   14dac:	9003      	str	r0, [sp, #12]
   14dae:	9805      	ldr	r0, [sp, #20]
   14db0:	f007 fb7f 	bl	1c4b2 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   14db4:	2800      	cmp	r0, #0
   14db6:	dc1e      	bgt.n	14df6 <register_events+0x166>
	return list->head == list;
   14db8:	9b04      	ldr	r3, [sp, #16]
   14dba:	691b      	ldr	r3, [r3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14dbc:	9a02      	ldr	r2, [sp, #8]
   14dbe:	429a      	cmp	r2, r3
   14dc0:	d030      	beq.n	14e24 <register_events+0x194>
   14dc2:	9404      	str	r4, [sp, #16]
   14dc4:	9505      	str	r5, [sp, #20]
   14dc6:	9d02      	ldr	r5, [sp, #8]
   14dc8:	461c      	mov	r4, r3
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14dca:	2c00      	cmp	r4, #0
   14dcc:	d030      	beq.n	14e30 <register_events+0x1a0>
		if (z_sched_prio_cmp(poller_thread(poller),
   14dce:	68a0      	ldr	r0, [r4, #8]
   14dd0:	f007 fdf6 	bl	1c9c0 <poller_thread>
   14dd4:	4601      	mov	r1, r0
   14dd6:	9803      	ldr	r0, [sp, #12]
   14dd8:	f007 fb6b 	bl	1c4b2 <z_sched_prio_cmp>
   14ddc:	2800      	cmp	r0, #0
   14dde:	dc17      	bgt.n	14e10 <register_events+0x180>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   14de0:	2c00      	cmp	r4, #0
   14de2:	d028      	beq.n	14e36 <register_events+0x1a6>
	return (node == list->tail) ? NULL : node->next;
   14de4:	686b      	ldr	r3, [r5, #4]
   14de6:	429c      	cmp	r4, r3
   14de8:	d02f      	beq.n	14e4a <register_events+0x1ba>
   14dea:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14dec:	2c00      	cmp	r4, #0
   14dee:	d1ec      	bne.n	14dca <register_events+0x13a>
   14df0:	9c04      	ldr	r4, [sp, #16]
   14df2:	9d05      	ldr	r5, [sp, #20]
   14df4:	e021      	b.n	14e3a <register_events+0x1aa>
	sys_dnode_t *const tail = list->tail;
   14df6:	9a02      	ldr	r2, [sp, #8]
   14df8:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   14dfa:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   14dfe:	6063      	str	r3, [r4, #4]
	tail->next = node;
   14e00:	601c      	str	r4, [r3, #0]
	list->tail = node;
   14e02:	6054      	str	r4, [r2, #4]
	event->poller = poller;
   14e04:	f8c4 b008 	str.w	fp, [r4, #8]
			register_event(&events[ii], poller);
			events_registered += 1;
   14e08:	9b01      	ldr	r3, [sp, #4]
   14e0a:	3301      	adds	r3, #1
   14e0c:	9301      	str	r3, [sp, #4]
   14e0e:	e774      	b.n	14cfa <register_events+0x6a>
	sys_dnode_t *const prev = successor->prev;
   14e10:	9d05      	ldr	r5, [sp, #20]
   14e12:	4622      	mov	r2, r4
   14e14:	9c04      	ldr	r4, [sp, #16]
   14e16:	6853      	ldr	r3, [r2, #4]
	node->prev = prev;
   14e18:	6063      	str	r3, [r4, #4]
	node->next = successor;
   14e1a:	f84a 2008 	str.w	r2, [sl, r8]
	prev->next = node;
   14e1e:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   14e20:	6054      	str	r4, [r2, #4]
			return;
   14e22:	e7ef      	b.n	14e04 <register_events+0x174>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14e24:	2300      	movs	r3, #0
   14e26:	9404      	str	r4, [sp, #16]
   14e28:	9505      	str	r5, [sp, #20]
   14e2a:	9d02      	ldr	r5, [sp, #8]
   14e2c:	461c      	mov	r4, r3
   14e2e:	e7cc      	b.n	14dca <register_events+0x13a>
   14e30:	9c04      	ldr	r4, [sp, #16]
   14e32:	9d05      	ldr	r5, [sp, #20]
   14e34:	e001      	b.n	14e3a <register_events+0x1aa>
   14e36:	9c04      	ldr	r4, [sp, #16]
   14e38:	9d05      	ldr	r5, [sp, #20]
	sys_dnode_t *const tail = list->tail;
   14e3a:	9a02      	ldr	r2, [sp, #8]
   14e3c:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   14e3e:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   14e42:	6063      	str	r3, [r4, #4]
	tail->next = node;
   14e44:	601c      	str	r4, [r3, #0]
	list->tail = node;
   14e46:	6054      	str	r4, [r2, #4]
}
   14e48:	e7dc      	b.n	14e04 <register_events+0x174>
   14e4a:	9c04      	ldr	r4, [sp, #16]
   14e4c:	9d05      	ldr	r5, [sp, #20]
   14e4e:	e7f4      	b.n	14e3a <register_events+0x1aa>
		add_event(&event->queue->poll_events, event, poller);
   14e50:	6923      	ldr	r3, [r4, #16]
   14e52:	9304      	str	r3, [sp, #16]
   14e54:	f103 0210 	add.w	r2, r3, #16
   14e58:	9202      	str	r2, [sp, #8]
	return list->head == list;
   14e5a:	691b      	ldr	r3, [r3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   14e5c:	429a      	cmp	r2, r3
   14e5e:	d02d      	beq.n	14ebc <register_events+0x22c>
   14e60:	6853      	ldr	r3, [r2, #4]
	if ((pending == NULL) ||
   14e62:	b35b      	cbz	r3, 14ebc <register_events+0x22c>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   14e64:	6898      	ldr	r0, [r3, #8]
   14e66:	f007 fdab 	bl	1c9c0 <poller_thread>
   14e6a:	9005      	str	r0, [sp, #20]
   14e6c:	4658      	mov	r0, fp
   14e6e:	f007 fda7 	bl	1c9c0 <poller_thread>
   14e72:	4601      	mov	r1, r0
   14e74:	9003      	str	r0, [sp, #12]
   14e76:	9805      	ldr	r0, [sp, #20]
   14e78:	f007 fb1b 	bl	1c4b2 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   14e7c:	2800      	cmp	r0, #0
   14e7e:	dc1d      	bgt.n	14ebc <register_events+0x22c>
	return list->head == list;
   14e80:	9b04      	ldr	r3, [sp, #16]
   14e82:	691b      	ldr	r3, [r3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14e84:	9a02      	ldr	r2, [sp, #8]
   14e86:	429a      	cmp	r2, r3
   14e88:	d02a      	beq.n	14ee0 <register_events+0x250>
   14e8a:	9404      	str	r4, [sp, #16]
   14e8c:	9505      	str	r5, [sp, #20]
   14e8e:	9d02      	ldr	r5, [sp, #8]
   14e90:	461c      	mov	r4, r3
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14e92:	2c00      	cmp	r4, #0
   14e94:	d02a      	beq.n	14eec <register_events+0x25c>
		if (z_sched_prio_cmp(poller_thread(poller),
   14e96:	68a0      	ldr	r0, [r4, #8]
   14e98:	f007 fd92 	bl	1c9c0 <poller_thread>
   14e9c:	4601      	mov	r1, r0
   14e9e:	9803      	ldr	r0, [sp, #12]
   14ea0:	f007 fb07 	bl	1c4b2 <z_sched_prio_cmp>
   14ea4:	2800      	cmp	r0, #0
   14ea6:	dc11      	bgt.n	14ecc <register_events+0x23c>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   14ea8:	b31c      	cbz	r4, 14ef2 <register_events+0x262>
	return (node == list->tail) ? NULL : node->next;
   14eaa:	686b      	ldr	r3, [r5, #4]
   14eac:	429c      	cmp	r4, r3
   14eae:	d02a      	beq.n	14f06 <register_events+0x276>
   14eb0:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14eb2:	2c00      	cmp	r4, #0
   14eb4:	d1ed      	bne.n	14e92 <register_events+0x202>
   14eb6:	9c04      	ldr	r4, [sp, #16]
   14eb8:	9d05      	ldr	r5, [sp, #20]
   14eba:	e01c      	b.n	14ef6 <register_events+0x266>
	sys_dnode_t *const tail = list->tail;
   14ebc:	9a02      	ldr	r2, [sp, #8]
   14ebe:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   14ec0:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   14ec4:	6063      	str	r3, [r4, #4]
	tail->next = node;
   14ec6:	601c      	str	r4, [r3, #0]
	list->tail = node;
   14ec8:	6054      	str	r4, [r2, #4]
		return;
   14eca:	e79b      	b.n	14e04 <register_events+0x174>
	sys_dnode_t *const prev = successor->prev;
   14ecc:	9d05      	ldr	r5, [sp, #20]
   14ece:	4622      	mov	r2, r4
   14ed0:	9c04      	ldr	r4, [sp, #16]
   14ed2:	6853      	ldr	r3, [r2, #4]
	node->prev = prev;
   14ed4:	6063      	str	r3, [r4, #4]
	node->next = successor;
   14ed6:	f84a 2008 	str.w	r2, [sl, r8]
	prev->next = node;
   14eda:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   14edc:	6054      	str	r4, [r2, #4]
			return;
   14ede:	e791      	b.n	14e04 <register_events+0x174>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14ee0:	2300      	movs	r3, #0
   14ee2:	9404      	str	r4, [sp, #16]
   14ee4:	9505      	str	r5, [sp, #20]
   14ee6:	9d02      	ldr	r5, [sp, #8]
   14ee8:	461c      	mov	r4, r3
   14eea:	e7d2      	b.n	14e92 <register_events+0x202>
   14eec:	9c04      	ldr	r4, [sp, #16]
   14eee:	9d05      	ldr	r5, [sp, #20]
   14ef0:	e001      	b.n	14ef6 <register_events+0x266>
   14ef2:	9c04      	ldr	r4, [sp, #16]
   14ef4:	9d05      	ldr	r5, [sp, #20]
	sys_dnode_t *const tail = list->tail;
   14ef6:	9a02      	ldr	r2, [sp, #8]
   14ef8:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   14efa:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   14efe:	6063      	str	r3, [r4, #4]
	tail->next = node;
   14f00:	601c      	str	r4, [r3, #0]
	list->tail = node;
   14f02:	6054      	str	r4, [r2, #4]
}
   14f04:	e77e      	b.n	14e04 <register_events+0x174>
   14f06:	9c04      	ldr	r4, [sp, #16]
   14f08:	9d05      	ldr	r5, [sp, #20]
   14f0a:	e7f4      	b.n	14ef6 <register_events+0x266>
		add_event(&event->signal->poll_events, event, poller);
   14f0c:	6922      	ldr	r2, [r4, #16]
   14f0e:	9202      	str	r2, [sp, #8]
	return list->head == list;
   14f10:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   14f12:	429a      	cmp	r2, r3
   14f14:	d02c      	beq.n	14f70 <register_events+0x2e0>
   14f16:	6853      	ldr	r3, [r2, #4]
	if ((pending == NULL) ||
   14f18:	b353      	cbz	r3, 14f70 <register_events+0x2e0>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   14f1a:	6898      	ldr	r0, [r3, #8]
   14f1c:	f007 fd50 	bl	1c9c0 <poller_thread>
   14f20:	9004      	str	r0, [sp, #16]
   14f22:	4658      	mov	r0, fp
   14f24:	f007 fd4c 	bl	1c9c0 <poller_thread>
   14f28:	4601      	mov	r1, r0
   14f2a:	9003      	str	r0, [sp, #12]
   14f2c:	9804      	ldr	r0, [sp, #16]
   14f2e:	f007 fac0 	bl	1c4b2 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   14f32:	2800      	cmp	r0, #0
   14f34:	dc1c      	bgt.n	14f70 <register_events+0x2e0>
	return list->head == list;
   14f36:	9b02      	ldr	r3, [sp, #8]
   14f38:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14f3a:	4293      	cmp	r3, r2
   14f3c:	d02a      	beq.n	14f94 <register_events+0x304>
   14f3e:	9404      	str	r4, [sp, #16]
   14f40:	9505      	str	r5, [sp, #20]
   14f42:	9d02      	ldr	r5, [sp, #8]
   14f44:	4614      	mov	r4, r2
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14f46:	2c00      	cmp	r4, #0
   14f48:	d02a      	beq.n	14fa0 <register_events+0x310>
		if (z_sched_prio_cmp(poller_thread(poller),
   14f4a:	68a0      	ldr	r0, [r4, #8]
   14f4c:	f007 fd38 	bl	1c9c0 <poller_thread>
   14f50:	4601      	mov	r1, r0
   14f52:	9803      	ldr	r0, [sp, #12]
   14f54:	f007 faad 	bl	1c4b2 <z_sched_prio_cmp>
   14f58:	2800      	cmp	r0, #0
   14f5a:	dc11      	bgt.n	14f80 <register_events+0x2f0>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   14f5c:	b31c      	cbz	r4, 14fa6 <register_events+0x316>
	return (node == list->tail) ? NULL : node->next;
   14f5e:	686b      	ldr	r3, [r5, #4]
   14f60:	429c      	cmp	r4, r3
   14f62:	d02a      	beq.n	14fba <register_events+0x32a>
   14f64:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14f66:	2c00      	cmp	r4, #0
   14f68:	d1ed      	bne.n	14f46 <register_events+0x2b6>
   14f6a:	9c04      	ldr	r4, [sp, #16]
   14f6c:	9d05      	ldr	r5, [sp, #20]
   14f6e:	e01c      	b.n	14faa <register_events+0x31a>
	sys_dnode_t *const tail = list->tail;
   14f70:	9a02      	ldr	r2, [sp, #8]
   14f72:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   14f74:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   14f78:	6063      	str	r3, [r4, #4]
	tail->next = node;
   14f7a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   14f7c:	6054      	str	r4, [r2, #4]
		return;
   14f7e:	e741      	b.n	14e04 <register_events+0x174>
	sys_dnode_t *const prev = successor->prev;
   14f80:	9d05      	ldr	r5, [sp, #20]
   14f82:	4622      	mov	r2, r4
   14f84:	9c04      	ldr	r4, [sp, #16]
   14f86:	6853      	ldr	r3, [r2, #4]
	node->prev = prev;
   14f88:	6063      	str	r3, [r4, #4]
	node->next = successor;
   14f8a:	f84a 2008 	str.w	r2, [sl, r8]
	prev->next = node;
   14f8e:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   14f90:	6054      	str	r4, [r2, #4]
			return;
   14f92:	e737      	b.n	14e04 <register_events+0x174>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   14f94:	2300      	movs	r3, #0
   14f96:	9404      	str	r4, [sp, #16]
   14f98:	9505      	str	r5, [sp, #20]
   14f9a:	9d02      	ldr	r5, [sp, #8]
   14f9c:	461c      	mov	r4, r3
   14f9e:	e7d2      	b.n	14f46 <register_events+0x2b6>
   14fa0:	9c04      	ldr	r4, [sp, #16]
   14fa2:	9d05      	ldr	r5, [sp, #20]
   14fa4:	e001      	b.n	14faa <register_events+0x31a>
   14fa6:	9c04      	ldr	r4, [sp, #16]
   14fa8:	9d05      	ldr	r5, [sp, #20]
	sys_dnode_t *const tail = list->tail;
   14faa:	9a02      	ldr	r2, [sp, #8]
   14fac:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   14fae:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   14fb2:	6063      	str	r3, [r4, #4]
	tail->next = node;
   14fb4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   14fb6:	6054      	str	r4, [r2, #4]
}
   14fb8:	e724      	b.n	14e04 <register_events+0x174>
   14fba:	9c04      	ldr	r4, [sp, #16]
   14fbc:	9d05      	ldr	r5, [sp, #20]
   14fbe:	e7f4      	b.n	14faa <register_events+0x31a>
		add_event(&event->msgq->poll_events, event, poller);
   14fc0:	6923      	ldr	r3, [r4, #16]
   14fc2:	9304      	str	r3, [sp, #16]
   14fc4:	f103 0224 	add.w	r2, r3, #36	; 0x24
   14fc8:	9202      	str	r2, [sp, #8]
	return list->head == list;
   14fca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   14fcc:	429a      	cmp	r2, r3
   14fce:	d02d      	beq.n	1502c <register_events+0x39c>
   14fd0:	6853      	ldr	r3, [r2, #4]
	if ((pending == NULL) ||
   14fd2:	b35b      	cbz	r3, 1502c <register_events+0x39c>
		(z_sched_prio_cmp(poller_thread(pending->poller),
   14fd4:	6898      	ldr	r0, [r3, #8]
   14fd6:	f007 fcf3 	bl	1c9c0 <poller_thread>
   14fda:	9005      	str	r0, [sp, #20]
   14fdc:	4658      	mov	r0, fp
   14fde:	f007 fcef 	bl	1c9c0 <poller_thread>
   14fe2:	4601      	mov	r1, r0
   14fe4:	9003      	str	r0, [sp, #12]
   14fe6:	9805      	ldr	r0, [sp, #20]
   14fe8:	f007 fa63 	bl	1c4b2 <z_sched_prio_cmp>
	if ((pending == NULL) ||
   14fec:	2800      	cmp	r0, #0
   14fee:	dc1d      	bgt.n	1502c <register_events+0x39c>
	return list->head == list;
   14ff0:	9b04      	ldr	r3, [sp, #16]
   14ff2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   14ff4:	9a02      	ldr	r2, [sp, #8]
   14ff6:	429a      	cmp	r2, r3
   14ff8:	d02a      	beq.n	15050 <register_events+0x3c0>
   14ffa:	9404      	str	r4, [sp, #16]
   14ffc:	9505      	str	r5, [sp, #20]
   14ffe:	9d02      	ldr	r5, [sp, #8]
   15000:	461c      	mov	r4, r3
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   15002:	2c00      	cmp	r4, #0
   15004:	d02a      	beq.n	1505c <register_events+0x3cc>
		if (z_sched_prio_cmp(poller_thread(poller),
   15006:	68a0      	ldr	r0, [r4, #8]
   15008:	f007 fcda 	bl	1c9c0 <poller_thread>
   1500c:	4601      	mov	r1, r0
   1500e:	9803      	ldr	r0, [sp, #12]
   15010:	f007 fa4f 	bl	1c4b2 <z_sched_prio_cmp>
   15014:	2800      	cmp	r0, #0
   15016:	dc11      	bgt.n	1503c <register_events+0x3ac>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   15018:	b31c      	cbz	r4, 15062 <register_events+0x3d2>
	return (node == list->tail) ? NULL : node->next;
   1501a:	686b      	ldr	r3, [r5, #4]
   1501c:	429c      	cmp	r4, r3
   1501e:	d02a      	beq.n	15076 <register_events+0x3e6>
   15020:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   15022:	2c00      	cmp	r4, #0
   15024:	d1ed      	bne.n	15002 <register_events+0x372>
   15026:	9c04      	ldr	r4, [sp, #16]
   15028:	9d05      	ldr	r5, [sp, #20]
   1502a:	e01c      	b.n	15066 <register_events+0x3d6>
	sys_dnode_t *const tail = list->tail;
   1502c:	9a02      	ldr	r2, [sp, #8]
   1502e:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   15030:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   15034:	6063      	str	r3, [r4, #4]
	tail->next = node;
   15036:	601c      	str	r4, [r3, #0]
	list->tail = node;
   15038:	6054      	str	r4, [r2, #4]
		return;
   1503a:	e6e3      	b.n	14e04 <register_events+0x174>
	sys_dnode_t *const prev = successor->prev;
   1503c:	9d05      	ldr	r5, [sp, #20]
   1503e:	4622      	mov	r2, r4
   15040:	9c04      	ldr	r4, [sp, #16]
   15042:	6853      	ldr	r3, [r2, #4]
	node->prev = prev;
   15044:	6063      	str	r3, [r4, #4]
	node->next = successor;
   15046:	f84a 2008 	str.w	r2, [sl, r8]
	prev->next = node;
   1504a:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   1504c:	6054      	str	r4, [r2, #4]
			return;
   1504e:	e6d9      	b.n	14e04 <register_events+0x174>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   15050:	2300      	movs	r3, #0
   15052:	9404      	str	r4, [sp, #16]
   15054:	9505      	str	r5, [sp, #20]
   15056:	9d02      	ldr	r5, [sp, #8]
   15058:	461c      	mov	r4, r3
   1505a:	e7d2      	b.n	15002 <register_events+0x372>
   1505c:	9c04      	ldr	r4, [sp, #16]
   1505e:	9d05      	ldr	r5, [sp, #20]
   15060:	e001      	b.n	15066 <register_events+0x3d6>
   15062:	9c04      	ldr	r4, [sp, #16]
   15064:	9d05      	ldr	r5, [sp, #20]
	sys_dnode_t *const tail = list->tail;
   15066:	9a02      	ldr	r2, [sp, #8]
   15068:	6853      	ldr	r3, [r2, #4]
	node->next = list;
   1506a:	f84a 2008 	str.w	r2, [sl, r8]
	node->prev = tail;
   1506e:	6063      	str	r3, [r4, #4]
	tail->next = node;
   15070:	601c      	str	r4, [r3, #0]
	list->tail = node;
   15072:	6054      	str	r4, [r2, #4]
}
   15074:	e6c6      	b.n	14e04 <register_events+0x174>
   15076:	9c04      	ldr	r4, [sp, #16]
   15078:	9d05      	ldr	r5, [sp, #20]
   1507a:	e7f4      	b.n	15066 <register_events+0x3d6>
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
   1507c:	9801      	ldr	r0, [sp, #4]
   1507e:	b007      	add	sp, #28
   15080:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00015084 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   15084:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15088:	b082      	sub	sp, #8
   1508a:	4605      	mov	r5, r0
   1508c:	4690      	mov	r8, r2
   1508e:	461f      	mov	r7, r3
	int events_registered;
	k_spinlock_key_t key;
	struct z_poller *poller = &_current->poller;
   15090:	4b4f      	ldr	r3, [pc, #316]	; (151d0 <z_impl_k_poll+0x14c>)
   15092:	689e      	ldr	r6, [r3, #8]

	poller->is_polling = true;
   15094:	2301      	movs	r3, #1
   15096:	f886 3060 	strb.w	r3, [r6, #96]	; 0x60
	poller->mode = MODE_POLL;
   1509a:	f886 3061 	strb.w	r3, [r6, #97]	; 0x61
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	SYS_PORT_TRACING_FUNC_ENTER(k_poll_api, poll, events);

	events_registered = register_events(events, num_events, poller,
   1509e:	ea57 0302 	orrs.w	r3, r7, r2
   150a2:	bf0c      	ite	eq
   150a4:	2301      	moveq	r3, #1
   150a6:	2300      	movne	r3, #0
   150a8:	f106 0260 	add.w	r2, r6, #96	; 0x60
   150ac:	f7ff fdf0 	bl	14c90 <register_events>
   150b0:	4604      	mov	r4, r0
   150b2:	f04f 0320 	mov.w	r3, #32
   150b6:	f3ef 8111 	mrs	r1, BASEPRI
   150ba:	f383 8812 	msr	BASEPRI_MAX, r3
   150be:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller->is_polling) {
   150c2:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
   150c6:	b1b3      	cbz	r3, 150f6 <z_impl_k_poll+0x72>
		SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, 0);

		return 0;
	}

	poller->is_polling = false;
   150c8:	2300      	movs	r3, #0
   150ca:	f886 3060 	strb.w	r3, [r6, #96]	; 0x60

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   150ce:	ea57 0308 	orrs.w	r3, r7, r8
   150d2:	d043      	beq.n	1515c <z_impl_k_poll+0xd8>
		return -EAGAIN;
	}

	static _wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);

	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   150d4:	f8cd 8000 	str.w	r8, [sp]
   150d8:	9701      	str	r7, [sp, #4]
   150da:	4a3e      	ldr	r2, [pc, #248]	; (151d4 <z_impl_k_poll+0x150>)
   150dc:	483e      	ldr	r0, [pc, #248]	; (151d8 <z_impl_k_poll+0x154>)
   150de:	f7ff f95b 	bl	14398 <z_pend_curr>
   150e2:	f04f 0320 	mov.w	r3, #32
   150e6:	f3ef 8611 	mrs	r6, BASEPRI
   150ea:	f383 8812 	msr	BASEPRI_MAX, r3
   150ee:	f3bf 8f6f 	isb	sy
   150f2:	46b4      	mov	ip, r6
	while (num_events--) {
   150f4:	e04c      	b.n	15190 <z_impl_k_poll+0x10c>
		clear_event_registrations(events, events_registered, key);
   150f6:	460e      	mov	r6, r1
	while (num_events--) {
   150f8:	e00c      	b.n	15114 <z_impl_k_poll+0x90>
	__asm__ volatile(
   150fa:	f386 8811 	msr	BASEPRI, r6
   150fe:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   15102:	f04f 0320 	mov.w	r3, #32
   15106:	f3ef 8611 	mrs	r6, BASEPRI
   1510a:	f383 8812 	msr	BASEPRI_MAX, r3
   1510e:	f3bf 8f6f 	isb	sy
   15112:	4604      	mov	r4, r0
   15114:	1e60      	subs	r0, r4, #1
   15116:	b1dc      	cbz	r4, 15150 <z_impl_k_poll+0xcc>
		clear_event_registration(&events[num_events]);
   15118:	eb00 0380 	add.w	r3, r0, r0, lsl #2
   1511c:	009f      	lsls	r7, r3, #2
   1511e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	event->poller = NULL;
   15122:	2200      	movs	r2, #0
   15124:	609a      	str	r2, [r3, #8]
	switch (event->type) {
   15126:	7b5a      	ldrb	r2, [r3, #13]
   15128:	f002 021f 	and.w	r2, r2, #31
   1512c:	2a08      	cmp	r2, #8
   1512e:	d8e4      	bhi.n	150fa <z_impl_k_poll+0x76>
   15130:	2401      	movs	r4, #1
   15132:	fa04 f202 	lsl.w	r2, r4, r2
   15136:	f412 7f8b 	tst.w	r2, #278	; 0x116
   1513a:	d0de      	beq.n	150fa <z_impl_k_poll+0x76>
	return node->next != NULL;
   1513c:	59ea      	ldr	r2, [r5, r7]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   1513e:	2a00      	cmp	r2, #0
   15140:	d0db      	beq.n	150fa <z_impl_k_poll+0x76>
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   15142:	685c      	ldr	r4, [r3, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   15144:	6022      	str	r2, [r4, #0]
	next->prev = prev;
   15146:	6054      	str	r4, [r2, #4]
	node->next = NULL;
   15148:	2200      	movs	r2, #0
   1514a:	51ea      	str	r2, [r5, r7]
	node->prev = NULL;
   1514c:	605a      	str	r2, [r3, #4]
	sys_dnode_init(node);
}
   1514e:	e7d4      	b.n	150fa <z_impl_k_poll+0x76>
	__asm__ volatile(
   15150:	f381 8811 	msr	BASEPRI, r1
   15154:	f3bf 8f6f 	isb	sy
		return 0;
   15158:	4620      	mov	r0, r4
   1515a:	e036      	b.n	151ca <z_impl_k_poll+0x146>
   1515c:	f381 8811 	msr	BASEPRI, r1
   15160:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   15164:	f06f 000a 	mvn.w	r0, #10
   15168:	e02f      	b.n	151ca <z_impl_k_poll+0x146>
	sys_dnode_t *const prev = node->prev;
   1516a:	6859      	ldr	r1, [r3, #4]
	prev->next = next;
   1516c:	600a      	str	r2, [r1, #0]
	next->prev = prev;
   1516e:	6051      	str	r1, [r2, #4]
	node->next = NULL;
   15170:	2200      	movs	r2, #0
   15172:	512a      	str	r2, [r5, r4]
	node->prev = NULL;
   15174:	605a      	str	r2, [r3, #4]
   15176:	f38c 8811 	msr	BASEPRI, ip
   1517a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1517e:	f04f 0320 	mov.w	r3, #32
   15182:	f3ef 8c11 	mrs	ip, BASEPRI
   15186:	f383 8812 	msr	BASEPRI_MAX, r3
   1518a:	f3bf 8f6f 	isb	sy
	while (num_events--) {
   1518e:	4674      	mov	r4, lr
   15190:	f104 3eff 	add.w	lr, r4, #4294967295
   15194:	b1ac      	cbz	r4, 151c2 <z_impl_k_poll+0x13e>
		clear_event_registration(&events[num_events]);
   15196:	eb0e 038e 	add.w	r3, lr, lr, lsl #2
   1519a:	009c      	lsls	r4, r3, #2
   1519c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	event->poller = NULL;
   151a0:	2200      	movs	r2, #0
   151a2:	609a      	str	r2, [r3, #8]
	switch (event->type) {
   151a4:	7b5a      	ldrb	r2, [r3, #13]
   151a6:	f002 021f 	and.w	r2, r2, #31
   151aa:	2a08      	cmp	r2, #8
   151ac:	d8e3      	bhi.n	15176 <z_impl_k_poll+0xf2>
   151ae:	2101      	movs	r1, #1
   151b0:	fa01 f202 	lsl.w	r2, r1, r2
   151b4:	f412 7f8b 	tst.w	r2, #278	; 0x116
   151b8:	d0dd      	beq.n	15176 <z_impl_k_poll+0xf2>
	return node->next != NULL;
   151ba:	592a      	ldr	r2, [r5, r4]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
   151bc:	2a00      	cmp	r2, #0
   151be:	d1d4      	bne.n	1516a <z_impl_k_poll+0xe6>
   151c0:	e7d9      	b.n	15176 <z_impl_k_poll+0xf2>
	__asm__ volatile(
   151c2:	f386 8811 	msr	BASEPRI, r6
   151c6:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_FUNC_EXIT(k_poll_api, poll, events, swap_rc);

	return swap_rc;
}
   151ca:	b002      	add	sp, #8
   151cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   151d0:	200026d8 	.word	0x200026d8
   151d4:	200004dc 	.word	0x200004dc
   151d8:	2000271c 	.word	0x2000271c

000151dc <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *sig, int result)
{
   151dc:	b538      	push	{r3, r4, r5, lr}
   151de:	4603      	mov	r3, r0
	__asm__ volatile(
   151e0:	f04f 0220 	mov.w	r2, #32
   151e4:	f3ef 8511 	mrs	r5, BASEPRI
   151e8:	f382 8812 	msr	BASEPRI_MAX, r2
   151ec:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	sig->result = result;
   151f0:	60c1      	str	r1, [r0, #12]
	sig->signaled = 1U;
   151f2:	2201      	movs	r2, #1
   151f4:	6082      	str	r2, [r0, #8]
	return list->head == list;
   151f6:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   151f8:	4283      	cmp	r3, r0
   151fa:	d011      	beq.n	15220 <z_impl_k_poll_signal_raise+0x44>
	sys_dnode_t *const prev = node->prev;
   151fc:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;
   151fe:	6803      	ldr	r3, [r0, #0]
	prev->next = next;
   15200:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   15202:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   15204:	2300      	movs	r3, #0
   15206:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   15208:	6043      	str	r3, [r0, #4]

	poll_event = (struct k_poll_event *)sys_dlist_get(&sig->poll_events);
	if (poll_event == NULL) {
   1520a:	b148      	cbz	r0, 15220 <z_impl_k_poll_signal_raise+0x44>
		SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, 0);

		return 0;
	}

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   1520c:	2101      	movs	r1, #1
   1520e:	f007 fc24 	bl	1ca5a <signal_poll_event>
   15212:	4604      	mov	r4, r0

	SYS_PORT_TRACING_FUNC(k_poll_api, signal_raise, sig, rc);

	z_reschedule(&lock, key);
   15214:	4629      	mov	r1, r5
   15216:	4805      	ldr	r0, [pc, #20]	; (1522c <z_impl_k_poll_signal_raise+0x50>)
   15218:	f7fe ff36 	bl	14088 <z_reschedule>
	return rc;
}
   1521c:	4620      	mov	r0, r4
   1521e:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   15220:	f385 8811 	msr	BASEPRI, r5
   15224:	f3bf 8f6f 	isb	sy
		return 0;
   15228:	2400      	movs	r4, #0
   1522a:	e7f7      	b.n	1521c <z_impl_k_poll_signal_raise+0x40>
   1522c:	2000271c 	.word	0x2000271c

00015230 <k_aligned_alloc>:

K_HEAP_DEFINE(_system_heap, CONFIG_HEAP_MEM_POOL_SIZE);
#define _SYSTEM_HEAP (&_system_heap)

void *k_aligned_alloc(size_t align, size_t size)
{
   15230:	b508      	push	{r3, lr}
   15232:	460a      	mov	r2, r1
	__ASSERT((align & (align - 1)) == 0,
		"align must be a power of 2");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP);

	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
   15234:	4601      	mov	r1, r0
   15236:	4802      	ldr	r0, [pc, #8]	; (15240 <k_aligned_alloc+0x10>)
   15238:	f007 fc5e 	bl	1caf8 <z_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap_sys, k_aligned_alloc, _SYSTEM_HEAP, ret);

	return ret;
}
   1523c:	bd08      	pop	{r3, pc}
   1523e:	bf00      	nop
   15240:	200005c0 	.word	0x200005c0

00015244 <k_thread_system_pool_assign>:
	return ret;
}

void k_thread_system_pool_assign(struct k_thread *thread)
{
	thread->resource_pool = _SYSTEM_HEAP;
   15244:	4b01      	ldr	r3, [pc, #4]	; (1524c <k_thread_system_pool_assign+0x8>)
   15246:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
}
   1524a:	4770      	bx	lr
   1524c:	200005c0 	.word	0x200005c0

00015250 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   15250:	b538      	push	{r3, r4, r5, lr}
   15252:	4604      	mov	r4, r0
   15254:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   15256:	f006 fe9a 	bl	1bf8e <k_is_in_isr>
   1525a:	b948      	cbnz	r0, 15270 <z_thread_aligned_alloc+0x20>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   1525c:	4b05      	ldr	r3, [pc, #20]	; (15274 <z_thread_aligned_alloc+0x24>)
   1525e:	689b      	ldr	r3, [r3, #8]
   15260:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
	}

	if (heap != NULL) {
   15264:	b118      	cbz	r0, 1526e <z_thread_aligned_alloc+0x1e>
		ret = z_heap_aligned_alloc(heap, align, size);
   15266:	462a      	mov	r2, r5
   15268:	4621      	mov	r1, r4
   1526a:	f007 fc45 	bl	1caf8 <z_heap_aligned_alloc>
	} else {
		ret = NULL;
	}

	return ret;
}
   1526e:	bd38      	pop	{r3, r4, r5, pc}
		heap = _SYSTEM_HEAP;
   15270:	4801      	ldr	r0, [pc, #4]	; (15278 <z_thread_aligned_alloc+0x28>)
   15272:	e7f7      	b.n	15264 <z_thread_aligned_alloc+0x14>
   15274:	200026d8 	.word	0x200026d8
   15278:	200005c0 	.word	0x200005c0

0001527c <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
   1527c:	b508      	push	{r3, lr}
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   1527e:	4a03      	ldr	r2, [pc, #12]	; (1528c <boot_banner+0x10>)
   15280:	4903      	ldr	r1, [pc, #12]	; (15290 <boot_banner+0x14>)
   15282:	4804      	ldr	r0, [pc, #16]	; (15294 <boot_banner+0x18>)
   15284:	f000 fa3b 	bl	156fe <printk>
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
   15288:	bd08      	pop	{r3, pc}
   1528a:	bf00      	nop
   1528c:	0001d410 	.word	0x0001d410
   15290:	0001ffa8 	.word	0x0001ffa8
   15294:	0001ffb8 	.word	0x0001ffb8

00015298 <nrf_cc3xx_platform_init_no_rng>:
   15298:	b510      	push	{r4, lr}
   1529a:	4c0a      	ldr	r4, [pc, #40]	; (152c4 <nrf_cc3xx_platform_init_no_rng+0x2c>)
   1529c:	6823      	ldr	r3, [r4, #0]
   1529e:	b11b      	cbz	r3, 152a8 <nrf_cc3xx_platform_init_no_rng+0x10>
   152a0:	2301      	movs	r3, #1
   152a2:	2000      	movs	r0, #0
   152a4:	6023      	str	r3, [r4, #0]
   152a6:	bd10      	pop	{r4, pc}
   152a8:	f000 f8dc 	bl	15464 <CC_LibInitNoRng>
   152ac:	2800      	cmp	r0, #0
   152ae:	d0f7      	beq.n	152a0 <nrf_cc3xx_platform_init_no_rng+0x8>
   152b0:	3801      	subs	r0, #1
   152b2:	2807      	cmp	r0, #7
   152b4:	d803      	bhi.n	152be <nrf_cc3xx_platform_init_no_rng+0x26>
   152b6:	4b04      	ldr	r3, [pc, #16]	; (152c8 <nrf_cc3xx_platform_init_no_rng+0x30>)
   152b8:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
   152bc:	bd10      	pop	{r4, pc}
   152be:	4803      	ldr	r0, [pc, #12]	; (152cc <nrf_cc3xx_platform_init_no_rng+0x34>)
   152c0:	bd10      	pop	{r4, pc}
   152c2:	bf00      	nop
   152c4:	2000271c 	.word	0x2000271c
   152c8:	0001ffe0 	.word	0x0001ffe0
   152cc:	ffff8ffe 	.word	0xffff8ffe

000152d0 <nrf_cc3xx_platform_abort>:
   152d0:	f3bf 8f4f 	dsb	sy
   152d4:	4905      	ldr	r1, [pc, #20]	; (152ec <nrf_cc3xx_platform_abort+0x1c>)
   152d6:	4b06      	ldr	r3, [pc, #24]	; (152f0 <nrf_cc3xx_platform_abort+0x20>)
   152d8:	68ca      	ldr	r2, [r1, #12]
   152da:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   152de:	4313      	orrs	r3, r2
   152e0:	60cb      	str	r3, [r1, #12]
   152e2:	f3bf 8f4f 	dsb	sy
   152e6:	bf00      	nop
   152e8:	e7fd      	b.n	152e6 <nrf_cc3xx_platform_abort+0x16>
   152ea:	bf00      	nop
   152ec:	e000ed00 	.word	0xe000ed00
   152f0:	05fa0004 	.word	0x05fa0004

000152f4 <CC_PalAbort>:
   152f4:	b430      	push	{r4, r5}
   152f6:	f04f 32fe 	mov.w	r2, #4278124286	; 0xfefefefe
   152fa:	2500      	movs	r5, #0
   152fc:	4b0b      	ldr	r3, [pc, #44]	; (1532c <CC_PalAbort+0x38>)
   152fe:	4c0c      	ldr	r4, [pc, #48]	; (15330 <CC_PalAbort+0x3c>)
   15300:	490c      	ldr	r1, [pc, #48]	; (15334 <CC_PalAbort+0x40>)
   15302:	6849      	ldr	r1, [r1, #4]
   15304:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
   15308:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
   1530c:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
   15310:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
   15314:	f8c3 2410 	str.w	r2, [r3, #1040]	; 0x410
   15318:	f8c3 2414 	str.w	r2, [r3, #1044]	; 0x414
   1531c:	f8c3 2418 	str.w	r2, [r3, #1048]	; 0x418
   15320:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
   15324:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
   15328:	bc30      	pop	{r4, r5}
   1532a:	4708      	bx	r1
   1532c:	50845000 	.word	0x50845000
   15330:	50844000 	.word	0x50844000
   15334:	200004e4 	.word	0x200004e4

00015338 <nrf_cc3xx_platform_set_abort>:
   15338:	4b02      	ldr	r3, [pc, #8]	; (15344 <nrf_cc3xx_platform_set_abort+0xc>)
   1533a:	e9d0 1200 	ldrd	r1, r2, [r0]
   1533e:	e9c3 1200 	strd	r1, r2, [r3]
   15342:	4770      	bx	lr
   15344:	200004e4 	.word	0x200004e4

00015348 <mutex_free>:
   15348:	b510      	push	{r4, lr}
   1534a:	4604      	mov	r4, r0
   1534c:	b130      	cbz	r0, 1535c <mutex_free+0x14>
   1534e:	6863      	ldr	r3, [r4, #4]
   15350:	06db      	lsls	r3, r3, #27
   15352:	d502      	bpl.n	1535a <mutex_free+0x12>
   15354:	2300      	movs	r3, #0
   15356:	6023      	str	r3, [r4, #0]
   15358:	6063      	str	r3, [r4, #4]
   1535a:	bd10      	pop	{r4, pc}
   1535c:	4b02      	ldr	r3, [pc, #8]	; (15368 <mutex_free+0x20>)
   1535e:	4803      	ldr	r0, [pc, #12]	; (1536c <mutex_free+0x24>)
   15360:	685b      	ldr	r3, [r3, #4]
   15362:	4798      	blx	r3
   15364:	e7f3      	b.n	1534e <mutex_free+0x6>
   15366:	bf00      	nop
   15368:	200004e4 	.word	0x200004e4
   1536c:	00020000 	.word	0x00020000

00015370 <mutex_lock>:
   15370:	b1b0      	cbz	r0, 153a0 <mutex_lock+0x30>
   15372:	6843      	ldr	r3, [r0, #4]
   15374:	b193      	cbz	r3, 1539c <mutex_lock+0x2c>
   15376:	06db      	lsls	r3, r3, #27
   15378:	d50e      	bpl.n	15398 <mutex_lock+0x28>
   1537a:	2301      	movs	r3, #1
   1537c:	e850 2f00 	ldrex	r2, [r0]
   15380:	4619      	mov	r1, r3
   15382:	e840 1c00 	strex	ip, r1, [r0]
   15386:	f09c 0f00 	teq	ip, #0
   1538a:	d1f7      	bne.n	1537c <mutex_lock+0xc>
   1538c:	2a01      	cmp	r2, #1
   1538e:	d0f5      	beq.n	1537c <mutex_lock+0xc>
   15390:	f3bf 8f5f 	dmb	sy
   15394:	2000      	movs	r0, #0
   15396:	4770      	bx	lr
   15398:	4803      	ldr	r0, [pc, #12]	; (153a8 <mutex_lock+0x38>)
   1539a:	4770      	bx	lr
   1539c:	4803      	ldr	r0, [pc, #12]	; (153ac <mutex_lock+0x3c>)
   1539e:	4770      	bx	lr
   153a0:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
   153a4:	4770      	bx	lr
   153a6:	bf00      	nop
   153a8:	ffff8fe9 	.word	0xffff8fe9
   153ac:	ffff8fea 	.word	0xffff8fea

000153b0 <mutex_unlock>:
   153b0:	4603      	mov	r3, r0
   153b2:	b168      	cbz	r0, 153d0 <mutex_unlock+0x20>
   153b4:	6842      	ldr	r2, [r0, #4]
   153b6:	b13a      	cbz	r2, 153c8 <mutex_unlock+0x18>
   153b8:	06d2      	lsls	r2, r2, #27
   153ba:	d507      	bpl.n	153cc <mutex_unlock+0x1c>
   153bc:	f3bf 8f5f 	dmb	sy
   153c0:	2200      	movs	r2, #0
   153c2:	4610      	mov	r0, r2
   153c4:	601a      	str	r2, [r3, #0]
   153c6:	4770      	bx	lr
   153c8:	4803      	ldr	r0, [pc, #12]	; (153d8 <mutex_unlock+0x28>)
   153ca:	4770      	bx	lr
   153cc:	4803      	ldr	r0, [pc, #12]	; (153dc <mutex_unlock+0x2c>)
   153ce:	4770      	bx	lr
   153d0:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
   153d4:	4770      	bx	lr
   153d6:	bf00      	nop
   153d8:	ffff8fea 	.word	0xffff8fea
   153dc:	ffff8fe9 	.word	0xffff8fe9

000153e0 <mutex_init>:
   153e0:	b510      	push	{r4, lr}
   153e2:	4604      	mov	r4, r0
   153e4:	b120      	cbz	r0, 153f0 <mutex_init+0x10>
   153e6:	2200      	movs	r2, #0
   153e8:	2311      	movs	r3, #17
   153ea:	6022      	str	r2, [r4, #0]
   153ec:	6063      	str	r3, [r4, #4]
   153ee:	bd10      	pop	{r4, pc}
   153f0:	4801      	ldr	r0, [pc, #4]	; (153f8 <mutex_init+0x18>)
   153f2:	f7ff ff7f 	bl	152f4 <CC_PalAbort>
   153f6:	e7f6      	b.n	153e6 <mutex_init+0x6>
   153f8:	00020028 	.word	0x00020028

000153fc <nrf_cc3xx_platform_set_mutexes>:
   153fc:	b570      	push	{r4, r5, r6, lr}
   153fe:	4c16      	ldr	r4, [pc, #88]	; (15458 <nrf_cc3xx_platform_set_mutexes+0x5c>)
   15400:	f8d0 c004 	ldr.w	ip, [r0, #4]
   15404:	6806      	ldr	r6, [r0, #0]
   15406:	f8c4 c004 	str.w	ip, [r4, #4]
   1540a:	f8d0 c008 	ldr.w	ip, [r0, #8]
   1540e:	68c0      	ldr	r0, [r0, #12]
   15410:	f8c4 c008 	str.w	ip, [r4, #8]
   15414:	60e0      	str	r0, [r4, #12]
   15416:	6026      	str	r6, [r4, #0]
   15418:	6808      	ldr	r0, [r1, #0]
   1541a:	4b10      	ldr	r3, [pc, #64]	; (1545c <nrf_cc3xx_platform_set_mutexes+0x60>)
   1541c:	4d10      	ldr	r5, [pc, #64]	; (15460 <nrf_cc3xx_platform_set_mutexes+0x64>)
   1541e:	6018      	str	r0, [r3, #0]
   15420:	6848      	ldr	r0, [r1, #4]
   15422:	f8d5 2118 	ldr.w	r2, [r5, #280]	; 0x118
   15426:	6058      	str	r0, [r3, #4]
   15428:	6888      	ldr	r0, [r1, #8]
   1542a:	6098      	str	r0, [r3, #8]
   1542c:	68c8      	ldr	r0, [r1, #12]
   1542e:	6909      	ldr	r1, [r1, #16]
   15430:	60d8      	str	r0, [r3, #12]
   15432:	6119      	str	r1, [r3, #16]
   15434:	06d3      	lsls	r3, r2, #27
   15436:	d50d      	bpl.n	15454 <nrf_cc3xx_platform_set_mutexes+0x58>
   15438:	2300      	movs	r3, #0
   1543a:	f505 708a 	add.w	r0, r5, #276	; 0x114
   1543e:	e9c5 3345 	strd	r3, r3, [r5, #276]	; 0x114
   15442:	e9c5 336e 	strd	r3, r3, [r5, #440]	; 0x1b8
   15446:	47b0      	blx	r6
   15448:	6823      	ldr	r3, [r4, #0]
   1544a:	f505 70dc 	add.w	r0, r5, #440	; 0x1b8
   1544e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   15452:	4718      	bx	r3
   15454:	bd70      	pop	{r4, r5, r6, pc}
   15456:	bf00      	nop
   15458:	200004f4 	.word	0x200004f4
   1545c:	20000504 	.word	0x20000504
   15460:	20002734 	.word	0x20002734

00015464 <CC_LibInitNoRng>:
   15464:	b508      	push	{r3, lr}
   15466:	f000 f811 	bl	1548c <CC_HalInit>
   1546a:	b930      	cbnz	r0, 1547a <CC_LibInitNoRng+0x16>
   1546c:	f000 f810 	bl	15490 <CC_PalInit>
   15470:	b938      	cbnz	r0, 15482 <CC_LibInitNoRng+0x1e>
   15472:	4a05      	ldr	r2, [pc, #20]	; (15488 <CC_LibInitNoRng+0x24>)
   15474:	f8c2 0a0c 	str.w	r0, [r2, #2572]	; 0xa0c
   15478:	bd08      	pop	{r3, pc}
   1547a:	f000 f837 	bl	154ec <CC_PalTerminate>
   1547e:	2003      	movs	r0, #3
   15480:	bd08      	pop	{r3, pc}
   15482:	2004      	movs	r0, #4
   15484:	bd08      	pop	{r3, pc}
   15486:	bf00      	nop
   15488:	50845000 	.word	0x50845000

0001548c <CC_HalInit>:
   1548c:	2000      	movs	r0, #0
   1548e:	4770      	bx	lr

00015490 <CC_PalInit>:
   15490:	b510      	push	{r4, lr}
   15492:	4811      	ldr	r0, [pc, #68]	; (154d8 <CC_PalInit+0x48>)
   15494:	f000 f848 	bl	15528 <CC_PalMutexCreate>
   15498:	b100      	cbz	r0, 1549c <CC_PalInit+0xc>
   1549a:	bd10      	pop	{r4, pc}
   1549c:	480f      	ldr	r0, [pc, #60]	; (154dc <CC_PalInit+0x4c>)
   1549e:	f000 f843 	bl	15528 <CC_PalMutexCreate>
   154a2:	2800      	cmp	r0, #0
   154a4:	d1f9      	bne.n	1549a <CC_PalInit+0xa>
   154a6:	4c0e      	ldr	r4, [pc, #56]	; (154e0 <CC_PalInit+0x50>)
   154a8:	4620      	mov	r0, r4
   154aa:	f000 f83d 	bl	15528 <CC_PalMutexCreate>
   154ae:	2800      	cmp	r0, #0
   154b0:	d1f3      	bne.n	1549a <CC_PalInit+0xa>
   154b2:	4b0c      	ldr	r3, [pc, #48]	; (154e4 <CC_PalInit+0x54>)
   154b4:	480c      	ldr	r0, [pc, #48]	; (154e8 <CC_PalInit+0x58>)
   154b6:	601c      	str	r4, [r3, #0]
   154b8:	f000 f836 	bl	15528 <CC_PalMutexCreate>
   154bc:	4601      	mov	r1, r0
   154be:	2800      	cmp	r0, #0
   154c0:	d1eb      	bne.n	1549a <CC_PalInit+0xa>
   154c2:	f000 f82d 	bl	15520 <CC_PalDmaInit>
   154c6:	4604      	mov	r4, r0
   154c8:	b108      	cbz	r0, 154ce <CC_PalInit+0x3e>
   154ca:	4620      	mov	r0, r4
   154cc:	bd10      	pop	{r4, pc}
   154ce:	f000 f83f 	bl	15550 <CC_PalPowerSaveModeInit>
   154d2:	4620      	mov	r0, r4
   154d4:	e7fa      	b.n	154cc <CC_PalInit+0x3c>
   154d6:	bf00      	nop
   154d8:	2000053c 	.word	0x2000053c
   154dc:	20000530 	.word	0x20000530
   154e0:	20000538 	.word	0x20000538
   154e4:	20000540 	.word	0x20000540
   154e8:	20000534 	.word	0x20000534

000154ec <CC_PalTerminate>:
   154ec:	b508      	push	{r3, lr}
   154ee:	4808      	ldr	r0, [pc, #32]	; (15510 <CC_PalTerminate+0x24>)
   154f0:	f000 f824 	bl	1553c <CC_PalMutexDestroy>
   154f4:	4807      	ldr	r0, [pc, #28]	; (15514 <CC_PalTerminate+0x28>)
   154f6:	f000 f821 	bl	1553c <CC_PalMutexDestroy>
   154fa:	4807      	ldr	r0, [pc, #28]	; (15518 <CC_PalTerminate+0x2c>)
   154fc:	f000 f81e 	bl	1553c <CC_PalMutexDestroy>
   15500:	4806      	ldr	r0, [pc, #24]	; (1551c <CC_PalTerminate+0x30>)
   15502:	f000 f81b 	bl	1553c <CC_PalMutexDestroy>
   15506:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1550a:	f000 b80b 	b.w	15524 <CC_PalDmaTerminate>
   1550e:	bf00      	nop
   15510:	2000053c 	.word	0x2000053c
   15514:	20000530 	.word	0x20000530
   15518:	20000538 	.word	0x20000538
   1551c:	20000534 	.word	0x20000534

00015520 <CC_PalDmaInit>:
   15520:	2000      	movs	r0, #0
   15522:	4770      	bx	lr

00015524 <CC_PalDmaTerminate>:
   15524:	4770      	bx	lr
   15526:	bf00      	nop

00015528 <CC_PalMutexCreate>:
   15528:	b508      	push	{r3, lr}
   1552a:	4b03      	ldr	r3, [pc, #12]	; (15538 <CC_PalMutexCreate+0x10>)
   1552c:	6802      	ldr	r2, [r0, #0]
   1552e:	681b      	ldr	r3, [r3, #0]
   15530:	6810      	ldr	r0, [r2, #0]
   15532:	4798      	blx	r3
   15534:	2000      	movs	r0, #0
   15536:	bd08      	pop	{r3, pc}
   15538:	200004f4 	.word	0x200004f4

0001553c <CC_PalMutexDestroy>:
   1553c:	b508      	push	{r3, lr}
   1553e:	4b03      	ldr	r3, [pc, #12]	; (1554c <CC_PalMutexDestroy+0x10>)
   15540:	6802      	ldr	r2, [r0, #0]
   15542:	685b      	ldr	r3, [r3, #4]
   15544:	6810      	ldr	r0, [r2, #0]
   15546:	4798      	blx	r3
   15548:	2000      	movs	r0, #0
   1554a:	bd08      	pop	{r3, pc}
   1554c:	200004f4 	.word	0x200004f4

00015550 <CC_PalPowerSaveModeInit>:
   15550:	b570      	push	{r4, r5, r6, lr}
   15552:	4c09      	ldr	r4, [pc, #36]	; (15578 <CC_PalPowerSaveModeInit+0x28>)
   15554:	4d09      	ldr	r5, [pc, #36]	; (1557c <CC_PalPowerSaveModeInit+0x2c>)
   15556:	6920      	ldr	r0, [r4, #16]
   15558:	68ab      	ldr	r3, [r5, #8]
   1555a:	4798      	blx	r3
   1555c:	b118      	cbz	r0, 15566 <CC_PalPowerSaveModeInit+0x16>
   1555e:	4b08      	ldr	r3, [pc, #32]	; (15580 <CC_PalPowerSaveModeInit+0x30>)
   15560:	4808      	ldr	r0, [pc, #32]	; (15584 <CC_PalPowerSaveModeInit+0x34>)
   15562:	685b      	ldr	r3, [r3, #4]
   15564:	4798      	blx	r3
   15566:	2100      	movs	r1, #0
   15568:	4a07      	ldr	r2, [pc, #28]	; (15588 <CC_PalPowerSaveModeInit+0x38>)
   1556a:	68eb      	ldr	r3, [r5, #12]
   1556c:	6011      	str	r1, [r2, #0]
   1556e:	6920      	ldr	r0, [r4, #16]
   15570:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   15574:	4718      	bx	r3
   15576:	bf00      	nop
   15578:	20000504 	.word	0x20000504
   1557c:	200004f4 	.word	0x200004f4
   15580:	200004e4 	.word	0x200004e4
   15584:	0002004c 	.word	0x0002004c
   15588:	20002730 	.word	0x20002730

0001558c <recv>:
{
   1558c:	b508      	push	{r3, lr}
	led_update();
   1558e:	f7ea ff4d 	bl	42c <led_update>
}
   15592:	2000      	movs	r0, #0
   15594:	bd08      	pop	{r3, pc}

00015596 <cbprintf_via_va_list>:
{
   15596:	b510      	push	{r4, lr}
   15598:	460c      	mov	r4, r1
   1559a:	4611      	mov	r1, r2
   1559c:	461a      	mov	r2, r3
	return formatter(out, ctx, fmt, u.ap);
   1559e:	9b02      	ldr	r3, [sp, #8]
   155a0:	47a0      	blx	r4
}
   155a2:	bd10      	pop	{r4, pc}

000155a4 <get_package_len>:
{
   155a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   155a6:	4606      	mov	r6, r0
	args_size = buf[0] * sizeof(int);
   155a8:	7800      	ldrb	r0, [r0, #0]
	s_nbr     = buf[1];
   155aa:	7875      	ldrb	r5, [r6, #1]
	ros_nbr   = buf[2];
   155ac:	78b4      	ldrb	r4, [r6, #2]
	buf += ros_nbr;
   155ae:	eb04 0480 	add.w	r4, r4, r0, lsl #2
   155b2:	4434      	add	r4, r6
	for (int i = 0; i < s_nbr; i++) {
   155b4:	2700      	movs	r7, #0
   155b6:	e006      	b.n	155c6 <get_package_len+0x22>
		buf++;
   155b8:	3401      	adds	r4, #1
		buf += strlen((const char *)buf) + 1;
   155ba:	4620      	mov	r0, r4
   155bc:	f002 f875 	bl	176aa <strlen>
   155c0:	3001      	adds	r0, #1
   155c2:	4404      	add	r4, r0
	for (int i = 0; i < s_nbr; i++) {
   155c4:	3701      	adds	r7, #1
   155c6:	42af      	cmp	r7, r5
   155c8:	d3f6      	bcc.n	155b8 <get_package_len+0x14>
}
   155ca:	1ba0      	subs	r0, r4, r6
   155cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000155ce <append_string>:
{
   155ce:	b570      	push	{r4, r5, r6, lr}
   155d0:	4614      	mov	r4, r2
	if (cb == NULL) {
   155d2:	b138      	cbz	r0, 155e4 <append_string+0x16>
   155d4:	460d      	mov	r5, r1
   155d6:	4619      	mov	r1, r3
   155d8:	4606      	mov	r6, r0
	strl = strl > 0 ? strl : strlen(str) + 1;
   155da:	b143      	cbz	r3, 155ee <append_string+0x20>
	return cb(str, strl, ctx);
   155dc:	462a      	mov	r2, r5
   155de:	4620      	mov	r0, r4
   155e0:	47b0      	blx	r6
}
   155e2:	bd70      	pop	{r4, r5, r6, pc}
		return 1 + strlen(str);
   155e4:	4610      	mov	r0, r2
   155e6:	f002 f860 	bl	176aa <strlen>
   155ea:	3001      	adds	r0, #1
   155ec:	e7f9      	b.n	155e2 <append_string+0x14>
	strl = strl > 0 ? strl : strlen(str) + 1;
   155ee:	4610      	mov	r0, r2
   155f0:	f002 f85b 	bl	176aa <strlen>
   155f4:	b283      	uxth	r3, r0
   155f6:	3301      	adds	r3, #1
   155f8:	b299      	uxth	r1, r3
   155fa:	e7ef      	b.n	155dc <append_string+0xe>

000155fc <cbpprintf_external>:
	if (buf == NULL) {
   155fc:	b353      	cbz	r3, 15654 <cbpprintf_external+0x58>
{
   155fe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15602:	b082      	sub	sp, #8
   15604:	4607      	mov	r7, r0
   15606:	4688      	mov	r8, r1
   15608:	4691      	mov	r9, r2
   1560a:	461d      	mov	r5, r3
	args_size = hdr->hdr.desc.len * sizeof(int);
   1560c:	781a      	ldrb	r2, [r3, #0]
	s_nbr     = hdr->hdr.desc.str_cnt;
   1560e:	785e      	ldrb	r6, [r3, #1]
	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
   15610:	789c      	ldrb	r4, [r3, #2]
	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
   15612:	78db      	ldrb	r3, [r3, #3]
	s = (char *)(buf + args_size + ros_nbr + rws_nbr);
   15614:	eb04 0482 	add.w	r4, r4, r2, lsl #2
   15618:	441c      	add	r4, r3
   1561a:	442c      	add	r4, r5
	for (i = 0; i < s_nbr; i++) {
   1561c:	f04f 0a00 	mov.w	sl, #0
   15620:	e00a      	b.n	15638 <cbpprintf_external+0x3c>
		s_idx = *(uint8_t *)s++;
   15622:	f814 3b01 	ldrb.w	r3, [r4], #1
		*ps = s;
   15626:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
		s += strlen(s) + 1;
   1562a:	4620      	mov	r0, r4
   1562c:	f002 f83d 	bl	176aa <strlen>
   15630:	3001      	adds	r0, #1
   15632:	4404      	add	r4, r0
	for (i = 0; i < s_nbr; i++) {
   15634:	f10a 0a01 	add.w	sl, sl, #1
   15638:	45b2      	cmp	sl, r6
   1563a:	d3f2      	bcc.n	15622 <cbpprintf_external+0x26>
	buf += sizeof(*hdr);
   1563c:	f105 0308 	add.w	r3, r5, #8
	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
   15640:	9300      	str	r3, [sp, #0]
   15642:	686b      	ldr	r3, [r5, #4]
   15644:	464a      	mov	r2, r9
   15646:	4641      	mov	r1, r8
   15648:	4638      	mov	r0, r7
   1564a:	f7ff ffa4 	bl	15596 <cbprintf_via_va_list>
}
   1564e:	b002      	add	sp, #8
   15650:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -EINVAL;
   15654:	f06f 0015 	mvn.w	r0, #21
}
   15658:	4770      	bx	lr

0001565a <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   1565a:	4602      	mov	r2, r0
   1565c:	b1b0      	cbz	r0, 1568c <sys_notify_validate+0x32>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   1565e:	6843      	ldr	r3, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   15660:	f003 0303 	and.w	r3, r3, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   15664:	2b02      	cmp	r3, #2
   15666:	d00b      	beq.n	15680 <sys_notify_validate+0x26>
   15668:	2b03      	cmp	r3, #3
   1566a:	d004      	beq.n	15676 <sys_notify_validate+0x1c>
   1566c:	2b01      	cmp	r3, #1
   1566e:	d004      	beq.n	1567a <sys_notify_validate+0x20>
   15670:	f06f 0015 	mvn.w	r0, #21
   15674:	4770      	bx	lr
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   15676:	6803      	ldr	r3, [r0, #0]
   15678:	b15b      	cbz	r3, 15692 <sys_notify_validate+0x38>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   1567a:	2000      	movs	r0, #0
   1567c:	6090      	str	r0, [r2, #8]
   1567e:	4770      	bx	lr
		if (notify->method.signal == NULL) {
   15680:	6803      	ldr	r3, [r0, #0]
   15682:	2b00      	cmp	r3, #0
   15684:	d1f9      	bne.n	1567a <sys_notify_validate+0x20>
			rv = -EINVAL;
   15686:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   1568a:	4770      	bx	lr
		return -EINVAL;
   1568c:	f06f 0015 	mvn.w	r0, #21
   15690:	4770      	bx	lr
			rv = -EINVAL;
   15692:	f06f 0015 	mvn.w	r0, #21
   15696:	4770      	bx	lr

00015698 <sys_notify_finalize>:

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   15698:	b510      	push	{r4, lr}
   1569a:	4603      	mov	r3, r0
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   1569c:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   1569e:	f002 0203 	and.w	r2, r2, #3
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
   156a2:	6081      	str	r1, [r0, #8]
	switch (method) {
   156a4:	2a02      	cmp	r2, #2
   156a6:	d004      	beq.n	156b2 <sys_notify_finalize+0x1a>
   156a8:	2a03      	cmp	r2, #3
   156aa:	d105      	bne.n	156b8 <sys_notify_finalize+0x20>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   156ac:	6804      	ldr	r4, [r0, #0]
	struct k_poll_signal *sig = NULL;
   156ae:	2000      	movs	r0, #0
		break;
   156b0:	e004      	b.n	156bc <sys_notify_finalize+0x24>
	case SYS_NOTIFY_METHOD_SIGNAL:
		sig = notify->method.signal;
   156b2:	6800      	ldr	r0, [r0, #0]
	sys_notify_generic_callback rv = NULL;
   156b4:	2400      	movs	r4, #0
		break;
   156b6:	e001      	b.n	156bc <sys_notify_finalize+0x24>
	switch (method) {
   156b8:	2400      	movs	r4, #0
   156ba:	4620      	mov	r0, r4
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   156bc:	2200      	movs	r2, #0
   156be:	605a      	str	r2, [r3, #4]

	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
   156c0:	b108      	cbz	r0, 156c6 <sys_notify_finalize+0x2e>
	return z_impl_k_poll_signal_raise(sig, result);
   156c2:	f7ff fd8b 	bl	151dc <z_impl_k_poll_signal_raise>
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   156c6:	4620      	mov	r0, r4
   156c8:	bd10      	pop	{r4, pc}

000156ca <arch_printk_char_out>:
}
   156ca:	2000      	movs	r0, #0
   156cc:	4770      	bx	lr

000156ce <str_out>:
{
   156ce:	b410      	push	{r4}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   156d0:	680c      	ldr	r4, [r1, #0]
   156d2:	b154      	cbz	r4, 156ea <str_out+0x1c>
   156d4:	688a      	ldr	r2, [r1, #8]
   156d6:	684b      	ldr	r3, [r1, #4]
   156d8:	429a      	cmp	r2, r3
   156da:	da06      	bge.n	156ea <str_out+0x1c>
	if (ctx->count == ctx->max - 1) {
   156dc:	3b01      	subs	r3, #1
   156de:	429a      	cmp	r2, r3
   156e0:	d008      	beq.n	156f4 <str_out+0x26>
		ctx->str[ctx->count++] = c;
   156e2:	1c53      	adds	r3, r2, #1
   156e4:	608b      	str	r3, [r1, #8]
   156e6:	54a0      	strb	r0, [r4, r2]
   156e8:	e002      	b.n	156f0 <str_out+0x22>
		ctx->count++;
   156ea:	688b      	ldr	r3, [r1, #8]
   156ec:	3301      	adds	r3, #1
   156ee:	608b      	str	r3, [r1, #8]
}
   156f0:	bc10      	pop	{r4}
   156f2:	4770      	bx	lr
		ctx->str[ctx->count++] = '\0';
   156f4:	1c53      	adds	r3, r2, #1
   156f6:	608b      	str	r3, [r1, #8]
   156f8:	2300      	movs	r3, #0
   156fa:	54a3      	strb	r3, [r4, r2]
   156fc:	e7f8      	b.n	156f0 <str_out+0x22>

000156fe <printk>:
{
   156fe:	b40f      	push	{r0, r1, r2, r3}
   15700:	b500      	push	{lr}
   15702:	b083      	sub	sp, #12
   15704:	a904      	add	r1, sp, #16
   15706:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   1570a:	9101      	str	r1, [sp, #4]
	vprintk(fmt, ap);
   1570c:	f7eb fc02 	bl	f14 <vprintk>
}
   15710:	b003      	add	sp, #12
   15712:	f85d eb04 	ldr.w	lr, [sp], #4
   15716:	b004      	add	sp, #16
   15718:	4770      	bx	lr

0001571a <snprintk>:
{
   1571a:	b40c      	push	{r2, r3}
   1571c:	b500      	push	{lr}
   1571e:	b083      	sub	sp, #12
   15720:	ab04      	add	r3, sp, #16
   15722:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   15726:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   15728:	f7eb fc02 	bl	f30 <vsnprintk>
}
   1572c:	b003      	add	sp, #12
   1572e:	f85d eb04 	ldr.w	lr, [sp], #4
   15732:	b002      	add	sp, #8
   15734:	4770      	bx	lr

00015736 <set_state>:
	mgr->flags = (state & ONOFF_STATE_MASK)
   15736:	f001 0307 	and.w	r3, r1, #7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1573a:	8b01      	ldrh	r1, [r0, #24]
   1573c:	f021 0107 	bic.w	r1, r1, #7
   15740:	4319      	orrs	r1, r3
	mgr->flags = (state & ONOFF_STATE_MASK)
   15742:	8301      	strh	r1, [r0, #24]
}
   15744:	4770      	bx	lr

00015746 <notify_monitors>:
{
   15746:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1574a:	4606      	mov	r6, r0
   1574c:	460f      	mov	r7, r1
   1574e:	4690      	mov	r8, r2
	return list->head;
   15750:	6881      	ldr	r1, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   15752:	b119      	cbz	r1, 1575c <notify_monitors+0x16>
   15754:	460c      	mov	r4, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
   15756:	b131      	cbz	r1, 15766 <notify_monitors+0x20>
	return node->next;
   15758:	680c      	ldr	r4, [r1, #0]
   1575a:	e004      	b.n	15766 <notify_monitors+0x20>
   1575c:	460c      	mov	r4, r1
   1575e:	e002      	b.n	15766 <notify_monitors+0x20>
   15760:	4623      	mov	r3, r4
   15762:	4621      	mov	r1, r4
   15764:	461c      	mov	r4, r3
   15766:	b159      	cbz	r1, 15780 <notify_monitors+0x3a>
		mon->callback(mgr, mon, state, res);
   15768:	684d      	ldr	r5, [r1, #4]
   1576a:	4643      	mov	r3, r8
   1576c:	463a      	mov	r2, r7
   1576e:	4630      	mov	r0, r6
   15770:	47a8      	blx	r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   15772:	2c00      	cmp	r4, #0
   15774:	d0f4      	beq.n	15760 <notify_monitors+0x1a>
   15776:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
   15778:	2c00      	cmp	r4, #0
   1577a:	d0f2      	beq.n	15762 <notify_monitors+0x1c>
	return node->next;
   1577c:	6823      	ldr	r3, [r4, #0]
   1577e:	e7f0      	b.n	15762 <notify_monitors+0x1c>
}
   15780:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00015784 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15784:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   15786:	f013 0307 	ands.w	r3, r3, #7
   1578a:	d103      	bne.n	15794 <process_recheck+0x10>
	return list->head;
   1578c:	6802      	ldr	r2, [r0, #0]
	    && !sys_slist_is_empty(&mgr->clients)) {
   1578e:	b10a      	cbz	r2, 15794 <process_recheck+0x10>
		evt = EVT_START;
   15790:	2003      	movs	r0, #3
   15792:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   15794:	2b02      	cmp	r3, #2
   15796:	d003      	beq.n	157a0 <process_recheck+0x1c>
	} else if ((state == ONOFF_STATE_ERROR)
   15798:	2b01      	cmp	r3, #1
   1579a:	d006      	beq.n	157aa <process_recheck+0x26>
	int evt = EVT_NOP;
   1579c:	2000      	movs	r0, #0
   1579e:	4770      	bx	lr
		   && (mgr->refs == 0U)) {
   157a0:	8b42      	ldrh	r2, [r0, #26]
   157a2:	2a00      	cmp	r2, #0
   157a4:	d1f8      	bne.n	15798 <process_recheck+0x14>
		evt = EVT_STOP;
   157a6:	2004      	movs	r0, #4
   157a8:	4770      	bx	lr
   157aa:	6803      	ldr	r3, [r0, #0]
		   && !sys_slist_is_empty(&mgr->clients)) {
   157ac:	b10b      	cbz	r3, 157b2 <process_recheck+0x2e>
		evt = EVT_RESET;
   157ae:	2005      	movs	r0, #5
}
   157b0:	4770      	bx	lr
	int evt = EVT_NOP;
   157b2:	2000      	movs	r0, #0
   157b4:	4770      	bx	lr

000157b6 <process_complete>:
{
   157b6:	b510      	push	{r4, lr}
   157b8:	4604      	mov	r4, r0
   157ba:	468c      	mov	ip, r1
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   157bc:	8b03      	ldrh	r3, [r0, #24]
	if (res < 0) {
   157be:	2a00      	cmp	r2, #0
   157c0:	db07      	blt.n	157d2 <process_complete+0x1c>
   157c2:	f003 0307 	and.w	r3, r3, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   157c6:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   157c8:	2a01      	cmp	r2, #1
   157ca:	d90e      	bls.n	157ea <process_complete+0x34>
	} else if (state == ONOFF_STATE_TO_OFF) {
   157cc:	2b04      	cmp	r3, #4
   157ce:	d033      	beq.n	15838 <process_complete+0x82>
}
   157d0:	bd10      	pop	{r4, pc}
		*clients = mgr->clients;
   157d2:	e9d0 0100 	ldrd	r0, r1, [r0]
   157d6:	e88c 0003 	stmia.w	ip, {r0, r1}
	list->head = NULL;
   157da:	2300      	movs	r3, #0
   157dc:	6023      	str	r3, [r4, #0]
	list->tail = NULL;
   157de:	6063      	str	r3, [r4, #4]
		set_state(mgr, ONOFF_STATE_ERROR);
   157e0:	2101      	movs	r1, #1
   157e2:	4620      	mov	r0, r4
   157e4:	f7ff ffa7 	bl	15736 <set_state>
   157e8:	e7f2      	b.n	157d0 <process_complete+0x1a>
		*clients = mgr->clients;
   157ea:	e9d0 0100 	ldrd	r0, r1, [r0]
   157ee:	e88c 0003 	stmia.w	ip, {r0, r1}
	list->head = NULL;
   157f2:	2200      	movs	r2, #0
   157f4:	6022      	str	r2, [r4, #0]
	list->tail = NULL;
   157f6:	6062      	str	r2, [r4, #4]
		if (state == ONOFF_STATE_TO_ON) {
   157f8:	2b06      	cmp	r3, #6
   157fa:	d118      	bne.n	1582e <process_complete+0x78>
	return list->head;
   157fc:	f8dc 3000 	ldr.w	r3, [ip]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   15800:	b13b      	cbz	r3, 15812 <process_complete+0x5c>
				mgr->refs += 1U;
   15802:	8b62      	ldrh	r2, [r4, #26]
   15804:	3201      	adds	r2, #1
   15806:	8362      	strh	r2, [r4, #26]
Z_GENLIST_PEEK_NEXT(slist, snode)
   15808:	2b00      	cmp	r3, #0
   1580a:	d0f9      	beq.n	15800 <process_complete+0x4a>
	return node->next;
   1580c:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   1580e:	2b00      	cmp	r3, #0
   15810:	d1f6      	bne.n	15800 <process_complete+0x4a>
			set_state(mgr, ONOFF_STATE_ON);
   15812:	2102      	movs	r1, #2
   15814:	4620      	mov	r0, r4
   15816:	f7ff ff8e 	bl	15736 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
   1581a:	4620      	mov	r0, r4
   1581c:	f7ff ffb2 	bl	15784 <process_recheck>
   15820:	2800      	cmp	r0, #0
   15822:	d0d5      	beq.n	157d0 <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   15824:	8b23      	ldrh	r3, [r4, #24]
   15826:	f043 0320 	orr.w	r3, r3, #32
   1582a:	8323      	strh	r3, [r4, #24]
   1582c:	e7d0      	b.n	157d0 <process_complete+0x1a>
			set_state(mgr, ONOFF_STATE_OFF);
   1582e:	2100      	movs	r1, #0
   15830:	4620      	mov	r0, r4
   15832:	f7ff ff80 	bl	15736 <set_state>
   15836:	e7f0      	b.n	1581a <process_complete+0x64>
		set_state(mgr, ONOFF_STATE_OFF);
   15838:	2100      	movs	r1, #0
   1583a:	f7ff ff7c 	bl	15736 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
   1583e:	4620      	mov	r0, r4
   15840:	f7ff ffa0 	bl	15784 <process_recheck>
   15844:	2800      	cmp	r0, #0
   15846:	d0c3      	beq.n	157d0 <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   15848:	8b23      	ldrh	r3, [r4, #24]
   1584a:	f043 0320 	orr.w	r3, r3, #32
   1584e:	8323      	strh	r3, [r4, #24]
}
   15850:	e7be      	b.n	157d0 <process_complete+0x1a>

00015852 <validate_args>:
	if ((mgr == NULL) || (cli == NULL)) {
   15852:	b158      	cbz	r0, 1586c <validate_args+0x1a>
{
   15854:	b510      	push	{r4, lr}
   15856:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   15858:	b159      	cbz	r1, 15872 <validate_args+0x20>
	int rv = sys_notify_validate(&cli->notify);
   1585a:	1d08      	adds	r0, r1, #4
   1585c:	f7ff fefd 	bl	1565a <sys_notify_validate>
	if ((rv == 0)
   15860:	b918      	cbnz	r0, 1586a <validate_args+0x18>
	    && ((cli->notify.flags
   15862:	68a3      	ldr	r3, [r4, #8]
   15864:	f033 0303 	bics.w	r3, r3, #3
   15868:	d106      	bne.n	15878 <validate_args+0x26>
}
   1586a:	bd10      	pop	{r4, pc}
		return -EINVAL;
   1586c:	f06f 0015 	mvn.w	r0, #21
}
   15870:	4770      	bx	lr
		return -EINVAL;
   15872:	f06f 0015 	mvn.w	r0, #21
   15876:	e7f8      	b.n	1586a <validate_args+0x18>
		rv = -EINVAL;
   15878:	f06f 0015 	mvn.w	r0, #21
   1587c:	e7f5      	b.n	1586a <validate_args+0x18>

0001587e <notify_one>:
{
   1587e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15882:	4607      	mov	r7, r0
   15884:	460c      	mov	r4, r1
   15886:	4616      	mov	r6, r2
   15888:	461d      	mov	r5, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   1588a:	4619      	mov	r1, r3
   1588c:	1d20      	adds	r0, r4, #4
   1588e:	f7ff ff03 	bl	15698 <sys_notify_finalize>
	if (cb) {
   15892:	b128      	cbz	r0, 158a0 <notify_one+0x22>
   15894:	4680      	mov	r8, r0
		cb(mgr, cli, state, res);
   15896:	462b      	mov	r3, r5
   15898:	4632      	mov	r2, r6
   1589a:	4621      	mov	r1, r4
   1589c:	4638      	mov	r0, r7
   1589e:	47c0      	blx	r8
}
   158a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000158a4 <notify_all>:
{
   158a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   158a8:	4680      	mov	r8, r0
   158aa:	460c      	mov	r4, r1
   158ac:	4617      	mov	r7, r2
   158ae:	461e      	mov	r6, r3
	while (!sys_slist_is_empty(list)) {
   158b0:	e004      	b.n	158bc <notify_all+0x18>
		notify_one(mgr, cli, state, res);
   158b2:	4633      	mov	r3, r6
   158b4:	463a      	mov	r2, r7
   158b6:	4640      	mov	r0, r8
   158b8:	f7ff ffe1 	bl	1587e <notify_one>
	return list->head;
   158bc:	6821      	ldr	r1, [r4, #0]
	while (!sys_slist_is_empty(list)) {
   158be:	b131      	cbz	r1, 158ce <notify_all+0x2a>
	return node->next;
   158c0:	680d      	ldr	r5, [r1, #0]
	list->head = node;
   158c2:	6025      	str	r5, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   158c4:	6863      	ldr	r3, [r4, #4]
   158c6:	428b      	cmp	r3, r1
   158c8:	d1f3      	bne.n	158b2 <notify_all+0xe>
	list->tail = node;
   158ca:	6065      	str	r5, [r4, #4]
}
   158cc:	e7f1      	b.n	158b2 <notify_all+0xe>
}
   158ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000158d2 <transition_complete>:
{
   158d2:	b508      	push	{r3, lr}
	__asm__ volatile(
   158d4:	f04f 0c20 	mov.w	ip, #32
   158d8:	f3ef 8211 	mrs	r2, BASEPRI
   158dc:	f38c 8812 	msr	BASEPRI_MAX, ip
   158e0:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   158e4:	6141      	str	r1, [r0, #20]
	process_event(mgr, EVT_COMPLETE, key);
   158e6:	2101      	movs	r1, #1
   158e8:	f7eb fb3a 	bl	f60 <process_event>
}
   158ec:	bd08      	pop	{r3, pc}

000158ee <onoff_manager_init>:
	if ((mgr == NULL)
   158ee:	4603      	mov	r3, r0
   158f0:	b170      	cbz	r0, 15910 <onoff_manager_init+0x22>
	    || (transitions == NULL)
   158f2:	b181      	cbz	r1, 15916 <onoff_manager_init+0x28>
	    || (transitions->start == NULL)
   158f4:	680a      	ldr	r2, [r1, #0]
   158f6:	b18a      	cbz	r2, 1591c <onoff_manager_init+0x2e>
	    || (transitions->stop == NULL)) {
   158f8:	684a      	ldr	r2, [r1, #4]
   158fa:	b192      	cbz	r2, 15922 <onoff_manager_init+0x34>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   158fc:	2000      	movs	r0, #0
   158fe:	6018      	str	r0, [r3, #0]
   15900:	6058      	str	r0, [r3, #4]
   15902:	6098      	str	r0, [r3, #8]
   15904:	60d8      	str	r0, [r3, #12]
   15906:	6118      	str	r0, [r3, #16]
   15908:	6158      	str	r0, [r3, #20]
   1590a:	6198      	str	r0, [r3, #24]
   1590c:	6119      	str	r1, [r3, #16]
	return 0;
   1590e:	4770      	bx	lr
		return -EINVAL;
   15910:	f06f 0015 	mvn.w	r0, #21
   15914:	4770      	bx	lr
   15916:	f06f 0015 	mvn.w	r0, #21
   1591a:	4770      	bx	lr
   1591c:	f06f 0015 	mvn.w	r0, #21
   15920:	4770      	bx	lr
   15922:	f06f 0015 	mvn.w	r0, #21
}
   15926:	4770      	bx	lr

00015928 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   15928:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1592a:	4604      	mov	r4, r0
   1592c:	460f      	mov	r7, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   1592e:	f7ff ff90 	bl	15852 <validate_args>

	if (rv < 0) {
   15932:	1e06      	subs	r6, r0, #0
   15934:	db37      	blt.n	159a6 <onoff_request+0x7e>
   15936:	f04f 0320 	mov.w	r3, #32
   1593a:	f3ef 8211 	mrs	r2, BASEPRI
   1593e:	f383 8812 	msr	BASEPRI_MAX, r3
   15942:	f3bf 8f6f 	isb	sy
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15946:	8b25      	ldrh	r5, [r4, #24]
   15948:	f005 0507 	and.w	r5, r5, #7

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   1594c:	8b63      	ldrh	r3, [r4, #26]
   1594e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   15952:	428b      	cmp	r3, r1
   15954:	d02f      	beq.n	159b6 <onoff_request+0x8e>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
   15956:	462e      	mov	r6, r5
	if (state == ONOFF_STATE_ON) {
   15958:	2d02      	cmp	r5, #2
   1595a:	d00c      	beq.n	15976 <onoff_request+0x4e>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
	} else if ((state == ONOFF_STATE_OFF)
   1595c:	b18d      	cbz	r5, 15982 <onoff_request+0x5a>
		   || (state == ONOFF_STATE_TO_OFF)
   1595e:	2d04      	cmp	r5, #4
   15960:	d00f      	beq.n	15982 <onoff_request+0x5a>
		   || (state == ONOFF_STATE_TO_ON)) {
   15962:	2d06      	cmp	r5, #6
   15964:	d00d      	beq.n	15982 <onoff_request+0x5a>
		/* Start if OFF, queue client */
		start = (state == ONOFF_STATE_OFF);
		add_client = true;
	} else if (state == ONOFF_STATE_RESETTING) {
   15966:	2d05      	cmp	r5, #5
   15968:	d01f      	beq.n	159aa <onoff_request+0x82>
		rv = -ENOTSUP;
	} else {
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
		rv = -EIO;
   1596a:	f06f 0604 	mvn.w	r6, #4
	bool notify = false;            /* do client notification */
   1596e:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
   15970:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
   15972:	4608      	mov	r0, r1
   15974:	e00a      	b.n	1598c <onoff_request+0x64>
		mgr->refs += 1U;
   15976:	3301      	adds	r3, #1
   15978:	8363      	strh	r3, [r4, #26]
		notify = true;
   1597a:	2101      	movs	r1, #1
	bool start = false;             /* trigger a start transition */
   1597c:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
   1597e:	4618      	mov	r0, r3
   15980:	e004      	b.n	1598c <onoff_request+0x64>
		start = (state == ONOFF_STATE_OFF);
   15982:	fab5 f385 	clz	r3, r5
   15986:	095b      	lsrs	r3, r3, #5
	bool notify = false;            /* do client notification */
   15988:	2100      	movs	r1, #0
		add_client = true;
   1598a:	2001      	movs	r0, #1
	}

out:
	if (add_client) {
   1598c:	b128      	cbz	r0, 1599a <onoff_request+0x72>
	parent->next = child;
   1598e:	2000      	movs	r0, #0
   15990:	6038      	str	r0, [r7, #0]
	return list->tail;
   15992:	6860      	ldr	r0, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
   15994:	b1a8      	cbz	r0, 159c2 <onoff_request+0x9a>
	parent->next = child;
   15996:	6007      	str	r7, [r0, #0]
	list->tail = node;
   15998:	6067      	str	r7, [r4, #4]
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
   1599a:	b9ab      	cbnz	r3, 159c8 <onoff_request+0xa0>
	__asm__ volatile(
   1599c:	f382 8811 	msr	BASEPRI, r2
   159a0:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   159a4:	b9a9      	cbnz	r1, 159d2 <onoff_request+0xaa>
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
   159a6:	4630      	mov	r0, r6
   159a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rv = -ENOTSUP;
   159aa:	f06f 0685 	mvn.w	r6, #133	; 0x85
	bool notify = false;            /* do client notification */
   159ae:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
   159b0:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
   159b2:	4608      	mov	r0, r1
   159b4:	e7ea      	b.n	1598c <onoff_request+0x64>
		rv = -EAGAIN;
   159b6:	f06f 060a 	mvn.w	r6, #10
	bool notify = false;            /* do client notification */
   159ba:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
   159bc:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
   159be:	4608      	mov	r0, r1
   159c0:	e7e4      	b.n	1598c <onoff_request+0x64>
   159c2:	6067      	str	r7, [r4, #4]
	list->head = node;
   159c4:	6027      	str	r7, [r4, #0]
}
   159c6:	e7e8      	b.n	1599a <onoff_request+0x72>
		process_event(mgr, EVT_RECHECK, key);
   159c8:	2102      	movs	r1, #2
   159ca:	4620      	mov	r0, r4
   159cc:	f7eb fac8 	bl	f60 <process_event>
   159d0:	e7e9      	b.n	159a6 <onoff_request+0x7e>
			notify_one(mgr, cli, state, 0);
   159d2:	2300      	movs	r3, #0
   159d4:	462a      	mov	r2, r5
   159d6:	4639      	mov	r1, r7
   159d8:	4620      	mov	r0, r4
   159da:	f7ff ff50 	bl	1587e <notify_one>
   159de:	e7e2      	b.n	159a6 <onoff_request+0x7e>

000159e0 <onoff_sync_lock>:
	__asm__ volatile(
   159e0:	f04f 0220 	mov.w	r2, #32
   159e4:	f3ef 8311 	mrs	r3, BASEPRI
   159e8:	f382 8812 	msr	BASEPRI_MAX, r2
   159ec:	f3bf 8f6f 	isb	sy
}

int onoff_sync_lock(struct onoff_sync_service *srv,
		    k_spinlock_key_t *keyp)
{
	*keyp = k_spin_lock(&srv->lock);
   159f0:	600b      	str	r3, [r1, #0]
	return srv->count;
}
   159f2:	6800      	ldr	r0, [r0, #0]
   159f4:	4770      	bx	lr

000159f6 <onoff_sync_finalize>:
int onoff_sync_finalize(struct onoff_sync_service *srv,
			k_spinlock_key_t key,
			struct onoff_client *cli,
			int res,
			bool on)
{
   159f6:	b510      	push	{r4, lr}
   159f8:	468c      	mov	ip, r1
   159fa:	4611      	mov	r1, r2
   159fc:	f89d 4008 	ldrb.w	r4, [sp, #8]

	/* Clear errors visible when locked.  If they are to be
	 * preserved the caller must finalize with the previous
	 * error code.
	 */
	if (srv->count < 0) {
   15a00:	6802      	ldr	r2, [r0, #0]
   15a02:	2a00      	cmp	r2, #0
   15a04:	db07      	blt.n	15a16 <onoff_sync_finalize+0x20>
		srv->count = 0;
	}
	if (res < 0) {
   15a06:	2b00      	cmp	r3, #0
   15a08:	db08      	blt.n	15a1c <onoff_sync_finalize+0x26>
		srv->count = res;
		state = ONOFF_STATE_ERROR;
	} else if (on) {
   15a0a:	b1a4      	cbz	r4, 15a36 <onoff_sync_finalize+0x40>
		srv->count += 1;
   15a0c:	6802      	ldr	r2, [r0, #0]
   15a0e:	3201      	adds	r2, #1
   15a10:	6002      	str	r2, [r0, #0]
	uint32_t state = ONOFF_STATE_ON;
   15a12:	2202      	movs	r2, #2
   15a14:	e004      	b.n	15a20 <onoff_sync_finalize+0x2a>
		srv->count = 0;
   15a16:	2200      	movs	r2, #0
   15a18:	6002      	str	r2, [r0, #0]
   15a1a:	e7f4      	b.n	15a06 <onoff_sync_finalize+0x10>
		srv->count = res;
   15a1c:	6003      	str	r3, [r0, #0]
		state = ONOFF_STATE_ERROR;
   15a1e:	2201      	movs	r2, #1
		 * callbacks are used only when turning on don't
		 * bother changing it.
		 */
	}

	int rv = srv->count;
   15a20:	6804      	ldr	r4, [r0, #0]
	__asm__ volatile(
   15a22:	f38c 8811 	msr	BASEPRI, ip
   15a26:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&srv->lock, key);

	if (cli) {
   15a2a:	b111      	cbz	r1, 15a32 <onoff_sync_finalize+0x3c>
		/* Detect service mis-use: onoff does not callback on transition
		 * to off, so no client should have been passed.
		 */
		__ASSERT_NO_MSG(on);
		notify_one(NULL, cli, state, res);
   15a2c:	2000      	movs	r0, #0
   15a2e:	f7ff ff26 	bl	1587e <notify_one>
	}

	return rv;
}
   15a32:	4620      	mov	r0, r4
   15a34:	bd10      	pop	{r4, pc}
		srv->count -= 1;
   15a36:	6802      	ldr	r2, [r0, #0]
   15a38:	3a01      	subs	r2, #1
   15a3a:	6002      	str	r2, [r0, #0]
	uint32_t state = ONOFF_STATE_ON;
   15a3c:	2202      	movs	r2, #2
   15a3e:	e7ef      	b.n	15a20 <onoff_sync_finalize+0x2a>

00015a40 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   15a40:	b508      	push	{r3, lr}
   15a42:	4604      	mov	r4, r0
   15a44:	4608      	mov	r0, r1
   15a46:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   15a48:	461a      	mov	r2, r3
   15a4a:	47a0      	blx	r4
	return z_impl_z_current_get();
   15a4c:	f7fe fe98 	bl	14780 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   15a50:	f7ef fb58 	bl	5104 <z_impl_k_thread_abort>

00015a54 <chunk_mem>:
#endif

static void *chunk_mem(struct z_heap *h, chunkid_t c)
{
	chunk_unit_t *buf = chunk_buf(h);
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   15a54:	00c9      	lsls	r1, r1, #3
	return big_heap_chunks(bytes / CHUNK_UNIT);
}

static inline bool big_heap(struct z_heap *h)
{
	return big_heap_chunks(h->end_chunk);
   15a56:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
   15a58:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15a5c:	d303      	bcc.n	15a66 <chunk_mem+0x12>
   15a5e:	2308      	movs	r3, #8
   15a60:	4419      	add	r1, r3

	CHECK(!(((uintptr_t)ret) & (big_heap(h) ? 7 : 3)));

	return ret;
}
   15a62:	4408      	add	r0, r1
   15a64:	4770      	bx	lr
   15a66:	2304      	movs	r3, #4
   15a68:	e7fa      	b.n	15a60 <chunk_mem+0xc>

00015a6a <free_list_remove_bidx>:

static void free_list_remove_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
   15a6a:	b410      	push	{r4}
	void *cmem = &buf[c];
   15a6c:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
   15a70:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   15a72:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15a76:	d319      	bcc.n	15aac <free_list_remove_bidx+0x42>
		return ((uint32_t *)cmem)[f];
   15a78:	f8dc 300c 	ldr.w	r3, [ip, #12]

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & BIT(bidx));

	if (next_free_chunk(h, c) == c) {
   15a7c:	4299      	cmp	r1, r3
   15a7e:	d018      	beq.n	15ab2 <free_list_remove_bidx+0x48>
	if (big_heap(h)) {
   15a80:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15a84:	d322      	bcc.n	15acc <free_list_remove_bidx+0x62>
		return ((uint32_t *)cmem)[f];
   15a86:	f8dc 1008 	ldr.w	r1, [ip, #8]
		b->next = 0;
	} else {
		chunkid_t first = prev_free_chunk(h, c),
			  second = next_free_chunk(h, c);

		b->next = second;
   15a8a:	3204      	adds	r2, #4
   15a8c:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	void *cmem = &buf[c];
   15a90:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
	if (big_heap(h)) {
   15a94:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15a98:	d31b      	bcc.n	15ad2 <free_list_remove_bidx+0x68>
		((uint32_t *)cmem)[f] = val;
   15a9a:	60d3      	str	r3, [r2, #12]
	void *cmem = &buf[c];
   15a9c:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
	return big_heap_chunks(h->end_chunk);
   15aa0:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
   15aa2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15aa6:	d316      	bcc.n	15ad6 <free_list_remove_bidx+0x6c>
		((uint32_t *)cmem)[f] = val;
   15aa8:	6099      	str	r1, [r3, #8]
   15aaa:	e00d      	b.n	15ac8 <free_list_remove_bidx+0x5e>
		return ((uint16_t *)cmem)[f];
   15aac:	f8bc 3006 	ldrh.w	r3, [ip, #6]
   15ab0:	e7e4      	b.n	15a7c <free_list_remove_bidx+0x12>
		h->avail_buckets &= ~BIT(bidx);
   15ab2:	2301      	movs	r3, #1
   15ab4:	fa03 f102 	lsl.w	r1, r3, r2
   15ab8:	68c3      	ldr	r3, [r0, #12]
   15aba:	ea23 0301 	bic.w	r3, r3, r1
   15abe:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   15ac0:	3204      	adds	r2, #4
   15ac2:	2300      	movs	r3, #0
   15ac4:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes -= chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
   15ac8:	bc10      	pop	{r4}
   15aca:	4770      	bx	lr
   15acc:	f8bc 1004 	ldrh.w	r1, [ip, #4]
   15ad0:	e7db      	b.n	15a8a <free_list_remove_bidx+0x20>
		((uint16_t *)cmem)[f] = val;
   15ad2:	80d3      	strh	r3, [r2, #6]
   15ad4:	e7e2      	b.n	15a9c <free_list_remove_bidx+0x32>
   15ad6:	8099      	strh	r1, [r3, #4]
   15ad8:	e7f6      	b.n	15ac8 <free_list_remove_bidx+0x5e>

00015ada <free_list_add_bidx>:

static void free_list_add_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
	struct z_heap_bucket *b = &h->buckets[bidx];

	if (b->next == 0U) {
   15ada:	1d13      	adds	r3, r2, #4
   15adc:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   15ae0:	b9d3      	cbnz	r3, 15b18 <free_list_add_bidx+0x3e>
		CHECK((h->avail_buckets & BIT(bidx)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= BIT(bidx);
   15ae2:	2301      	movs	r3, #1
   15ae4:	fa03 fc02 	lsl.w	ip, r3, r2
   15ae8:	68c3      	ldr	r3, [r0, #12]
   15aea:	ea43 030c 	orr.w	r3, r3, ip
   15aee:	60c3      	str	r3, [r0, #12]
		b->next = c;
   15af0:	3204      	adds	r2, #4
   15af2:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
	void *cmem = &buf[c];
   15af6:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
   15afa:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
   15afc:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15b00:	d306      	bcc.n	15b10 <free_list_add_bidx+0x36>
		((uint32_t *)cmem)[f] = val;
   15b02:	6099      	str	r1, [r3, #8]
	return big_heap_chunks(h->end_chunk);
   15b04:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
   15b06:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15b0a:	d303      	bcc.n	15b14 <free_list_add_bidx+0x3a>
		((uint32_t *)cmem)[f] = val;
   15b0c:	60d9      	str	r1, [r3, #12]
   15b0e:	4770      	bx	lr
		((uint16_t *)cmem)[f] = val;
   15b10:	8099      	strh	r1, [r3, #4]
   15b12:	e7f7      	b.n	15b04 <free_list_add_bidx+0x2a>
   15b14:	80d9      	strh	r1, [r3, #6]
   15b16:	4770      	bx	lr
{
   15b18:	b510      	push	{r4, lr}
	void *cmem = &buf[c];
   15b1a:	eb00 0cc3 	add.w	ip, r0, r3, lsl #3
	return big_heap_chunks(h->end_chunk);
   15b1e:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   15b20:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15b24:	d31c      	bcc.n	15b60 <free_list_add_bidx+0x86>
		return ((uint32_t *)cmem)[f];
   15b26:	f8dc 2008 	ldr.w	r2, [ip, #8]
	void *cmem = &buf[c];
   15b2a:	eb00 0ec1 	add.w	lr, r0, r1, lsl #3
	if (big_heap(h)) {
   15b2e:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15b32:	d318      	bcc.n	15b66 <free_list_add_bidx+0x8c>
		((uint32_t *)cmem)[f] = val;
   15b34:	f8ce 2008 	str.w	r2, [lr, #8]
	return big_heap_chunks(h->end_chunk);
   15b38:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   15b3a:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15b3e:	d315      	bcc.n	15b6c <free_list_add_bidx+0x92>
		((uint32_t *)cmem)[f] = val;
   15b40:	f8ce 300c 	str.w	r3, [lr, #12]
	void *cmem = &buf[c];
   15b44:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
	return big_heap_chunks(h->end_chunk);
   15b48:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
   15b4a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15b4e:	d310      	bcc.n	15b72 <free_list_add_bidx+0x98>
		((uint32_t *)cmem)[f] = val;
   15b50:	60d1      	str	r1, [r2, #12]
	return big_heap_chunks(h->end_chunk);
   15b52:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
   15b54:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15b58:	d30d      	bcc.n	15b76 <free_list_add_bidx+0x9c>
		((uint32_t *)cmem)[f] = val;
   15b5a:	f8cc 1008 	str.w	r1, [ip, #8]
	}

#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}
   15b5e:	bd10      	pop	{r4, pc}
		return ((uint16_t *)cmem)[f];
   15b60:	f8bc 2004 	ldrh.w	r2, [ip, #4]
   15b64:	e7e1      	b.n	15b2a <free_list_add_bidx+0x50>
		((uint16_t *)cmem)[f] = val;
   15b66:	f8ae 2004 	strh.w	r2, [lr, #4]
   15b6a:	e7e5      	b.n	15b38 <free_list_add_bidx+0x5e>
   15b6c:	f8ae 3006 	strh.w	r3, [lr, #6]
   15b70:	e7e8      	b.n	15b44 <free_list_add_bidx+0x6a>
   15b72:	80d1      	strh	r1, [r2, #6]
   15b74:	e7ed      	b.n	15b52 <free_list_add_bidx+0x78>
   15b76:	f8ac 1004 	strh.w	r1, [ip, #4]
   15b7a:	e7f0      	b.n	15b5e <free_list_add_bidx+0x84>

00015b7c <split_chunks>:

/* Splits a chunk "lc" into a left chunk and a right chunk at "rc".
 * Leaves both chunks marked "free"
 */
static void split_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
   15b7c:	b430      	push	{r4, r5}
	void *cmem = &buf[c];
   15b7e:	eb00 0cc1 	add.w	ip, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
   15b82:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   15b84:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15b88:	d329      	bcc.n	15bde <split_chunks+0x62>
		return ((uint32_t *)cmem)[f];
   15b8a:	f8dc 5004 	ldr.w	r5, [ip, #4]
	CHECK(rc > lc);
	CHECK(rc - lc < chunk_size(h, lc));

	chunksz_t sz0 = chunk_size(h, lc);
	chunksz_t lsz = rc - lc;
   15b8e:	1a53      	subs	r3, r2, r1
	chunksz_t rsz = sz0 - lsz;
   15b90:	1a89      	subs	r1, r1, r2
   15b92:	eb01 0155 	add.w	r1, r1, r5, lsr #1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   15b96:	005d      	lsls	r5, r3, #1
	if (big_heap(h)) {
   15b98:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15b9c:	d322      	bcc.n	15be4 <split_chunks+0x68>
		((uint32_t *)cmem)[f] = val;
   15b9e:	f8cc 5004 	str.w	r5, [ip, #4]
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   15ba2:	004c      	lsls	r4, r1, #1
	void *cmem = &buf[c];
   15ba4:	eb00 0cc2 	add.w	ip, r0, r2, lsl #3
	if (big_heap(h)) {
   15ba8:	6885      	ldr	r5, [r0, #8]
   15baa:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   15bae:	d31c      	bcc.n	15bea <split_chunks+0x6e>
		((uint32_t *)cmem)[f] = val;
   15bb0:	f8cc 4004 	str.w	r4, [ip, #4]
	return big_heap_chunks(h->end_chunk);
   15bb4:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   15bb6:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15bba:	d319      	bcc.n	15bf0 <split_chunks+0x74>
		((uint32_t *)cmem)[f] = val;
   15bbc:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
	return big_heap_chunks(h->end_chunk);
   15bc0:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
   15bc2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15bc6:	d316      	bcc.n	15bf6 <split_chunks+0x7a>
		return ((uint32_t *)cmem)[f];
   15bc8:	f8dc 4004 	ldr.w	r4, [ip, #4]
	return c + chunk_size(h, c);
   15bcc:	eb02 0254 	add.w	r2, r2, r4, lsr #1
	if (big_heap(h)) {
   15bd0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15bd4:	d312      	bcc.n	15bfc <split_chunks+0x80>
		((uint32_t *)cmem)[f] = val;
   15bd6:	f840 1032 	str.w	r1, [r0, r2, lsl #3]

	set_chunk_size(h, lc, lsz);
	set_chunk_size(h, rc, rsz);
	set_left_chunk_size(h, rc, lsz);
	set_left_chunk_size(h, right_chunk(h, rc), rsz);
}
   15bda:	bc30      	pop	{r4, r5}
   15bdc:	4770      	bx	lr
		return ((uint16_t *)cmem)[f];
   15bde:	f8bc 5002 	ldrh.w	r5, [ip, #2]
   15be2:	e7d4      	b.n	15b8e <split_chunks+0x12>
		((uint16_t *)cmem)[f] = val;
   15be4:	f8ac 5002 	strh.w	r5, [ip, #2]
   15be8:	e7db      	b.n	15ba2 <split_chunks+0x26>
   15bea:	f8ac 4002 	strh.w	r4, [ip, #2]
   15bee:	e7e1      	b.n	15bb4 <split_chunks+0x38>
   15bf0:	f820 3032 	strh.w	r3, [r0, r2, lsl #3]
   15bf4:	e7e4      	b.n	15bc0 <split_chunks+0x44>
		return ((uint16_t *)cmem)[f];
   15bf6:	f8bc 4002 	ldrh.w	r4, [ip, #2]
   15bfa:	e7e7      	b.n	15bcc <split_chunks+0x50>
		((uint16_t *)cmem)[f] = val;
   15bfc:	f820 1032 	strh.w	r1, [r0, r2, lsl #3]
   15c00:	e7eb      	b.n	15bda <split_chunks+0x5e>

00015c02 <merge_chunks>:

/* Does not modify free list */
static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
   15c02:	b430      	push	{r4, r5}
	void *cmem = &buf[c];
   15c04:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
   15c08:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   15c0a:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15c0e:	d31e      	bcc.n	15c4e <merge_chunks+0x4c>
		return ((uint32_t *)cmem)[f];
   15c10:	684b      	ldr	r3, [r1, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   15c12:	085b      	lsrs	r3, r3, #1
	void *cmem = &buf[c];
   15c14:	eb00 0cc2 	add.w	ip, r0, r2, lsl #3
	if (big_heap(h)) {
   15c18:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15c1c:	d319      	bcc.n	15c52 <merge_chunks+0x50>
		return ((uint32_t *)cmem)[f];
   15c1e:	f8dc 5004 	ldr.w	r5, [ip, #4]
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   15c22:	eb03 0355 	add.w	r3, r3, r5, lsr #1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   15c26:	005d      	lsls	r5, r3, #1
	if (big_heap(h)) {
   15c28:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   15c2c:	d314      	bcc.n	15c58 <merge_chunks+0x56>
		((uint32_t *)cmem)[f] = val;
   15c2e:	604d      	str	r5, [r1, #4]
	return big_heap_chunks(h->end_chunk);
   15c30:	6881      	ldr	r1, [r0, #8]
	if (big_heap(h)) {
   15c32:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   15c36:	d311      	bcc.n	15c5c <merge_chunks+0x5a>
		return ((uint32_t *)cmem)[f];
   15c38:	f8dc 4004 	ldr.w	r4, [ip, #4]
	return c + chunk_size(h, c);
   15c3c:	eb02 0254 	add.w	r2, r2, r4, lsr #1
	if (big_heap(h)) {
   15c40:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   15c44:	d30d      	bcc.n	15c62 <merge_chunks+0x60>
		((uint32_t *)cmem)[f] = val;
   15c46:	f840 3032 	str.w	r3, [r0, r2, lsl #3]

	set_chunk_size(h, lc, newsz);
	set_left_chunk_size(h, right_chunk(h, rc), newsz);
}
   15c4a:	bc30      	pop	{r4, r5}
   15c4c:	4770      	bx	lr
		return ((uint16_t *)cmem)[f];
   15c4e:	884b      	ldrh	r3, [r1, #2]
   15c50:	e7df      	b.n	15c12 <merge_chunks+0x10>
   15c52:	f8bc 5002 	ldrh.w	r5, [ip, #2]
   15c56:	e7e4      	b.n	15c22 <merge_chunks+0x20>
		((uint16_t *)cmem)[f] = val;
   15c58:	804d      	strh	r5, [r1, #2]
   15c5a:	e7e9      	b.n	15c30 <merge_chunks+0x2e>
		return ((uint16_t *)cmem)[f];
   15c5c:	f8bc 4002 	ldrh.w	r4, [ip, #2]
   15c60:	e7ec      	b.n	15c3c <merge_chunks+0x3a>
		((uint16_t *)cmem)[f] = val;
   15c62:	f820 3032 	strh.w	r3, [r0, r2, lsl #3]
   15c66:	e7f0      	b.n	15c4a <merge_chunks+0x48>

00015c68 <mem_to_chunkid>:
	return big_heap_chunks(h->end_chunk);
   15c68:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) ? 8 : 4;
   15c6a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15c6e:	d304      	bcc.n	15c7a <mem_to_chunkid+0x12>
   15c70:	2308      	movs	r3, #8
 * boundary.
 */
static chunkid_t mem_to_chunkid(struct z_heap *h, void *p)
{
	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   15c72:	1ac9      	subs	r1, r1, r3
   15c74:	1a08      	subs	r0, r1, r0
}
   15c76:	08c0      	lsrs	r0, r0, #3
   15c78:	4770      	bx	lr
   15c7a:	2304      	movs	r3, #4
   15c7c:	e7f9      	b.n	15c72 <mem_to_chunkid+0xa>

00015c7e <free_list_remove>:
{
   15c7e:	b508      	push	{r3, lr}
	return big_heap_chunks(h->end_chunk);
   15c80:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) && chunk_size(h, c) == 1U;
   15c82:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15c86:	d307      	bcc.n	15c98 <free_list_remove+0x1a>
	void *cmem = &buf[c];
   15c88:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
		return ((uint32_t *)cmem)[f];
   15c8c:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   15c8e:	0852      	lsrs	r2, r2, #1
	return big_heap(h) && chunk_size(h, c) == 1U;
   15c90:	2a01      	cmp	r2, #1
   15c92:	d002      	beq.n	15c9a <free_list_remove+0x1c>
   15c94:	2200      	movs	r2, #0
   15c96:	e000      	b.n	15c9a <free_list_remove+0x1c>
   15c98:	2200      	movs	r2, #0
	if (!solo_free_header(h, c)) {
   15c9a:	b9a2      	cbnz	r2, 15cc6 <free_list_remove+0x48>
	void *cmem = &buf[c];
   15c9c:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
	if (big_heap(h)) {
   15ca0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15ca4:	d310      	bcc.n	15cc8 <free_list_remove+0x4a>
		return ((uint32_t *)cmem)[f];
   15ca6:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   15ca8:	0852      	lsrs	r2, r2, #1
	return big_heap(h) ? 8 : 4;
   15caa:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15cae:	d30d      	bcc.n	15ccc <free_list_remove+0x4e>
   15cb0:	2308      	movs	r3, #8
	return big_heap_bytes(size) ? 8 : 4;
}

static inline chunksz_t chunksz(size_t bytes)
{
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   15cb2:	3308      	adds	r3, #8
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
   15cb4:	eba2 02d3 	sub.w	r2, r2, r3, lsr #3
   15cb8:	3201      	adds	r2, #1
	return 31 - __builtin_clz(usable_sz);
   15cba:	fab2 f282 	clz	r2, r2
		free_list_remove_bidx(h, c, bidx);
   15cbe:	f1c2 021f 	rsb	r2, r2, #31
   15cc2:	f7ff fed2 	bl	15a6a <free_list_remove_bidx>
}
   15cc6:	bd08      	pop	{r3, pc}
		return ((uint16_t *)cmem)[f];
   15cc8:	8852      	ldrh	r2, [r2, #2]
   15cca:	e7ed      	b.n	15ca8 <free_list_remove+0x2a>
	return big_heap(h) ? 8 : 4;
   15ccc:	2304      	movs	r3, #4
   15cce:	e7f0      	b.n	15cb2 <free_list_remove+0x34>

00015cd0 <free_list_add>:
{
   15cd0:	b508      	push	{r3, lr}
	return big_heap_chunks(h->end_chunk);
   15cd2:	6883      	ldr	r3, [r0, #8]
	return big_heap(h) && chunk_size(h, c) == 1U;
   15cd4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15cd8:	d307      	bcc.n	15cea <free_list_add+0x1a>
	void *cmem = &buf[c];
   15cda:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
		return ((uint32_t *)cmem)[f];
   15cde:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   15ce0:	0852      	lsrs	r2, r2, #1
	return big_heap(h) && chunk_size(h, c) == 1U;
   15ce2:	2a01      	cmp	r2, #1
   15ce4:	d002      	beq.n	15cec <free_list_add+0x1c>
   15ce6:	2200      	movs	r2, #0
   15ce8:	e000      	b.n	15cec <free_list_add+0x1c>
   15cea:	2200      	movs	r2, #0
	if (!solo_free_header(h, c)) {
   15cec:	b9a2      	cbnz	r2, 15d18 <free_list_add+0x48>
	void *cmem = &buf[c];
   15cee:	eb00 02c1 	add.w	r2, r0, r1, lsl #3
	if (big_heap(h)) {
   15cf2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15cf6:	d310      	bcc.n	15d1a <free_list_add+0x4a>
		return ((uint32_t *)cmem)[f];
   15cf8:	6852      	ldr	r2, [r2, #4]
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   15cfa:	0852      	lsrs	r2, r2, #1
	return big_heap(h) ? 8 : 4;
   15cfc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15d00:	d30d      	bcc.n	15d1e <free_list_add+0x4e>
   15d02:	2308      	movs	r3, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   15d04:	3308      	adds	r3, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
   15d06:	eba2 02d3 	sub.w	r2, r2, r3, lsr #3
   15d0a:	3201      	adds	r2, #1
	return 31 - __builtin_clz(usable_sz);
   15d0c:	fab2 f282 	clz	r2, r2
		free_list_add_bidx(h, c, bidx);
   15d10:	f1c2 021f 	rsb	r2, r2, #31
   15d14:	f7ff fee1 	bl	15ada <free_list_add_bidx>
}
   15d18:	bd08      	pop	{r3, pc}
		return ((uint16_t *)cmem)[f];
   15d1a:	8852      	ldrh	r2, [r2, #2]
   15d1c:	e7ed      	b.n	15cfa <free_list_add+0x2a>
	return big_heap(h) ? 8 : 4;
   15d1e:	2304      	movs	r3, #4
   15d20:	e7f0      	b.n	15d04 <free_list_add+0x34>

00015d22 <free_chunk>:
{
   15d22:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15d24:	4604      	mov	r4, r0
   15d26:	460d      	mov	r5, r1
	void *cmem = &buf[c];
   15d28:	00ce      	lsls	r6, r1, #3
   15d2a:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
	return big_heap_chunks(h->end_chunk);
   15d2e:	6883      	ldr	r3, [r0, #8]
	if (big_heap(h)) {
   15d30:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15d34:	d31f      	bcc.n	15d76 <free_chunk+0x54>
		return ((uint32_t *)cmem)[f];
   15d36:	6879      	ldr	r1, [r7, #4]
	return c + chunk_size(h, c);
   15d38:	eb05 0151 	add.w	r1, r5, r1, lsr #1
	void *cmem = &buf[c];
   15d3c:	eb04 02c1 	add.w	r2, r4, r1, lsl #3
	if (big_heap(h)) {
   15d40:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15d44:	d319      	bcc.n	15d7a <free_chunk+0x58>
		return ((uint32_t *)cmem)[f];
   15d46:	6853      	ldr	r3, [r2, #4]
	if (!chunk_used(h, right_chunk(h, c))) {
   15d48:	f013 0f01 	tst.w	r3, #1
   15d4c:	d017      	beq.n	15d7e <free_chunk+0x5c>
	return big_heap_chunks(h->end_chunk);
   15d4e:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
   15d50:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15d54:	d324      	bcc.n	15da0 <free_chunk+0x7e>
		return ((uint32_t *)cmem)[f];
   15d56:	59a1      	ldr	r1, [r4, r6]
	return c - chunk_field(h, c, LEFT_SIZE);
   15d58:	1a69      	subs	r1, r5, r1
	void *cmem = &buf[c];
   15d5a:	eb04 02c1 	add.w	r2, r4, r1, lsl #3
	if (big_heap(h)) {
   15d5e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15d62:	d31f      	bcc.n	15da4 <free_chunk+0x82>
		return ((uint32_t *)cmem)[f];
   15d64:	6853      	ldr	r3, [r2, #4]
	if (!chunk_used(h, left_chunk(h, c))) {
   15d66:	f013 0f01 	tst.w	r3, #1
   15d6a:	d01d      	beq.n	15da8 <free_chunk+0x86>
	free_list_add(h, c);
   15d6c:	4629      	mov	r1, r5
   15d6e:	4620      	mov	r0, r4
   15d70:	f7ff ffae 	bl	15cd0 <free_list_add>
}
   15d74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return ((uint16_t *)cmem)[f];
   15d76:	8879      	ldrh	r1, [r7, #2]
   15d78:	e7de      	b.n	15d38 <free_chunk+0x16>
   15d7a:	8853      	ldrh	r3, [r2, #2]
   15d7c:	e7e4      	b.n	15d48 <free_chunk+0x26>
		free_list_remove(h, right_chunk(h, c));
   15d7e:	4620      	mov	r0, r4
   15d80:	f7ff ff7d 	bl	15c7e <free_list_remove>
	return big_heap_chunks(h->end_chunk);
   15d84:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
   15d86:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15d8a:	d307      	bcc.n	15d9c <free_chunk+0x7a>
		return ((uint32_t *)cmem)[f];
   15d8c:	687a      	ldr	r2, [r7, #4]
		merge_chunks(h, c, right_chunk(h, c));
   15d8e:	eb05 0252 	add.w	r2, r5, r2, lsr #1
   15d92:	4629      	mov	r1, r5
   15d94:	4620      	mov	r0, r4
   15d96:	f7ff ff34 	bl	15c02 <merge_chunks>
   15d9a:	e7d8      	b.n	15d4e <free_chunk+0x2c>
		return ((uint16_t *)cmem)[f];
   15d9c:	887a      	ldrh	r2, [r7, #2]
   15d9e:	e7f6      	b.n	15d8e <free_chunk+0x6c>
   15da0:	5ba1      	ldrh	r1, [r4, r6]
   15da2:	e7d9      	b.n	15d58 <free_chunk+0x36>
   15da4:	8853      	ldrh	r3, [r2, #2]
   15da6:	e7de      	b.n	15d66 <free_chunk+0x44>
		free_list_remove(h, left_chunk(h, c));
   15da8:	4620      	mov	r0, r4
   15daa:	f7ff ff68 	bl	15c7e <free_list_remove>
	return big_heap_chunks(h->end_chunk);
   15dae:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
   15db0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15db4:	d30c      	bcc.n	15dd0 <free_chunk+0xae>
		return ((uint32_t *)cmem)[f];
   15db6:	59a1      	ldr	r1, [r4, r6]
		merge_chunks(h, left_chunk(h, c), c);
   15db8:	462a      	mov	r2, r5
   15dba:	1a69      	subs	r1, r5, r1
   15dbc:	4620      	mov	r0, r4
   15dbe:	f7ff ff20 	bl	15c02 <merge_chunks>
	return big_heap_chunks(h->end_chunk);
   15dc2:	68a3      	ldr	r3, [r4, #8]
	if (big_heap(h)) {
   15dc4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15dc8:	d304      	bcc.n	15dd4 <free_chunk+0xb2>
		return ((uint32_t *)cmem)[f];
   15dca:	59a3      	ldr	r3, [r4, r6]
	return c - chunk_field(h, c, LEFT_SIZE);
   15dcc:	1aed      	subs	r5, r5, r3
   15dce:	e7cd      	b.n	15d6c <free_chunk+0x4a>
		return ((uint16_t *)cmem)[f];
   15dd0:	5ba1      	ldrh	r1, [r4, r6]
   15dd2:	e7f1      	b.n	15db8 <free_chunk+0x96>
   15dd4:	5ba3      	ldrh	r3, [r4, r6]
   15dd6:	e7f9      	b.n	15dcc <free_chunk+0xaa>

00015dd8 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   15dd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return big_heap_chunks(h->end_chunk);
   15dda:	6885      	ldr	r5, [r0, #8]
	return big_heap(h) ? 8 : 4;
   15ddc:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   15de0:	d310      	bcc.n	15e04 <alloc_chunk+0x2c>
   15de2:	2308      	movs	r3, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   15de4:	3308      	adds	r3, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
   15de6:	eba1 03d3 	sub.w	r3, r1, r3, lsr #3
   15dea:	3301      	adds	r3, #1
	return 31 - __builtin_clz(usable_sz);
   15dec:	fab3 f383 	clz	r3, r3
   15df0:	f1c3 021f 	rsb	r2, r3, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   15df4:	f1c3 0423 	rsb	r4, r3, #35	; 0x23
   15df8:	f850 6024 	ldr.w	r6, [r0, r4, lsl #2]
   15dfc:	b346      	cbz	r6, 15e50 <alloc_chunk+0x78>
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
   15dfe:	f04f 0c03 	mov.w	ip, #3
   15e02:	e012      	b.n	15e2a <alloc_chunk+0x52>
	return big_heap(h) ? 8 : 4;
   15e04:	2304      	movs	r3, #4
   15e06:	e7ed      	b.n	15de4 <alloc_chunk+0xc>
		return ((uint16_t *)cmem)[f];
   15e08:	f8be 7002 	ldrh.w	r7, [lr, #2]
   15e0c:	e017      	b.n	15e3e <alloc_chunk+0x66>
		do {
			chunkid_t c = b->next;
			if (chunk_size(h, c) >= sz) {
				free_list_remove_bidx(h, c, bi);
   15e0e:	4621      	mov	r1, r4
   15e10:	f7ff fe2b 	bl	15a6a <free_list_remove_bidx>
				return c;
   15e14:	e024      	b.n	15e60 <alloc_chunk+0x88>
   15e16:	f8be 4006 	ldrh.w	r4, [lr, #6]
			}
			b->next = next_free_chunk(h, c);
   15e1a:	1d17      	adds	r7, r2, #4
   15e1c:	f840 4027 	str.w	r4, [r0, r7, lsl #2]
			CHECK(b->next != 0);
		} while (--i && b->next != first);
   15e20:	f1bc 0c01 	subs.w	ip, ip, #1
   15e24:	d014      	beq.n	15e50 <alloc_chunk+0x78>
   15e26:	42a6      	cmp	r6, r4
   15e28:	d012      	beq.n	15e50 <alloc_chunk+0x78>
			chunkid_t c = b->next;
   15e2a:	1d14      	adds	r4, r2, #4
   15e2c:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
	void *cmem = &buf[c];
   15e30:	eb00 0ec4 	add.w	lr, r0, r4, lsl #3
	if (big_heap(h)) {
   15e34:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   15e38:	d3e6      	bcc.n	15e08 <alloc_chunk+0x30>
		return ((uint32_t *)cmem)[f];
   15e3a:	f8de 7004 	ldr.w	r7, [lr, #4]
			if (chunk_size(h, c) >= sz) {
   15e3e:	ebb1 0f57 	cmp.w	r1, r7, lsr #1
   15e42:	d9e4      	bls.n	15e0e <alloc_chunk+0x36>
	if (big_heap(h)) {
   15e44:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   15e48:	d3e5      	bcc.n	15e16 <alloc_chunk+0x3e>
		return ((uint32_t *)cmem)[f];
   15e4a:	f8de 400c 	ldr.w	r4, [lr, #12]
   15e4e:	e7e4      	b.n	15e1a <alloc_chunk+0x42>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   15e50:	68c4      	ldr	r4, [r0, #12]
   15e52:	f1c3 0220 	rsb	r2, r3, #32
   15e56:	2301      	movs	r3, #1
   15e58:	4093      	lsls	r3, r2
   15e5a:	425b      	negs	r3, r3

	if (bmask != 0U) {
   15e5c:	401c      	ands	r4, r3
   15e5e:	d101      	bne.n	15e64 <alloc_chunk+0x8c>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   15e60:	4620      	mov	r0, r4
   15e62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		int minbucket = __builtin_ctz(bmask);
   15e64:	fa94 f2a4 	rbit	r2, r4
   15e68:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   15e6c:	1d13      	adds	r3, r2, #4
   15e6e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   15e72:	4621      	mov	r1, r4
   15e74:	f7ff fdf9 	bl	15a6a <free_list_remove_bidx>
		return c;
   15e78:	e7f2      	b.n	15e60 <alloc_chunk+0x88>

00015e7a <sys_heap_free>:
	if (mem == NULL) {
   15e7a:	b1c1      	cbz	r1, 15eae <sys_heap_free+0x34>
{
   15e7c:	b510      	push	{r4, lr}
	struct z_heap *h = heap->heap;
   15e7e:	6804      	ldr	r4, [r0, #0]
	chunkid_t c = mem_to_chunkid(h, mem);
   15e80:	4620      	mov	r0, r4
   15e82:	f7ff fef1 	bl	15c68 <mem_to_chunkid>
   15e86:	4601      	mov	r1, r0
	void *cmem = &buf[c];
   15e88:	eb04 03c0 	add.w	r3, r4, r0, lsl #3
	return big_heap_chunks(h->end_chunk);
   15e8c:	68a2      	ldr	r2, [r4, #8]
	if (big_heap(h)) {
   15e8e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15e92:	d307      	bcc.n	15ea4 <sys_heap_free+0x2a>
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
   15e94:	685a      	ldr	r2, [r3, #4]
   15e96:	f022 0201 	bic.w	r2, r2, #1
   15e9a:	605a      	str	r2, [r3, #4]
	free_chunk(h, c);
   15e9c:	4620      	mov	r0, r4
   15e9e:	f7ff ff40 	bl	15d22 <free_chunk>
}
   15ea2:	bd10      	pop	{r4, pc}
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   15ea4:	885a      	ldrh	r2, [r3, #2]
   15ea6:	f022 0201 	bic.w	r2, r2, #1
   15eaa:	805a      	strh	r2, [r3, #2]
   15eac:	e7f6      	b.n	15e9c <sys_heap_free+0x22>
   15eae:	4770      	bx	lr

00015eb0 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   15eb0:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   15eb2:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
   15eb4:	2900      	cmp	r1, #0
   15eb6:	d03e      	beq.n	15f36 <sys_heap_alloc+0x86>
   15eb8:	460b      	mov	r3, r1
{
	/*
	 * Quick check to bail out early if size is too big.
	 * Also guards against potential arithmetic overflows elsewhere.
	 */
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
   15eba:	68aa      	ldr	r2, [r5, #8]
   15ebc:	ebb2 0fd1 	cmp.w	r2, r1, lsr #3
   15ec0:	d93b      	bls.n	15f3a <sys_heap_alloc+0x8a>
	return big_heap(h) ? 8 : 4;
   15ec2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15ec6:	d322      	bcc.n	15f0e <sys_heap_alloc+0x5e>
   15ec8:	2408      	movs	r4, #8
	return chunksz(chunk_header_bytes(h) + bytes);
   15eca:	441c      	add	r4, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   15ecc:	3407      	adds	r4, #7
   15ece:	08e4      	lsrs	r4, r4, #3
		return NULL;
	}

	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
	chunkid_t c = alloc_chunk(h, chunk_sz);
   15ed0:	4621      	mov	r1, r4
   15ed2:	4628      	mov	r0, r5
   15ed4:	f7ff ff80 	bl	15dd8 <alloc_chunk>
	if (c == 0U) {
   15ed8:	4606      	mov	r6, r0
   15eda:	b380      	cbz	r0, 15f3e <sys_heap_alloc+0x8e>
	void *cmem = &buf[c];
   15edc:	eb05 03c0 	add.w	r3, r5, r0, lsl #3
	return big_heap_chunks(h->end_chunk);
   15ee0:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
   15ee2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15ee6:	d314      	bcc.n	15f12 <sys_heap_alloc+0x62>
		return ((uint32_t *)cmem)[f];
   15ee8:	685b      	ldr	r3, [r3, #4]
		return NULL;
	}

	/* Split off remainder if any */
	if (chunk_size(h, c) > chunk_sz) {
   15eea:	ebb4 0f53 	cmp.w	r4, r3, lsr #1
   15eee:	d312      	bcc.n	15f16 <sys_heap_alloc+0x66>
	void *cmem = &buf[c];
   15ef0:	eb05 03c6 	add.w	r3, r5, r6, lsl #3
	return big_heap_chunks(h->end_chunk);
   15ef4:	68aa      	ldr	r2, [r5, #8]
	if (big_heap(h)) {
   15ef6:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15efa:	d317      	bcc.n	15f2c <sys_heap_alloc+0x7c>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   15efc:	685a      	ldr	r2, [r3, #4]
   15efe:	f042 0201 	orr.w	r2, r2, #1
   15f02:	605a      	str	r2, [r3, #4]
		free_list_add(h, c + chunk_sz);
	}

	set_chunk_used(h, c, true);

	mem = chunk_mem(h, c);
   15f04:	4631      	mov	r1, r6
   15f06:	4628      	mov	r0, r5
   15f08:	f7ff fda4 	bl	15a54 <chunk_mem>
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
   15f0c:	bd70      	pop	{r4, r5, r6, pc}
	return big_heap(h) ? 8 : 4;
   15f0e:	2404      	movs	r4, #4
   15f10:	e7db      	b.n	15eca <sys_heap_alloc+0x1a>
		return ((uint16_t *)cmem)[f];
   15f12:	885b      	ldrh	r3, [r3, #2]
   15f14:	e7e9      	b.n	15eea <sys_heap_alloc+0x3a>
		split_chunks(h, c, c + chunk_sz);
   15f16:	4434      	add	r4, r6
   15f18:	4622      	mov	r2, r4
   15f1a:	4631      	mov	r1, r6
   15f1c:	4628      	mov	r0, r5
   15f1e:	f7ff fe2d 	bl	15b7c <split_chunks>
		free_list_add(h, c + chunk_sz);
   15f22:	4621      	mov	r1, r4
   15f24:	4628      	mov	r0, r5
   15f26:	f7ff fed3 	bl	15cd0 <free_list_add>
   15f2a:	e7e1      	b.n	15ef0 <sys_heap_alloc+0x40>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   15f2c:	885a      	ldrh	r2, [r3, #2]
   15f2e:	f042 0201 	orr.w	r2, r2, #1
   15f32:	805a      	strh	r2, [r3, #2]
   15f34:	e7e6      	b.n	15f04 <sys_heap_alloc+0x54>
		return NULL;
   15f36:	2000      	movs	r0, #0
   15f38:	e7e8      	b.n	15f0c <sys_heap_alloc+0x5c>
   15f3a:	2000      	movs	r0, #0
   15f3c:	e7e6      	b.n	15f0c <sys_heap_alloc+0x5c>
		return NULL;
   15f3e:	2000      	movs	r0, #0
   15f40:	e7e4      	b.n	15f0c <sys_heap_alloc+0x5c>

00015f42 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   15f42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15f46:	460d      	mov	r5, r1
   15f48:	4614      	mov	r4, r2
	struct z_heap *h = heap->heap;
   15f4a:	6806      	ldr	r6, [r0, #0]
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   15f4c:	424b      	negs	r3, r1
   15f4e:	ea03 0801 	and.w	r8, r3, r1
	if (align != rew) {
   15f52:	ea31 0303 	bics.w	r3, r1, r3
   15f56:	d052      	beq.n	15ffe <sys_heap_aligned_alloc+0xbc>
		align -= rew;
   15f58:	eba1 0508 	sub.w	r5, r1, r8
	return big_heap_chunks(h->end_chunk);
   15f5c:	68b3      	ldr	r3, [r6, #8]
	return big_heap(h) ? 8 : 4;
   15f5e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15f62:	d34a      	bcc.n	15ffa <sys_heap_aligned_alloc+0xb8>
   15f64:	2308      	movs	r3, #8
		gap = MIN(rew, chunk_header_bytes(h));
   15f66:	4598      	cmp	r8, r3
   15f68:	d200      	bcs.n	15f6c <sys_heap_aligned_alloc+0x2a>
   15f6a:	4643      	mov	r3, r8
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   15f6c:	2c00      	cmp	r4, #0
   15f6e:	d076      	beq.n	1605e <sys_heap_aligned_alloc+0x11c>
	return (bytes / CHUNK_UNIT) >= h->end_chunk;
   15f70:	68b2      	ldr	r2, [r6, #8]
   15f72:	ebb2 0fd4 	cmp.w	r2, r4, lsr #3
   15f76:	d974      	bls.n	16062 <sys_heap_aligned_alloc+0x120>
	/*
	 * Find a free block that is guaranteed to fit.
	 * We over-allocate to account for alignment and then free
	 * the extra allocations afterwards.
	 */
	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
   15f78:	1929      	adds	r1, r5, r4
   15f7a:	1ac9      	subs	r1, r1, r3
	return big_heap(h) ? 8 : 4;
   15f7c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   15f80:	d34e      	bcc.n	16020 <sys_heap_aligned_alloc+0xde>
   15f82:	2308      	movs	r3, #8
	return chunksz(chunk_header_bytes(h) + bytes);
   15f84:	4419      	add	r1, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   15f86:	3107      	adds	r1, #7
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   15f88:	08c9      	lsrs	r1, r1, #3
   15f8a:	4630      	mov	r0, r6
   15f8c:	f7ff ff24 	bl	15dd8 <alloc_chunk>

	if (c0 == 0) {
   15f90:	4607      	mov	r7, r0
   15f92:	2800      	cmp	r0, #0
   15f94:	d067      	beq.n	16066 <sys_heap_aligned_alloc+0x124>
		return NULL;
	}
	uint8_t *mem = chunk_mem(h, c0);
   15f96:	4601      	mov	r1, r0
   15f98:	4630      	mov	r0, r6
   15f9a:	f7ff fd5b 	bl	15a54 <chunk_mem>

	/* Align allocated memory */
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   15f9e:	4440      	add	r0, r8
   15fa0:	4428      	add	r0, r5
   15fa2:	3801      	subs	r0, #1
   15fa4:	426d      	negs	r5, r5
   15fa6:	4005      	ands	r5, r0
   15fa8:	eba5 0508 	sub.w	r5, r5, r8
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   15fac:	442c      	add	r4, r5
   15fae:	3407      	adds	r4, #7
   15fb0:	f024 0407 	bic.w	r4, r4, #7

	/* Get corresponding chunks */
	chunkid_t c = mem_to_chunkid(h, mem);
   15fb4:	4629      	mov	r1, r5
   15fb6:	4630      	mov	r0, r6
   15fb8:	f7ff fe56 	bl	15c68 <mem_to_chunkid>
   15fbc:	4680      	mov	r8, r0
	chunkid_t c_end = end - chunk_buf(h);
   15fbe:	1ba4      	subs	r4, r4, r6
   15fc0:	10e4      	asrs	r4, r4, #3
	CHECK(c >= c0 && c  < c_end && c_end <= c0 + padded_sz);

	/* Split and free unused prefix */
	if (c > c0) {
   15fc2:	4287      	cmp	r7, r0
   15fc4:	d32e      	bcc.n	16024 <sys_heap_aligned_alloc+0xe2>
	void *cmem = &buf[c];
   15fc6:	eb06 02c8 	add.w	r2, r6, r8, lsl #3
	return big_heap_chunks(h->end_chunk);
   15fca:	68b3      	ldr	r3, [r6, #8]
	if (big_heap(h)) {
   15fcc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15fd0:	d332      	bcc.n	16038 <sys_heap_aligned_alloc+0xf6>
		return ((uint32_t *)cmem)[f];
   15fd2:	6853      	ldr	r3, [r2, #4]
	return c + chunk_size(h, c);
   15fd4:	eb08 0353 	add.w	r3, r8, r3, lsr #1
		split_chunks(h, c0, c);
		free_list_add(h, c0);
	}

	/* Split and free unused suffix */
	if (right_chunk(h, c) > c_end) {
   15fd8:	429c      	cmp	r4, r3
   15fda:	d32f      	bcc.n	1603c <sys_heap_aligned_alloc+0xfa>
	void *cmem = &buf[c];
   15fdc:	eb06 08c8 	add.w	r8, r6, r8, lsl #3
	return big_heap_chunks(h->end_chunk);
   15fe0:	68b3      	ldr	r3, [r6, #8]
	if (big_heap(h)) {
   15fe2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   15fe6:	d333      	bcc.n	16050 <sys_heap_aligned_alloc+0x10e>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   15fe8:	f8d8 3004 	ldr.w	r3, [r8, #4]
   15fec:	f043 0301 	orr.w	r3, r3, #1
   15ff0:	f8c8 3004 	str.w	r3, [r8, #4]
	heap_listener_notify_alloc(HEAP_ID_FROM_POINTER(heap), mem,
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	return mem;
}
   15ff4:	4628      	mov	r0, r5
   15ff6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return big_heap(h) ? 8 : 4;
   15ffa:	2304      	movs	r3, #4
   15ffc:	e7b3      	b.n	15f66 <sys_heap_aligned_alloc+0x24>
	return big_heap_chunks(h->end_chunk);
   15ffe:	68b3      	ldr	r3, [r6, #8]
	return big_heap(h) ? 8 : 4;
   16000:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   16004:	d305      	bcc.n	16012 <sys_heap_aligned_alloc+0xd0>
   16006:	2308      	movs	r3, #8
		if (align <= chunk_header_bytes(h)) {
   16008:	429d      	cmp	r5, r3
   1600a:	d904      	bls.n	16016 <sys_heap_aligned_alloc+0xd4>
		rew = 0;
   1600c:	f04f 0800 	mov.w	r8, #0
   16010:	e7ac      	b.n	15f6c <sys_heap_aligned_alloc+0x2a>
   16012:	2304      	movs	r3, #4
   16014:	e7f8      	b.n	16008 <sys_heap_aligned_alloc+0xc6>
			return sys_heap_alloc(heap, bytes);
   16016:	4621      	mov	r1, r4
   16018:	f7ff ff4a 	bl	15eb0 <sys_heap_alloc>
   1601c:	4605      	mov	r5, r0
   1601e:	e7e9      	b.n	15ff4 <sys_heap_aligned_alloc+0xb2>
   16020:	2304      	movs	r3, #4
   16022:	e7af      	b.n	15f84 <sys_heap_aligned_alloc+0x42>
		split_chunks(h, c0, c);
   16024:	4602      	mov	r2, r0
   16026:	4639      	mov	r1, r7
   16028:	4630      	mov	r0, r6
   1602a:	f7ff fda7 	bl	15b7c <split_chunks>
		free_list_add(h, c0);
   1602e:	4639      	mov	r1, r7
   16030:	4630      	mov	r0, r6
   16032:	f7ff fe4d 	bl	15cd0 <free_list_add>
   16036:	e7c6      	b.n	15fc6 <sys_heap_aligned_alloc+0x84>
		return ((uint16_t *)cmem)[f];
   16038:	8853      	ldrh	r3, [r2, #2]
   1603a:	e7cb      	b.n	15fd4 <sys_heap_aligned_alloc+0x92>
		split_chunks(h, c, c_end);
   1603c:	4622      	mov	r2, r4
   1603e:	4641      	mov	r1, r8
   16040:	4630      	mov	r0, r6
   16042:	f7ff fd9b 	bl	15b7c <split_chunks>
		free_list_add(h, c_end);
   16046:	4621      	mov	r1, r4
   16048:	4630      	mov	r0, r6
   1604a:	f7ff fe41 	bl	15cd0 <free_list_add>
   1604e:	e7c5      	b.n	15fdc <sys_heap_aligned_alloc+0x9a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   16050:	f8b8 3002 	ldrh.w	r3, [r8, #2]
   16054:	f043 0301 	orr.w	r3, r3, #1
   16058:	f8a8 3002 	strh.w	r3, [r8, #2]
}
   1605c:	e7ca      	b.n	15ff4 <sys_heap_aligned_alloc+0xb2>
		return NULL;
   1605e:	2500      	movs	r5, #0
   16060:	e7c8      	b.n	15ff4 <sys_heap_aligned_alloc+0xb2>
   16062:	2500      	movs	r5, #0
   16064:	e7c6      	b.n	15ff4 <sys_heap_aligned_alloc+0xb2>
		return NULL;
   16066:	2500      	movs	r5, #0
   16068:	e7c4      	b.n	15ff4 <sys_heap_aligned_alloc+0xb2>

0001606a <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   1606a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1606c:	4603      	mov	r3, r0
	return big_heap_bytes(size) ? 8 : 4;
   1606e:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
   16072:	d324      	bcc.n	160be <sys_heap_init+0x54>
   16074:	f04f 0c08 	mov.w	ip, #8
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   16078:	eba2 0c0c 	sub.w	ip, r2, ip

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   1607c:	1dc8      	adds	r0, r1, #7
   1607e:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   16082:	448c      	add	ip, r1
   16084:	f02c 0c07 	bic.w	ip, ip, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   16088:	ebac 0c00 	sub.w	ip, ip, r0
   1608c:	ea4f 05dc 	mov.w	r5, ip, lsr #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   16090:	6018      	str	r0, [r3, #0]
	h->end_chunk = heap_sz;
   16092:	6085      	str	r5, [r0, #8]
	h->avail_buckets = 0;
   16094:	2300      	movs	r3, #0
   16096:	60c3      	str	r3, [r0, #12]
	return big_heap(h) ? 8 : 4;
   16098:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   1609c:	d312      	bcc.n	160c4 <sys_heap_init+0x5a>
   1609e:	2308      	movs	r3, #8
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   160a0:	3308      	adds	r3, #8
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
   160a2:	eba5 03d3 	sub.w	r3, r5, r3, lsr #3
   160a6:	3301      	adds	r3, #1
	return 31 - __builtin_clz(usable_sz);
   160a8:	fab3 f383 	clz	r3, r3
	h->free_bytes = 0;
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   160ac:	f1c3 0e20 	rsb	lr, r3, #32
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   160b0:	f1c3 0324 	rsb	r3, r3, #36	; 0x24
   160b4:	009b      	lsls	r3, r3, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   160b6:	1dde      	adds	r6, r3, #7
   160b8:	08f1      	lsrs	r1, r6, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   160ba:	2300      	movs	r3, #0
   160bc:	e009      	b.n	160d2 <sys_heap_init+0x68>
	return big_heap_bytes(size) ? 8 : 4;
   160be:	f04f 0c04 	mov.w	ip, #4
   160c2:	e7d9      	b.n	16078 <sys_heap_init+0xe>
	return big_heap(h) ? 8 : 4;
   160c4:	2304      	movs	r3, #4
   160c6:	e7eb      	b.n	160a0 <sys_heap_init+0x36>
		h->buckets[i].next = 0;
   160c8:	1d1a      	adds	r2, r3, #4
   160ca:	2400      	movs	r4, #0
   160cc:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
   160d0:	3301      	adds	r3, #1
   160d2:	4573      	cmp	r3, lr
   160d4:	dbf8      	blt.n	160c8 <sys_heap_init+0x5e>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   160d6:	004b      	lsls	r3, r1, #1
	if (big_heap(h)) {
   160d8:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   160dc:	d336      	bcc.n	1614c <sys_heap_init+0xe2>
		((uint32_t *)cmem)[f] = val;
   160de:	6043      	str	r3, [r0, #4]
	if (big_heap(h)) {
   160e0:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   160e4:	d334      	bcc.n	16150 <sys_heap_init+0xe6>
		((uint32_t *)cmem)[f] = val;
   160e6:	2300      	movs	r3, #0
   160e8:	6003      	str	r3, [r0, #0]
	if (big_heap(h)) {
   160ea:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   160ee:	d332      	bcc.n	16156 <sys_heap_init+0xec>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   160f0:	6843      	ldr	r3, [r0, #4]
   160f2:	f043 0301 	orr.w	r3, r3, #1
   160f6:	6043      	str	r3, [r0, #4]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   160f8:	1a6a      	subs	r2, r5, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   160fa:	0057      	lsls	r7, r2, #1
	void *cmem = &buf[c];
   160fc:	f026 0307 	bic.w	r3, r6, #7
   16100:	18c4      	adds	r4, r0, r3
	if (big_heap(h)) {
   16102:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
   16106:	d32b      	bcc.n	16160 <sys_heap_init+0xf6>
		((uint32_t *)cmem)[f] = val;
   16108:	6067      	str	r7, [r4, #4]
	return big_heap_chunks(h->end_chunk);
   1610a:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   1610c:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   16110:	d328      	bcc.n	16164 <sys_heap_init+0xfa>
		((uint32_t *)cmem)[f] = val;
   16112:	50c1      	str	r1, [r0, r3]
	void *cmem = &buf[c];
   16114:	f02c 0307 	bic.w	r3, ip, #7
   16118:	4484      	add	ip, r0
	return big_heap_chunks(h->end_chunk);
   1611a:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   1611c:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   16120:	d322      	bcc.n	16168 <sys_heap_init+0xfe>
		((uint32_t *)cmem)[f] = val;
   16122:	2400      	movs	r4, #0
   16124:	f8cc 4004 	str.w	r4, [ip, #4]
	return big_heap_chunks(h->end_chunk);
   16128:	6884      	ldr	r4, [r0, #8]
	if (big_heap(h)) {
   1612a:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
   1612e:	d31f      	bcc.n	16170 <sys_heap_init+0x106>
		((uint32_t *)cmem)[f] = val;
   16130:	50c2      	str	r2, [r0, r3]
	void *cmem = &buf[c];
   16132:	eb00 03c5 	add.w	r3, r0, r5, lsl #3
	return big_heap_chunks(h->end_chunk);
   16136:	6882      	ldr	r2, [r0, #8]
	if (big_heap(h)) {
   16138:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   1613c:	d31a      	bcc.n	16174 <sys_heap_init+0x10a>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   1613e:	685a      	ldr	r2, [r3, #4]
   16140:	f042 0201 	orr.w	r2, r2, #1
   16144:	605a      	str	r2, [r3, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   16146:	f7ff fdc3 	bl	15cd0 <free_list_add>
}
   1614a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		((uint16_t *)cmem)[f] = val;
   1614c:	8043      	strh	r3, [r0, #2]
   1614e:	e7c7      	b.n	160e0 <sys_heap_init+0x76>
   16150:	2300      	movs	r3, #0
   16152:	8003      	strh	r3, [r0, #0]
   16154:	e7c9      	b.n	160ea <sys_heap_init+0x80>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   16156:	8843      	ldrh	r3, [r0, #2]
   16158:	f043 0301 	orr.w	r3, r3, #1
   1615c:	8043      	strh	r3, [r0, #2]
   1615e:	e7cb      	b.n	160f8 <sys_heap_init+0x8e>
		((uint16_t *)cmem)[f] = val;
   16160:	8067      	strh	r7, [r4, #2]
   16162:	e7d2      	b.n	1610a <sys_heap_init+0xa0>
   16164:	52c1      	strh	r1, [r0, r3]
   16166:	e7d5      	b.n	16114 <sys_heap_init+0xaa>
   16168:	2400      	movs	r4, #0
   1616a:	f8ac 4002 	strh.w	r4, [ip, #2]
   1616e:	e7db      	b.n	16128 <sys_heap_init+0xbe>
   16170:	52c2      	strh	r2, [r0, r3]
   16172:	e7de      	b.n	16132 <sys_heap_init+0xc8>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   16174:	885a      	ldrh	r2, [r3, #2]
   16176:	f042 0201 	orr.w	r2, r2, #1
   1617a:	805a      	strh	r2, [r3, #2]
   1617c:	e7e3      	b.n	16146 <sys_heap_init+0xdc>

0001617e <extract_decimal>:
{
   1617e:	4684      	mov	ip, r0
	const char *sp = *str;
   16180:	6802      	ldr	r2, [r0, #0]
	size_t val = 0;
   16182:	2000      	movs	r0, #0
	while (isdigit((int)(unsigned char)*sp)) {
   16184:	e005      	b.n	16192 <extract_decimal+0x14>
		val = 10U * val + *sp++ - '0';
   16186:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1618a:	3201      	adds	r2, #1
   1618c:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   16190:	3830      	subs	r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   16192:	7813      	ldrb	r3, [r2, #0]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   16194:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
   16198:	2909      	cmp	r1, #9
   1619a:	d9f4      	bls.n	16186 <extract_decimal+0x8>
	*str = sp;
   1619c:	f8cc 2000 	str.w	r2, [ip]
}
   161a0:	4770      	bx	lr

000161a2 <encode_uint>:
{
   161a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   161a6:	b083      	sub	sp, #12
   161a8:	4604      	mov	r4, r0
   161aa:	460d      	mov	r5, r1
   161ac:	9201      	str	r2, [sp, #4]
   161ae:	469a      	mov	sl, r3
   161b0:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	bool upcase = isupper((int)conv->specifier);
   161b2:	78d3      	ldrb	r3, [r2, #3]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   161b4:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
   161b8:	2b6f      	cmp	r3, #111	; 0x6f
   161ba:	d00f      	beq.n	161dc <encode_uint+0x3a>
   161bc:	d906      	bls.n	161cc <encode_uint+0x2a>
   161be:	2b70      	cmp	r3, #112	; 0x70
   161c0:	d00f      	beq.n	161e2 <encode_uint+0x40>
   161c2:	2b78      	cmp	r3, #120	; 0x78
   161c4:	d110      	bne.n	161e8 <encode_uint+0x46>
		return 16;
   161c6:	f04f 0910 	mov.w	r9, #16
   161ca:	e026      	b.n	1621a <encode_uint+0x78>
	switch (specifier) {
   161cc:	2b58      	cmp	r3, #88	; 0x58
   161ce:	d002      	beq.n	161d6 <encode_uint+0x34>
   161d0:	f04f 090a 	mov.w	r9, #10
   161d4:	e021      	b.n	1621a <encode_uint+0x78>
		return 16;
   161d6:	f04f 0910 	mov.w	r9, #16
   161da:	e01e      	b.n	1621a <encode_uint+0x78>
		return 8;
   161dc:	f04f 0908 	mov.w	r9, #8
   161e0:	e01b      	b.n	1621a <encode_uint+0x78>
		return 16;
   161e2:	f04f 0910 	mov.w	r9, #16
   161e6:	e018      	b.n	1621a <encode_uint+0x78>
	switch (specifier) {
   161e8:	f04f 090a 	mov.w	r9, #10
	char *bp = bps + (bpe - bps);
   161ec:	e015      	b.n	1621a <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   161ee:	f1bb 0f19 	cmp.w	fp, #25
   161f2:	d821      	bhi.n	16238 <encode_uint+0x96>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
   161f4:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
   161f6:	3237      	adds	r2, #55	; 0x37
   161f8:	b2d2      	uxtb	r2, r2
   161fa:	f806 2d01 	strb.w	r2, [r6, #-1]!
		value /= radix;
   161fe:	463a      	mov	r2, r7
   16200:	4643      	mov	r3, r8
   16202:	4620      	mov	r0, r4
   16204:	4629      	mov	r1, r5
   16206:	f7e9 ffa5 	bl	154 <__aeabi_uldivmod>
	} while ((value != 0) && (bps < bp));
   1620a:	42bc      	cmp	r4, r7
   1620c:	f175 0300 	sbcs.w	r3, r5, #0
   16210:	d316      	bcc.n	16240 <encode_uint+0x9e>
   16212:	4556      	cmp	r6, sl
   16214:	d914      	bls.n	16240 <encode_uint+0x9e>
		value /= radix;
   16216:	4604      	mov	r4, r0
   16218:	460d      	mov	r5, r1
		unsigned int lsv = (unsigned int)(value % radix);
   1621a:	f04f 0800 	mov.w	r8, #0
   1621e:	464f      	mov	r7, r9
   16220:	464a      	mov	r2, r9
   16222:	4643      	mov	r3, r8
   16224:	4620      	mov	r0, r4
   16226:	4629      	mov	r1, r5
   16228:	f7e9 ff94 	bl	154 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   1622c:	2a09      	cmp	r2, #9
   1622e:	d8de      	bhi.n	161ee <encode_uint+0x4c>
   16230:	b2d2      	uxtb	r2, r2
   16232:	3230      	adds	r2, #48	; 0x30
   16234:	b2d2      	uxtb	r2, r2
   16236:	e7e0      	b.n	161fa <encode_uint+0x58>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
   16238:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
   1623a:	3257      	adds	r2, #87	; 0x57
   1623c:	b2d2      	uxtb	r2, r2
   1623e:	e7dc      	b.n	161fa <encode_uint+0x58>
	if (conv->flag_hash) {
   16240:	9b01      	ldr	r3, [sp, #4]
   16242:	781b      	ldrb	r3, [r3, #0]
   16244:	f013 0f20 	tst.w	r3, #32
   16248:	d005      	beq.n	16256 <encode_uint+0xb4>
		if (radix == 8) {
   1624a:	f1b9 0f08 	cmp.w	r9, #8
   1624e:	d006      	beq.n	1625e <encode_uint+0xbc>
		} else if (radix == 16) {
   16250:	f1b9 0f10 	cmp.w	r9, #16
   16254:	d009      	beq.n	1626a <encode_uint+0xc8>
}
   16256:	4630      	mov	r0, r6
   16258:	b003      	add	sp, #12
   1625a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			conv->altform_0 = true;
   1625e:	9a01      	ldr	r2, [sp, #4]
   16260:	7893      	ldrb	r3, [r2, #2]
   16262:	f043 0308 	orr.w	r3, r3, #8
   16266:	7093      	strb	r3, [r2, #2]
   16268:	e7f5      	b.n	16256 <encode_uint+0xb4>
			conv->altform_0c = true;
   1626a:	9a01      	ldr	r2, [sp, #4]
   1626c:	7893      	ldrb	r3, [r2, #2]
   1626e:	f043 0310 	orr.w	r3, r3, #16
   16272:	7093      	strb	r3, [r2, #2]
   16274:	e7ef      	b.n	16256 <encode_uint+0xb4>

00016276 <outs>:
{
   16276:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1627a:	4607      	mov	r7, r0
   1627c:	460e      	mov	r6, r1
   1627e:	4614      	mov	r4, r2
   16280:	4698      	mov	r8, r3
	size_t count = 0;
   16282:	2500      	movs	r5, #0
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   16284:	e006      	b.n	16294 <outs+0x1e>
		int rc = out((int)*sp++, ctx);
   16286:	4631      	mov	r1, r6
   16288:	f814 0b01 	ldrb.w	r0, [r4], #1
   1628c:	47b8      	blx	r7
		if (rc < 0) {
   1628e:	2800      	cmp	r0, #0
   16290:	db09      	blt.n	162a6 <outs+0x30>
		++count;
   16292:	3501      	adds	r5, #1
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   16294:	4544      	cmp	r4, r8
   16296:	d3f6      	bcc.n	16286 <outs+0x10>
   16298:	f1b8 0f00 	cmp.w	r8, #0
   1629c:	d102      	bne.n	162a4 <outs+0x2e>
   1629e:	7823      	ldrb	r3, [r4, #0]
   162a0:	2b00      	cmp	r3, #0
   162a2:	d1f0      	bne.n	16286 <outs+0x10>
	return (int)count;
   162a4:	4628      	mov	r0, r5
}
   162a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000162aa <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
   162aa:	b40f      	push	{r0, r1, r2, r3}
   162ac:	b500      	push	{lr}
   162ae:	b083      	sub	sp, #12
   162b0:	a904      	add	r1, sp, #16
   162b2:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   162b6:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
   162b8:	f7ea fe2c 	bl	f14 <vprintk>

	va_end(ap);
}
   162bc:	b003      	add	sp, #12
   162be:	f85d eb04 	ldr.w	lr, [sp], #4
   162c2:	b004      	add	sp, #16
   162c4:	4770      	bx	lr

000162c6 <add_skip_item>:

	return 0;
}

static void add_skip_item(struct mpsc_pbuf_buffer *buffer, uint32_t wlen)
{
   162c6:	b410      	push	{r4}
	union mpsc_pbuf_generic skip = {
   162c8:	2300      	movs	r3, #0
   162ca:	f36f 0300 	bfc	r3, #0, #1
   162ce:	f043 0302 	orr.w	r3, r3, #2
   162d2:	f361 039f 	bfi	r3, r1, #2, #30
		.skip = { .valid = 0, .busy = 1, .len = wlen }
	};

	buffer->buf[buffer->tmp_wr_idx] = skip.raw;
   162d6:	69c2      	ldr	r2, [r0, #28]
   162d8:	6804      	ldr	r4, [r0, #0]
   162da:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
   162de:	6803      	ldr	r3, [r0, #0]
	uint32_t i = idx + val;
   162e0:	440b      	add	r3, r1
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   162e2:	6902      	ldr	r2, [r0, #16]
   162e4:	f012 0201 	ands.w	r2, r2, #1
   162e8:	d104      	bne.n	162f4 <add_skip_item+0x2e>
	return (i >= buffer->size) ? i - buffer->size : i;
   162ea:	6a04      	ldr	r4, [r0, #32]
   162ec:	42a3      	cmp	r3, r4
   162ee:	d304      	bcc.n	162fa <add_skip_item+0x34>
   162f0:	1b1b      	subs	r3, r3, r4
   162f2:	e002      	b.n	162fa <add_skip_item+0x34>
		return i & (buffer->size - 1);
   162f4:	6a04      	ldr	r4, [r0, #32]
   162f6:	3c01      	subs	r4, #1
   162f8:	4023      	ands	r3, r4
	buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, wlen);
   162fa:	6003      	str	r3, [r0, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   162fc:	6843      	ldr	r3, [r0, #4]
	uint32_t i = idx + val;
   162fe:	4419      	add	r1, r3
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   16300:	b922      	cbnz	r2, 1630c <add_skip_item+0x46>
	return (i >= buffer->size) ? i - buffer->size : i;
   16302:	6a03      	ldr	r3, [r0, #32]
   16304:	4299      	cmp	r1, r3
   16306:	d304      	bcc.n	16312 <add_skip_item+0x4c>
   16308:	1ac9      	subs	r1, r1, r3
   1630a:	e002      	b.n	16312 <add_skip_item+0x4c>
		return i & (buffer->size - 1);
   1630c:	6a03      	ldr	r3, [r0, #32]
   1630e:	3b01      	subs	r3, #1
   16310:	4019      	ands	r1, r3
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   16312:	6041      	str	r1, [r0, #4]
}
   16314:	bc10      	pop	{r4}
   16316:	4770      	bx	lr

00016318 <drop_item_locked>:
 */
static union mpsc_pbuf_generic *drop_item_locked(struct mpsc_pbuf_buffer *buffer,
						 uint32_t free_wlen,
						 bool allow_drop,
						 bool *user_packet)
{
   16318:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1631c:	b083      	sub	sp, #12
   1631e:	4604      	mov	r4, r0
   16320:	9101      	str	r1, [sp, #4]
   16322:	4615      	mov	r5, r2
   16324:	461e      	mov	r6, r3
	union mpsc_pbuf_generic *item;
	uint32_t rd_wlen;
	uint32_t skip_wlen;

	*user_packet = false;
   16326:	2300      	movs	r3, #0
   16328:	7033      	strb	r3, [r6, #0]
	item = (union mpsc_pbuf_generic *)&buffer->buf[buffer->rd_idx];
   1632a:	f8d0 801c 	ldr.w	r8, [r0, #28]
   1632e:	f8d0 900c 	ldr.w	r9, [r0, #12]
   16332:	eb08 0a89 	add.w	sl, r8, r9, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
   16336:	f818 3029 	ldrb.w	r3, [r8, r9, lsl #2]
   1633a:	f003 0303 	and.w	r3, r3, #3
   1633e:	2b02      	cmp	r3, #2
   16340:	d012      	beq.n	16368 <drop_item_locked+0x50>
	return 0;
   16342:	f04f 0b00 	mov.w	fp, #0
	skip_wlen = get_skip(item);

	rd_wlen = skip_wlen ? skip_wlen : buffer->get_wlen(item);
   16346:	69a3      	ldr	r3, [r4, #24]
   16348:	4650      	mov	r0, sl
   1634a:	4798      	blx	r3
   1634c:	4607      	mov	r7, r0
	if (skip_wlen) {
   1634e:	f1bb 0f00 	cmp.w	fp, #0
   16352:	d151      	bne.n	163f8 <drop_item_locked+0xe0>
		allow_drop = true;
	} else if (allow_drop) {
   16354:	2d00      	cmp	r5, #0
   16356:	d05c      	beq.n	16412 <drop_item_locked+0xfa>
		if (item->hdr.busy) {
   16358:	f818 3029 	ldrb.w	r3, [r8, r9, lsl #2]
   1635c:	f013 0f02 	tst.w	r3, #2
   16360:	d109      	bne.n	16376 <drop_item_locked+0x5e>
			} else {
				rd_wlen += buffer->get_wlen(item);
				*user_packet = true;
			}
		} else {
			*user_packet = true;
   16362:	2301      	movs	r3, #1
   16364:	7033      	strb	r3, [r6, #0]
   16366:	e048      	b.n	163fa <drop_item_locked+0xe2>
		return item->skip.len;
   16368:	f858 3029 	ldr.w	r3, [r8, r9, lsl #2]
	rd_wlen = skip_wlen ? skip_wlen : buffer->get_wlen(item);
   1636c:	ea5f 0b93 	movs.w	fp, r3, lsr #2
   16370:	d0e9      	beq.n	16346 <drop_item_locked+0x2e>
		return item->skip.len;
   16372:	465f      	mov	r7, fp
   16374:	e7eb      	b.n	1634e <drop_item_locked+0x36>
			add_skip_item(buffer, free_wlen + 1);
   16376:	9901      	ldr	r1, [sp, #4]
   16378:	3101      	adds	r1, #1
   1637a:	4620      	mov	r0, r4
   1637c:	f7ff ffa3 	bl	162c6 <add_skip_item>
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
   16380:	6863      	ldr	r3, [r4, #4]
	uint32_t i = idx + val;
   16382:	443b      	add	r3, r7
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   16384:	6922      	ldr	r2, [r4, #16]
   16386:	f012 0201 	ands.w	r2, r2, #1
   1638a:	d104      	bne.n	16396 <drop_item_locked+0x7e>
	return (i >= buffer->size) ? i - buffer->size : i;
   1638c:	6a21      	ldr	r1, [r4, #32]
   1638e:	428b      	cmp	r3, r1
   16390:	d304      	bcc.n	1639c <drop_item_locked+0x84>
   16392:	1a5b      	subs	r3, r3, r1
   16394:	e002      	b.n	1639c <drop_item_locked+0x84>
		return i & (buffer->size - 1);
   16396:	6a21      	ldr	r1, [r4, #32]
   16398:	3901      	subs	r1, #1
   1639a:	400b      	ands	r3, r1
			buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, rd_wlen);
   1639c:	6063      	str	r3, [r4, #4]
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
   1639e:	6823      	ldr	r3, [r4, #0]
	uint32_t i = idx + val;
   163a0:	443b      	add	r3, r7
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   163a2:	b922      	cbnz	r2, 163ae <drop_item_locked+0x96>
	return (i >= buffer->size) ? i - buffer->size : i;
   163a4:	6a21      	ldr	r1, [r4, #32]
   163a6:	428b      	cmp	r3, r1
   163a8:	d304      	bcc.n	163b4 <drop_item_locked+0x9c>
   163aa:	1a5b      	subs	r3, r3, r1
   163ac:	e002      	b.n	163b4 <drop_item_locked+0x9c>
		return i & (buffer->size - 1);
   163ae:	6a21      	ldr	r1, [r4, #32]
   163b0:	3901      	subs	r1, #1
   163b2:	400b      	ands	r3, r1
			buffer->tmp_wr_idx = idx_inc(buffer, buffer->tmp_wr_idx, rd_wlen);
   163b4:	6023      	str	r3, [r4, #0]
			uint32_t next_rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
   163b6:	68e3      	ldr	r3, [r4, #12]
	uint32_t i = idx + val;
   163b8:	443b      	add	r3, r7
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   163ba:	b922      	cbnz	r2, 163c6 <drop_item_locked+0xae>
	return (i >= buffer->size) ? i - buffer->size : i;
   163bc:	6a22      	ldr	r2, [r4, #32]
   163be:	4293      	cmp	r3, r2
   163c0:	d304      	bcc.n	163cc <drop_item_locked+0xb4>
   163c2:	1a9b      	subs	r3, r3, r2
   163c4:	e002      	b.n	163cc <drop_item_locked+0xb4>
		return i & (buffer->size - 1);
   163c6:	6a22      	ldr	r2, [r4, #32]
   163c8:	3a01      	subs	r2, #1
   163ca:	4013      	ands	r3, r2
			item = (union mpsc_pbuf_generic *)&buffer->buf[next_rd_idx];
   163cc:	69e1      	ldr	r1, [r4, #28]
   163ce:	eb01 0a83 	add.w	sl, r1, r3, lsl #2
	if (item->hdr.busy && !item->hdr.valid) {
   163d2:	f811 2023 	ldrb.w	r2, [r1, r3, lsl #2]
   163d6:	f002 0203 	and.w	r2, r2, #3
   163da:	2a02      	cmp	r2, #2
   163dc:	d006      	beq.n	163ec <drop_item_locked+0xd4>
				rd_wlen += buffer->get_wlen(item);
   163de:	69a3      	ldr	r3, [r4, #24]
   163e0:	4650      	mov	r0, sl
   163e2:	4798      	blx	r3
   163e4:	4407      	add	r7, r0
				*user_packet = true;
   163e6:	2301      	movs	r3, #1
   163e8:	7033      	strb	r3, [r6, #0]
   163ea:	e006      	b.n	163fa <drop_item_locked+0xe2>
		return item->skip.len;
   163ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
			if (skip_wlen) {
   163f0:	089b      	lsrs	r3, r3, #2
   163f2:	d0f4      	beq.n	163de <drop_item_locked+0xc6>
				rd_wlen += skip_wlen;
   163f4:	441f      	add	r7, r3
   163f6:	e000      	b.n	163fa <drop_item_locked+0xe2>
		allow_drop = true;
   163f8:	2501      	movs	r5, #1
		}
	} else {
		item = NULL;
	}

	if (allow_drop) {
   163fa:	b195      	cbz	r5, 16422 <drop_item_locked+0x10a>
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
   163fc:	68e0      	ldr	r0, [r4, #12]
	uint32_t i = idx + val;
   163fe:	4407      	add	r7, r0
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   16400:	6923      	ldr	r3, [r4, #16]
   16402:	f013 0f01 	tst.w	r3, #1
   16406:	d107      	bne.n	16418 <drop_item_locked+0x100>
	return (i >= buffer->size) ? i - buffer->size : i;
   16408:	6a23      	ldr	r3, [r4, #32]
   1640a:	429f      	cmp	r7, r3
   1640c:	d307      	bcc.n	1641e <drop_item_locked+0x106>
   1640e:	1aff      	subs	r7, r7, r3
   16410:	e005      	b.n	1641e <drop_item_locked+0x106>
		item = NULL;
   16412:	f04f 0a00 	mov.w	sl, #0
   16416:	e7f0      	b.n	163fa <drop_item_locked+0xe2>
		return i & (buffer->size - 1);
   16418:	6a23      	ldr	r3, [r4, #32]
   1641a:	3b01      	subs	r3, #1
   1641c:	401f      	ands	r7, r3
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, rd_wlen);
   1641e:	60e7      	str	r7, [r4, #12]
		buffer->tmp_rd_idx = buffer->rd_idx;
   16420:	60a7      	str	r7, [r4, #8]
	}

	return item;
}
   16422:	4650      	mov	r0, sl
   16424:	b003      	add	sp, #12
   16426:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001642a <mpsc_pbuf_init>:
{
   1642a:	b538      	push	{r3, r4, r5, lr}
   1642c:	4604      	mov	r4, r0
   1642e:	460d      	mov	r5, r1
	memset(buffer, 0, offsetof(struct mpsc_pbuf_buffer, buf));
   16430:	221c      	movs	r2, #28
   16432:	2100      	movs	r1, #0
   16434:	f001 f9ab 	bl	1778e <memset>
	buffer->get_wlen = cfg->get_wlen;
   16438:	68eb      	ldr	r3, [r5, #12]
   1643a:	61a3      	str	r3, [r4, #24]
	buffer->notify_drop = cfg->notify_drop;
   1643c:	68ab      	ldr	r3, [r5, #8]
   1643e:	6163      	str	r3, [r4, #20]
	buffer->buf = cfg->buf;
   16440:	682b      	ldr	r3, [r5, #0]
   16442:	61e3      	str	r3, [r4, #28]
	buffer->size = cfg->size;
   16444:	686b      	ldr	r3, [r5, #4]
   16446:	6223      	str	r3, [r4, #32]
	buffer->max_usage = 0;
   16448:	2200      	movs	r2, #0
   1644a:	6262      	str	r2, [r4, #36]	; 0x24
	buffer->flags = cfg->flags;
   1644c:	692a      	ldr	r2, [r5, #16]
   1644e:	6122      	str	r2, [r4, #16]
 * @param x value to check
 * @return true if @p x is a power of two, false otherwise
 */
static inline bool is_power_of_two(unsigned int x)
{
	return (x != 0U) && ((x & (x - 1U)) == 0U);
   16450:	b123      	cbz	r3, 1645c <mpsc_pbuf_init+0x32>
   16452:	1e59      	subs	r1, r3, #1
   16454:	420b      	tst	r3, r1
   16456:	d00d      	beq.n	16474 <mpsc_pbuf_init+0x4a>
   16458:	2300      	movs	r3, #0
   1645a:	e000      	b.n	1645e <mpsc_pbuf_init+0x34>
   1645c:	2300      	movs	r3, #0
	if (is_power_of_two(buffer->size)) {
   1645e:	b113      	cbz	r3, 16466 <mpsc_pbuf_init+0x3c>
		buffer->flags |= MPSC_PBUF_SIZE_POW2;
   16460:	f042 0201 	orr.w	r2, r2, #1
   16464:	6122      	str	r2, [r4, #16]
	err = k_sem_init(&buffer->sem, 0, 1);
   16466:	f104 0028 	add.w	r0, r4, #40	; 0x28
	return z_impl_k_sem_init(sem, initial_count, limit);
   1646a:	2201      	movs	r2, #1
   1646c:	2100      	movs	r1, #0
   1646e:	f005 fed1 	bl	1c214 <z_impl_k_sem_init>
}
   16472:	bd38      	pop	{r3, r4, r5, pc}
   16474:	2301      	movs	r3, #1
   16476:	e7f2      	b.n	1645e <mpsc_pbuf_init+0x34>

00016478 <mpsc_pbuf_alloc>:

}

union mpsc_pbuf_generic *mpsc_pbuf_alloc(struct mpsc_pbuf_buffer *buffer,
					 size_t wlen, k_timeout_t timeout)
{
   16478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1647c:	b085      	sub	sp, #20
   1647e:	9200      	str	r2, [sp, #0]
   16480:	9301      	str	r3, [sp, #4]
	uint32_t free_wlen;
	bool valid_drop;

	MPSC_PBUF_DBG(buffer, "alloc %d words, ", (int)wlen);

	if (wlen > (buffer->size - 1)) {
   16482:	6a03      	ldr	r3, [r0, #32]
   16484:	3b01      	subs	r3, #1
   16486:	428b      	cmp	r3, r1
   16488:	f0c0 808c 	bcc.w	165a4 <mpsc_pbuf_alloc+0x12c>
   1648c:	4605      	mov	r5, r0
   1648e:	4689      	mov	r9, r1
	union mpsc_pbuf_generic *dropped_item = NULL;
   16490:	f04f 0a00 	mov.w	sl, #0
	union mpsc_pbuf_generic *item = NULL;
   16494:	46d3      	mov	fp, sl
   16496:	e022      	b.n	164de <mpsc_pbuf_alloc+0x66>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
   16498:	1b1c      	subs	r4, r3, r4
   1649a:	3c01      	subs	r4, #1
		return false;
   1649c:	2600      	movs	r6, #0
   1649e:	e030      	b.n	16502 <mpsc_pbuf_alloc+0x8a>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
   164a0:	6a2b      	ldr	r3, [r5, #32]
   164a2:	1b1c      	subs	r4, r3, r4
   164a4:	3c01      	subs	r4, #1
		return false;
   164a6:	2600      	movs	r6, #0
   164a8:	e02b      	b.n	16502 <mpsc_pbuf_alloc+0x8a>
		return i & (buffer->size - 1);
   164aa:	6a2a      	ldr	r2, [r5, #32]
   164ac:	3a01      	subs	r2, #1
   164ae:	4013      	ands	r3, r2
		if (free_wlen >= wlen) {
			item =
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
			item->hdr.valid = 0;
			item->hdr.busy = 0;
			buffer->tmp_wr_idx = idx_inc(buffer,
   164b0:	602b      	str	r3, [r5, #0]
		cont = false;
   164b2:	2600      	movs	r6, #0
   164b4:	f387 8811 	msr	BASEPRI, r7
   164b8:	f3bf 8f6f 	isb	sy
			cont = dropped_item != NULL;
		}

		k_spin_unlock(&buffer->lock, key);

		if (cont && dropped_item && valid_drop) {
   164bc:	b16e      	cbz	r6, 164da <mpsc_pbuf_alloc+0x62>
   164be:	f1ba 0f00 	cmp.w	sl, #0
   164c2:	d00a      	beq.n	164da <mpsc_pbuf_alloc+0x62>
   164c4:	f89d 300f 	ldrb.w	r3, [sp, #15]
   164c8:	b13b      	cbz	r3, 164da <mpsc_pbuf_alloc+0x62>
			/* Notify about item being dropped. */
			if (buffer->notify_drop) {
   164ca:	696b      	ldr	r3, [r5, #20]
   164cc:	2b00      	cmp	r3, #0
   164ce:	d066      	beq.n	1659e <mpsc_pbuf_alloc+0x126>
				buffer->notify_drop(buffer, dropped_item);
   164d0:	4651      	mov	r1, sl
   164d2:	4628      	mov	r0, r5
   164d4:	4798      	blx	r3
			}
			dropped_item = NULL;
   164d6:	f04f 0a00 	mov.w	sl, #0
		}
	} while (cont);
   164da:	2e00      	cmp	r6, #0
   164dc:	d064      	beq.n	165a8 <mpsc_pbuf_alloc+0x130>
	__asm__ volatile(
   164de:	f04f 0320 	mov.w	r3, #32
   164e2:	f3ef 8811 	mrs	r8, BASEPRI
   164e6:	f383 8812 	msr	BASEPRI_MAX, r3
   164ea:	f3bf 8f6f 	isb	sy
   164ee:	4647      	mov	r7, r8
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
   164f0:	68eb      	ldr	r3, [r5, #12]
   164f2:	682c      	ldr	r4, [r5, #0]
   164f4:	42a3      	cmp	r3, r4
   164f6:	d8cf      	bhi.n	16498 <mpsc_pbuf_alloc+0x20>
	} else if (!buffer->rd_idx) {
   164f8:	2b00      	cmp	r3, #0
   164fa:	d0d1      	beq.n	164a0 <mpsc_pbuf_alloc+0x28>
	*res = buffer->size - buffer->tmp_wr_idx;
   164fc:	6a2b      	ldr	r3, [r5, #32]
   164fe:	1b1c      	subs	r4, r3, r4
	return true;
   16500:	2601      	movs	r6, #1
		if (free_wlen >= wlen) {
   16502:	45a1      	cmp	r9, r4
   16504:	d819      	bhi.n	1653a <mpsc_pbuf_alloc+0xc2>
			    (union mpsc_pbuf_generic *)&buffer->buf[buffer->tmp_wr_idx];
   16506:	69eb      	ldr	r3, [r5, #28]
   16508:	682a      	ldr	r2, [r5, #0]
			item =
   1650a:	eb03 0b82 	add.w	fp, r3, r2, lsl #2
			item->hdr.valid = 0;
   1650e:	f813 1022 	ldrb.w	r1, [r3, r2, lsl #2]
   16512:	f36f 0100 	bfc	r1, #0, #1
   16516:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
			item->hdr.busy = 0;
   1651a:	b2c9      	uxtb	r1, r1
   1651c:	f36f 0141 	bfc	r1, #1, #1
   16520:	f803 1022 	strb.w	r1, [r3, r2, lsl #2]
			buffer->tmp_wr_idx = idx_inc(buffer,
   16524:	682b      	ldr	r3, [r5, #0]
	uint32_t i = idx + val;
   16526:	444b      	add	r3, r9
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   16528:	692a      	ldr	r2, [r5, #16]
   1652a:	f012 0f01 	tst.w	r2, #1
   1652e:	d1bc      	bne.n	164aa <mpsc_pbuf_alloc+0x32>
	return (i >= buffer->size) ? i - buffer->size : i;
   16530:	6a2a      	ldr	r2, [r5, #32]
   16532:	4293      	cmp	r3, r2
   16534:	d3bc      	bcc.n	164b0 <mpsc_pbuf_alloc+0x38>
   16536:	1a9b      	subs	r3, r3, r2
   16538:	e7ba      	b.n	164b0 <mpsc_pbuf_alloc+0x38>
		} else if (wrap) {
   1653a:	b9ae      	cbnz	r6, 16568 <mpsc_pbuf_alloc+0xf0>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1653c:	9b01      	ldr	r3, [sp, #4]
   1653e:	9a00      	ldr	r2, [sp, #0]
   16540:	4313      	orrs	r3, r2
   16542:	d003      	beq.n	1654c <mpsc_pbuf_alloc+0xd4>
			   !k_is_in_isr()) {
   16544:	f005 fd23 	bl	1bf8e <k_is_in_isr>
		} else if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   16548:	4606      	mov	r6, r0
   1654a:	b190      	cbz	r0, 16572 <mpsc_pbuf_alloc+0xfa>
			bool user_drop = buffer->flags & MPSC_PBUF_MODE_OVERWRITE;
   1654c:	692a      	ldr	r2, [r5, #16]
			dropped_item = drop_item_locked(buffer, free_wlen,
   1654e:	f10d 030f 	add.w	r3, sp, #15
   16552:	f3c2 0240 	ubfx	r2, r2, #1, #1
   16556:	4621      	mov	r1, r4
   16558:	4628      	mov	r0, r5
   1655a:	f7ff fedd 	bl	16318 <drop_item_locked>
			cont = dropped_item != NULL;
   1655e:	4682      	mov	sl, r0
   16560:	1e06      	subs	r6, r0, #0
   16562:	bf18      	it	ne
   16564:	2601      	movne	r6, #1
   16566:	e7a5      	b.n	164b4 <mpsc_pbuf_alloc+0x3c>
			add_skip_item(buffer, free_wlen);
   16568:	4621      	mov	r1, r4
   1656a:	4628      	mov	r0, r5
   1656c:	f7ff feab 	bl	162c6 <add_skip_item>
			cont = true;
   16570:	e7a0      	b.n	164b4 <mpsc_pbuf_alloc+0x3c>
	__asm__ volatile(
   16572:	f388 8811 	msr	BASEPRI, r8
   16576:	f3bf 8f6f 	isb	sy
			err = k_sem_take(&buffer->sem, timeout);
   1657a:	f105 0028 	add.w	r0, r5, #40	; 0x28
	return z_impl_k_sem_take(sem, timeout);
   1657e:	9a00      	ldr	r2, [sp, #0]
   16580:	9b01      	ldr	r3, [sp, #4]
   16582:	f7fd fb2d 	bl	13be0 <z_impl_k_sem_take>
	__asm__ volatile(
   16586:	f04f 0320 	mov.w	r3, #32
   1658a:	f3ef 8711 	mrs	r7, BASEPRI
   1658e:	f383 8812 	msr	BASEPRI_MAX, r3
   16592:	f3bf 8f6f 	isb	sy
			if (err == 0) {
   16596:	2800      	cmp	r0, #0
   16598:	d18c      	bne.n	164b4 <mpsc_pbuf_alloc+0x3c>
				cont = true;
   1659a:	2601      	movs	r6, #1
   1659c:	e78a      	b.n	164b4 <mpsc_pbuf_alloc+0x3c>
			dropped_item = NULL;
   1659e:	f04f 0a00 	mov.w	sl, #0
   165a2:	e79a      	b.n	164da <mpsc_pbuf_alloc+0x62>
		return NULL;
   165a4:	f04f 0b00 	mov.w	fp, #0
		/* During test fill with 0's to simplify message comparison */
		memset(item, 0, sizeof(int) * wlen);
	}

	return item;
}
   165a8:	4658      	mov	r0, fp
   165aa:	b005      	add	sp, #20
   165ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000165b0 <mpsc_pbuf_commit>:

void mpsc_pbuf_commit(struct mpsc_pbuf_buffer *buffer,
		       union mpsc_pbuf_generic *item)
{
   165b0:	b538      	push	{r3, r4, r5, lr}
   165b2:	4604      	mov	r4, r0
   165b4:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
   165b6:	6983      	ldr	r3, [r0, #24]
   165b8:	4608      	mov	r0, r1
   165ba:	4798      	blx	r3
   165bc:	f04f 0320 	mov.w	r3, #32
   165c0:	f3ef 8111 	mrs	r1, BASEPRI
   165c4:	f383 8812 	msr	BASEPRI_MAX, r3
   165c8:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&buffer->lock);

	item->hdr.valid = 1;
   165cc:	782b      	ldrb	r3, [r5, #0]
   165ce:	f043 0301 	orr.w	r3, r3, #1
   165d2:	702b      	strb	r3, [r5, #0]
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   165d4:	6863      	ldr	r3, [r4, #4]
	uint32_t i = idx + val;
   165d6:	4418      	add	r0, r3
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   165d8:	6923      	ldr	r3, [r4, #16]
   165da:	f013 0f01 	tst.w	r3, #1
   165de:	d104      	bne.n	165ea <mpsc_pbuf_commit+0x3a>
	return (i >= buffer->size) ? i - buffer->size : i;
   165e0:	6a23      	ldr	r3, [r4, #32]
   165e2:	4298      	cmp	r0, r3
   165e4:	d304      	bcc.n	165f0 <mpsc_pbuf_commit+0x40>
   165e6:	1ac0      	subs	r0, r0, r3
   165e8:	e002      	b.n	165f0 <mpsc_pbuf_commit+0x40>
		return i & (buffer->size - 1);
   165ea:	6a23      	ldr	r3, [r4, #32]
   165ec:	3b01      	subs	r3, #1
   165ee:	4018      	ands	r0, r3
	buffer->wr_idx = idx_inc(buffer, buffer->wr_idx, wlen);
   165f0:	6060      	str	r0, [r4, #4]
	if (!(buffer->flags & MPSC_PBUF_MAX_UTILIZATION)) {
   165f2:	6923      	ldr	r3, [r4, #16]
   165f4:	f013 0f04 	tst.w	r3, #4
   165f8:	d104      	bne.n	16604 <mpsc_pbuf_commit+0x54>
	__asm__ volatile(
   165fa:	f381 8811 	msr	BASEPRI, r1
   165fe:	f3bf 8f6f 	isb	sy
	max_utilization_update(buffer);
	k_spin_unlock(&buffer->lock, key);
	MPSC_PBUF_DBG(buffer, "committed %p ", item);
}
   16602:	bd38      	pop	{r3, r4, r5, pc}
	buffer->max_usage = MAX(buffer->max_usage, get_usage(buffer));
   16604:	6a65      	ldr	r5, [r4, #36]	; 0x24
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
   16606:	68e3      	ldr	r3, [r4, #12]
   16608:	6820      	ldr	r0, [r4, #0]
   1660a:	4283      	cmp	r3, r0
   1660c:	d80f      	bhi.n	1662e <mpsc_pbuf_commit+0x7e>
	} else if (!buffer->rd_idx) {
   1660e:	b193      	cbz	r3, 16636 <mpsc_pbuf_commit+0x86>
	*res = buffer->size - buffer->tmp_wr_idx;
   16610:	6a23      	ldr	r3, [r4, #32]
   16612:	1a1b      	subs	r3, r3, r0
	return true;
   16614:	2201      	movs	r2, #1
	if (free_space(buffer, &f)) {
   16616:	b112      	cbz	r2, 1661e <mpsc_pbuf_commit+0x6e>
		f += (buffer->rd_idx - 1);
   16618:	68e2      	ldr	r2, [r4, #12]
   1661a:	4413      	add	r3, r2
   1661c:	3b01      	subs	r3, #1
	return buffer->size - 1 - f;
   1661e:	6a22      	ldr	r2, [r4, #32]
   16620:	1ad3      	subs	r3, r2, r3
   16622:	3b01      	subs	r3, #1
	buffer->max_usage = MAX(buffer->max_usage, get_usage(buffer));
   16624:	429d      	cmp	r5, r3
   16626:	d90b      	bls.n	16640 <mpsc_pbuf_commit+0x90>
   16628:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1662a:	6263      	str	r3, [r4, #36]	; 0x24
   1662c:	e7e5      	b.n	165fa <mpsc_pbuf_commit+0x4a>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
   1662e:	1a1b      	subs	r3, r3, r0
   16630:	3b01      	subs	r3, #1
		return false;
   16632:	2200      	movs	r2, #0
   16634:	e7ef      	b.n	16616 <mpsc_pbuf_commit+0x66>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
   16636:	6a22      	ldr	r2, [r4, #32]
   16638:	1a13      	subs	r3, r2, r0
   1663a:	3b01      	subs	r3, #1
		return false;
   1663c:	2200      	movs	r2, #0
   1663e:	e7ea      	b.n	16616 <mpsc_pbuf_commit+0x66>
	if (buffer->rd_idx > buffer->tmp_wr_idx) {
   16640:	68e2      	ldr	r2, [r4, #12]
   16642:	6825      	ldr	r5, [r4, #0]
   16644:	42aa      	cmp	r2, r5
   16646:	d80b      	bhi.n	16660 <mpsc_pbuf_commit+0xb0>
	} else if (!buffer->rd_idx) {
   16648:	b172      	cbz	r2, 16668 <mpsc_pbuf_commit+0xb8>
	*res = buffer->size - buffer->tmp_wr_idx;
   1664a:	6a23      	ldr	r3, [r4, #32]
   1664c:	1b5a      	subs	r2, r3, r5
	return true;
   1664e:	2301      	movs	r3, #1
	if (free_space(buffer, &f)) {
   16650:	b113      	cbz	r3, 16658 <mpsc_pbuf_commit+0xa8>
		f += (buffer->rd_idx - 1);
   16652:	68e3      	ldr	r3, [r4, #12]
   16654:	4413      	add	r3, r2
   16656:	1e5a      	subs	r2, r3, #1
	return buffer->size - 1 - f;
   16658:	6a23      	ldr	r3, [r4, #32]
   1665a:	1a9b      	subs	r3, r3, r2
   1665c:	3b01      	subs	r3, #1
   1665e:	e7e4      	b.n	1662a <mpsc_pbuf_commit+0x7a>
		*res =  buffer->rd_idx - buffer->tmp_wr_idx - 1;
   16660:	1b52      	subs	r2, r2, r5
   16662:	3a01      	subs	r2, #1
		return false;
   16664:	2300      	movs	r3, #0
   16666:	e7f3      	b.n	16650 <mpsc_pbuf_commit+0xa0>
		*res = buffer->size - buffer->tmp_wr_idx - 1;
   16668:	6a20      	ldr	r0, [r4, #32]
   1666a:	1b42      	subs	r2, r0, r5
   1666c:	3a01      	subs	r2, #1
		return false;
   1666e:	2300      	movs	r3, #0
   16670:	e7ee      	b.n	16650 <mpsc_pbuf_commit+0xa0>

00016672 <mpsc_pbuf_claim>:
		}
	} while (cont);
}

const union mpsc_pbuf_generic *mpsc_pbuf_claim(struct mpsc_pbuf_buffer *buffer)
{
   16672:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16674:	4604      	mov	r4, r0
   16676:	e039      	b.n	166ec <mpsc_pbuf_claim+0x7a>
		*res = (buffer->wr_idx - buffer->tmp_rd_idx);
   16678:	1a9b      	subs	r3, r3, r2
		return false;
   1667a:	e045      	b.n	16708 <mpsc_pbuf_claim+0x96>
		return item->skip.len;
   1667c:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
		if (!a || is_invalid(item)) {
			item = NULL;
		} else {
			uint32_t skip = get_skip(item);

			if (skip || !is_valid(item)) {
   16680:	0880      	lsrs	r0, r0, #2
   16682:	d153      	bne.n	1672c <mpsc_pbuf_claim+0xba>
   16684:	e04d      	b.n	16722 <mpsc_pbuf_claim+0xb0>
		return i & (buffer->size - 1);
   16686:	6a21      	ldr	r1, [r4, #32]
   16688:	3901      	subs	r1, #1
   1668a:	400b      	ands	r3, r1
				uint32_t inc =
					skip ? skip : buffer->get_wlen(item);

				buffer->tmp_rd_idx =
   1668c:	60a3      	str	r3, [r4, #8]
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
				buffer->rd_idx =
					idx_inc(buffer, buffer->rd_idx, inc);
   1668e:	68e3      	ldr	r3, [r4, #12]
	uint32_t i = idx + val;
   16690:	4418      	add	r0, r3
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   16692:	b922      	cbnz	r2, 1669e <mpsc_pbuf_claim+0x2c>
	return (i >= buffer->size) ? i - buffer->size : i;
   16694:	6a23      	ldr	r3, [r4, #32]
   16696:	4298      	cmp	r0, r3
   16698:	d304      	bcc.n	166a4 <mpsc_pbuf_claim+0x32>
   1669a:	1ac0      	subs	r0, r0, r3
   1669c:	e002      	b.n	166a4 <mpsc_pbuf_claim+0x32>
		return i & (buffer->size - 1);
   1669e:	6a23      	ldr	r3, [r4, #32]
   166a0:	3b01      	subs	r3, #1
   166a2:	4018      	ands	r0, r3
				buffer->rd_idx =
   166a4:	60e0      	str	r0, [r4, #12]
				cont = true;
   166a6:	2301      	movs	r3, #1
			if (skip || !is_valid(item)) {
   166a8:	e01b      	b.n	166e2 <mpsc_pbuf_claim+0x70>
			} else {
				item->hdr.busy = 1;
   166aa:	f811 3022 	ldrb.w	r3, [r1, r2, lsl #2]
   166ae:	f043 0302 	orr.w	r3, r3, #2
   166b2:	f801 3022 	strb.w	r3, [r1, r2, lsl #2]
				buffer->tmp_rd_idx =
					idx_inc(buffer, buffer->tmp_rd_idx,
   166b6:	68a7      	ldr	r7, [r4, #8]
						buffer->get_wlen(item));
   166b8:	69a3      	ldr	r3, [r4, #24]
					idx_inc(buffer, buffer->tmp_rd_idx,
   166ba:	4630      	mov	r0, r6
   166bc:	4798      	blx	r3
	uint32_t i = idx + val;
   166be:	4438      	add	r0, r7
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   166c0:	6923      	ldr	r3, [r4, #16]
   166c2:	f013 0f01 	tst.w	r3, #1
   166c6:	d104      	bne.n	166d2 <mpsc_pbuf_claim+0x60>
	return (i >= buffer->size) ? i - buffer->size : i;
   166c8:	6a23      	ldr	r3, [r4, #32]
   166ca:	4298      	cmp	r0, r3
   166cc:	d304      	bcc.n	166d8 <mpsc_pbuf_claim+0x66>
   166ce:	1ac0      	subs	r0, r0, r3
   166d0:	e002      	b.n	166d8 <mpsc_pbuf_claim+0x66>
		return i & (buffer->size - 1);
   166d2:	6a23      	ldr	r3, [r4, #32]
   166d4:	3b01      	subs	r3, #1
   166d6:	4018      	ands	r0, r3
				buffer->tmp_rd_idx =
   166d8:	60a0      	str	r0, [r4, #8]
		cont = false;
   166da:	2300      	movs	r3, #0
   166dc:	e001      	b.n	166e2 <mpsc_pbuf_claim+0x70>
   166de:	2300      	movs	r3, #0
			item = NULL;
   166e0:	461e      	mov	r6, r3
   166e2:	f385 8811 	msr	BASEPRI, r5
   166e6:	f3bf 8f6f 	isb	sy

		if (!cont) {
			MPSC_PBUF_DBG(buffer, "claimed: %p ", item);
		}
		k_spin_unlock(&buffer->lock, key);
	} while (cont);
   166ea:	b38b      	cbz	r3, 16750 <mpsc_pbuf_claim+0xde>
	__asm__ volatile(
   166ec:	f04f 0320 	mov.w	r3, #32
   166f0:	f3ef 8511 	mrs	r5, BASEPRI
   166f4:	f383 8812 	msr	BASEPRI_MAX, r3
   166f8:	f3bf 8f6f 	isb	sy
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
   166fc:	68a2      	ldr	r2, [r4, #8]
   166fe:	6863      	ldr	r3, [r4, #4]
   16700:	429a      	cmp	r2, r3
   16702:	d9b9      	bls.n	16678 <mpsc_pbuf_claim+0x6>
	*res = buffer->size - buffer->tmp_rd_idx;
   16704:	6a23      	ldr	r3, [r4, #32]
   16706:	1a9b      	subs	r3, r3, r2
			&buffer->buf[buffer->tmp_rd_idx];
   16708:	69e1      	ldr	r1, [r4, #28]
		item = (union mpsc_pbuf_generic *)
   1670a:	eb01 0682 	add.w	r6, r1, r2, lsl #2
		if (!a || is_invalid(item)) {
   1670e:	2b00      	cmp	r3, #0
   16710:	d0e5      	beq.n	166de <mpsc_pbuf_claim+0x6c>
	return !item->hdr.valid && !item->hdr.busy;
   16712:	f811 3022 	ldrb.w	r3, [r1, r2, lsl #2]
		if (!a || is_invalid(item)) {
   16716:	f013 0303 	ands.w	r3, r3, #3
   1671a:	d016      	beq.n	1674a <mpsc_pbuf_claim+0xd8>
	if (item->hdr.busy && !item->hdr.valid) {
   1671c:	2b02      	cmp	r3, #2
   1671e:	d0ad      	beq.n	1667c <mpsc_pbuf_claim+0xa>
	return 0;
   16720:	2000      	movs	r0, #0
	return item->hdr.valid;
   16722:	f811 3022 	ldrb.w	r3, [r1, r2, lsl #2]
			if (skip || !is_valid(item)) {
   16726:	f013 0f01 	tst.w	r3, #1
   1672a:	d1be      	bne.n	166aa <mpsc_pbuf_claim+0x38>
					skip ? skip : buffer->get_wlen(item);
   1672c:	b910      	cbnz	r0, 16734 <mpsc_pbuf_claim+0xc2>
   1672e:	69a3      	ldr	r3, [r4, #24]
   16730:	4630      	mov	r0, r6
   16732:	4798      	blx	r3
				      idx_inc(buffer, buffer->tmp_rd_idx, inc);
   16734:	68a3      	ldr	r3, [r4, #8]
	uint32_t i = idx + val;
   16736:	4403      	add	r3, r0
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   16738:	6922      	ldr	r2, [r4, #16]
   1673a:	f012 0201 	ands.w	r2, r2, #1
   1673e:	d1a2      	bne.n	16686 <mpsc_pbuf_claim+0x14>
	return (i >= buffer->size) ? i - buffer->size : i;
   16740:	6a21      	ldr	r1, [r4, #32]
   16742:	428b      	cmp	r3, r1
   16744:	d3a2      	bcc.n	1668c <mpsc_pbuf_claim+0x1a>
   16746:	1a5b      	subs	r3, r3, r1
   16748:	e7a0      	b.n	1668c <mpsc_pbuf_claim+0x1a>
		cont = false;
   1674a:	2300      	movs	r3, #0
			item = NULL;
   1674c:	461e      	mov	r6, r3
   1674e:	e7c8      	b.n	166e2 <mpsc_pbuf_claim+0x70>

	return item;
}
   16750:	4630      	mov	r0, r6
   16752:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00016754 <mpsc_pbuf_free>:

void mpsc_pbuf_free(struct mpsc_pbuf_buffer *buffer,
		     const union mpsc_pbuf_generic *item)
{
   16754:	b538      	push	{r3, r4, r5, lr}
   16756:	4604      	mov	r4, r0
   16758:	460d      	mov	r5, r1
	uint32_t wlen = buffer->get_wlen(item);
   1675a:	6983      	ldr	r3, [r0, #24]
   1675c:	4608      	mov	r0, r1
   1675e:	4798      	blx	r3
   16760:	f04f 0320 	mov.w	r3, #32
   16764:	f3ef 8211 	mrs	r2, BASEPRI
   16768:	f383 8812 	msr	BASEPRI_MAX, r3
   1676c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&buffer->lock);
	union mpsc_pbuf_generic *witem = (union mpsc_pbuf_generic *)item;

	witem->hdr.valid = 0;
   16770:	782b      	ldrb	r3, [r5, #0]
   16772:	f36f 0300 	bfc	r3, #0, #1
   16776:	702b      	strb	r3, [r5, #0]
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
   16778:	6923      	ldr	r3, [r4, #16]
   1677a:	f013 0f02 	tst.w	r3, #2
   1677e:	d00a      	beq.n	16796 <mpsc_pbuf_free+0x42>
		 ((uint32_t *)item == &buffer->buf[buffer->rd_idx])) {
   16780:	69e3      	ldr	r3, [r4, #28]
   16782:	68e1      	ldr	r1, [r4, #12]
   16784:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	if (!(buffer->flags & MPSC_PBUF_MODE_OVERWRITE) ||
   16788:	42ab      	cmp	r3, r5
   1678a:	d004      	beq.n	16796 <mpsc_pbuf_free+0x42>
		witem->hdr.busy = 0;
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
	} else {
		witem->skip.len = wlen;
   1678c:	682b      	ldr	r3, [r5, #0]
   1678e:	f360 039f 	bfi	r3, r0, #2, #30
   16792:	602b      	str	r3, [r5, #0]
   16794:	e012      	b.n	167bc <mpsc_pbuf_free+0x68>
		witem->hdr.busy = 0;
   16796:	782b      	ldrb	r3, [r5, #0]
   16798:	f36f 0341 	bfc	r3, #1, #1
   1679c:	702b      	strb	r3, [r5, #0]
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
   1679e:	68e3      	ldr	r3, [r4, #12]
	uint32_t i = idx + val;
   167a0:	4418      	add	r0, r3
	if (buffer->flags & MPSC_PBUF_SIZE_POW2) {
   167a2:	6923      	ldr	r3, [r4, #16]
   167a4:	f013 0f01 	tst.w	r3, #1
   167a8:	d104      	bne.n	167b4 <mpsc_pbuf_free+0x60>
	return (i >= buffer->size) ? i - buffer->size : i;
   167aa:	6a23      	ldr	r3, [r4, #32]
   167ac:	4298      	cmp	r0, r3
   167ae:	d304      	bcc.n	167ba <mpsc_pbuf_free+0x66>
   167b0:	1ac0      	subs	r0, r0, r3
   167b2:	e002      	b.n	167ba <mpsc_pbuf_free+0x66>
		return i & (buffer->size - 1);
   167b4:	6a23      	ldr	r3, [r4, #32]
   167b6:	3b01      	subs	r3, #1
   167b8:	4018      	ands	r0, r3
		buffer->rd_idx = idx_inc(buffer, buffer->rd_idx, wlen);
   167ba:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   167bc:	f382 8811 	msr	BASEPRI, r2
   167c0:	f3bf 8f6f 	isb	sy
	}
	MPSC_PBUF_DBG(buffer, "freed: %p ", item);

	k_spin_unlock(&buffer->lock, key);
	k_sem_give(&buffer->sem);
   167c4:	f104 0028 	add.w	r0, r4, #40	; 0x28
	z_impl_k_sem_give(sem);
   167c8:	f7fd f9e2 	bl	13b90 <z_impl_k_sem_give>
}
   167cc:	bd38      	pop	{r3, r4, r5, pc}

000167ce <mpsc_pbuf_is_pending>:
	if (buffer->tmp_rd_idx <= buffer->wr_idx) {
   167ce:	6883      	ldr	r3, [r0, #8]
   167d0:	6842      	ldr	r2, [r0, #4]
   167d2:	4293      	cmp	r3, r2
   167d4:	d905      	bls.n	167e2 <mpsc_pbuf_is_pending+0x14>
	*res = buffer->size - buffer->tmp_rd_idx;
   167d6:	6a00      	ldr	r0, [r0, #32]
   167d8:	1ac0      	subs	r0, r0, r3
	uint32_t a;

	(void)available(buffer, &a);

	return a ? true : false;
}
   167da:	3800      	subs	r0, #0
   167dc:	bf18      	it	ne
   167de:	2001      	movne	r0, #1
   167e0:	4770      	bx	lr
		*res = (buffer->wr_idx - buffer->tmp_rd_idx);
   167e2:	1ad0      	subs	r0, r2, r3
		return false;
   167e4:	e7f9      	b.n	167da <mpsc_pbuf_is_pending+0xc>

000167e6 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
   167e6:	4770      	bx	lr

000167e8 <pm_state_exit_post_ops>:
   167e8:	2300      	movs	r3, #0
   167ea:	f383 8811 	msr	BASEPRI, r3
   167ee:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   167f2:	4770      	bx	lr

000167f4 <rtc_cb>:
{
   167f4:	b510      	push	{r4, lr}
   167f6:	9c02      	ldr	r4, [sp, #8]
	ppi_rtc_to_ipc(channels, false);
   167f8:	2100      	movs	r1, #0
   167fa:	4620      	mov	r0, r4
   167fc:	f7eb f98c 	bl	1b18 <ppi_rtc_to_ipc>
		free_resources(channels);
   16800:	4620      	mov	r0, r4
   16802:	f7eb f977 	bl	1af4 <free_resources>
}
   16806:	bd10      	pop	{r4, pc}

00016808 <mbox_callback>:
{
   16808:	b510      	push	{r4, lr}
   1680a:	b082      	sub	sp, #8
   1680c:	4614      	mov	r4, r2
	channel->dev = dev;
   1680e:	9000      	str	r0, [sp, #0]
	channel->id = ch_id;
   16810:	9101      	str	r1, [sp, #4]
		(const struct mbox_driver_api *)channel->dev->api;
   16812:	9800      	ldr	r0, [sp, #0]
	const struct mbox_driver_api *api =
   16814:	6883      	ldr	r3, [r0, #8]
	if (api->set_enabled == NULL) {
   16816:	691b      	ldr	r3, [r3, #16]
   16818:	b113      	cbz	r3, 16820 <mbox_callback+0x18>
	return api->set_enabled(channel->dev, channel->id, enable);
   1681a:	2200      	movs	r2, #0
   1681c:	9901      	ldr	r1, [sp, #4]
   1681e:	4798      	blx	r3
	remote_callback(user_data);
   16820:	4620      	mov	r0, r4
   16822:	f7eb f9b3 	bl	1b8c <remote_callback>
}
   16826:	b002      	add	sp, #8
   16828:	bd10      	pop	{r4, pc}

0001682a <log_msg_generic_get_wlen>:
	return msg->generic.type == Z_LOG_MSG2_LOG;
   1682a:	7803      	ldrb	r3, [r0, #0]
	if (z_log_item_is_msg(generic_msg)) {
   1682c:	f013 0f04 	tst.w	r3, #4
   16830:	d001      	beq.n	16836 <log_msg_generic_get_wlen+0xc>
	return 0;
   16832:	2000      	movs	r0, #0
}
   16834:	4770      	bx	lr
		return log_msg_get_total_wlen(msg->hdr.desc);
   16836:	6803      	ldr	r3, [r0, #0]
	return Z_LOG_MSG2_ALIGNED_WLEN(desc.package_len, desc.data_len);
   16838:	f3c3 2049 	ubfx	r0, r3, #9, #10
   1683c:	f3c3 43cb 	ubfx	r3, r3, #19, #12
   16840:	4418      	add	r0, r3
   16842:	3017      	adds	r0, #23
   16844:	f020 0007 	bic.w	r0, r0, #7
   16848:	0880      	lsrs	r0, r0, #2
		return log_msg_get_total_wlen(msg->hdr.desc);
   1684a:	4770      	bx	lr

0001684c <dummy_timestamp>:
}
   1684c:	2000      	movs	r0, #0
   1684e:	4770      	bx	lr

00016850 <msg_filter_check>:
}
   16850:	2001      	movs	r0, #1
   16852:	4770      	bx	lr

00016854 <default_get_timestamp>:
{
   16854:	b508      	push	{r3, lr}
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   16856:	f004 fa33 	bl	1acc0 <sys_clock_cycle_get_32>
}
   1685a:	bd08      	pop	{r3, pc}

0001685c <notify_drop>:
{
   1685c:	b508      	push	{r3, lr}
	z_log_dropped(true);
   1685e:	2001      	movs	r0, #1
   16860:	f7eb fb64 	bl	1f2c <z_log_dropped>
}
   16864:	bd08      	pop	{r3, pc}

00016866 <z_log_get_tag>:
}
   16866:	2000      	movs	r0, #0
   16868:	4770      	bx	lr

0001686a <z_cbprintf_cpy>:
{
   1686a:	b570      	push	{r4, r5, r6, lr}
	if ((desc->size - desc->off) < len) {
   1686c:	6853      	ldr	r3, [r2, #4]
   1686e:	6896      	ldr	r6, [r2, #8]
   16870:	1b9b      	subs	r3, r3, r6
   16872:	428b      	cmp	r3, r1
   16874:	d30c      	bcc.n	16890 <z_cbprintf_cpy+0x26>
   16876:	460c      	mov	r4, r1
   16878:	4615      	mov	r5, r2
	memcpy(&((uint8_t *)desc->buf)[desc->off], (void *)buf, len);
   1687a:	6813      	ldr	r3, [r2, #0]
   1687c:	460a      	mov	r2, r1
   1687e:	4601      	mov	r1, r0
   16880:	1998      	adds	r0, r3, r6
   16882:	f000 ff55 	bl	17730 <memcpy>
	desc->off += len;
   16886:	68ab      	ldr	r3, [r5, #8]
   16888:	4423      	add	r3, r4
   1688a:	60ab      	str	r3, [r5, #8]
	return len;
   1688c:	4620      	mov	r0, r4
}
   1688e:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOSPC;
   16890:	f06f 001b 	mvn.w	r0, #27
   16894:	e7fb      	b.n	1688e <z_cbprintf_cpy+0x24>

00016896 <z_log_msg_finalize>:
{
   16896:	b570      	push	{r4, r5, r6, lr}
	if (!msg) {
   16898:	b198      	cbz	r0, 168c2 <z_log_msg_finalize+0x2c>
   1689a:	460e      	mov	r6, r1
   1689c:	4614      	mov	r4, r2
   1689e:	4619      	mov	r1, r3
   168a0:	4605      	mov	r5, r0
	if (data) {
   168a2:	b143      	cbz	r3, 168b6 <z_log_msg_finalize+0x20>
		uint8_t *d = msg->data + desc.package_len;
   168a4:	f100 0310 	add.w	r3, r0, #16
   168a8:	f3c2 2049 	ubfx	r0, r2, #9, #10
		memcpy(d, data, desc.data_len);
   168ac:	f3c2 42cb 	ubfx	r2, r2, #19, #12
   168b0:	4418      	add	r0, r3
   168b2:	f000 ff3d 	bl	17730 <memcpy>
	msg->hdr.desc = desc;
   168b6:	602c      	str	r4, [r5, #0]
	msg->hdr.source = source;
   168b8:	606e      	str	r6, [r5, #4]
	z_log_msg_commit(msg);
   168ba:	4628      	mov	r0, r5
   168bc:	f7eb fc58 	bl	2170 <z_log_msg_commit>
}
   168c0:	bd70      	pop	{r4, r5, r6, pc}
		z_log_dropped(false);
   168c2:	f7eb fb33 	bl	1f2c <z_log_dropped>
		return;
   168c6:	e7fb      	b.n	168c0 <z_log_msg_finalize+0x2a>

000168c8 <buffer_write>:
{
   168c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   168ca:	4607      	mov	r7, r0
   168cc:	460d      	mov	r5, r1
   168ce:	4614      	mov	r4, r2
   168d0:	461e      	mov	r6, r3
		processed = outf(buf, len, ctx);
   168d2:	4632      	mov	r2, r6
   168d4:	4621      	mov	r1, r4
   168d6:	4628      	mov	r0, r5
   168d8:	47b8      	blx	r7
		buf += processed;
   168da:	4405      	add	r5, r0
	} while (len != 0);
   168dc:	1a24      	subs	r4, r4, r0
   168de:	d1f8      	bne.n	168d2 <buffer_write+0xa>
}
   168e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000168e2 <cbvprintf>:
{
   168e2:	b510      	push	{r4, lr}
   168e4:	b082      	sub	sp, #8
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
   168e6:	2400      	movs	r4, #0
   168e8:	9400      	str	r4, [sp, #0]
   168ea:	f7ea fd6f 	bl	13cc <z_cbvprintf_impl>
}
   168ee:	b002      	add	sp, #8
   168f0:	bd10      	pop	{r4, pc}

000168f2 <color_prefix>:
{
   168f2:	b508      	push	{r3, lr}
   168f4:	4613      	mov	r3, r2
	color_print(output, color, true, level);
   168f6:	2201      	movs	r2, #1
   168f8:	f7eb fd56 	bl	23a8 <color_print>
}
   168fc:	bd08      	pop	{r3, pc}

000168fe <color_postfix>:
{
   168fe:	b508      	push	{r3, lr}
   16900:	4613      	mov	r3, r2
	color_print(output, color, false, level);
   16902:	2200      	movs	r2, #0
   16904:	f7eb fd50 	bl	23a8 <color_print>
}
   16908:	bd08      	pop	{r3, pc}

0001690a <postfix_print>:
{
   1690a:	b538      	push	{r3, r4, r5, lr}
   1690c:	4605      	mov	r5, r0
   1690e:	460c      	mov	r4, r1
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
   16910:	f001 0101 	and.w	r1, r1, #1
   16914:	f7ff fff3 	bl	168fe <color_postfix>
	newline_print(output, flags);
   16918:	4621      	mov	r1, r4
   1691a:	4628      	mov	r0, r5
   1691c:	f7eb fdce 	bl	24bc <newline_print>
}
   16920:	bd38      	pop	{r3, r4, r5, pc}

00016922 <log_msg_hexdump>:
{
   16922:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   16926:	b083      	sub	sp, #12
   16928:	4680      	mov	r8, r0
   1692a:	460e      	mov	r6, r1
   1692c:	4615      	mov	r5, r2
   1692e:	461f      	mov	r7, r3
   16930:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
   16934:	462c      	mov	r4, r5
   16936:	2d10      	cmp	r5, #16
   16938:	bf28      	it	cs
   1693a:	2410      	movcs	r4, #16
		hexdump_line_print(output, data, length,
   1693c:	f8cd 9000 	str.w	r9, [sp]
   16940:	463b      	mov	r3, r7
   16942:	4622      	mov	r2, r4
   16944:	4631      	mov	r1, r6
   16946:	4640      	mov	r0, r8
   16948:	f7eb fdcc 	bl	24e4 <hexdump_line_print>
		data += length;
   1694c:	4426      	add	r6, r4
	} while (len);
   1694e:	1b2d      	subs	r5, r5, r4
   16950:	d1f0      	bne.n	16934 <log_msg_hexdump+0x12>
}
   16952:	b003      	add	sp, #12
   16954:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00016958 <log_output_flush>:
{
   16958:	b510      	push	{r4, lr}
   1695a:	4604      	mov	r4, r0
		     output->control_block->offset,
   1695c:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
   1695e:	6853      	ldr	r3, [r2, #4]
   16960:	6812      	ldr	r2, [r2, #0]
   16962:	6881      	ldr	r1, [r0, #8]
   16964:	6800      	ldr	r0, [r0, #0]
   16966:	f7ff ffaf 	bl	168c8 <buffer_write>
	output->control_block->offset = 0;
   1696a:	6863      	ldr	r3, [r4, #4]
   1696c:	2200      	movs	r2, #0
   1696e:	601a      	str	r2, [r3, #0]
}
   16970:	bd10      	pop	{r4, pc}

00016972 <out_func>:
{
   16972:	b538      	push	{r3, r4, r5, lr}
   16974:	4605      	mov	r5, r0
   16976:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
   16978:	684b      	ldr	r3, [r1, #4]
   1697a:	681a      	ldr	r2, [r3, #0]
   1697c:	68cb      	ldr	r3, [r1, #12]
   1697e:	429a      	cmp	r2, r3
   16980:	d00b      	beq.n	1699a <out_func+0x28>
	idx = atomic_inc(&out_ctx->control_block->offset);
   16982:	6863      	ldr	r3, [r4, #4]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   16984:	e8d3 2fef 	ldaex	r2, [r3]
   16988:	1c51      	adds	r1, r2, #1
   1698a:	e8c3 1fe0 	stlex	r0, r1, [r3]
   1698e:	2800      	cmp	r0, #0
   16990:	d1f8      	bne.n	16984 <out_func+0x12>
	out_ctx->buf[idx] = (uint8_t)c;
   16992:	68a3      	ldr	r3, [r4, #8]
   16994:	549d      	strb	r5, [r3, r2]
}
   16996:	2000      	movs	r0, #0
   16998:	bd38      	pop	{r3, r4, r5, pc}
		log_output_flush(out_ctx);
   1699a:	4608      	mov	r0, r1
   1699c:	f7ff ffdc 	bl	16958 <log_output_flush>
   169a0:	e7ef      	b.n	16982 <out_func+0x10>

000169a2 <cr_out_func>:
{
   169a2:	b538      	push	{r3, r4, r5, lr}
   169a4:	4604      	mov	r4, r0
   169a6:	460d      	mov	r5, r1
	out_func(c, ctx);
   169a8:	f7ff ffe3 	bl	16972 <out_func>
	if (c == '\n') {
   169ac:	2c0a      	cmp	r4, #10
   169ae:	d001      	beq.n	169b4 <cr_out_func+0x12>
}
   169b0:	2000      	movs	r0, #0
   169b2:	bd38      	pop	{r3, r4, r5, pc}
		out_func((int)'\r', ctx);
   169b4:	4629      	mov	r1, r5
   169b6:	200d      	movs	r0, #13
   169b8:	f7ff ffdb 	bl	16972 <out_func>
   169bc:	e7f8      	b.n	169b0 <cr_out_func+0xe>

000169be <virtio_notify_cb>:
{
   169be:	b508      	push	{r3, lr}
	if (conf->mbox_tx.dev) {
   169c0:	68cb      	ldr	r3, [r1, #12]
   169c2:	b14b      	cbz	r3, 169d8 <virtio_notify_cb+0x1a>
		mbox_send(&conf->mbox_tx, NULL);
   169c4:	f101 0c0c 	add.w	ip, r1, #12
		(const struct mbox_driver_api *)channel->dev->api;
   169c8:	68c8      	ldr	r0, [r1, #12]
	const struct mbox_driver_api *api =
   169ca:	6883      	ldr	r3, [r0, #8]
	if (api->send == NULL) {
   169cc:	681b      	ldr	r3, [r3, #0]
   169ce:	b11b      	cbz	r3, 169d8 <virtio_notify_cb+0x1a>
	return api->send(channel->dev, channel->id, msg);
   169d0:	2200      	movs	r2, #0
   169d2:	f8dc 1004 	ldr.w	r1, [ip, #4]
   169d6:	4798      	blx	r3
}
   169d8:	bd08      	pop	{r3, pc}

000169da <get_tx_buffer_size>:
	struct backend_data_t *data = instance->data;
   169da:	6903      	ldr	r3, [r0, #16]
}
   169dc:	f8d3 0388 	ldr.w	r0, [r3, #904]	; 0x388
   169e0:	4770      	bx	lr

000169e2 <drop_tx_buffer>:
}
   169e2:	f06f 0085 	mvn.w	r0, #133	; 0x85
   169e6:	4770      	bx	lr

000169e8 <release_rx_buffer>:
	if (!rpmsg_ept) {
   169e8:	b131      	cbz	r1, 169f8 <release_rx_buffer+0x10>
{
   169ea:	b508      	push	{r3, lr}
   169ec:	4608      	mov	r0, r1
	rpmsg_release_rx_buffer(&rpmsg_ept->ep, data);
   169ee:	4611      	mov	r1, r2
   169f0:	f004 ff83 	bl	1b8fa <rpmsg_release_rx_buffer>
	return 0;
   169f4:	2000      	movs	r0, #0
}
   169f6:	bd08      	pop	{r3, pc}
		return -ENOENT;
   169f8:	f06f 0001 	mvn.w	r0, #1
}
   169fc:	4770      	bx	lr

000169fe <hold_rx_buffer>:
	if (!rpmsg_ept) {
   169fe:	b131      	cbz	r1, 16a0e <hold_rx_buffer+0x10>
{
   16a00:	b508      	push	{r3, lr}
   16a02:	4608      	mov	r0, r1
	rpmsg_hold_rx_buffer(&rpmsg_ept->ep, data);
   16a04:	4611      	mov	r1, r2
   16a06:	f004 ff6e 	bl	1b8e6 <rpmsg_hold_rx_buffer>
	return 0;
   16a0a:	2000      	movs	r0, #0
}
   16a0c:	bd08      	pop	{r3, pc}
		return -ENOENT;
   16a0e:	f06f 0001 	mvn.w	r0, #1
}
   16a12:	4770      	bx	lr

00016a14 <send_nocopy>:
{
   16a14:	b510      	push	{r4, lr}
   16a16:	b082      	sub	sp, #8
   16a18:	460c      	mov	r4, r1
	struct backend_data_t *data = instance->data;
   16a1a:	6901      	ldr	r1, [r0, #16]
	if (atomic_get(&data->state) != STATE_INITED) {
   16a1c:	f501 7161 	add.w	r1, r1, #900	; 0x384
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   16a20:	e8d1 1faf 	lda	r1, [r1]
   16a24:	2902      	cmp	r1, #2
   16a26:	d10a      	bne.n	16a3e <send_nocopy+0x2a>
	if (len == 0) {
   16a28:	b163      	cbz	r3, 16a44 <send_nocopy+0x30>
	if (!rpmsg_ept) {
   16a2a:	b174      	cbz	r4, 16a4a <send_nocopy+0x36>
 * @see rpmsg_sendto_nocopy
 */
static inline int rpmsg_send_nocopy(struct rpmsg_endpoint *ept,
				    const void *data, int len)
{
	return rpmsg_send_offchannel_nocopy(ept, ept->addr,
   16a2c:	9300      	str	r3, [sp, #0]
   16a2e:	4613      	mov	r3, r2
   16a30:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   16a32:	6a61      	ldr	r1, [r4, #36]	; 0x24
   16a34:	4620      	mov	r0, r4
   16a36:	f7fc f9af 	bl	12d98 <rpmsg_send_offchannel_nocopy>
}
   16a3a:	b002      	add	sp, #8
   16a3c:	bd10      	pop	{r4, pc}
		return -EBUSY;
   16a3e:	f06f 000f 	mvn.w	r0, #15
   16a42:	e7fa      	b.n	16a3a <send_nocopy+0x26>
		return -EBADMSG;
   16a44:	f06f 004c 	mvn.w	r0, #76	; 0x4c
   16a48:	e7f7      	b.n	16a3a <send_nocopy+0x26>
		return -ENOENT;
   16a4a:	f06f 0001 	mvn.w	r0, #1
   16a4e:	e7f4      	b.n	16a3a <send_nocopy+0x26>

00016a50 <get_tx_buffer>:
{
   16a50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16a54:	4690      	mov	r8, r2
   16a56:	461e      	mov	r6, r3
   16a58:	9b06      	ldr	r3, [sp, #24]
   16a5a:	9a07      	ldr	r2, [sp, #28]
	struct backend_data_t *data = instance->data;
   16a5c:	6900      	ldr	r0, [r0, #16]
	if (!rpmsg_ept) {
   16a5e:	b3a1      	cbz	r1, 16aca <get_tx_buffer+0x7a>
   16a60:	460f      	mov	r7, r1
	if (!r_data || !size) {
   16a62:	f1b8 0f00 	cmp.w	r8, #0
   16a66:	d033      	beq.n	16ad0 <get_tx_buffer+0x80>
   16a68:	b3ae      	cbz	r6, 16ad6 <get_tx_buffer+0x86>
	if (!K_TIMEOUT_EQ(wait, K_FOREVER) && !K_TIMEOUT_EQ(wait, K_NO_WAIT)) {
   16a6a:	461c      	mov	r4, r3
   16a6c:	4615      	mov	r5, r2
   16a6e:	f1b2 3fff 	cmp.w	r2, #4294967295
   16a72:	bf08      	it	eq
   16a74:	f1b3 3fff 	cmpeq.w	r3, #4294967295
   16a78:	d001      	beq.n	16a7e <get_tx_buffer+0x2e>
   16a7a:	4313      	orrs	r3, r2
   16a7c:	d11e      	bne.n	16abc <get_tx_buffer+0x6c>
	if ((*size) && (*size > data->tx_buffer_size)) {
   16a7e:	6833      	ldr	r3, [r6, #0]
   16a80:	b11b      	cbz	r3, 16a8a <get_tx_buffer+0x3a>
   16a82:	f8d0 2388 	ldr.w	r2, [r0, #904]	; 0x388
   16a86:	4293      	cmp	r3, r2
   16a88:	d81b      	bhi.n	16ac2 <get_tx_buffer+0x72>
		payload = rpmsg_get_tx_payload_buffer(&rpmsg_ept->ep, size,
   16a8a:	ea04 0205 	and.w	r2, r4, r5
   16a8e:	f1b2 3fff 	cmp.w	r2, #4294967295
   16a92:	bf14      	ite	ne
   16a94:	2200      	movne	r2, #0
   16a96:	2201      	moveq	r2, #1
   16a98:	4631      	mov	r1, r6
   16a9a:	4638      	mov	r0, r7
   16a9c:	f004 ff37 	bl	1b90e <rpmsg_get_tx_payload_buffer>
	} while ((!payload) && K_TIMEOUT_EQ(wait, K_FOREVER));
   16aa0:	4603      	mov	r3, r0
   16aa2:	b928      	cbnz	r0, 16ab0 <get_tx_buffer+0x60>
   16aa4:	f1b5 3fff 	cmp.w	r5, #4294967295
   16aa8:	bf08      	it	eq
   16aaa:	f1b4 3fff 	cmpeq.w	r4, #4294967295
   16aae:	d0ec      	beq.n	16a8a <get_tx_buffer+0x3a>
	if (!payload) {
   16ab0:	b1a3      	cbz	r3, 16adc <get_tx_buffer+0x8c>
	(*r_data) = payload;
   16ab2:	f8c8 3000 	str.w	r3, [r8]
	return 0;
   16ab6:	2000      	movs	r0, #0
}
   16ab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOTSUP;
   16abc:	f06f 0085 	mvn.w	r0, #133	; 0x85
   16ac0:	e7fa      	b.n	16ab8 <get_tx_buffer+0x68>
		*size = data->tx_buffer_size;
   16ac2:	6032      	str	r2, [r6, #0]
		return -ENOMEM;
   16ac4:	f06f 000b 	mvn.w	r0, #11
   16ac8:	e7f6      	b.n	16ab8 <get_tx_buffer+0x68>
		return -ENOENT;
   16aca:	f06f 0001 	mvn.w	r0, #1
   16ace:	e7f3      	b.n	16ab8 <get_tx_buffer+0x68>
		return -EINVAL;
   16ad0:	f06f 0015 	mvn.w	r0, #21
   16ad4:	e7f0      	b.n	16ab8 <get_tx_buffer+0x68>
   16ad6:	f06f 0015 	mvn.w	r0, #21
   16ada:	e7ed      	b.n	16ab8 <get_tx_buffer+0x68>
		return -ENOBUFS;
   16adc:	f06f 0068 	mvn.w	r0, #104	; 0x68
   16ae0:	e7ea      	b.n	16ab8 <get_tx_buffer+0x68>

00016ae2 <get_ept_slot_with_name>:
{
   16ae2:	b570      	push	{r4, r5, r6, lr}
   16ae4:	4605      	mov	r5, r0
   16ae6:	460e      	mov	r6, r1
	for (size_t i = 0; i < NUM_ENDPOINTS; i++) {
   16ae8:	2400      	movs	r4, #0
   16aea:	2c01      	cmp	r4, #1
   16aec:	d80f      	bhi.n	16b0e <get_ept_slot_with_name+0x2c>
		if (strcmp(name, rpmsg_ept->name) == 0) {
   16aee:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   16af2:	011b      	lsls	r3, r3, #4
   16af4:	3340      	adds	r3, #64	; 0x40
   16af6:	18e9      	adds	r1, r5, r3
   16af8:	4630      	mov	r0, r6
   16afa:	f000 fde9 	bl	176d0 <strcmp>
   16afe:	b108      	cbz	r0, 16b04 <get_ept_slot_with_name+0x22>
	for (size_t i = 0; i < NUM_ENDPOINTS; i++) {
   16b00:	3401      	adds	r4, #1
   16b02:	e7f2      	b.n	16aea <get_ept_slot_with_name+0x8>
			return &rpmsg_inst->endpoint[i];
   16b04:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   16b08:	eb05 1004 	add.w	r0, r5, r4, lsl #4
   16b0c:	e000      	b.n	16b10 <get_ept_slot_with_name+0x2e>
	return NULL;
   16b0e:	2000      	movs	r0, #0
}
   16b10:	bd70      	pop	{r4, r5, r6, pc}

00016b12 <get_ept>:
{
   16b12:	b538      	push	{r3, r4, r5, lr}
   16b14:	4605      	mov	r5, r0
   16b16:	460c      	mov	r4, r1
	ept = get_ept_slot_with_name(rpmsg_inst, name);
   16b18:	4611      	mov	r1, r2
   16b1a:	f7ff ffe2 	bl	16ae2 <get_ept_slot_with_name>
	if (ept != NULL) {
   16b1e:	b110      	cbz	r0, 16b26 <get_ept+0x14>
		(*rpmsg_ept) = ept;
   16b20:	6020      	str	r0, [r4, #0]
		return true;
   16b22:	2001      	movs	r0, #1
}
   16b24:	bd38      	pop	{r3, r4, r5, pc}
	ept = get_available_ept_slot(rpmsg_inst);
   16b26:	4628      	mov	r0, r5
   16b28:	f7eb ff92 	bl	2a50 <get_available_ept_slot>
	if (ept != NULL) {
   16b2c:	b110      	cbz	r0, 16b34 <get_ept+0x22>
		(*rpmsg_ept) = ept;
   16b2e:	6020      	str	r0, [r4, #0]
		return false;
   16b30:	2000      	movs	r0, #0
   16b32:	e7f7      	b.n	16b24 <get_ept+0x12>
	(*rpmsg_ept) = NULL;
   16b34:	2000      	movs	r0, #0
   16b36:	6020      	str	r0, [r4, #0]
	return false;
   16b38:	e7f4      	b.n	16b24 <get_ept+0x12>

00016b3a <rpmsg_service_unbind>:
{
   16b3a:	b508      	push	{r3, lr}
	rpmsg_destroy_ept(ep);
   16b3c:	f004 ff2b 	bl	1b996 <rpmsg_destroy_ept>
}
   16b40:	bd08      	pop	{r3, pc}

00016b42 <register_ept_on_host>:
{
   16b42:	b5f0      	push	{r4, r5, r6, r7, lr}
   16b44:	b083      	sub	sp, #12
   16b46:	4607      	mov	r7, r0
   16b48:	460d      	mov	r5, r1
	k_mutex_lock(&rpmsg_inst->mtx, K_FOREVER);
   16b4a:	f500 76ce 	add.w	r6, r0, #412	; 0x19c
	return z_impl_k_mutex_lock(mutex, timeout);
   16b4e:	f04f 32ff 	mov.w	r2, #4294967295
   16b52:	f04f 33ff 	mov.w	r3, #4294967295
   16b56:	4630      	mov	r0, r6
   16b58:	f7fc ff18 	bl	1398c <z_impl_k_mutex_lock>
	ept_cached = get_ept(rpmsg_inst, &rpmsg_ept, cfg->name);
   16b5c:	682a      	ldr	r2, [r5, #0]
   16b5e:	a901      	add	r1, sp, #4
   16b60:	4638      	mov	r0, r7
   16b62:	f7ff ffd6 	bl	16b12 <get_ept>
	if (rpmsg_ept == NULL) {
   16b66:	9c01      	ldr	r4, [sp, #4]
   16b68:	b1b4      	cbz	r4, 16b98 <register_ept_on_host+0x56>
	rpmsg_ept->cb = &cfg->cb;
   16b6a:	f105 0308 	add.w	r3, r5, #8
   16b6e:	66a3      	str	r3, [r4, #104]	; 0x68
	rpmsg_ept->priv = cfg->priv;
   16b70:	696b      	ldr	r3, [r5, #20]
   16b72:	66e3      	str	r3, [r4, #108]	; 0x6c
	rpmsg_ept->bound = false;
   16b74:	2300      	movs	r3, #0
   16b76:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
	rpmsg_ept->ep.priv = rpmsg_ept;
   16b7a:	63e4      	str	r4, [r4, #60]	; 0x3c
	if (ept_cached) {
   16b7c:	b180      	cbz	r0, 16ba0 <register_ept_on_host+0x5e>
	return z_impl_k_mutex_unlock(mutex);
   16b7e:	4630      	mov	r0, r6
   16b80:	f7fc ff8e 	bl	13aa0 <z_impl_k_mutex_unlock>
		advertise_ept(rpmsg_inst, rpmsg_ept, cfg->name, rpmsg_ept->dest);
   16b84:	9901      	ldr	r1, [sp, #4]
   16b86:	6e0b      	ldr	r3, [r1, #96]	; 0x60
   16b88:	682a      	ldr	r2, [r5, #0]
   16b8a:	4638      	mov	r0, r7
   16b8c:	f7eb ff68 	bl	2a60 <advertise_ept>
	return rpmsg_ept;
   16b90:	9c01      	ldr	r4, [sp, #4]
}
   16b92:	4620      	mov	r0, r4
   16b94:	b003      	add	sp, #12
   16b96:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16b98:	4630      	mov	r0, r6
   16b9a:	f7fc ff81 	bl	13aa0 <z_impl_k_mutex_unlock>
		return NULL;
   16b9e:	e7f8      	b.n	16b92 <register_ept_on_host+0x50>
		strncpy(rpmsg_ept->name, cfg->name, sizeof(rpmsg_ept->name));
   16ba0:	2220      	movs	r2, #32
   16ba2:	6829      	ldr	r1, [r5, #0]
   16ba4:	f104 0040 	add.w	r0, r4, #64	; 0x40
   16ba8:	f000 fd65 	bl	17676 <strncpy>
   16bac:	4630      	mov	r0, r6
   16bae:	f7fc ff77 	bl	13aa0 <z_impl_k_mutex_unlock>
   16bb2:	e7ed      	b.n	16b90 <register_ept_on_host+0x4e>

00016bb4 <ns_bind_cb>:
{
   16bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
   16bb6:	b083      	sub	sp, #12
	rpmsg_inst = CONTAINER_OF(p_rvdev->shpool, struct ipc_rpmsg_instance, shm_pool);
   16bb8:	f8d0 40a4 	ldr.w	r4, [r0, #164]	; 0xa4
	if (name == NULL || name[0] == '\0') {
   16bbc:	b129      	cbz	r1, 16bca <ns_bind_cb+0x16>
   16bbe:	4616      	mov	r6, r2
   16bc0:	f5a4 77c4 	sub.w	r7, r4, #392	; 0x188
   16bc4:	460d      	mov	r5, r1
   16bc6:	780b      	ldrb	r3, [r1, #0]
   16bc8:	b90b      	cbnz	r3, 16bce <ns_bind_cb+0x1a>
}
   16bca:	b003      	add	sp, #12
   16bcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	k_mutex_lock(&rpmsg_inst->mtx, K_FOREVER);
   16bce:	3414      	adds	r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   16bd0:	f04f 32ff 	mov.w	r2, #4294967295
   16bd4:	f04f 33ff 	mov.w	r3, #4294967295
   16bd8:	4620      	mov	r0, r4
   16bda:	f7fc fed7 	bl	1398c <z_impl_k_mutex_lock>
	ept_cached = get_ept(rpmsg_inst, &rpmsg_ept, name);
   16bde:	462a      	mov	r2, r5
   16be0:	a901      	add	r1, sp, #4
   16be2:	4638      	mov	r0, r7
   16be4:	f7ff ff95 	bl	16b12 <get_ept>
	if (rpmsg_ept == NULL) {
   16be8:	9b01      	ldr	r3, [sp, #4]
   16bea:	b153      	cbz	r3, 16c02 <ns_bind_cb+0x4e>
	if (ept_cached) {
   16bec:	b168      	cbz	r0, 16c0a <ns_bind_cb+0x56>
	return z_impl_k_mutex_unlock(mutex);
   16bee:	4620      	mov	r0, r4
   16bf0:	f7fc ff56 	bl	13aa0 <z_impl_k_mutex_unlock>
		advertise_ept(rpmsg_inst, rpmsg_ept, name, dest);
   16bf4:	4633      	mov	r3, r6
   16bf6:	462a      	mov	r2, r5
   16bf8:	9901      	ldr	r1, [sp, #4]
   16bfa:	4638      	mov	r0, r7
   16bfc:	f7eb ff30 	bl	2a60 <advertise_ept>
   16c00:	e7e3      	b.n	16bca <ns_bind_cb+0x16>
   16c02:	4620      	mov	r0, r4
   16c04:	f7fc ff4c 	bl	13aa0 <z_impl_k_mutex_unlock>
		return;
   16c08:	e7df      	b.n	16bca <ns_bind_cb+0x16>
		strncpy(rpmsg_ept->name, name, sizeof(rpmsg_ept->name));
   16c0a:	2220      	movs	r2, #32
   16c0c:	4629      	mov	r1, r5
   16c0e:	f103 0040 	add.w	r0, r3, #64	; 0x40
   16c12:	f000 fd30 	bl	17676 <strncpy>
		rpmsg_ept->dest = dest;
   16c16:	9b01      	ldr	r3, [sp, #4]
   16c18:	661e      	str	r6, [r3, #96]	; 0x60
   16c1a:	4620      	mov	r0, r4
   16c1c:	f7fc ff40 	bl	13aa0 <z_impl_k_mutex_unlock>
   16c20:	e7d3      	b.n	16bca <ns_bind_cb+0x16>

00016c22 <register_ept_on_remote>:
{
   16c22:	b570      	push	{r4, r5, r6, lr}
   16c24:	4606      	mov	r6, r0
   16c26:	460d      	mov	r5, r1
	rpmsg_ept = get_available_ept_slot(rpmsg_inst);
   16c28:	f7eb ff12 	bl	2a50 <get_available_ept_slot>
	if (rpmsg_ept == NULL) {
   16c2c:	4604      	mov	r4, r0
   16c2e:	b198      	cbz	r0, 16c58 <register_ept_on_remote+0x36>
	rpmsg_ept->cb = &cfg->cb;
   16c30:	f105 0308 	add.w	r3, r5, #8
   16c34:	6683      	str	r3, [r0, #104]	; 0x68
	rpmsg_ept->priv = cfg->priv;
   16c36:	696b      	ldr	r3, [r5, #20]
   16c38:	66c3      	str	r3, [r0, #108]	; 0x6c
	rpmsg_ept->bound = false;
   16c3a:	2300      	movs	r3, #0
   16c3c:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
	rpmsg_ept->ep.priv = rpmsg_ept;
   16c40:	63e0      	str	r0, [r4, #60]	; 0x3c
	strncpy(rpmsg_ept->name, cfg->name, sizeof(rpmsg_ept->name));
   16c42:	2220      	movs	r2, #32
   16c44:	6829      	ldr	r1, [r5, #0]
   16c46:	3040      	adds	r0, #64	; 0x40
   16c48:	f000 fd15 	bl	17676 <strncpy>
	err = ipc_rpmsg_register_ept(rpmsg_inst, RPMSG_REMOTE, rpmsg_ept);
   16c4c:	4622      	mov	r2, r4
   16c4e:	2101      	movs	r1, #1
   16c50:	4630      	mov	r0, r6
   16c52:	f7ec f871 	bl	2d38 <ipc_rpmsg_register_ept>
	if (err != 0) {
   16c56:	b908      	cbnz	r0, 16c5c <register_ept_on_remote+0x3a>
}
   16c58:	4620      	mov	r0, r4
   16c5a:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   16c5c:	2400      	movs	r4, #0
   16c5e:	e7fb      	b.n	16c58 <register_ept_on_remote+0x36>

00016c60 <register_ept>:
	struct backend_data_t *data = instance->data;
   16c60:	6900      	ldr	r0, [r0, #16]
	if (atomic_get(&data->state) != STATE_INITED) {
   16c62:	f500 7361 	add.w	r3, r0, #900	; 0x384
   16c66:	e8d3 3faf 	lda	r3, [r3]
   16c6a:	2b02      	cmp	r3, #2
   16c6c:	d112      	bne.n	16c94 <register_ept+0x34>
{
   16c6e:	b510      	push	{r4, lr}
   16c70:	460c      	mov	r4, r1
   16c72:	4611      	mov	r1, r2
	if (cfg->name == NULL || cfg->name[0] == '\0') {
   16c74:	6813      	ldr	r3, [r2, #0]
   16c76:	b183      	cbz	r3, 16c9a <register_ept+0x3a>
   16c78:	781b      	ldrb	r3, [r3, #0]
   16c7a:	b18b      	cbz	r3, 16ca0 <register_ept+0x40>
	rpmsg_ept = (data->role == ROLE_HOST) ?
   16c7c:	f8d0 3380 	ldr.w	r3, [r0, #896]	; 0x380
			register_ept_on_host(rpmsg_inst, cfg) :
   16c80:	b92b      	cbnz	r3, 16c8e <register_ept+0x2e>
   16c82:	f7ff ff5e 	bl	16b42 <register_ept_on_host>
	if (rpmsg_ept == NULL) {
   16c86:	b170      	cbz	r0, 16ca6 <register_ept+0x46>
	(*token) = rpmsg_ept;
   16c88:	6020      	str	r0, [r4, #0]
	return 0;
   16c8a:	2000      	movs	r0, #0
}
   16c8c:	bd10      	pop	{r4, pc}
			register_ept_on_remote(rpmsg_inst, cfg);
   16c8e:	f7ff ffc8 	bl	16c22 <register_ept_on_remote>
   16c92:	e7f8      	b.n	16c86 <register_ept+0x26>
		return -EBUSY;
   16c94:	f06f 000f 	mvn.w	r0, #15
}
   16c98:	4770      	bx	lr
		return -EINVAL;
   16c9a:	f06f 0015 	mvn.w	r0, #21
   16c9e:	e7f5      	b.n	16c8c <register_ept+0x2c>
   16ca0:	f06f 0015 	mvn.w	r0, #21
   16ca4:	e7f2      	b.n	16c8c <register_ept+0x2c>
		return -EINVAL;
   16ca6:	f06f 0015 	mvn.w	r0, #21
   16caa:	e7ef      	b.n	16c8c <register_ept+0x2c>

00016cac <ept_cb>:
{
   16cac:	b510      	push	{r4, lr}
   16cae:	9b02      	ldr	r3, [sp, #8]
	if (len == 0) {
   16cb0:	b142      	cbz	r2, 16cc4 <ept_cb+0x18>
   16cb2:	4608      	mov	r0, r1
   16cb4:	4611      	mov	r1, r2
	if (ept->cb->received) {
   16cb6:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   16cb8:	6854      	ldr	r4, [r2, #4]
   16cba:	b10c      	cbz	r4, 16cc0 <ept_cb+0x14>
		ept->cb->received(data, len, ept->priv);
   16cbc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   16cbe:	47a0      	blx	r4
}
   16cc0:	2000      	movs	r0, #0
   16cc2:	bd10      	pop	{r4, pc}
		if (!ept->bound) {
   16cc4:	f893 2064 	ldrb.w	r2, [r3, #100]	; 0x64
   16cc8:	2a00      	cmp	r2, #0
   16cca:	d1f9      	bne.n	16cc0 <ept_cb+0x14>
			ept->bound = true;
   16ccc:	2201      	movs	r2, #1
   16cce:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
			bound_cb(ept);
   16cd2:	4618      	mov	r0, r3
   16cd4:	f7eb fee2 	bl	2a9c <bound_cb>
		return RPMSG_SUCCESS;
   16cd8:	e7f2      	b.n	16cc0 <ept_cb+0x14>

00016cda <vr_shm_configure>:
{
   16cda:	b530      	push	{r4, r5, lr}
	num_desc = optimal_num_desc(conf->shm_size, conf->buffer_size);
   16cdc:	688c      	ldr	r4, [r1, #8]
   16cde:	6a8a      	ldr	r2, [r1, #40]	; 0x28
static inline unsigned int optimal_num_desc(size_t shm_size, unsigned int buf_size)
{
	size_t available, single_alloc;
	unsigned int num_desc;

	available = shm_size - VDEV_STATUS_SIZE;
   16ce0:	3c04      	subs	r4, #4
	single_alloc = VRING_COUNT * (vq_ring_size(1, buf_size) + vring_size(1, VRING_ALIGNMENT));
   16ce2:	3226      	adds	r2, #38	; 0x26
   16ce4:	0052      	lsls	r2, r2, #1

	num_desc = (unsigned int) (available / single_alloc);
   16ce6:	fbb4 fcf2 	udiv	ip, r4, r2
 * @return most significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	if (op == 0) {
   16cea:	42a2      	cmp	r2, r4
   16cec:	d842      	bhi.n	16d74 <vr_shm_configure+0x9a>
		return 0;
	}

	return 32 - __builtin_clz(op);
   16cee:	fabc fc8c 	clz	ip, ip
   16cf2:	f1cc 0c20 	rsb	ip, ip, #32

	return (1 << (find_msb_set(num_desc) - 1));
   16cf6:	f10c 3cff 	add.w	ip, ip, #4294967295
   16cfa:	2201      	movs	r2, #1
	if (num_desc == 0) {
   16cfc:	fa12 f20c 	lsls.w	r2, r2, ip
   16d00:	d03b      	beq.n	16d7a <vr_shm_configure+0xa0>
	vr->shm_addr = conf->shm_addr + VDEV_STATUS_SIZE;
   16d02:	684c      	ldr	r4, [r1, #4]
   16d04:	1d25      	adds	r5, r4, #4
   16d06:	f8c0 5098 	str.w	r5, [r0, #152]	; 0x98
	vr->shm_size = shm_size(num_desc, conf->buffer_size) - VDEV_STATUS_SIZE;
   16d0a:	6a8b      	ldr	r3, [r1, #40]	; 0x28
	return (buf_size * num);
   16d0c:	fb02 f303 	mul.w	r3, r2, r3
	return (VDEV_STATUS_SIZE + (VRING_COUNT * vq_ring_size(num, buf_size)) +
   16d10:	1c9c      	adds	r4, r3, #2
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
   16d12:	1cd3      	adds	r3, r2, #3
   16d14:	ea4f 0e43 	mov.w	lr, r3, lsl #1
   16d18:	eb0e 1302 	add.w	r3, lr, r2, lsl #4
	size = (size + align - 1) & ~(align - 1);
   16d1c:	3303      	adds	r3, #3
   16d1e:	f023 0303 	bic.w	r3, r3, #3
	size += sizeof(struct vring_used) +
   16d22:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   16d26:	3306      	adds	r3, #6
	       (VRING_COUNT * vring_size(num, VRING_ALIGNMENT)));
   16d28:	005b      	lsls	r3, r3, #1
	return (VDEV_STATUS_SIZE + (VRING_COUNT * vq_ring_size(num, buf_size)) +
   16d2a:	eb03 0344 	add.w	r3, r3, r4, lsl #1
   16d2e:	3b04      	subs	r3, #4
   16d30:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
	vr->rx_addr = vr->shm_addr + VRING_COUNT * vq_ring_size(num_desc, conf->buffer_size);
   16d34:	6a8c      	ldr	r4, [r1, #40]	; 0x28
	return (buf_size * num);
   16d36:	fa04 f40c 	lsl.w	r4, r4, ip
   16d3a:	eb05 0444 	add.w	r4, r5, r4, lsl #1
   16d3e:	f8c0 4090 	str.w	r4, [r0, #144]	; 0x90
	size = num * sizeof(struct vring_desc);
   16d42:	2310      	movs	r3, #16
   16d44:	fa03 f30c 	lsl.w	r3, r3, ip
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
   16d48:	4473      	add	r3, lr
	size = (size + align - 1) & ~(align - 1);
   16d4a:	3303      	adds	r3, #3
   16d4c:	f023 0303 	bic.w	r3, r3, #3
	    (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);
   16d50:	2508      	movs	r5, #8
   16d52:	fa05 fc0c 	lsl.w	ip, r5, ip
	size += sizeof(struct vring_used) +
   16d56:	4463      	add	r3, ip
   16d58:	3306      	adds	r3, #6
	vr->tx_addr = ROUND_UP(vr->rx_addr + vring_size(num_desc, VRING_ALIGNMENT),
   16d5a:	4423      	add	r3, r4
   16d5c:	3303      	adds	r3, #3
   16d5e:	f023 0303 	bic.w	r3, r3, #3
   16d62:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
	vr->status_reg_addr = conf->shm_addr;
   16d66:	684b      	ldr	r3, [r1, #4]
   16d68:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
	vr->vring_size = num_desc;
   16d6c:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
	return 0;
   16d70:	2000      	movs	r0, #0
}
   16d72:	bd30      	pop	{r4, r5, pc}
		return 0;
   16d74:	f04f 0c00 	mov.w	ip, #0
   16d78:	e7bd      	b.n	16cf6 <vr_shm_configure+0x1c>
		return -ENOMEM;
   16d7a:	f06f 000b 	mvn.w	r0, #11
   16d7e:	e7f8      	b.n	16d72 <vr_shm_configure+0x98>

00016d80 <mbox_callback>:
{
   16d80:	b508      	push	{r3, lr}
	k_work_submit_to_queue(&data->mbox_wq, &data->mbox_work);
   16d82:	f502 7126 	add.w	r1, r2, #664	; 0x298
   16d86:	f502 702a 	add.w	r0, r2, #680	; 0x2a8
   16d8a:	f005 fadf 	bl	1c34c <k_work_submit_to_queue>
}
   16d8e:	bd08      	pop	{r3, pc}

00016d90 <mbox_callback_process>:
{
   16d90:	b508      	push	{r3, lr}
	vq_id = (data->role == ROLE_HOST) ? VIRTQUEUE_ID_HOST : VIRTQUEUE_ID_REMOTE;
   16d92:	f8d0 30e8 	ldr.w	r3, [r0, #232]	; 0xe8
   16d96:	f5a0 7026 	sub.w	r0, r0, #664	; 0x298
   16d9a:	3b00      	subs	r3, #0
   16d9c:	bf18      	it	ne
   16d9e:	2301      	movne	r3, #1
	virtqueue_notification(data->vr.vq[vq_id]);
   16da0:	33a0      	adds	r3, #160	; 0xa0
   16da2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   16da6:	6840      	ldr	r0, [r0, #4]
   16da8:	f004 fd20 	bl	1b7ec <virtqueue_notification>
}
   16dac:	bd08      	pop	{r3, pc}

00016dae <backend_init>:
{
   16dae:	b510      	push	{r4, lr}
	const struct backend_config_t *conf = instance->config;
   16db0:	6843      	ldr	r3, [r0, #4]
	struct backend_data_t *data = instance->data;
   16db2:	6904      	ldr	r4, [r0, #16]
	data->role = conf->role;
   16db4:	681b      	ldr	r3, [r3, #0]
   16db6:	f8c4 3380 	str.w	r3, [r4, #896]	; 0x380
	k_mutex_init(&data->rpmsg_inst.mtx);
   16dba:	f504 70ce 	add.w	r0, r4, #412	; 0x19c
	return z_impl_k_mutex_init(mutex);
   16dbe:	f005 f93b 	bl	1c038 <z_impl_k_mutex_init>
	atomic_set(&data->state, STATE_READY);
   16dc2:	f504 7461 	add.w	r4, r4, #900	; 0x384
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   16dc6:	2000      	movs	r0, #0
   16dc8:	e8d4 3fef 	ldaex	r3, [r4]
   16dcc:	e8c4 0fe2 	stlex	r2, r0, [r4]
   16dd0:	2a00      	cmp	r2, #0
   16dd2:	d1f9      	bne.n	16dc8 <backend_init+0x1a>
}
   16dd4:	bd10      	pop	{r4, pc}

00016dd6 <rpmsg_service_unbind>:
{
   16dd6:	b508      	push	{r3, lr}
	rpmsg_destroy_ept(ep);
   16dd8:	f004 fddd 	bl	1b996 <rpmsg_destroy_ept>
}
   16ddc:	bd08      	pop	{r3, pc}

00016dde <virtio_notify>:
{
   16dde:	b508      	push	{r3, lr}
	vr = CONTAINER_OF(vq->vq_dev, struct ipc_static_vrings, vdev);
   16de0:	6802      	ldr	r2, [r0, #0]
	if (vr->notify_cb) {
   16de2:	f8d2 30e0 	ldr.w	r3, [r2, #224]	; 0xe0
   16de6:	b113      	cbz	r3, 16dee <virtio_notify+0x10>
		vr->notify_cb(vq, vr->priv);
   16de8:	f8d2 10dc 	ldr.w	r1, [r2, #220]	; 0xdc
   16dec:	4798      	blx	r3
}
   16dee:	bd08      	pop	{r3, pc}

00016df0 <virtio_set_features>:
}
   16df0:	4770      	bx	lr

00016df2 <virtio_set_status>:
	if (p_vdev->role != VIRTIO_DEV_DRIVER) {
   16df2:	6983      	ldr	r3, [r0, #24]
   16df4:	b913      	cbnz	r3, 16dfc <virtio_set_status+0xa>
	sys_write8(status, vr->status_reg_addr);
   16df6:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
	return *(volatile uint8_t *)addr;
}

static ALWAYS_INLINE void sys_write8(uint8_t data, mem_addr_t addr)
{
	*(volatile uint8_t *)addr = data;
   16dfa:	7019      	strb	r1, [r3, #0]
}
   16dfc:	4770      	bx	lr

00016dfe <virtio_get_features>:
}
   16dfe:	2001      	movs	r0, #1
   16e00:	4770      	bx	lr

00016e02 <virtio_get_status>:
	if (p_vdev->role == VIRTIO_DEV_DEVICE) {
   16e02:	6983      	ldr	r3, [r0, #24]
   16e04:	2b01      	cmp	r3, #1
   16e06:	d001      	beq.n	16e0c <virtio_get_status+0xa>
	ret = VIRTIO_CONFIG_STATUS_DRIVER_OK;
   16e08:	2004      	movs	r0, #4
}
   16e0a:	4770      	bx	lr
		ret = sys_read8(vr->status_reg_addr);
   16e0c:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
	return *(volatile uint8_t *)addr;
   16e10:	7818      	ldrb	r0, [r3, #0]
   16e12:	b2c0      	uxtb	r0, r0
   16e14:	4770      	bx	lr

00016e16 <pm_policy_state_lock_is_active>:
			return (atomic_get(&substate_lock_t[i].lock) != 0);
		}
	}

	return false;
}
   16e16:	2000      	movs	r0, #0
   16e18:	4770      	bx	lr

00016e1a <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
   16e1a:	428b      	cmp	r3, r1
   16e1c:	d901      	bls.n	16e22 <_copy+0x8>
		(void)memcpy(to, from, from_len);
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
   16e1e:	2000      	movs	r0, #0
	}
}
   16e20:	4770      	bx	lr
{
   16e22:	b510      	push	{r4, lr}
   16e24:	4694      	mov	ip, r2
   16e26:	461c      	mov	r4, r3
		(void)memcpy(to, from, from_len);
   16e28:	461a      	mov	r2, r3
   16e2a:	4661      	mov	r1, ip
   16e2c:	f000 fc80 	bl	17730 <memcpy>
		return from_len;
   16e30:	4620      	mov	r0, r4
}
   16e32:	bd10      	pop	{r4, pc}

00016e34 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
   16e34:	b508      	push	{r3, lr}
	(void)memset(to, val, len);
   16e36:	f000 fcaa 	bl	1778e <memset>
}
   16e3a:	bd08      	pop	{r3, pc}

00016e3c <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   16e3c:	09c3      	lsrs	r3, r0, #7
   16e3e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   16e42:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   16e46:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   16e4a:	b2c0      	uxtb	r0, r0
   16e4c:	4770      	bx	lr

00016e4e <gf_double>:
 */
void gf_double(uint8_t *out, uint8_t *in)
{

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);
   16e4e:	460b      	mov	r3, r1

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   16e50:	f913 2b0f 	ldrsb.w	r2, [r3], #15
   16e54:	2a00      	cmp	r2, #0
   16e56:	db04      	blt.n	16e62 <gf_double+0x14>
   16e58:	f04f 0c00 	mov.w	ip, #0

	out += (TC_AES_BLOCK_SIZE - 1);
   16e5c:	f100 020f 	add.w	r2, r0, #15
   16e60:	e006      	b.n	16e70 <gf_double+0x22>
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   16e62:	f04f 0c87 	mov.w	ip, #135	; 0x87
   16e66:	e7f9      	b.n	16e5c <gf_double+0xe>
	for (;;) {
		*out-- = (*x << 1) ^ carry;
		if (x == in) {
			break;
		}
		carry = *x-- >> 7;
   16e68:	f813 0901 	ldrb.w	r0, [r3], #-1
   16e6c:	ea4f 1cd0 	mov.w	ip, r0, lsr #7
		*out-- = (*x << 1) ^ carry;
   16e70:	7818      	ldrb	r0, [r3, #0]
   16e72:	ea8c 0040 	eor.w	r0, ip, r0, lsl #1
   16e76:	f802 0901 	strb.w	r0, [r2], #-1
		if (x == in) {
   16e7a:	428b      	cmp	r3, r1
   16e7c:	d1f4      	bne.n	16e68 <gf_double+0x1a>
	}
}
   16e7e:	4770      	bx	lr

00016e80 <tc_cmac_erase>:
	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
	if (s == (TCCmacState_t) 0) {
   16e80:	b130      	cbz	r0, 16e90 <tc_cmac_erase+0x10>
{
   16e82:	b508      	push	{r3, lr}
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   16e84:	2258      	movs	r2, #88	; 0x58
   16e86:	2100      	movs	r1, #0
   16e88:	f7ff ffd4 	bl	16e34 <_set>

	return TC_CRYPTO_SUCCESS;
   16e8c:	2001      	movs	r0, #1
}
   16e8e:	bd08      	pop	{r3, pc}
		return TC_CRYPTO_FAIL;
   16e90:	2000      	movs	r0, #0
}
   16e92:	4770      	bx	lr

00016e94 <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   16e94:	b1a0      	cbz	r0, 16ec0 <tc_cmac_init+0x2c>
{
   16e96:	b510      	push	{r4, lr}
   16e98:	4604      	mov	r4, r0
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   16e9a:	2210      	movs	r2, #16
   16e9c:	2100      	movs	r1, #0
   16e9e:	f7ff ffc9 	bl	16e34 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   16ea2:	2210      	movs	r2, #16
   16ea4:	2100      	movs	r1, #0
   16ea6:	f104 0030 	add.w	r0, r4, #48	; 0x30
   16eaa:	f7ff ffc3 	bl	16e34 <_set>
	s->leftover_offset = 0;
   16eae:	2300      	movs	r3, #0
   16eb0:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   16eb2:	2200      	movs	r2, #0
   16eb4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   16eb8:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50

	return TC_CRYPTO_SUCCESS;
   16ebc:	2001      	movs	r0, #1
}
   16ebe:	bd10      	pop	{r4, pc}
		return TC_CRYPTO_FAIL;
   16ec0:	2000      	movs	r0, #0
}
   16ec2:	4770      	bx	lr

00016ec4 <tc_cmac_setup>:
	if (s == (TCCmacState_t) 0 ||
   16ec4:	b338      	cbz	r0, 16f16 <tc_cmac_setup+0x52>
{
   16ec6:	b570      	push	{r4, r5, r6, lr}
   16ec8:	460d      	mov	r5, r1
   16eca:	4616      	mov	r6, r2
   16ecc:	4604      	mov	r4, r0
	if (s == (TCCmacState_t) 0 ||
   16ece:	b321      	cbz	r1, 16f1a <tc_cmac_setup+0x56>
	_set(s, 0, sizeof(*s));
   16ed0:	2258      	movs	r2, #88	; 0x58
   16ed2:	2100      	movs	r1, #0
   16ed4:	f7ff ffae 	bl	16e34 <_set>
	s->sched = sched;
   16ed8:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   16eda:	4629      	mov	r1, r5
   16edc:	4630      	mov	r0, r6
   16ede:	f7ec f989 	bl	31f4 <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   16ee2:	2210      	movs	r2, #16
   16ee4:	2100      	movs	r1, #0
   16ee6:	4620      	mov	r0, r4
   16ee8:	f7ff ffa4 	bl	16e34 <_set>
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   16eec:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   16eee:	4621      	mov	r1, r4
   16ef0:	4620      	mov	r0, r4
   16ef2:	f7ec f9e1 	bl	32b8 <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   16ef6:	f104 0510 	add.w	r5, r4, #16
   16efa:	4621      	mov	r1, r4
   16efc:	4628      	mov	r0, r5
   16efe:	f7ff ffa6 	bl	16e4e <gf_double>
	gf_double (s->K2, s->K1);
   16f02:	4629      	mov	r1, r5
   16f04:	f104 0020 	add.w	r0, r4, #32
   16f08:	f7ff ffa1 	bl	16e4e <gf_double>
	tc_cmac_init(s);
   16f0c:	4620      	mov	r0, r4
   16f0e:	f7ff ffc1 	bl	16e94 <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   16f12:	2001      	movs	r0, #1
}
   16f14:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   16f16:	2000      	movs	r0, #0
}
   16f18:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   16f1a:	2000      	movs	r0, #0
   16f1c:	e7fa      	b.n	16f14 <tc_cmac_setup+0x50>

00016f1e <tc_cmac_update>:
int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   16f1e:	2800      	cmp	r0, #0
   16f20:	d064      	beq.n	16fec <tc_cmac_update+0xce>
{
   16f22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16f26:	460d      	mov	r5, r1
   16f28:	4616      	mov	r6, r2
   16f2a:	4604      	mov	r4, r0
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   16f2c:	2a00      	cmp	r2, #0
   16f2e:	d05f      	beq.n	16ff0 <tc_cmac_update+0xd2>
		return  TC_CRYPTO_SUCCESS;
	}
	if (data == (const uint8_t *) 0) {
   16f30:	2900      	cmp	r1, #0
   16f32:	d060      	beq.n	16ff6 <tc_cmac_update+0xd8>
		return TC_CRYPTO_FAIL;
	}

	if (s->countdown == 0) {
   16f34:	6d03      	ldr	r3, [r0, #80]	; 0x50
   16f36:	6d42      	ldr	r2, [r0, #84]	; 0x54
   16f38:	ea53 0102 	orrs.w	r1, r3, r2
   16f3c:	d05d      	beq.n	16ffa <tc_cmac_update+0xdc>
		return TC_CRYPTO_FAIL;
	}

	s->countdown--;
   16f3e:	3b01      	subs	r3, #1
   16f40:	f142 32ff 	adc.w	r2, r2, #4294967295
   16f44:	6503      	str	r3, [r0, #80]	; 0x50
   16f46:	6542      	str	r2, [r0, #84]	; 0x54

	if (s->leftover_offset > 0) {
   16f48:	6c47      	ldr	r7, [r0, #68]	; 0x44
   16f4a:	2f00      	cmp	r7, #0
   16f4c:	d03d      	beq.n	16fca <tc_cmac_update+0xac>
		/* last data added to s didn't end on a TC_AES_BLOCK_SIZE byte boundary */
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   16f4e:	f1c7 0810 	rsb	r8, r7, #16

		if (data_length < remaining_space) {
   16f52:	4546      	cmp	r6, r8
   16f54:	d30d      	bcc.n	16f72 <tc_cmac_update+0x54>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
			s->leftover_offset += data_length;
			return TC_CRYPTO_SUCCESS;
		}
		/* leftover block is now full; encrypt it first */
		_copy(&s->leftover[s->leftover_offset],
   16f56:	f107 0030 	add.w	r0, r7, #48	; 0x30
   16f5a:	4643      	mov	r3, r8
   16f5c:	462a      	mov	r2, r5
   16f5e:	4641      	mov	r1, r8
   16f60:	4420      	add	r0, r4
   16f62:	f7ff ff5a 	bl	16e1a <_copy>
		      remaining_space,
		      data,
		      remaining_space);
		data_length -= remaining_space;
   16f66:	3f10      	subs	r7, #16
   16f68:	443e      	add	r6, r7
		data += remaining_space;
   16f6a:	4445      	add	r5, r8
		s->leftover_offset = 0;
   16f6c:	2300      	movs	r3, #0
   16f6e:	6463      	str	r3, [r4, #68]	; 0x44

		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   16f70:	e013      	b.n	16f9a <tc_cmac_update+0x7c>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   16f72:	f107 0030 	add.w	r0, r7, #48	; 0x30
   16f76:	4633      	mov	r3, r6
   16f78:	462a      	mov	r2, r5
   16f7a:	4631      	mov	r1, r6
   16f7c:	4420      	add	r0, r4
   16f7e:	f7ff ff4c 	bl	16e1a <_copy>
			s->leftover_offset += data_length;
   16f82:	6c63      	ldr	r3, [r4, #68]	; 0x44
   16f84:	4433      	add	r3, r6
   16f86:	6463      	str	r3, [r4, #68]	; 0x44
			return TC_CRYPTO_SUCCESS;
   16f88:	2001      	movs	r0, #1
   16f8a:	e032      	b.n	16ff2 <tc_cmac_update+0xd4>
			s->iv[i] ^= s->leftover[i];
   16f8c:	18e2      	adds	r2, r4, r3
   16f8e:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
   16f92:	5ce1      	ldrb	r1, [r4, r3]
   16f94:	404a      	eors	r2, r1
   16f96:	54e2      	strb	r2, [r4, r3]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   16f98:	3301      	adds	r3, #1
   16f9a:	2b0f      	cmp	r3, #15
   16f9c:	d9f6      	bls.n	16f8c <tc_cmac_update+0x6e>
		}
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   16f9e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   16fa0:	4621      	mov	r1, r4
   16fa2:	4620      	mov	r0, r4
   16fa4:	f7ec f988 	bl	32b8 <tc_aes_encrypt>
   16fa8:	e00f      	b.n	16fca <tc_cmac_update+0xac>
	}

	/* CBC encrypt each (except the last) of the data blocks */
	while (data_length > TC_AES_BLOCK_SIZE) {
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
			s->iv[i] ^= data[i];
   16faa:	5ce8      	ldrb	r0, [r5, r3]
   16fac:	f814 c003 	ldrb.w	ip, [r4, r3]
   16fb0:	ea80 000c 	eor.w	r0, r0, ip
   16fb4:	54e0      	strb	r0, [r4, r3]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   16fb6:	3301      	adds	r3, #1
   16fb8:	2b0f      	cmp	r3, #15
   16fba:	d9f6      	bls.n	16faa <tc_cmac_update+0x8c>
		}
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   16fbc:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   16fbe:	4621      	mov	r1, r4
   16fc0:	4620      	mov	r0, r4
   16fc2:	f7ec f979 	bl	32b8 <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   16fc6:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   16fc8:	3e10      	subs	r6, #16
	while (data_length > TC_AES_BLOCK_SIZE) {
   16fca:	2e10      	cmp	r6, #16
   16fcc:	d901      	bls.n	16fd2 <tc_cmac_update+0xb4>
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   16fce:	2300      	movs	r3, #0
   16fd0:	e7f2      	b.n	16fb8 <tc_cmac_update+0x9a>
	}

	if (data_length > 0) {
   16fd2:	b90e      	cbnz	r6, 16fd8 <tc_cmac_update+0xba>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   16fd4:	2001      	movs	r0, #1
   16fd6:	e00c      	b.n	16ff2 <tc_cmac_update+0xd4>
		_copy(s->leftover, data_length, data, data_length);
   16fd8:	4633      	mov	r3, r6
   16fda:	462a      	mov	r2, r5
   16fdc:	4631      	mov	r1, r6
   16fde:	f104 0030 	add.w	r0, r4, #48	; 0x30
   16fe2:	f7ff ff1a 	bl	16e1a <_copy>
		s->leftover_offset = data_length;
   16fe6:	6466      	str	r6, [r4, #68]	; 0x44
	return TC_CRYPTO_SUCCESS;
   16fe8:	2001      	movs	r0, #1
   16fea:	e002      	b.n	16ff2 <tc_cmac_update+0xd4>
		return TC_CRYPTO_FAIL;
   16fec:	2000      	movs	r0, #0
}
   16fee:	4770      	bx	lr
		return  TC_CRYPTO_SUCCESS;
   16ff0:	2001      	movs	r0, #1
}
   16ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TC_CRYPTO_FAIL;
   16ff6:	2000      	movs	r0, #0
   16ff8:	e7fb      	b.n	16ff2 <tc_cmac_update+0xd4>
		return TC_CRYPTO_FAIL;
   16ffa:	2000      	movs	r0, #0
   16ffc:	e7f9      	b.n	16ff2 <tc_cmac_update+0xd4>

00016ffe <tc_cmac_final>:
{
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   16ffe:	b370      	cbz	r0, 1705e <tc_cmac_final+0x60>
{
   17000:	b538      	push	{r3, r4, r5, lr}
   17002:	460c      	mov	r4, r1
   17004:	4605      	mov	r5, r0
	if (tag == (uint8_t *) 0 ||
   17006:	b361      	cbz	r1, 17062 <tc_cmac_final+0x64>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   17008:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   1700a:	2a10      	cmp	r2, #16
   1700c:	d102      	bne.n	17014 <tc_cmac_final+0x16>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   1700e:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   17010:	2300      	movs	r3, #0
   17012:	e018      	b.n	17046 <tc_cmac_final+0x48>
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   17014:	f102 0030 	add.w	r0, r2, #48	; 0x30
   17018:	f1c2 0210 	rsb	r2, r2, #16
   1701c:	2100      	movs	r1, #0
   1701e:	4420      	add	r0, r4
   17020:	f7ff ff08 	bl	16e34 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   17024:	6c63      	ldr	r3, [r4, #68]	; 0x44
   17026:	4423      	add	r3, r4
   17028:	2280      	movs	r2, #128	; 0x80
   1702a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   1702e:	f104 0120 	add.w	r1, r4, #32
   17032:	e7ed      	b.n	17010 <tc_cmac_final+0x12>
		s->iv[i] ^= s->leftover[i] ^ k[i];
   17034:	18e2      	adds	r2, r4, r3
   17036:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
   1703a:	5cc8      	ldrb	r0, [r1, r3]
   1703c:	4050      	eors	r0, r2
   1703e:	5ce2      	ldrb	r2, [r4, r3]
   17040:	4042      	eors	r2, r0
   17042:	54e2      	strb	r2, [r4, r3]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   17044:	3301      	adds	r3, #1
   17046:	2b0f      	cmp	r3, #15
   17048:	d9f4      	bls.n	17034 <tc_cmac_final+0x36>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   1704a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   1704c:	4621      	mov	r1, r4
   1704e:	4628      	mov	r0, r5
   17050:	f7ec f932 	bl	32b8 <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   17054:	4620      	mov	r0, r4
   17056:	f7ff ff13 	bl	16e80 <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   1705a:	2001      	movs	r0, #1
}
   1705c:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   1705e:	2000      	movs	r0, #0
}
   17060:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   17062:	2000      	movs	r0, #0
   17064:	e7fa      	b.n	1705c <tc_cmac_final+0x5e>

00017066 <tc_sha256_update>:
	if (s == (TCSha256State_t) 0 ||
   17066:	b328      	cbz	r0, 170b4 <tc_sha256_update+0x4e>
{
   17068:	b570      	push	{r4, r5, r6, lr}
   1706a:	460c      	mov	r4, r1
   1706c:	4605      	mov	r5, r0
	if (s == (TCSha256State_t) 0 ||
   1706e:	b319      	cbz	r1, 170b8 <tc_sha256_update+0x52>
	} else if (datalen == 0) {
   17070:	b912      	cbnz	r2, 17078 <tc_sha256_update+0x12>
		return TC_CRYPTO_SUCCESS;
   17072:	2001      	movs	r0, #1
   17074:	e01d      	b.n	170b2 <tc_sha256_update+0x4c>
{
   17076:	4632      	mov	r2, r6
	while (datalen-- > 0) {
   17078:	1e56      	subs	r6, r2, #1
   1707a:	b1ca      	cbz	r2, 170b0 <tc_sha256_update+0x4a>
		s->leftover[s->leftover_offset++] = *(data++);
   1707c:	6eab      	ldr	r3, [r5, #104]	; 0x68
   1707e:	1c5a      	adds	r2, r3, #1
   17080:	66aa      	str	r2, [r5, #104]	; 0x68
   17082:	f814 1b01 	ldrb.w	r1, [r4], #1
   17086:	442b      	add	r3, r5
   17088:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
   1708c:	2a3f      	cmp	r2, #63	; 0x3f
   1708e:	d9f2      	bls.n	17076 <tc_sha256_update+0x10>
			compress(s->iv, s->leftover);
   17090:	f105 0128 	add.w	r1, r5, #40	; 0x28
   17094:	4628      	mov	r0, r5
   17096:	f7ec fc81 	bl	399c <compress>
			s->leftover_offset = 0;
   1709a:	2300      	movs	r3, #0
   1709c:	66ab      	str	r3, [r5, #104]	; 0x68
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
   1709e:	6a2b      	ldr	r3, [r5, #32]
   170a0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   170a2:	f513 7300 	adds.w	r3, r3, #512	; 0x200
   170a6:	f142 0200 	adc.w	r2, r2, #0
   170aa:	622b      	str	r3, [r5, #32]
   170ac:	626a      	str	r2, [r5, #36]	; 0x24
   170ae:	e7e2      	b.n	17076 <tc_sha256_update+0x10>
	return TC_CRYPTO_SUCCESS;
   170b0:	2001      	movs	r0, #1
}
   170b2:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   170b4:	2000      	movs	r0, #0
}
   170b6:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   170b8:	2000      	movs	r0, #0
   170ba:	e7fa      	b.n	170b2 <tc_sha256_update+0x4c>

000170bc <tc_sha256_final>:
	if (digest == (uint8_t *) 0 ||
   170bc:	2800      	cmp	r0, #0
   170be:	d065      	beq.n	1718c <tc_sha256_final+0xd0>
{
   170c0:	b570      	push	{r4, r5, r6, lr}
   170c2:	460d      	mov	r5, r1
   170c4:	4604      	mov	r4, r0
	if (digest == (uint8_t *) 0 ||
   170c6:	2900      	cmp	r1, #0
   170c8:	d062      	beq.n	17190 <tc_sha256_final+0xd4>
	s->bits_hashed += (s->leftover_offset << 3);
   170ca:	6e8b      	ldr	r3, [r1, #104]	; 0x68
   170cc:	00d8      	lsls	r0, r3, #3
   170ce:	6a0a      	ldr	r2, [r1, #32]
   170d0:	6a49      	ldr	r1, [r1, #36]	; 0x24
   170d2:	1812      	adds	r2, r2, r0
   170d4:	f141 0100 	adc.w	r1, r1, #0
   170d8:	622a      	str	r2, [r5, #32]
   170da:	6269      	str	r1, [r5, #36]	; 0x24
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
   170dc:	1c58      	adds	r0, r3, #1
   170de:	66a8      	str	r0, [r5, #104]	; 0x68
   170e0:	442b      	add	r3, r5
   170e2:	2280      	movs	r2, #128	; 0x80
   170e4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
   170e8:	2838      	cmp	r0, #56	; 0x38
   170ea:	d82a      	bhi.n	17142 <tc_sha256_final+0x86>
	_set(s->leftover + s->leftover_offset, 0x00,
   170ec:	f105 0628 	add.w	r6, r5, #40	; 0x28
   170f0:	6ea8      	ldr	r0, [r5, #104]	; 0x68
   170f2:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   170f6:	2100      	movs	r1, #0
   170f8:	4430      	add	r0, r6
   170fa:	f7ff fe9b 	bl	16e34 <_set>
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
   170fe:	6a2a      	ldr	r2, [r5, #32]
   17100:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   17102:	f885 2067 	strb.w	r2, [r5, #103]	; 0x67
	s->leftover[sizeof(s->leftover) - 2] = (uint8_t)(s->bits_hashed >> 8);
   17106:	f3c2 2107 	ubfx	r1, r2, #8, #8
   1710a:	f885 1066 	strb.w	r1, [r5, #102]	; 0x66
	s->leftover[sizeof(s->leftover) - 3] = (uint8_t)(s->bits_hashed >> 16);
   1710e:	f3c2 4107 	ubfx	r1, r2, #16, #8
   17112:	f885 1065 	strb.w	r1, [r5, #101]	; 0x65
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
   17116:	0e12      	lsrs	r2, r2, #24
   17118:	f885 2064 	strb.w	r2, [r5, #100]	; 0x64
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
   1711c:	f885 3063 	strb.w	r3, [r5, #99]	; 0x63
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
   17120:	f3c3 2207 	ubfx	r2, r3, #8, #8
   17124:	f885 2062 	strb.w	r2, [r5, #98]	; 0x62
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
   17128:	f3c3 4207 	ubfx	r2, r3, #16, #8
   1712c:	f885 2061 	strb.w	r2, [r5, #97]	; 0x61
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
   17130:	0e1b      	lsrs	r3, r3, #24
   17132:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
	compress(s->iv, s->leftover);
   17136:	4631      	mov	r1, r6
   17138:	4628      	mov	r0, r5
   1713a:	f7ec fc2f 	bl	399c <compress>
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   1713e:	2200      	movs	r2, #0
   17140:	e01b      	b.n	1717a <tc_sha256_final+0xbe>
		_set(s->leftover + s->leftover_offset, 0x00,
   17142:	f105 0628 	add.w	r6, r5, #40	; 0x28
   17146:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   1714a:	2100      	movs	r1, #0
   1714c:	4430      	add	r0, r6
   1714e:	f7ff fe71 	bl	16e34 <_set>
		compress(s->iv, s->leftover);
   17152:	4631      	mov	r1, r6
   17154:	4628      	mov	r0, r5
   17156:	f7ec fc21 	bl	399c <compress>
		s->leftover_offset = 0;
   1715a:	2300      	movs	r3, #0
   1715c:	66ab      	str	r3, [r5, #104]	; 0x68
   1715e:	e7c5      	b.n	170ec <tc_sha256_final+0x30>
		unsigned int t = *((unsigned int *) &s->iv[i]);
   17160:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
		*digest++ = (uint8_t)(t >> 24);
   17164:	0e19      	lsrs	r1, r3, #24
   17166:	7021      	strb	r1, [r4, #0]
		*digest++ = (uint8_t)(t >> 16);
   17168:	f3c3 4107 	ubfx	r1, r3, #16, #8
   1716c:	7061      	strb	r1, [r4, #1]
		*digest++ = (uint8_t)(t >> 8);
   1716e:	f3c3 2107 	ubfx	r1, r3, #8, #8
   17172:	70a1      	strb	r1, [r4, #2]
		*digest++ = (uint8_t)(t);
   17174:	70e3      	strb	r3, [r4, #3]
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   17176:	3201      	adds	r2, #1
		*digest++ = (uint8_t)(t);
   17178:	3404      	adds	r4, #4
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   1717a:	2a07      	cmp	r2, #7
   1717c:	d9f0      	bls.n	17160 <tc_sha256_final+0xa4>
	_set(s, 0, sizeof(*s));
   1717e:	2270      	movs	r2, #112	; 0x70
   17180:	2100      	movs	r1, #0
   17182:	4628      	mov	r0, r5
   17184:	f7ff fe56 	bl	16e34 <_set>
	return TC_CRYPTO_SUCCESS;
   17188:	2001      	movs	r0, #1
}
   1718a:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   1718c:	2000      	movs	r0, #0
}
   1718e:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   17190:	2000      	movs	r0, #0
   17192:	e7fa      	b.n	1718a <tc_sha256_final+0xce>

00017194 <rekey>:
#include <tinycrypt/hmac.h>
#include <tinycrypt/constants.h>
#include <tinycrypt/utils.h>

static void rekey(uint8_t *key, const uint8_t *new_key, unsigned int key_size)
{
   17194:	b500      	push	{lr}
	const uint8_t inner_pad = (uint8_t) 0x36;
	const uint8_t outer_pad = (uint8_t) 0x5c;
	unsigned int i;

	for (i = 0; i < key_size; ++i) {
   17196:	2300      	movs	r3, #0
   17198:	e00e      	b.n	171b8 <rekey+0x24>
		key[i] = inner_pad ^ new_key[i];
   1719a:	f811 c003 	ldrb.w	ip, [r1, r3]
   1719e:	f08c 0c36 	eor.w	ip, ip, #54	; 0x36
   171a2:	f800 c003 	strb.w	ip, [r0, r3]
		key[i + TC_SHA256_BLOCK_SIZE] = outer_pad ^ new_key[i];
   171a6:	f811 c003 	ldrb.w	ip, [r1, r3]
   171aa:	f103 0e40 	add.w	lr, r3, #64	; 0x40
   171ae:	f08c 0c5c 	eor.w	ip, ip, #92	; 0x5c
   171b2:	f800 c00e 	strb.w	ip, [r0, lr]
	for (i = 0; i < key_size; ++i) {
   171b6:	3301      	adds	r3, #1
   171b8:	4293      	cmp	r3, r2
   171ba:	d3ee      	bcc.n	1719a <rekey+0x6>
   171bc:	e006      	b.n	171cc <rekey+0x38>
	}
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
		key[i] = inner_pad; key[i + TC_SHA256_BLOCK_SIZE] = outer_pad;
   171be:	2236      	movs	r2, #54	; 0x36
   171c0:	54c2      	strb	r2, [r0, r3]
   171c2:	f103 0240 	add.w	r2, r3, #64	; 0x40
   171c6:	215c      	movs	r1, #92	; 0x5c
   171c8:	5481      	strb	r1, [r0, r2]
	for (; i < TC_SHA256_BLOCK_SIZE; ++i) {
   171ca:	3301      	adds	r3, #1
   171cc:	2b3f      	cmp	r3, #63	; 0x3f
   171ce:	d9f6      	bls.n	171be <rekey+0x2a>
	}
}
   171d0:	f85d fb04 	ldr.w	pc, [sp], #4

000171d4 <tc_hmac_set_key>:

int tc_hmac_set_key(TCHmacState_t ctx, const uint8_t *key,
		    unsigned int key_size)
{
	/* Input sanity check */
	if (ctx == (TCHmacState_t) 0 ||
   171d4:	b388      	cbz	r0, 1723a <tc_hmac_set_key+0x66>
{
   171d6:	b570      	push	{r4, r5, r6, lr}
   171d8:	b0cc      	sub	sp, #304	; 0x130
   171da:	460d      	mov	r5, r1
   171dc:	4614      	mov	r4, r2
   171de:	4606      	mov	r6, r0
	if (ctx == (TCHmacState_t) 0 ||
   171e0:	b369      	cbz	r1, 1723e <tc_hmac_set_key+0x6a>
	    key == (const uint8_t *) 0 ||
   171e2:	b372      	cbz	r2, 17242 <tc_hmac_set_key+0x6e>
	}

	const uint8_t dummy_key[TC_SHA256_BLOCK_SIZE];
	struct tc_hmac_state_struct dummy_state;

	if (key_size <= TC_SHA256_BLOCK_SIZE) {
   171e4:	2a40      	cmp	r2, #64	; 0x40
   171e6:	d813      	bhi.n	17210 <tc_hmac_set_key+0x3c>
		 * certain timing attacks. Without these dummy calls,
		 * adversaries would be able to learn whether the key_size is
		 * greater than TC_SHA256_BLOCK_SIZE by measuring the time
		 * consumed in this process.
		 */
		(void)tc_sha256_init(&dummy_state.hash_state);
   171e8:	4668      	mov	r0, sp
   171ea:	f7ec fcb7 	bl	3b5c <tc_sha256_init>
		(void)tc_sha256_update(&dummy_state.hash_state,
   171ee:	4622      	mov	r2, r4
   171f0:	a93c      	add	r1, sp, #240	; 0xf0
   171f2:	4668      	mov	r0, sp
   171f4:	f7ff ff37 	bl	17066 <tc_sha256_update>
				       dummy_key,
				       key_size);
		(void)tc_sha256_final(&dummy_state.key[TC_SHA256_DIGEST_SIZE],
   171f8:	4669      	mov	r1, sp
   171fa:	a824      	add	r0, sp, #144	; 0x90
   171fc:	f7ff ff5e 	bl	170bc <tc_sha256_final>
				      &dummy_state.hash_state);

		/* Actual code for when key_size <= TC_SHA256_BLOCK_SIZE: */
		rekey(ctx->key, key, key_size);
   17200:	4622      	mov	r2, r4
   17202:	4629      	mov	r1, r5
   17204:	f106 0070 	add.w	r0, r6, #112	; 0x70
   17208:	f7ff ffc4 	bl	17194 <rekey>
		rekey(ctx->key,
		      &ctx->key[TC_SHA256_DIGEST_SIZE],
		      TC_SHA256_DIGEST_SIZE);
	}

	return TC_CRYPTO_SUCCESS;
   1720c:	2001      	movs	r0, #1
   1720e:	e019      	b.n	17244 <tc_hmac_set_key+0x70>
		(void)tc_sha256_init(&ctx->hash_state);
   17210:	f7ec fca4 	bl	3b5c <tc_sha256_init>
		(void)tc_sha256_update(&ctx->hash_state, key, key_size);
   17214:	4622      	mov	r2, r4
   17216:	4629      	mov	r1, r5
   17218:	4630      	mov	r0, r6
   1721a:	f7ff ff24 	bl	17066 <tc_sha256_update>
		(void)tc_sha256_final(&ctx->key[TC_SHA256_DIGEST_SIZE],
   1721e:	f106 0490 	add.w	r4, r6, #144	; 0x90
   17222:	4631      	mov	r1, r6
   17224:	4620      	mov	r0, r4
   17226:	f7ff ff49 	bl	170bc <tc_sha256_final>
		rekey(ctx->key,
   1722a:	2220      	movs	r2, #32
   1722c:	4621      	mov	r1, r4
   1722e:	f106 0070 	add.w	r0, r6, #112	; 0x70
   17232:	f7ff ffaf 	bl	17194 <rekey>
	return TC_CRYPTO_SUCCESS;
   17236:	2001      	movs	r0, #1
   17238:	e004      	b.n	17244 <tc_hmac_set_key+0x70>
		return TC_CRYPTO_FAIL;
   1723a:	2000      	movs	r0, #0
}
   1723c:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   1723e:	2000      	movs	r0, #0
   17240:	e000      	b.n	17244 <tc_hmac_set_key+0x70>
   17242:	2000      	movs	r0, #0
}
   17244:	b04c      	add	sp, #304	; 0x130
   17246:	bd70      	pop	{r4, r5, r6, pc}

00017248 <tc_hmac_init>:

int tc_hmac_init(TCHmacState_t ctx)
{

	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
   17248:	b158      	cbz	r0, 17262 <tc_hmac_init+0x1a>
{
   1724a:	b510      	push	{r4, lr}
   1724c:	4604      	mov	r4, r0
		return TC_CRYPTO_FAIL;
	}

  (void) tc_sha256_init(&ctx->hash_state);
   1724e:	f7ec fc85 	bl	3b5c <tc_sha256_init>
  (void) tc_sha256_update(&ctx->hash_state, ctx->key, TC_SHA256_BLOCK_SIZE);
   17252:	2240      	movs	r2, #64	; 0x40
   17254:	f104 0170 	add.w	r1, r4, #112	; 0x70
   17258:	4620      	mov	r0, r4
   1725a:	f7ff ff04 	bl	17066 <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
   1725e:	2001      	movs	r0, #1
}
   17260:	bd10      	pop	{r4, pc}
		return TC_CRYPTO_FAIL;
   17262:	2000      	movs	r0, #0
}
   17264:	4770      	bx	lr

00017266 <tc_hmac_update>:
		   const void *data,
		   unsigned int data_length)
{

	/* input sanity check: */
	if (ctx == (TCHmacState_t) 0) {
   17266:	b120      	cbz	r0, 17272 <tc_hmac_update+0xc>
{
   17268:	b508      	push	{r3, lr}
		return TC_CRYPTO_FAIL;
	}

	(void)tc_sha256_update(&ctx->hash_state, data, data_length);
   1726a:	f7ff fefc 	bl	17066 <tc_sha256_update>

	return TC_CRYPTO_SUCCESS;
   1726e:	2001      	movs	r0, #1
}
   17270:	bd08      	pop	{r3, pc}
		return TC_CRYPTO_FAIL;
   17272:	2000      	movs	r0, #0
}
   17274:	4770      	bx	lr

00017276 <tc_hmac_final>:

int tc_hmac_final(uint8_t *tag, unsigned int taglen, TCHmacState_t ctx)
{

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   17276:	b308      	cbz	r0, 172bc <tc_hmac_final+0x46>
{
   17278:	b538      	push	{r3, r4, r5, lr}
   1727a:	4614      	mov	r4, r2
   1727c:	4605      	mov	r5, r0
	if (tag == (uint8_t *) 0 ||
   1727e:	2920      	cmp	r1, #32
   17280:	d11e      	bne.n	172c0 <tc_hmac_final+0x4a>
	    taglen != TC_SHA256_DIGEST_SIZE ||
   17282:	b1fa      	cbz	r2, 172c4 <tc_hmac_final+0x4e>
	    ctx == (TCHmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	(void) tc_sha256_final(tag, &ctx->hash_state);
   17284:	4611      	mov	r1, r2
   17286:	f7ff ff19 	bl	170bc <tc_sha256_final>

	(void)tc_sha256_init(&ctx->hash_state);
   1728a:	4620      	mov	r0, r4
   1728c:	f7ec fc66 	bl	3b5c <tc_sha256_init>
	(void)tc_sha256_update(&ctx->hash_state,
   17290:	2240      	movs	r2, #64	; 0x40
   17292:	f104 01b0 	add.w	r1, r4, #176	; 0xb0
   17296:	4620      	mov	r0, r4
   17298:	f7ff fee5 	bl	17066 <tc_sha256_update>
			       &ctx->key[TC_SHA256_BLOCK_SIZE],
				TC_SHA256_BLOCK_SIZE);
	(void)tc_sha256_update(&ctx->hash_state, tag, TC_SHA256_DIGEST_SIZE);
   1729c:	2220      	movs	r2, #32
   1729e:	4629      	mov	r1, r5
   172a0:	4620      	mov	r0, r4
   172a2:	f7ff fee0 	bl	17066 <tc_sha256_update>
	(void)tc_sha256_final(tag, &ctx->hash_state);
   172a6:	4621      	mov	r1, r4
   172a8:	4628      	mov	r0, r5
   172aa:	f7ff ff07 	bl	170bc <tc_sha256_final>

	/* destroy the current state */
	_set(ctx, 0, sizeof(*ctx));
   172ae:	22f0      	movs	r2, #240	; 0xf0
   172b0:	2100      	movs	r1, #0
   172b2:	4620      	mov	r0, r4
   172b4:	f7ff fdbe 	bl	16e34 <_set>

	return TC_CRYPTO_SUCCESS;
   172b8:	2001      	movs	r0, #1
   172ba:	e002      	b.n	172c2 <tc_hmac_final+0x4c>
		return TC_CRYPTO_FAIL;
   172bc:	2000      	movs	r0, #0
}
   172be:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   172c0:	2000      	movs	r0, #0
}
   172c2:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   172c4:	2000      	movs	r0, #0
   172c6:	e7fc      	b.n	172c2 <tc_hmac_final+0x4c>

000172c8 <update>:

/*
 * Assumes: prng != NULL
 */
static void update(TCHmacPrng_t prng, const uint8_t *data, unsigned int datalen, const uint8_t *additional_data, unsigned int additional_datalen)
{
   172c8:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   172cc:	b082      	sub	sp, #8
   172ce:	4604      	mov	r4, r0
   172d0:	460d      	mov	r5, r1
   172d2:	4691      	mov	r9, r2
   172d4:	461f      	mov	r7, r3
	const uint8_t separator0 = 0x00;
   172d6:	2300      	movs	r3, #0
   172d8:	f88d 3007 	strb.w	r3, [sp, #7]
	const uint8_t separator1 = 0x01;
   172dc:	f04f 0b01 	mov.w	fp, #1
   172e0:	f88d b006 	strb.w	fp, [sp, #6]

	/* configure the new prng key into the prng's instance of hmac */
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   172e4:	f100 08f0 	add.w	r8, r0, #240	; 0xf0
   172e8:	2220      	movs	r2, #32
   172ea:	4641      	mov	r1, r8
   172ec:	f7ff ff72 	bl	171d4 <tc_hmac_set_key>

	/* use current state, e and separator 0 to compute a new prng key: */
	(void)tc_hmac_init(&prng->h);
   172f0:	4620      	mov	r0, r4
   172f2:	f7ff ffa9 	bl	17248 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   172f6:	f504 7688 	add.w	r6, r4, #272	; 0x110
   172fa:	2220      	movs	r2, #32
   172fc:	4631      	mov	r1, r6
   172fe:	4620      	mov	r0, r4
   17300:	f7ff ffb1 	bl	17266 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator0, sizeof(separator0));
   17304:	465a      	mov	r2, fp
   17306:	f10d 0107 	add.w	r1, sp, #7
   1730a:	4620      	mov	r0, r4
   1730c:	f7ff ffab 	bl	17266 <tc_hmac_update>

	if (data && datalen)
   17310:	b115      	cbz	r5, 17318 <update+0x50>
   17312:	f1b9 0f00 	cmp.w	r9, #0
   17316:	d120      	bne.n	1735a <update+0x92>
		(void)tc_hmac_update(&prng->h, data, datalen);
	if (additional_data && additional_datalen)
   17318:	b10f      	cbz	r7, 1731e <update+0x56>
   1731a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1731c:	bb1b      	cbnz	r3, 17366 <update+0x9e>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);

	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
   1731e:	4622      	mov	r2, r4
   17320:	2120      	movs	r1, #32
   17322:	4640      	mov	r0, r8
   17324:	f7ff ffa7 	bl	17276 <tc_hmac_final>

	/* configure the new prng key into the prng's instance of hmac */
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   17328:	2220      	movs	r2, #32
   1732a:	4641      	mov	r1, r8
   1732c:	4620      	mov	r0, r4
   1732e:	f7ff ff51 	bl	171d4 <tc_hmac_set_key>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
   17332:	4620      	mov	r0, r4
   17334:	f7ff ff88 	bl	17248 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   17338:	2220      	movs	r2, #32
   1733a:	4631      	mov	r1, r6
   1733c:	4620      	mov	r0, r4
   1733e:	f7ff ff92 	bl	17266 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
   17342:	4622      	mov	r2, r4
   17344:	2120      	movs	r1, #32
   17346:	4630      	mov	r0, r6
   17348:	f7ff ff95 	bl	17276 <tc_hmac_final>

	if (data == 0 || datalen == 0)
   1734c:	b115      	cbz	r5, 17354 <update+0x8c>
   1734e:	f1b9 0f00 	cmp.w	r9, #0
   17352:	d10e      	bne.n	17372 <update+0xaa>

	/* use the new key to compute a new state variable v */
	(void)tc_hmac_init(&prng->h);
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
}
   17354:	b002      	add	sp, #8
   17356:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		(void)tc_hmac_update(&prng->h, data, datalen);
   1735a:	464a      	mov	r2, r9
   1735c:	4629      	mov	r1, r5
   1735e:	4620      	mov	r0, r4
   17360:	f7ff ff81 	bl	17266 <tc_hmac_update>
   17364:	e7d8      	b.n	17318 <update+0x50>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);
   17366:	461a      	mov	r2, r3
   17368:	4639      	mov	r1, r7
   1736a:	4620      	mov	r0, r4
   1736c:	f7ff ff7b 	bl	17266 <tc_hmac_update>
   17370:	e7d5      	b.n	1731e <update+0x56>
	tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   17372:	2220      	movs	r2, #32
   17374:	4641      	mov	r1, r8
   17376:	4620      	mov	r0, r4
   17378:	f7ff ff2c 	bl	171d4 <tc_hmac_set_key>
	(void)tc_hmac_init(&prng->h);
   1737c:	4620      	mov	r0, r4
   1737e:	f7ff ff63 	bl	17248 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   17382:	2220      	movs	r2, #32
   17384:	4631      	mov	r1, r6
   17386:	4620      	mov	r0, r4
   17388:	f7ff ff6d 	bl	17266 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, &separator1, sizeof(separator1));
   1738c:	2201      	movs	r2, #1
   1738e:	f10d 0106 	add.w	r1, sp, #6
   17392:	4620      	mov	r0, r4
   17394:	f7ff ff67 	bl	17266 <tc_hmac_update>
	(void)tc_hmac_update(&prng->h, data, datalen);
   17398:	464a      	mov	r2, r9
   1739a:	4629      	mov	r1, r5
   1739c:	4620      	mov	r0, r4
   1739e:	f7ff ff62 	bl	17266 <tc_hmac_update>
	if (additional_data && additional_datalen)
   173a2:	b10f      	cbz	r7, 173a8 <update+0xe0>
   173a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   173a6:	b9bb      	cbnz	r3, 173d8 <update+0x110>
	(void)tc_hmac_final(prng->key, sizeof(prng->key), &prng->h);
   173a8:	4622      	mov	r2, r4
   173aa:	2120      	movs	r1, #32
   173ac:	4640      	mov	r0, r8
   173ae:	f7ff ff62 	bl	17276 <tc_hmac_final>
	(void)tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   173b2:	2220      	movs	r2, #32
   173b4:	4641      	mov	r1, r8
   173b6:	4620      	mov	r0, r4
   173b8:	f7ff ff0c 	bl	171d4 <tc_hmac_set_key>
	(void)tc_hmac_init(&prng->h);
   173bc:	4620      	mov	r0, r4
   173be:	f7ff ff43 	bl	17248 <tc_hmac_init>
	(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   173c2:	2220      	movs	r2, #32
   173c4:	4631      	mov	r1, r6
   173c6:	4620      	mov	r0, r4
   173c8:	f7ff ff4d 	bl	17266 <tc_hmac_update>
	(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
   173cc:	4622      	mov	r2, r4
   173ce:	2120      	movs	r1, #32
   173d0:	4630      	mov	r0, r6
   173d2:	f7ff ff50 	bl	17276 <tc_hmac_final>
   173d6:	e7bd      	b.n	17354 <update+0x8c>
		(void)tc_hmac_update(&prng->h, additional_data, additional_datalen);
   173d8:	461a      	mov	r2, r3
   173da:	4639      	mov	r1, r7
   173dc:	4620      	mov	r0, r4
   173de:	f7ff ff42 	bl	17266 <tc_hmac_update>
   173e2:	e7e1      	b.n	173a8 <update+0xe0>

000173e4 <tc_hmac_prng_init>:
		      const uint8_t *personalization,
		      unsigned int plen)
{

	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
   173e4:	b1e8      	cbz	r0, 17422 <tc_hmac_prng_init+0x3e>
{
   173e6:	b5f0      	push	{r4, r5, r6, r7, lr}
   173e8:	b083      	sub	sp, #12
   173ea:	460c      	mov	r4, r1
   173ec:	4615      	mov	r5, r2
   173ee:	4606      	mov	r6, r0
	    personalization == (uint8_t *) 0 ||
   173f0:	b1c9      	cbz	r1, 17426 <tc_hmac_prng_init+0x42>
	    plen > MAX_PLEN) {
		return TC_CRYPTO_FAIL;
	}

	/* put the generator into a known state: */
	_set(prng->key, 0x00, sizeof(prng->key));
   173f2:	2220      	movs	r2, #32
   173f4:	2100      	movs	r1, #0
   173f6:	30f0      	adds	r0, #240	; 0xf0
   173f8:	f7ff fd1c 	bl	16e34 <_set>
	_set(prng->v, 0x01, sizeof(prng->v));
   173fc:	2220      	movs	r2, #32
   173fe:	2101      	movs	r1, #1
   17400:	f506 7088 	add.w	r0, r6, #272	; 0x110
   17404:	f7ff fd16 	bl	16e34 <_set>

	update(prng, personalization, plen, 0, 0);
   17408:	2700      	movs	r7, #0
   1740a:	9700      	str	r7, [sp, #0]
   1740c:	463b      	mov	r3, r7
   1740e:	462a      	mov	r2, r5
   17410:	4621      	mov	r1, r4
   17412:	4630      	mov	r0, r6
   17414:	f7ff ff58 	bl	172c8 <update>

	/* force a reseed before allowing tc_hmac_prng_generate to succeed: */
	prng->countdown = 0;
   17418:	f8c6 7130 	str.w	r7, [r6, #304]	; 0x130

	return TC_CRYPTO_SUCCESS;
   1741c:	2001      	movs	r0, #1
}
   1741e:	b003      	add	sp, #12
   17420:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   17422:	2000      	movs	r0, #0
}
   17424:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   17426:	2000      	movs	r0, #0
   17428:	e7f9      	b.n	1741e <tc_hmac_prng_init+0x3a>

0001742a <tc_hmac_prng_reseed>:
			const uint8_t *additional_input,
			unsigned int additionallen)
{

	/* input sanity check: */
	if (prng == (TCHmacPrng_t) 0 ||
   1742a:	b1d0      	cbz	r0, 17462 <tc_hmac_prng_reseed+0x38>
{
   1742c:	b510      	push	{r4, lr}
   1742e:	b082      	sub	sp, #8
   17430:	4604      	mov	r4, r0
	if (prng == (TCHmacPrng_t) 0 ||
   17432:	b1c1      	cbz	r1, 17466 <tc_hmac_prng_reseed+0x3c>
	    seed == (const uint8_t *) 0 ||
	    seedlen < MIN_SLEN ||
   17434:	2a1f      	cmp	r2, #31
   17436:	d918      	bls.n	1746a <tc_hmac_prng_reseed+0x40>
	    seedlen > MAX_SLEN) {
		return TC_CRYPTO_FAIL;
	}

	if (additional_input != (const uint8_t *) 0) {
   17438:	b173      	cbz	r3, 17458 <tc_hmac_prng_reseed+0x2e>
		/*
		 * Abort if additional_input is provided but has inappropriate
		 * length
		 */
		if (additionallen == 0 ||
   1743a:	9804      	ldr	r0, [sp, #16]
   1743c:	b908      	cbnz	r0, 17442 <tc_hmac_prng_reseed+0x18>
		    additionallen > MAX_ALEN) {
			return TC_CRYPTO_FAIL;
   1743e:	2000      	movs	r0, #0
   17440:	e008      	b.n	17454 <tc_hmac_prng_reseed+0x2a>
		} else {
			/* call update for the seed and additional_input */
			update(prng, seed, seedlen, additional_input, additionallen);
   17442:	9000      	str	r0, [sp, #0]
   17444:	4620      	mov	r0, r4
   17446:	f7ff ff3f 	bl	172c8 <update>
		/* call update only for the seed */
		update(prng, seed, seedlen, 0, 0);
	}

	/* ... and enable hmac_prng_generate */
	prng->countdown = MAX_GENS;
   1744a:	f04f 33ff 	mov.w	r3, #4294967295
   1744e:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130

	return TC_CRYPTO_SUCCESS;
   17452:	2001      	movs	r0, #1
}
   17454:	b002      	add	sp, #8
   17456:	bd10      	pop	{r4, pc}
		update(prng, seed, seedlen, 0, 0);
   17458:	2300      	movs	r3, #0
   1745a:	9300      	str	r3, [sp, #0]
   1745c:	f7ff ff34 	bl	172c8 <update>
   17460:	e7f3      	b.n	1744a <tc_hmac_prng_reseed+0x20>
		return TC_CRYPTO_FAIL;
   17462:	2000      	movs	r0, #0
}
   17464:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   17466:	2000      	movs	r0, #0
   17468:	e7f4      	b.n	17454 <tc_hmac_prng_reseed+0x2a>
   1746a:	2000      	movs	r0, #0
   1746c:	e7f2      	b.n	17454 <tc_hmac_prng_reseed+0x2a>

0001746e <tc_hmac_prng_generate>:
int tc_hmac_prng_generate(uint8_t *out, unsigned int outlen, TCHmacPrng_t prng)
{
	unsigned int bufferlen;

	/* input sanity check: */
	if (out == (uint8_t *) 0 ||
   1746e:	2800      	cmp	r0, #0
   17470:	d045      	beq.n	174fe <tc_hmac_prng_generate+0x90>
{
   17472:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17476:	b082      	sub	sp, #8
   17478:	460f      	mov	r7, r1
   1747a:	4614      	mov	r4, r2
   1747c:	4680      	mov	r8, r0
	if (out == (uint8_t *) 0 ||
   1747e:	2a00      	cmp	r2, #0
   17480:	d03f      	beq.n	17502 <tc_hmac_prng_generate+0x94>
	    prng == (TCHmacPrng_t) 0 ||
   17482:	2900      	cmp	r1, #0
   17484:	d03f      	beq.n	17506 <tc_hmac_prng_generate+0x98>
	    outlen == 0 ||
   17486:	f5b1 2f00 	cmp.w	r1, #524288	; 0x80000
   1748a:	d840      	bhi.n	1750e <tc_hmac_prng_generate+0xa0>
	    outlen > MAX_OUT) {
		return TC_CRYPTO_FAIL;
	} else if (prng->countdown == 0) {
   1748c:	f8d2 3130 	ldr.w	r3, [r2, #304]	; 0x130
   17490:	2b00      	cmp	r3, #0
   17492:	d03e      	beq.n	17512 <tc_hmac_prng_generate+0xa4>
		return TC_HMAC_PRNG_RESEED_REQ;
	}

	prng->countdown--;
   17494:	3b01      	subs	r3, #1
   17496:	f8c2 3130 	str.w	r3, [r2, #304]	; 0x130

	while (outlen != 0) {
   1749a:	e025      	b.n	174e8 <tc_hmac_prng_generate+0x7a>
		/* configure the new prng key into the prng's instance of hmac */
		tc_hmac_set_key(&prng->h, prng->key, sizeof(prng->key));
   1749c:	2220      	movs	r2, #32
   1749e:	f104 01f0 	add.w	r1, r4, #240	; 0xf0
   174a2:	4620      	mov	r0, r4
   174a4:	f7ff fe96 	bl	171d4 <tc_hmac_set_key>

		/* operate HMAC in OFB mode to create "random" outputs */
		(void)tc_hmac_init(&prng->h);
   174a8:	4620      	mov	r0, r4
   174aa:	f7ff fecd 	bl	17248 <tc_hmac_init>
		(void)tc_hmac_update(&prng->h, prng->v, sizeof(prng->v));
   174ae:	f504 7588 	add.w	r5, r4, #272	; 0x110
   174b2:	2220      	movs	r2, #32
   174b4:	4629      	mov	r1, r5
   174b6:	4620      	mov	r0, r4
   174b8:	f7ff fed5 	bl	17266 <tc_hmac_update>
		(void)tc_hmac_final(prng->v, sizeof(prng->v), &prng->h);
   174bc:	4622      	mov	r2, r4
   174be:	2120      	movs	r1, #32
   174c0:	4628      	mov	r0, r5
   174c2:	f7ff fed8 	bl	17276 <tc_hmac_final>

		bufferlen = (TC_SHA256_DIGEST_SIZE > outlen) ?
   174c6:	463e      	mov	r6, r7
   174c8:	2f20      	cmp	r7, #32
   174ca:	bf28      	it	cs
   174cc:	2620      	movcs	r6, #32
			outlen : TC_SHA256_DIGEST_SIZE;
		(void)_copy(out, bufferlen, prng->v, bufferlen);
   174ce:	4633      	mov	r3, r6
   174d0:	462a      	mov	r2, r5
   174d2:	4631      	mov	r1, r6
   174d4:	4640      	mov	r0, r8
   174d6:	f7ff fca0 	bl	16e1a <_copy>

		out += bufferlen;
   174da:	44b0      	add	r8, r6
		outlen = (outlen > TC_SHA256_DIGEST_SIZE) ?
			(outlen - TC_SHA256_DIGEST_SIZE) : 0;
   174dc:	4639      	mov	r1, r7
   174de:	2f20      	cmp	r7, #32
   174e0:	bf38      	it	cc
   174e2:	2120      	movcc	r1, #32
		outlen = (outlen > TC_SHA256_DIGEST_SIZE) ?
   174e4:	f1a1 0720 	sub.w	r7, r1, #32
	while (outlen != 0) {
   174e8:	2f00      	cmp	r7, #0
   174ea:	d1d7      	bne.n	1749c <tc_hmac_prng_generate+0x2e>
	}

	/* block future PRNG compromises from revealing past state */
	update(prng, 0, 0, 0, 0);
   174ec:	2100      	movs	r1, #0
   174ee:	9100      	str	r1, [sp, #0]
   174f0:	460b      	mov	r3, r1
   174f2:	460a      	mov	r2, r1
   174f4:	4620      	mov	r0, r4
   174f6:	f7ff fee7 	bl	172c8 <update>

	return TC_CRYPTO_SUCCESS;
   174fa:	2001      	movs	r0, #1
   174fc:	e004      	b.n	17508 <tc_hmac_prng_generate+0x9a>
		return TC_CRYPTO_FAIL;
   174fe:	2000      	movs	r0, #0
}
   17500:	4770      	bx	lr
		return TC_CRYPTO_FAIL;
   17502:	2000      	movs	r0, #0
   17504:	e000      	b.n	17508 <tc_hmac_prng_generate+0x9a>
   17506:	2000      	movs	r0, #0
}
   17508:	b002      	add	sp, #8
   1750a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TC_CRYPTO_FAIL;
   1750e:	2000      	movs	r0, #0
   17510:	e7fa      	b.n	17508 <tc_hmac_prng_generate+0x9a>
		return TC_HMAC_PRNG_RESEED_REQ;
   17512:	f04f 30ff 	mov.w	r0, #4294967295
   17516:	e7f7      	b.n	17508 <tc_hmac_prng_generate+0x9a>

00017518 <abort_function>:
{
   17518:	b508      	push	{r3, lr}
	sys_reboot(SYS_REBOOT_WARM);
   1751a:	2000      	movs	r0, #0
   1751c:	f7ea fa3e 	bl	199c <sys_reboot>

00017520 <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   17520:	b538      	push	{r3, r4, r5, lr}
   17522:	4604      	mov	r4, r0

	if (esf != NULL) {
   17524:	460d      	mov	r5, r1
   17526:	b111      	cbz	r1, 1752e <z_arm_fatal_error+0xe>
		esf_dump(esf);
   17528:	4608      	mov	r0, r1
   1752a:	f7ec fc49 	bl	3dc0 <esf_dump>
	}
	z_fatal_error(reason, esf);
   1752e:	4629      	mov	r1, r5
   17530:	4620      	mov	r0, r4
   17532:	f7fb febb 	bl	132ac <z_fatal_error>
}
   17536:	bd38      	pop	{r3, r4, r5, pc}

00017538 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
   17538:	b508      	push	{r3, lr}
   1753a:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
   1753c:	6800      	ldr	r0, [r0, #0]
   1753e:	f7ff ffef 	bl	17520 <z_arm_fatal_error>
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
   17542:	bd08      	pop	{r3, pc}

00017544 <z_irq_spurious>:
 * Installed in all _sw_isr_table slots at boot time. Throws an error if
 * called.
 *
 */
void z_irq_spurious(const void *unused)
{
   17544:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   17546:	2100      	movs	r1, #0
   17548:	2001      	movs	r0, #1
   1754a:	f7ff ffe9 	bl	17520 <z_arm_fatal_error>
}
   1754e:	bd08      	pop	{r3, pc}

00017550 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   17550:	b508      	push	{r3, lr}
	handler();
   17552:	f7ec fd9d 	bl	4090 <z_SysNmiOnReset>
	z_arm_int_exit();
   17556:	f7ec fe6d 	bl	4234 <z_arm_exc_exit>
}
   1755a:	bd08      	pop	{r3, pc}

0001755c <configure_builtin_stack_guard>:
	uint32_t guard_start = thread->stack_info.start;
   1755c:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   17560:	f383 880b 	msr	PSPLIM, r3
}
   17564:	4770      	bx	lr

00017566 <memory_fault_recoverable>:
}
   17566:	2000      	movs	r0, #0
   17568:	4770      	bx	lr

0001756a <fault_handle>:
{
   1756a:	b508      	push	{r3, lr}
	*recoverable = false;
   1756c:	2300      	movs	r3, #0
   1756e:	7013      	strb	r3, [r2, #0]
	switch (fault) {
   17570:	1ecb      	subs	r3, r1, #3
   17572:	2b09      	cmp	r3, #9
   17574:	d81a      	bhi.n	175ac <fault_handle+0x42>
   17576:	e8df f003 	tbb	[pc, r3]
   1757a:	0905      	.short	0x0905
   1757c:	1919110d 	.word	0x1919110d
   17580:	14191919 	.word	0x14191919
		reason = hard_fault(esf, recoverable);
   17584:	4611      	mov	r1, r2
   17586:	f7ed fadd 	bl	4b44 <hard_fault>
}
   1758a:	bd08      	pop	{r3, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   1758c:	2100      	movs	r1, #0
   1758e:	f7ec fe5f 	bl	4250 <mem_manage_fault>
		break;
   17592:	e7fa      	b.n	1758a <fault_handle+0x20>
		reason = bus_fault(esf, 0, recoverable);
   17594:	2100      	movs	r1, #0
   17596:	f7ec ffcf 	bl	4538 <bus_fault>
		break;
   1759a:	e7f6      	b.n	1758a <fault_handle+0x20>
		reason = usage_fault(esf);
   1759c:	f7ed f95c 	bl	4858 <usage_fault>
		break;
   175a0:	e7f3      	b.n	1758a <fault_handle+0x20>
		debug_monitor(esf, recoverable);
   175a2:	4611      	mov	r1, r2
   175a4:	f7ed fbea 	bl	4d7c <debug_monitor>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   175a8:	2000      	movs	r0, #0
		break;
   175aa:	e7ee      	b.n	1758a <fault_handle+0x20>
		reserved_exception(esf, fault);
   175ac:	f7ed fc16 	bl	4ddc <reserved_exception>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   175b0:	2000      	movs	r0, #0
	return reason;
   175b2:	e7ea      	b.n	1758a <fault_handle+0x20>

000175b4 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   175b4:	e840 f000 	tt	r0, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   175b8:	f410 3f80 	tst.w	r0, #65536	; 0x10000
   175bc:	d001      	beq.n	175c2 <arm_cmse_mpu_region_get+0xe>
		return addr_info.flags.mpu_region;
   175be:	b2c0      	uxtb	r0, r0
   175c0:	4770      	bx	lr
	}

	return -EINVAL;
   175c2:	f06f 0015 	mvn.w	r0, #21
}
   175c6:	4770      	bx	lr

000175c8 <region_init>:
{
   175c8:	b508      	push	{r3, lr}
		(region_conf->base & MPU_RBAR_BASE_Msk)
   175ca:	680b      	ldr	r3, [r1, #0]
   175cc:	f023 0c1f 	bic.w	ip, r3, #31
		| (region_conf->attr.rbar &
   175d0:	7a0b      	ldrb	r3, [r1, #8]
   175d2:	f003 0e1f 	and.w	lr, r3, #31
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   175d6:	68ca      	ldr	r2, [r1, #12]
   175d8:	f022 021f 	bic.w	r2, r2, #31
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   175dc:	095b      	lsrs	r3, r3, #5
   175de:	ea42 0243 	orr.w	r2, r2, r3, lsl #1
	mpu_set_region(
   175e2:	f042 0201 	orr.w	r2, r2, #1
   175e6:	ea4c 010e 	orr.w	r1, ip, lr
   175ea:	f7ed fdcf 	bl	518c <mpu_set_region>
}
   175ee:	bd08      	pop	{r3, pc}

000175f0 <mpu_partition_is_valid>:
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
   175f0:	6843      	ldr	r3, [r0, #4]
		&&
   175f2:	2b1f      	cmp	r3, #31
   175f4:	d90a      	bls.n	1760c <mpu_partition_is_valid+0x1c>
		&&
   175f6:	f013 0f1f 	tst.w	r3, #31
   175fa:	d001      	beq.n	17600 <mpu_partition_is_valid+0x10>
		&&
   175fc:	2000      	movs	r0, #0
   175fe:	4770      	bx	lr
		((part->start &
   17600:	6803      	ldr	r3, [r0, #0]
		&&
   17602:	f013 0f1f 	tst.w	r3, #31
   17606:	d003      	beq.n	17610 <mpu_partition_is_valid+0x20>
   17608:	2000      	movs	r0, #0
   1760a:	4770      	bx	lr
   1760c:	2000      	movs	r0, #0
   1760e:	4770      	bx	lr
   17610:	2001      	movs	r0, #1
}
   17612:	4770      	bx	lr

00017614 <mpu_configure_region>:
{
   17614:	b510      	push	{r4, lr}
   17616:	b084      	sub	sp, #16
	region_conf.base = new_region->start;
   17618:	680b      	ldr	r3, [r1, #0]
   1761a:	9300      	str	r3, [sp, #0]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   1761c:	684c      	ldr	r4, [r1, #4]
	p_attr->rbar = attr->rbar &
   1761e:	f8b1 c008 	ldrh.w	ip, [r1, #8]
   17622:	f89d 2008 	ldrb.w	r2, [sp, #8]
   17626:	f36c 0204 	bfi	r2, ip, #0, #5
   1762a:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->mair_idx = attr->mair_idx;
   1762e:	8949      	ldrh	r1, [r1, #10]
   17630:	b2d2      	uxtb	r2, r2
   17632:	f361 1247 	bfi	r2, r1, #5, #3
   17636:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   1763a:	f023 031f 	bic.w	r3, r3, #31
   1763e:	4423      	add	r3, r4
   17640:	3b01      	subs	r3, #1
   17642:	f023 031f 	bic.w	r3, r3, #31
   17646:	9303      	str	r3, [sp, #12]
	return region_allocate_and_init(index,
   17648:	4669      	mov	r1, sp
   1764a:	f7ed fda9 	bl	51a0 <region_allocate_and_init>
}
   1764e:	b004      	add	sp, #16
   17650:	bd10      	pop	{r4, pc}

00017652 <arm_core_mpu_configure_static_mpu_regions>:
{
   17652:	b508      	push	{r3, lr}
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
   17654:	f7ed ff4a 	bl	54ec <mpu_configure_static_mpu_regions>
}
   17658:	bd08      	pop	{r3, pc}

0001765a <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
   1765a:	b508      	push	{r3, lr}
	if (mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1765c:	f7ed ff50 	bl	5500 <mpu_mark_areas_for_dynamic_regions>
}
   17660:	bd08      	pop	{r3, pc}

00017662 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   17662:	4602      	mov	r2, r0
   17664:	e002      	b.n	1766c <strcpy+0xa>
		*d = *s;
   17666:	f802 3b01 	strb.w	r3, [r2], #1
		d++;
		s++;
   1766a:	3101      	adds	r1, #1
	while (*s != '\0') {
   1766c:	780b      	ldrb	r3, [r1, #0]
   1766e:	2b00      	cmp	r3, #0
   17670:	d1f9      	bne.n	17666 <strcpy+0x4>
	}

	*d = '\0';
   17672:	7013      	strb	r3, [r2, #0]

	return dest;
}
   17674:	4770      	bx	lr

00017676 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   17676:	4603      	mov	r3, r0
   17678:	b1a2      	cbz	r2, 176a4 <strncpy+0x2e>
{
   1767a:	b410      	push	{r4}
	while ((n > 0) && *s != '\0') {
   1767c:	780c      	ldrb	r4, [r1, #0]
   1767e:	b12c      	cbz	r4, 1768c <strncpy+0x16>
		*d = *s;
   17680:	f803 4b01 	strb.w	r4, [r3], #1
		s++;
   17684:	3101      	adds	r1, #1
		d++;
		n--;
   17686:	3a01      	subs	r2, #1
	while ((n > 0) && *s != '\0') {
   17688:	2a00      	cmp	r2, #0
   1768a:	d1f7      	bne.n	1767c <strncpy+0x6>
	}

	while (n > 0) {
   1768c:	b122      	cbz	r2, 17698 <strncpy+0x22>
		*d = '\0';
   1768e:	2100      	movs	r1, #0
   17690:	f803 1b01 	strb.w	r1, [r3], #1
		d++;
		n--;
   17694:	3a01      	subs	r2, #1
   17696:	e7f9      	b.n	1768c <strncpy+0x16>
	}

	return dest;
}
   17698:	bc10      	pop	{r4}
   1769a:	4770      	bx	lr
		*d = '\0';
   1769c:	2100      	movs	r1, #0
   1769e:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   176a2:	3a01      	subs	r2, #1
	while (n > 0) {
   176a4:	2a00      	cmp	r2, #0
   176a6:	d1f9      	bne.n	1769c <strncpy+0x26>
   176a8:	4770      	bx	lr

000176aa <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   176aa:	4603      	mov	r3, r0
	size_t n = 0;
   176ac:	2000      	movs	r0, #0

	while (*s != '\0') {
   176ae:	e001      	b.n	176b4 <strlen+0xa>
		s++;
   176b0:	3301      	adds	r3, #1
		n++;
   176b2:	3001      	adds	r0, #1
	while (*s != '\0') {
   176b4:	781a      	ldrb	r2, [r3, #0]
   176b6:	2a00      	cmp	r2, #0
   176b8:	d1fa      	bne.n	176b0 <strlen+0x6>
	}

	return n;
}
   176ba:	4770      	bx	lr

000176bc <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   176bc:	4603      	mov	r3, r0
	size_t n = 0;
   176be:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   176c0:	e001      	b.n	176c6 <strnlen+0xa>
		s++;
   176c2:	3301      	adds	r3, #1
		n++;
   176c4:	3001      	adds	r0, #1
	while (*s != '\0' && n < maxlen) {
   176c6:	781a      	ldrb	r2, [r3, #0]
   176c8:	b10a      	cbz	r2, 176ce <strnlen+0x12>
   176ca:	4288      	cmp	r0, r1
   176cc:	d3f9      	bcc.n	176c2 <strnlen+0x6>
	}

	return n;
}
   176ce:	4770      	bx	lr

000176d0 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   176d0:	e001      	b.n	176d6 <strcmp+0x6>
		s1++;
   176d2:	3001      	adds	r0, #1
		s2++;
   176d4:	3101      	adds	r1, #1
	while ((*s1 == *s2) && (*s1 != '\0')) {
   176d6:	7803      	ldrb	r3, [r0, #0]
   176d8:	780a      	ldrb	r2, [r1, #0]
   176da:	4293      	cmp	r3, r2
   176dc:	d101      	bne.n	176e2 <strcmp+0x12>
   176de:	2b00      	cmp	r3, #0
   176e0:	d1f7      	bne.n	176d2 <strcmp+0x2>
	}

	return *s1 - *s2;
}
   176e2:	1a98      	subs	r0, r3, r2
   176e4:	4770      	bx	lr

000176e6 <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   176e6:	e002      	b.n	176ee <strncmp+0x8>
		s1++;
   176e8:	3001      	adds	r0, #1
		s2++;
   176ea:	3101      	adds	r1, #1
		n--;
   176ec:	3a01      	subs	r2, #1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   176ee:	b132      	cbz	r2, 176fe <strncmp+0x18>
   176f0:	7803      	ldrb	r3, [r0, #0]
   176f2:	f891 c000 	ldrb.w	ip, [r1]
   176f6:	4563      	cmp	r3, ip
   176f8:	d101      	bne.n	176fe <strncmp+0x18>
   176fa:	2b00      	cmp	r3, #0
   176fc:	d1f4      	bne.n	176e8 <strncmp+0x2>
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   176fe:	b11a      	cbz	r2, 17708 <strncmp+0x22>
   17700:	7800      	ldrb	r0, [r0, #0]
   17702:	780b      	ldrb	r3, [r1, #0]
   17704:	1ac0      	subs	r0, r0, r3
   17706:	4770      	bx	lr
   17708:	2000      	movs	r0, #0
}
   1770a:	4770      	bx	lr

0001770c <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   1770c:	4613      	mov	r3, r2
   1770e:	b16a      	cbz	r2, 1772c <memcmp+0x20>
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   17710:	3b01      	subs	r3, #1
   17712:	d007      	beq.n	17724 <memcmp+0x18>
   17714:	f890 c000 	ldrb.w	ip, [r0]
   17718:	780a      	ldrb	r2, [r1, #0]
   1771a:	4594      	cmp	ip, r2
   1771c:	d102      	bne.n	17724 <memcmp+0x18>
		c1++;
   1771e:	3001      	adds	r0, #1
		c2++;
   17720:	3101      	adds	r1, #1
   17722:	e7f5      	b.n	17710 <memcmp+0x4>
	}

	return *c1 - *c2;
   17724:	7800      	ldrb	r0, [r0, #0]
   17726:	780b      	ldrb	r3, [r1, #0]
   17728:	1ac0      	subs	r0, r0, r3
   1772a:	4770      	bx	lr
		return 0;
   1772c:	2000      	movs	r0, #0
}
   1772e:	4770      	bx	lr

00017730 <memcpy>:
	const unsigned char *s_byte = (const unsigned char *)s;

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   17730:	ea80 0301 	eor.w	r3, r0, r1
   17734:	f013 0f03 	tst.w	r3, #3
   17738:	d001      	beq.n	1773e <memcpy+0xe>
	unsigned char *d_byte = (unsigned char *)d;
   1773a:	4603      	mov	r3, r0
   1773c:	e023      	b.n	17786 <memcpy+0x56>
   1773e:	4603      	mov	r3, r0

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
   17740:	f013 0f03 	tst.w	r3, #3
   17744:	d00f      	beq.n	17766 <memcpy+0x36>
			if (n == 0) {
   17746:	b30a      	cbz	r2, 1778c <memcpy+0x5c>
				return d;
			}
			*(d_byte++) = *(s_byte++);
   17748:	f811 cb01 	ldrb.w	ip, [r1], #1
   1774c:	f803 cb01 	strb.w	ip, [r3], #1
			n--;
   17750:	3a01      	subs	r2, #1
   17752:	e7f5      	b.n	17740 <memcpy+0x10>
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
   17754:	f811 cb01 	ldrb.w	ip, [r1], #1
   17758:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
   1775c:	3a01      	subs	r2, #1
	while (n > 0) {
   1775e:	2a00      	cmp	r2, #0
   17760:	d1f8      	bne.n	17754 <memcpy+0x24>
	}

	return d;
}
   17762:	bc10      	pop	{r4}
   17764:	4770      	bx	lr
		while (n >= sizeof(mem_word_t)) {
   17766:	2a03      	cmp	r2, #3
   17768:	d90d      	bls.n	17786 <memcpy+0x56>
{
   1776a:	b410      	push	{r4}
			*(d_word++) = *(s_word++);
   1776c:	f851 4b04 	ldr.w	r4, [r1], #4
   17770:	f843 4b04 	str.w	r4, [r3], #4
			n -= sizeof(mem_word_t);
   17774:	3a04      	subs	r2, #4
		while (n >= sizeof(mem_word_t)) {
   17776:	2a03      	cmp	r2, #3
   17778:	d8f8      	bhi.n	1776c <memcpy+0x3c>
   1777a:	e7f0      	b.n	1775e <memcpy+0x2e>
		*(d_byte++) = *(s_byte++);
   1777c:	f811 cb01 	ldrb.w	ip, [r1], #1
   17780:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
   17784:	3a01      	subs	r2, #1
	while (n > 0) {
   17786:	2a00      	cmp	r2, #0
   17788:	d1f8      	bne.n	1777c <memcpy+0x4c>
   1778a:	4770      	bx	lr
}
   1778c:	4770      	bx	lr

0001778e <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   1778e:	fa5f fc81 	uxtb.w	ip, r1
	unsigned char *d_byte = (unsigned char *)buf;
   17792:	4603      	mov	r3, r0

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   17794:	e002      	b.n	1779c <memset+0xe>
		if (n == 0) {
			return buf;
		}
		*(d_byte++) = c_byte;
   17796:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
   1779a:	3a01      	subs	r2, #1
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   1779c:	f013 0f03 	tst.w	r3, #3
   177a0:	d002      	beq.n	177a8 <memset+0x1a>
		if (n == 0) {
   177a2:	2a00      	cmp	r2, #0
   177a4:	d1f7      	bne.n	17796 <memset+0x8>
   177a6:	e00f      	b.n	177c8 <memset+0x3a>
	}

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
   177a8:	b2c9      	uxtb	r1, r1

	c_word |= c_word << 8;
   177aa:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
	c_word |= c_word << 16;
   177ae:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   177b2:	2a03      	cmp	r2, #3
   177b4:	d906      	bls.n	177c4 <memset+0x36>
		*(d_word++) = c_word;
   177b6:	f843 1b04 	str.w	r1, [r3], #4
		n -= sizeof(mem_word_t);
   177ba:	3a04      	subs	r2, #4
   177bc:	e7f9      	b.n	177b2 <memset+0x24>

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
		*(d_byte++) = c_byte;
   177be:	f803 cb01 	strb.w	ip, [r3], #1
		n--;
   177c2:	3a01      	subs	r2, #1
	while (n > 0) {
   177c4:	2a00      	cmp	r2, #0
   177c6:	d1fa      	bne.n	177be <memset+0x30>
	}

	return buf;
}
   177c8:	4770      	bx	lr

000177ca <_stdout_hook_default>:
}
   177ca:	f04f 30ff 	mov.w	r0, #4294967295
   177ce:	4770      	bx	lr

000177d0 <setup>:

static int setup(const struct device *dev)
{
   177d0:	b508      	push	{r3, lr}
	}

#endif /* !CONFIG_TRUSTED_EXECUTION_SECURE */

	if (IS_ENABLED(CONFIG_BOARD_ENABLE_CPUNET)) {
		enable_cpunet();
   177d2:	f7ed ff31 	bl	5638 <enable_cpunet>
	}

	return 0;
}
   177d6:	2000      	movs	r0, #0
   177d8:	bd08      	pop	{r3, pc}

000177da <uuid128_cmp>:

static int uuid128_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   177da:	b510      	push	{r4, lr}
   177dc:	b08a      	sub	sp, #40	; 0x28
   177de:	460c      	mov	r4, r1
	struct bt_uuid_128 uuid1, uuid2;

	uuid_to_uuid128(u1, &uuid1);
   177e0:	a905      	add	r1, sp, #20
   177e2:	f7ed ffcf 	bl	5784 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   177e6:	4669      	mov	r1, sp
   177e8:	4620      	mov	r0, r4
   177ea:	f7ed ffcb 	bl	5784 <uuid_to_uuid128>

	return memcmp(uuid1.val, uuid2.val, 16);
   177ee:	2210      	movs	r2, #16
   177f0:	f10d 0101 	add.w	r1, sp, #1
   177f4:	f10d 0015 	add.w	r0, sp, #21
   177f8:	f7ff ff88 	bl	1770c <memcmp>
}
   177fc:	b00a      	add	sp, #40	; 0x28
   177fe:	bd10      	pop	{r4, pc}

00017800 <bt_uuid_cmp>:

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   17800:	b508      	push	{r3, lr}
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
   17802:	7803      	ldrb	r3, [r0, #0]
   17804:	780a      	ldrb	r2, [r1, #0]
   17806:	4293      	cmp	r3, r2
   17808:	d107      	bne.n	1781a <bt_uuid_cmp+0x1a>
		return uuid128_cmp(u1, u2);
	}

	switch (u1->type) {
   1780a:	2b01      	cmp	r3, #1
   1780c:	d00c      	beq.n	17828 <bt_uuid_cmp+0x28>
   1780e:	2b02      	cmp	r3, #2
   17810:	d00e      	beq.n	17830 <bt_uuid_cmp+0x30>
   17812:	b12b      	cbz	r3, 17820 <bt_uuid_cmp+0x20>
   17814:	f06f 0015 	mvn.w	r0, #21
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
	}

	return -EINVAL;
}
   17818:	bd08      	pop	{r3, pc}
		return uuid128_cmp(u1, u2);
   1781a:	f7ff ffde 	bl	177da <uuid128_cmp>
   1781e:	e7fb      	b.n	17818 <bt_uuid_cmp+0x18>
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   17820:	8840      	ldrh	r0, [r0, #2]
   17822:	884b      	ldrh	r3, [r1, #2]
   17824:	1ac0      	subs	r0, r0, r3
   17826:	e7f7      	b.n	17818 <bt_uuid_cmp+0x18>
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   17828:	6840      	ldr	r0, [r0, #4]
   1782a:	684b      	ldr	r3, [r1, #4]
   1782c:	1ac0      	subs	r0, r0, r3
   1782e:	e7f3      	b.n	17818 <bt_uuid_cmp+0x18>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   17830:	2210      	movs	r2, #16
   17832:	3101      	adds	r1, #1
   17834:	3001      	adds	r0, #1
   17836:	f7ff ff69 	bl	1770c <memcmp>
   1783a:	e7ed      	b.n	17818 <bt_uuid_cmp+0x18>

0001783c <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const uint8_t *data, uint8_t data_len)
{
   1783c:	b508      	push	{r3, lr}
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
   1783e:	2a04      	cmp	r2, #4
   17840:	d00e      	beq.n	17860 <bt_uuid_create+0x24>
   17842:	2a10      	cmp	r2, #16
   17844:	d01d      	beq.n	17882 <bt_uuid_create+0x46>
   17846:	2a02      	cmp	r2, #2
   17848:	d001      	beq.n	1784e <bt_uuid_create+0x12>
   1784a:	2000      	movs	r0, #0
		break;
	default:
		return false;
	}
	return true;
}
   1784c:	bd08      	pop	{r3, pc}
		uuid->type = BT_UUID_TYPE_16;
   1784e:	2300      	movs	r3, #0
   17850:	7003      	strb	r3, [r0, #0]
	return ((uint16_t)src[1] << 8) | src[0];
   17852:	784a      	ldrb	r2, [r1, #1]
   17854:	780b      	ldrb	r3, [r1, #0]
   17856:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   1785a:	8043      	strh	r3, [r0, #2]
	return true;
   1785c:	2001      	movs	r0, #1
		break;
   1785e:	e7f5      	b.n	1784c <bt_uuid_create+0x10>
		uuid->type = BT_UUID_TYPE_32;
   17860:	2301      	movs	r3, #1
   17862:	7003      	strb	r3, [r0, #0]
   17864:	f891 c003 	ldrb.w	ip, [r1, #3]
   17868:	788a      	ldrb	r2, [r1, #2]
   1786a:	ea42 2c0c 	orr.w	ip, r2, ip, lsl #8
   1786e:	f891 e001 	ldrb.w	lr, [r1, #1]
   17872:	780a      	ldrb	r2, [r1, #0]
   17874:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
	return ((uint32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   17878:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   1787c:	6042      	str	r2, [r0, #4]
	return true;
   1787e:	4618      	mov	r0, r3
		break;
   17880:	e7e4      	b.n	1784c <bt_uuid_create+0x10>
		uuid->type = BT_UUID_TYPE_128;
   17882:	2302      	movs	r3, #2
   17884:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
   17888:	2210      	movs	r2, #16
   1788a:	f7ff ff51 	bl	17730 <memcpy>
	return true;
   1788e:	2001      	movs	r0, #1
		break;
   17890:	e7dc      	b.n	1784c <bt_uuid_create+0x10>

00017892 <bt_addr_le_create_static>:

	return 0;
}

int bt_addr_le_create_static(bt_addr_le_t *addr)
{
   17892:	b510      	push	{r4, lr}
   17894:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   17896:	2301      	movs	r3, #1
   17898:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   1789c:	2106      	movs	r1, #6
   1789e:	f7f1 ffc7 	bl	9830 <bt_rand>
	int err;

	err = create_random_addr(addr);
	if (err) {
   178a2:	b918      	cbnz	r0, 178ac <bt_addr_le_create_static+0x1a>
		return err;
	}

	BT_ADDR_SET_STATIC(&addr->a);
   178a4:	79a3      	ldrb	r3, [r4, #6]
   178a6:	f063 033f 	orn	r3, r3, #63	; 0x3f
   178aa:	71a3      	strb	r3, [r4, #6]

	return 0;
}
   178ac:	bd10      	pop	{r4, pc}

000178ae <skip_auto_phy_update_on_conn_establishment>:
}
   178ae:	2000      	movs	r0, #0
   178b0:	4770      	bx	lr

000178b2 <hci_vendor_event>:
}
   178b2:	4770      	bx	lr

000178b4 <hci_disconn_complete_prio>:
{
   178b4:	b538      	push	{r3, r4, r5, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   178b6:	6883      	ldr	r3, [r0, #8]
	uint16_t handle = sys_le16_to_cpu(evt->handle);
   178b8:	f8b3 4001 	ldrh.w	r4, [r3, #1]
	if (evt->status) {
   178bc:	781b      	ldrb	r3, [r3, #0]
   178be:	b103      	cbz	r3, 178c2 <hci_disconn_complete_prio+0xe>
}
   178c0:	bd38      	pop	{r3, r4, r5, pc}
	conn = bt_conn_lookup_handle(handle);
   178c2:	4620      	mov	r0, r4
   178c4:	f7f2 fb6a 	bl	9f9c <bt_conn_lookup_handle>
	if (!conn) {
   178c8:	4605      	mov	r5, r0
   178ca:	b130      	cbz	r0, 178da <hci_disconn_complete_prio+0x26>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT_COMPLETE);
   178cc:	2101      	movs	r1, #1
   178ce:	f7f2 fb6f 	bl	9fb0 <bt_conn_set_state>
	bt_conn_unref(conn);
   178d2:	4628      	mov	r0, r5
   178d4:	f000 fc02 	bl	180dc <bt_conn_unref>
   178d8:	e7f2      	b.n	178c0 <hci_disconn_complete_prio+0xc>
		conn_handle_disconnected(handle);
   178da:	4620      	mov	r0, r4
   178dc:	f7ed fffc 	bl	58d8 <conn_handle_disconnected>
		return;
   178e0:	e7ee      	b.n	178c0 <hci_disconn_complete_prio+0xc>

000178e2 <set_event_mask>:
{
   178e2:	b510      	push	{r4, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
   178e4:	2108      	movs	r1, #8
   178e6:	f640 4001 	movw	r0, #3073	; 0xc01
   178ea:	f7ef fac9 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   178ee:	b1b8      	cbz	r0, 17920 <set_event_mask+0x3e>
   178f0:	4604      	mov	r4, r0
	return net_buf_simple_add(&buf->b, len);
   178f2:	2108      	movs	r1, #8
   178f4:	4408      	add	r0, r1
   178f6:	f002 fc82 	bl	1a1fe <net_buf_simple_add>
	dst[0] = val;
   178fa:	2310      	movs	r3, #16
   178fc:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
   178fe:	2388      	movs	r3, #136	; 0x88
   17900:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
   17902:	2200      	movs	r2, #0
   17904:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
   17906:	2302      	movs	r3, #2
   17908:	70c3      	strb	r3, [r0, #3]
	dst[0] = val;
   1790a:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
   1790c:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
   1790e:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
   17910:	2320      	movs	r3, #32
   17912:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
   17914:	4621      	mov	r1, r4
   17916:	f640 4001 	movw	r0, #3073	; 0xc01
   1791a:	f7ef faef 	bl	6efc <bt_hci_cmd_send_sync>
}
   1791e:	bd10      	pop	{r4, pc}
		return -ENOBUFS;
   17920:	f06f 0068 	mvn.w	r0, #104	; 0x68
   17924:	e7fb      	b.n	1791e <set_event_mask+0x3c>

00017926 <hci_le_read_remote_features>:
{
   17926:	b538      	push	{r3, r4, r5, lr}
   17928:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
   1792a:	2102      	movs	r1, #2
   1792c:	f242 0016 	movw	r0, #8214	; 0x2016
   17930:	f7ef faa6 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   17934:	b168      	cbz	r0, 17952 <hci_le_read_remote_features+0x2c>
   17936:	4605      	mov	r5, r0
   17938:	2102      	movs	r1, #2
   1793a:	3008      	adds	r0, #8
   1793c:	f002 fc5f 	bl	1a1fe <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   17940:	8823      	ldrh	r3, [r4, #0]
   17942:	8003      	strh	r3, [r0, #0]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf, NULL);
   17944:	2200      	movs	r2, #0
   17946:	4629      	mov	r1, r5
   17948:	f242 0016 	movw	r0, #8214	; 0x2016
   1794c:	f7ef fad6 	bl	6efc <bt_hci_cmd_send_sync>
}
   17950:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
   17952:	f06f 0068 	mvn.w	r0, #104	; 0x68
   17956:	e7fb      	b.n	17950 <hci_le_read_remote_features+0x2a>

00017958 <bt_hci_disconnect>:
{
   17958:	b570      	push	{r4, r5, r6, lr}
   1795a:	4605      	mov	r5, r0
   1795c:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   1795e:	2103      	movs	r1, #3
   17960:	f240 4006 	movw	r0, #1030	; 0x406
   17964:	f7ef fa8c 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   17968:	b168      	cbz	r0, 17986 <bt_hci_disconnect+0x2e>
   1796a:	4606      	mov	r6, r0
   1796c:	2103      	movs	r1, #3
   1796e:	3008      	adds	r0, #8
   17970:	f002 fc45 	bl	1a1fe <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(handle);
   17974:	8005      	strh	r5, [r0, #0]
	disconn->reason = reason;
   17976:	7084      	strb	r4, [r0, #2]
	return bt_hci_cmd_send_sync(BT_HCI_OP_DISCONNECT, buf, NULL);
   17978:	2200      	movs	r2, #0
   1797a:	4631      	mov	r1, r6
   1797c:	f240 4006 	movw	r0, #1030	; 0x406
   17980:	f7ef fabc 	bl	6efc <bt_hci_cmd_send_sync>
}
   17984:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   17986:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1798a:	e7fb      	b.n	17984 <bt_hci_disconnect+0x2c>

0001798c <bt_le_set_data_len>:
{
   1798c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1798e:	4606      	mov	r6, r0
   17990:	460f      	mov	r7, r1
   17992:	4614      	mov	r4, r2
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   17994:	2106      	movs	r1, #6
   17996:	f242 0022 	movw	r0, #8226	; 0x2022
   1799a:	f7ef fa71 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   1799e:	b178      	cbz	r0, 179c0 <bt_le_set_data_len+0x34>
   179a0:	4605      	mov	r5, r0
   179a2:	2106      	movs	r1, #6
   179a4:	3008      	adds	r0, #8
   179a6:	f002 fc2a 	bl	1a1fe <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   179aa:	8833      	ldrh	r3, [r6, #0]
   179ac:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
   179ae:	8047      	strh	r7, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
   179b0:	8084      	strh	r4, [r0, #4]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_DATA_LEN, buf, NULL);
   179b2:	2200      	movs	r2, #0
   179b4:	4629      	mov	r1, r5
   179b6:	f242 0022 	movw	r0, #8226	; 0x2022
   179ba:	f7ef fa9f 	bl	6efc <bt_hci_cmd_send_sync>
}
   179be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   179c0:	f06f 0068 	mvn.w	r0, #104	; 0x68
   179c4:	e7fb      	b.n	179be <bt_le_set_data_len+0x32>

000179c6 <bt_le_set_phy>:
{
   179c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   179ca:	4607      	mov	r7, r0
   179cc:	460e      	mov	r6, r1
   179ce:	4615      	mov	r5, r2
   179d0:	461c      	mov	r4, r3
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   179d2:	2107      	movs	r1, #7
   179d4:	f242 0032 	movw	r0, #8242	; 0x2032
   179d8:	f7ef fa52 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   179dc:	b1a8      	cbz	r0, 17a0a <bt_le_set_phy+0x44>
   179de:	4680      	mov	r8, r0
   179e0:	2107      	movs	r1, #7
   179e2:	3008      	adds	r0, #8
   179e4:	f002 fc0b 	bl	1a1fe <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   179e8:	883b      	ldrh	r3, [r7, #0]
   179ea:	8003      	strh	r3, [r0, #0]
	cp->all_phys = all_phys;
   179ec:	7086      	strb	r6, [r0, #2]
	cp->tx_phys = pref_tx_phy;
   179ee:	70c5      	strb	r5, [r0, #3]
	cp->rx_phys = pref_rx_phy;
   179f0:	7104      	strb	r4, [r0, #4]
	cp->phy_opts = phy_opts;
   179f2:	f89d 3018 	ldrb.w	r3, [sp, #24]
   179f6:	f8a0 3005 	strh.w	r3, [r0, #5]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_PHY, buf, NULL);
   179fa:	2200      	movs	r2, #0
   179fc:	4641      	mov	r1, r8
   179fe:	f242 0032 	movw	r0, #8242	; 0x2032
   17a02:	f7ef fa7b 	bl	6efc <bt_hci_cmd_send_sync>
}
   17a06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   17a0a:	f06f 0068 	mvn.w	r0, #104	; 0x68
   17a0e:	e7fa      	b.n	17a06 <bt_le_set_phy+0x40>

00017a10 <enh_conn_complete>:
{
   17a10:	b508      	push	{r3, lr}
	bt_hci_le_enh_conn_complete(evt);
   17a12:	f7f0 f8cb 	bl	7bac <bt_hci_le_enh_conn_complete>
}
   17a16:	bd08      	pop	{r3, pc}

00017a18 <le_enh_conn_complete>:
{
   17a18:	b508      	push	{r3, lr}
	enh_conn_complete((void *)buf->data);
   17a1a:	6880      	ldr	r0, [r0, #8]
   17a1c:	f7ff fff8 	bl	17a10 <enh_conn_complete>
}
   17a20:	bd08      	pop	{r3, pc}

00017a22 <le_legacy_conn_complete>:
{
   17a22:	b510      	push	{r4, lr}
   17a24:	b08c      	sub	sp, #48	; 0x30
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   17a26:	6881      	ldr	r1, [r0, #8]
	enh.status         = evt->status;
   17a28:	780b      	ldrb	r3, [r1, #0]
   17a2a:	f88d 3000 	strb.w	r3, [sp]
	enh.handle         = evt->handle;
   17a2e:	f8b1 3001 	ldrh.w	r3, [r1, #1]
   17a32:	f8ad 3001 	strh.w	r3, [sp, #1]
	enh.role           = evt->role;
   17a36:	78cb      	ldrb	r3, [r1, #3]
   17a38:	f88d 3003 	strb.w	r3, [sp, #3]
	enh.interval       = evt->interval;
   17a3c:	f8b1 300b 	ldrh.w	r3, [r1, #11]
   17a40:	f8ad 3017 	strh.w	r3, [sp, #23]
	enh.latency        = evt->latency;
   17a44:	f8b1 300d 	ldrh.w	r3, [r1, #13]
   17a48:	f8ad 3019 	strh.w	r3, [sp, #25]
	enh.supv_timeout   = evt->supv_timeout;
   17a4c:	f8b1 300f 	ldrh.w	r3, [r1, #15]
   17a50:	f8ad 301b 	strh.w	r3, [sp, #27]
	enh.clock_accuracy = evt->clock_accuracy;
   17a54:	7c4b      	ldrb	r3, [r1, #17]
   17a56:	f88d 301d 	strb.w	r3, [sp, #29]
	memcpy(dst, src, sizeof(*dst));
   17a5a:	2207      	movs	r2, #7
   17a5c:	3104      	adds	r1, #4
   17a5e:	a801      	add	r0, sp, #4
   17a60:	f7ff fe66 	bl	17730 <memcpy>
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   17a64:	2400      	movs	r4, #0
   17a66:	940a      	str	r4, [sp, #40]	; 0x28
   17a68:	f8ad 402c 	strh.w	r4, [sp, #44]	; 0x2c
	memcpy(dst, src, sizeof(*dst));
   17a6c:	2206      	movs	r2, #6
   17a6e:	a90a      	add	r1, sp, #40	; 0x28
   17a70:	f10d 000b 	add.w	r0, sp, #11
   17a74:	f7ff fe5c 	bl	17730 <memcpy>
	bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   17a78:	9408      	str	r4, [sp, #32]
   17a7a:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
   17a7e:	2206      	movs	r2, #6
   17a80:	a908      	add	r1, sp, #32
   17a82:	f10d 0011 	add.w	r0, sp, #17
   17a86:	f7ff fe53 	bl	17730 <memcpy>
	enh_conn_complete(&enh);
   17a8a:	4668      	mov	r0, sp
   17a8c:	f7ff ffc0 	bl	17a10 <enh_conn_complete>
}
   17a90:	b00c      	add	sp, #48	; 0x30
   17a92:	bd10      	pop	{r4, pc}

00017a94 <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   17a94:	8802      	ldrh	r2, [r0, #0]
   17a96:	8843      	ldrh	r3, [r0, #2]
   17a98:	429a      	cmp	r2, r3
   17a9a:	d817      	bhi.n	17acc <bt_le_conn_params_valid+0x38>
   17a9c:	2a05      	cmp	r2, #5
   17a9e:	d917      	bls.n	17ad0 <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   17aa0:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   17aa4:	d816      	bhi.n	17ad4 <bt_le_conn_params_valid+0x40>
	if (param->latency > 499) {
   17aa6:	8881      	ldrh	r1, [r0, #4]
   17aa8:	f5b1 7ffa 	cmp.w	r1, #500	; 0x1f4
   17aac:	d214      	bcs.n	17ad8 <bt_le_conn_params_valid+0x44>
	if (param->timeout < 10 || param->timeout > 3200 ||
   17aae:	88c0      	ldrh	r0, [r0, #6]
   17ab0:	f1a0 020a 	sub.w	r2, r0, #10
   17ab4:	b292      	uxth	r2, r2
   17ab6:	f640 4c76 	movw	ip, #3190	; 0xc76
   17aba:	4562      	cmp	r2, ip
   17abc:	d80e      	bhi.n	17adc <bt_le_conn_params_valid+0x48>
	     ((1U + param->latency) * param->interval_max))) {
   17abe:	fb01 3303 	mla	r3, r1, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   17ac2:	ebb3 0f80 	cmp.w	r3, r0, lsl #2
   17ac6:	d20b      	bcs.n	17ae0 <bt_le_conn_params_valid+0x4c>
	return true;
   17ac8:	2001      	movs	r0, #1
   17aca:	4770      	bx	lr
		return false;
   17acc:	2000      	movs	r0, #0
   17ace:	4770      	bx	lr
   17ad0:	2000      	movs	r0, #0
   17ad2:	4770      	bx	lr
   17ad4:	2000      	movs	r0, #0
   17ad6:	4770      	bx	lr
		return false;
   17ad8:	2000      	movs	r0, #0
   17ada:	4770      	bx	lr
		return false;
   17adc:	2000      	movs	r0, #0
   17ade:	4770      	bx	lr
   17ae0:	2000      	movs	r0, #0
}
   17ae2:	4770      	bx	lr

00017ae4 <le_conn_param_req_reply>:
{
   17ae4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17ae6:	4606      	mov	r6, r0
   17ae8:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
   17aea:	210e      	movs	r1, #14
   17aec:	f242 0020 	movw	r0, #8224	; 0x2020
   17af0:	f7ef f9c6 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   17af4:	b1c0      	cbz	r0, 17b28 <le_conn_param_req_reply+0x44>
   17af6:	4607      	mov	r7, r0
   17af8:	210e      	movs	r1, #14
   17afa:	3008      	adds	r0, #8
   17afc:	f002 fb7f 	bl	1a1fe <net_buf_simple_add>
   17b00:	4604      	mov	r4, r0
	(void)memset(cp, 0, sizeof(*cp));
   17b02:	220e      	movs	r2, #14
   17b04:	2100      	movs	r1, #0
   17b06:	f7ff fe42 	bl	1778e <memset>
	cp->handle = sys_cpu_to_le16(handle);
   17b0a:	8026      	strh	r6, [r4, #0]
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
   17b0c:	882b      	ldrh	r3, [r5, #0]
   17b0e:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
   17b10:	886b      	ldrh	r3, [r5, #2]
   17b12:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
   17b14:	88ab      	ldrh	r3, [r5, #4]
   17b16:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
   17b18:	88eb      	ldrh	r3, [r5, #6]
   17b1a:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   17b1c:	4639      	mov	r1, r7
   17b1e:	f242 0020 	movw	r0, #8224	; 0x2020
   17b22:	f7f0 f995 	bl	7e50 <bt_hci_cmd_send>
}
   17b26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   17b28:	f06f 0068 	mvn.w	r0, #104	; 0x68
   17b2c:	e7fb      	b.n	17b26 <le_conn_param_req_reply+0x42>

00017b2e <bt_init>:
{
   17b2e:	b510      	push	{r4, lr}
	err = hci_init();
   17b30:	f7ef feac 	bl	788c <hci_init>
	if (err) {
   17b34:	4604      	mov	r4, r0
   17b36:	b108      	cbz	r0, 17b3c <bt_init+0xe>
}
   17b38:	4620      	mov	r0, r4
   17b3a:	bd10      	pop	{r4, pc}
		err = bt_conn_init();
   17b3c:	f7f2 fee0 	bl	a900 <bt_conn_init>
		if (err) {
   17b40:	4604      	mov	r4, r0
   17b42:	2800      	cmp	r0, #0
   17b44:	d1f8      	bne.n	17b38 <bt_init+0xa>
	bt_finalize_init();
   17b46:	f7f0 fdbd 	bl	86c4 <bt_finalize_init>
	return 0;
   17b4a:	e7f5      	b.n	17b38 <bt_init+0xa>

00017b4c <bt_get_appearance>:
#if defined(CONFIG_BT_DEVICE_APPEARANCE_DYNAMIC)
	return bt_dev.appearance;
#else
	return CONFIG_BT_DEVICE_APPEARANCE;
#endif
}
   17b4c:	2000      	movs	r0, #0
   17b4e:	4770      	bx	lr

00017b50 <bt_addr_le_is_bonded>:
		/* if there are any keys stored then device is bonded */
		return keys && keys->keys;
	} else {
		return false;
	}
}
   17b50:	2000      	movs	r0, #0
   17b52:	4770      	bx	lr

00017b54 <bt_lookup_id_addr>:
}
   17b54:	4608      	mov	r0, r1
   17b56:	4770      	bx	lr

00017b58 <bt_id_set_adv_random_addr>:
{
   17b58:	b508      	push	{r3, lr}
		return set_random_address(addr);
   17b5a:	4608      	mov	r0, r1
   17b5c:	f7f0 fed4 	bl	8908 <set_random_address>
}
   17b60:	bd08      	pop	{r3, pc}

00017b62 <bt_id_set_adv_private_addr>:
{
   17b62:	b510      	push	{r4, lr}
   17b64:	b082      	sub	sp, #8
   17b66:	4604      	mov	r4, r0
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   17b68:	2106      	movs	r1, #6
   17b6a:	4668      	mov	r0, sp
   17b6c:	f7f1 fe60 	bl	9830 <bt_rand>
	if (err) {
   17b70:	b108      	cbz	r0, 17b76 <bt_id_set_adv_private_addr+0x14>
}
   17b72:	b002      	add	sp, #8
   17b74:	bd10      	pop	{r4, pc}
	BT_ADDR_SET_NRPA(&nrpa);
   17b76:	f89d 3005 	ldrb.w	r3, [sp, #5]
   17b7a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   17b7e:	f88d 3005 	strb.w	r3, [sp, #5]
	err = bt_id_set_adv_random_addr(adv, &nrpa);
   17b82:	4669      	mov	r1, sp
   17b84:	4620      	mov	r0, r4
   17b86:	f7ff ffe7 	bl	17b58 <bt_id_set_adv_random_addr>
	if (err) {
   17b8a:	e7f2      	b.n	17b72 <bt_id_set_adv_private_addr+0x10>

00017b8c <bt_id_adv_random_addr_check>:
}
   17b8c:	2001      	movs	r0, #1
   17b8e:	4770      	bx	lr

00017b90 <ad_is_limited>:
	for (i = 0; i < ad_len; i++) {
   17b90:	2300      	movs	r3, #0
   17b92:	428b      	cmp	r3, r1
   17b94:	d219      	bcs.n	17bca <ad_is_limited+0x3a>
{
   17b96:	b500      	push	{lr}
   17b98:	e002      	b.n	17ba0 <ad_is_limited+0x10>
	for (i = 0; i < ad_len; i++) {
   17b9a:	3301      	adds	r3, #1
   17b9c:	428b      	cmp	r3, r1
   17b9e:	d211      	bcs.n	17bc4 <ad_is_limited+0x34>
		if (ad[i].type == BT_DATA_FLAGS &&
   17ba0:	eb00 0ec3 	add.w	lr, r0, r3, lsl #3
   17ba4:	f830 c033 	ldrh.w	ip, [r0, r3, lsl #3]
   17ba8:	f240 1201 	movw	r2, #257	; 0x101
   17bac:	4594      	cmp	ip, r2
   17bae:	d1f4      	bne.n	17b9a <ad_is_limited+0xa>
		    ad[i].data != NULL) {
   17bb0:	f8de 2004 	ldr.w	r2, [lr, #4]
		    ad[i].data_len == sizeof(uint8_t) &&
   17bb4:	2a00      	cmp	r2, #0
   17bb6:	d0f0      	beq.n	17b9a <ad_is_limited+0xa>
			if (ad[i].data[0] & BT_LE_AD_LIMITED) {
   17bb8:	7812      	ldrb	r2, [r2, #0]
   17bba:	f012 0f01 	tst.w	r2, #1
   17bbe:	d0ec      	beq.n	17b9a <ad_is_limited+0xa>
				return true;
   17bc0:	2001      	movs	r0, #1
   17bc2:	e000      	b.n	17bc6 <ad_is_limited+0x36>
	return false;
   17bc4:	2000      	movs	r0, #0
}
   17bc6:	f85d fb04 	ldr.w	pc, [sp], #4
	return false;
   17bca:	2000      	movs	r0, #0
}
   17bcc:	4770      	bx	lr

00017bce <get_filter_policy>:
}
   17bce:	2000      	movs	r0, #0
   17bd0:	4770      	bx	lr

00017bd2 <get_adv_channel_map>:
{
   17bd2:	4603      	mov	r3, r0
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_37) {
   17bd4:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   17bd8:	d10b      	bne.n	17bf2 <get_adv_channel_map+0x20>
	uint8_t channel_map = 0x07;
   17bda:	2007      	movs	r0, #7
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_38) {
   17bdc:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   17be0:	d001      	beq.n	17be6 <get_adv_channel_map+0x14>
		channel_map &= ~0x02;
   17be2:	f000 00fd 	and.w	r0, r0, #253	; 0xfd
	if (options & BT_LE_ADV_OPT_DISABLE_CHAN_39) {
   17be6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
   17bea:	d001      	beq.n	17bf0 <get_adv_channel_map+0x1e>
		channel_map &= ~0x04;
   17bec:	f000 00fb 	and.w	r0, r0, #251	; 0xfb
}
   17bf0:	4770      	bx	lr
		channel_map &= ~0x01;
   17bf2:	2006      	movs	r0, #6
   17bf4:	e7f2      	b.n	17bdc <get_adv_channel_map+0xa>

00017bf6 <hci_set_ad>:
{
   17bf6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17bfa:	b082      	sub	sp, #8
   17bfc:	4607      	mov	r7, r0
   17bfe:	460d      	mov	r5, r1
   17c00:	4616      	mov	r6, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   17c02:	2120      	movs	r1, #32
   17c04:	f7ef f93c 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   17c08:	b300      	cbz	r0, 17c4c <hci_set_ad+0x56>
   17c0a:	4680      	mov	r8, r0
   17c0c:	2120      	movs	r1, #32
   17c0e:	3008      	adds	r0, #8
   17c10:	f002 faf5 	bl	1a1fe <net_buf_simple_add>
   17c14:	4604      	mov	r4, r0
	(void)memset(set_data, 0, sizeof(*set_data));
   17c16:	2220      	movs	r2, #32
   17c18:	2100      	movs	r1, #0
   17c1a:	f7ff fdb8 	bl	1778e <memset>
	err = set_data_add_complete(set_data->data, BT_GAP_ADV_MAX_ADV_DATA_LEN,
   17c1e:	9400      	str	r4, [sp, #0]
   17c20:	4633      	mov	r3, r6
   17c22:	462a      	mov	r2, r5
   17c24:	211f      	movs	r1, #31
   17c26:	1c60      	adds	r0, r4, #1
   17c28:	f7f1 f994 	bl	8f54 <set_data_add_complete>
	if (err) {
   17c2c:	4604      	mov	r4, r0
   17c2e:	b948      	cbnz	r0, 17c44 <hci_set_ad+0x4e>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   17c30:	2200      	movs	r2, #0
   17c32:	4641      	mov	r1, r8
   17c34:	4638      	mov	r0, r7
   17c36:	f7ef f961 	bl	6efc <bt_hci_cmd_send_sync>
   17c3a:	4604      	mov	r4, r0
}
   17c3c:	4620      	mov	r0, r4
   17c3e:	b002      	add	sp, #8
   17c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_buf_unref(buf);
   17c44:	4640      	mov	r0, r8
   17c46:	f002 fa90 	bl	1a16a <net_buf_unref>
		return err;
   17c4a:	e7f7      	b.n	17c3c <hci_set_ad+0x46>
		return -ENOBUFS;
   17c4c:	f06f 0468 	mvn.w	r4, #104	; 0x68
   17c50:	e7f4      	b.n	17c3c <hci_set_ad+0x46>

00017c52 <set_ad>:
{
   17c52:	b508      	push	{r3, lr}
	return hci_set_ad(BT_HCI_OP_LE_SET_ADV_DATA, ad, ad_len);
   17c54:	f242 0008 	movw	r0, #8200	; 0x2008
   17c58:	f7ff ffcd 	bl	17bf6 <hci_set_ad>
}
   17c5c:	bd08      	pop	{r3, pc}

00017c5e <set_sd>:
{
   17c5e:	b508      	push	{r3, lr}
	return hci_set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, sd, sd_len);
   17c60:	f242 0009 	movw	r0, #8201	; 0x2009
   17c64:	f7ff ffc7 	bl	17bf6 <hci_set_ad>
}
   17c68:	bd08      	pop	{r3, pc}

00017c6a <le_adv_update>:
{
   17c6a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17c6e:	b089      	sub	sp, #36	; 0x24
   17c70:	4604      	mov	r4, r0
   17c72:	460e      	mov	r6, r1
   17c74:	4617      	mov	r7, r2
   17c76:	461d      	mov	r5, r3
   17c78:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
   17c7c:	f89d b04c 	ldrb.w	fp, [sp, #76]	; 0x4c
   17c80:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
   17c84:	f89d 9054 	ldrb.w	r9, [sp, #84]	; 0x54
	struct bt_ad d[2] = {};
   17c88:	2300      	movs	r3, #0
   17c8a:	9304      	str	r3, [sp, #16]
   17c8c:	9305      	str	r3, [sp, #20]
   17c8e:	9306      	str	r3, [sp, #24]
   17c90:	9307      	str	r3, [sp, #28]
	if (name_type != ADV_NAME_TYPE_NONE) {
   17c92:	f1b9 0f00 	cmp.w	r9, #0
   17c96:	d12f      	bne.n	17cf8 <le_adv_update+0x8e>
	if (!(ext_adv && scannable)) {
   17c98:	f1bb 0f00 	cmp.w	fp, #0
   17c9c:	d002      	beq.n	17ca4 <le_adv_update+0x3a>
   17c9e:	f1ba 0f00 	cmp.w	sl, #0
   17ca2:	d10b      	bne.n	17cbc <le_adv_update+0x52>
		d[0].data = ad;
   17ca4:	9604      	str	r6, [sp, #16]
		d[0].len = ad_len;
   17ca6:	9705      	str	r7, [sp, #20]
		if (name_type == ADV_NAME_TYPE_AD) {
   17ca8:	f1b9 0f01 	cmp.w	r9, #1
   17cac:	d052      	beq.n	17d54 <le_adv_update+0xea>
		d_len = 1;
   17cae:	2201      	movs	r2, #1
		err = set_ad(adv, d, d_len);
   17cb0:	a904      	add	r1, sp, #16
   17cb2:	4620      	mov	r0, r4
   17cb4:	f7ff ffcd 	bl	17c52 <set_ad>
		if (err) {
   17cb8:	4603      	mov	r3, r0
   17cba:	b9c8      	cbnz	r0, 17cf0 <le_adv_update+0x86>
	if (scannable) {
   17cbc:	f1ba 0f00 	cmp.w	sl, #0
   17cc0:	d00c      	beq.n	17cdc <le_adv_update+0x72>
		d[0].data = sd;
   17cc2:	9504      	str	r5, [sp, #16]
		d[0].len = sd_len;
   17cc4:	f8cd 8014 	str.w	r8, [sp, #20]
		if (name_type == ADV_NAME_TYPE_SD) {
   17cc8:	f1b9 0f02 	cmp.w	r9, #2
   17ccc:	d048      	beq.n	17d60 <le_adv_update+0xf6>
		d_len = 1;
   17cce:	2201      	movs	r2, #1
		err = set_sd(adv, d, d_len);
   17cd0:	a904      	add	r1, sp, #16
   17cd2:	4620      	mov	r0, r4
   17cd4:	f7ff ffc3 	bl	17c5e <set_sd>
		if (err) {
   17cd8:	4603      	mov	r3, r0
   17cda:	b948      	cbnz	r0, 17cf0 <le_adv_update+0x86>
	atomic_set_bit(adv->flags, BT_ADV_DATA_SET);
   17cdc:	3410      	adds	r4, #16
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   17cde:	e8d4 3fef 	ldaex	r3, [r4]
   17ce2:	f043 0304 	orr.w	r3, r3, #4
   17ce6:	e8c4 3fe2 	stlex	r2, r3, [r4]
   17cea:	2a00      	cmp	r2, #0
   17cec:	d1f7      	bne.n	17cde <le_adv_update+0x74>
	return 0;
   17cee:	2300      	movs	r3, #0
}
   17cf0:	4618      	mov	r0, r3
   17cf2:	b009      	add	sp, #36	; 0x24
   17cf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		const char *name = bt_get_name();
   17cf8:	f7f0 fde6 	bl	88c8 <bt_get_name>
   17cfc:	9001      	str	r0, [sp, #4]
		if ((ad && ad_has_name(ad, ad_len)) ||
   17cfe:	b166      	cbz	r6, 17d1a <le_adv_update+0xb0>
	for (i = 0; i < ad_len; i++) {
   17d00:	2200      	movs	r2, #0
   17d02:	4297      	cmp	r7, r2
   17d04:	d907      	bls.n	17d16 <le_adv_update+0xac>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   17d06:	f816 3032 	ldrb.w	r3, [r6, r2, lsl #3]
   17d0a:	3b08      	subs	r3, #8
   17d0c:	b2db      	uxtb	r3, r3
   17d0e:	2b01      	cmp	r3, #1
   17d10:	d90f      	bls.n	17d32 <le_adv_update+0xc8>
	for (i = 0; i < ad_len; i++) {
   17d12:	3201      	adds	r2, #1
   17d14:	e7f5      	b.n	17d02 <le_adv_update+0x98>
	return false;
   17d16:	2300      	movs	r3, #0
		if ((ad && ad_has_name(ad, ad_len)) ||
   17d18:	bb43      	cbnz	r3, 17d6c <le_adv_update+0x102>
   17d1a:	b175      	cbz	r5, 17d3a <le_adv_update+0xd0>
	for (i = 0; i < ad_len; i++) {
   17d1c:	2200      	movs	r2, #0
   17d1e:	4590      	cmp	r8, r2
   17d20:	d909      	bls.n	17d36 <le_adv_update+0xcc>
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   17d22:	f815 3032 	ldrb.w	r3, [r5, r2, lsl #3]
   17d26:	3b08      	subs	r3, #8
   17d28:	b2db      	uxtb	r3, r3
   17d2a:	2b01      	cmp	r3, #1
   17d2c:	d910      	bls.n	17d50 <le_adv_update+0xe6>
	for (i = 0; i < ad_len; i++) {
   17d2e:	3201      	adds	r2, #1
   17d30:	e7f5      	b.n	17d1e <le_adv_update+0xb4>
			return true;
   17d32:	2301      	movs	r3, #1
   17d34:	e7f0      	b.n	17d18 <le_adv_update+0xae>
	return false;
   17d36:	2300      	movs	r3, #0
		    (sd && ad_has_name(sd, sd_len))) {
   17d38:	b9db      	cbnz	r3, 17d72 <le_adv_update+0x108>
		data = (struct bt_data)BT_DATA(
   17d3a:	9801      	ldr	r0, [sp, #4]
   17d3c:	f7ff fcb5 	bl	176aa <strlen>
   17d40:	2309      	movs	r3, #9
   17d42:	f88d 3008 	strb.w	r3, [sp, #8]
   17d46:	f88d 0009 	strb.w	r0, [sp, #9]
   17d4a:	9b01      	ldr	r3, [sp, #4]
   17d4c:	9303      	str	r3, [sp, #12]
   17d4e:	e7a3      	b.n	17c98 <le_adv_update+0x2e>
			return true;
   17d50:	2301      	movs	r3, #1
   17d52:	e7f1      	b.n	17d38 <le_adv_update+0xce>
			d[1].data = &data;
   17d54:	ab02      	add	r3, sp, #8
   17d56:	9306      	str	r3, [sp, #24]
			d[1].len = 1;
   17d58:	2301      	movs	r3, #1
   17d5a:	9307      	str	r3, [sp, #28]
			d_len = 2;
   17d5c:	2202      	movs	r2, #2
   17d5e:	e7a7      	b.n	17cb0 <le_adv_update+0x46>
			d[1].data = &data;
   17d60:	ab02      	add	r3, sp, #8
   17d62:	9306      	str	r3, [sp, #24]
			d[1].len = 1;
   17d64:	2301      	movs	r3, #1
   17d66:	9307      	str	r3, [sp, #28]
			d_len = 2;
   17d68:	2202      	movs	r2, #2
   17d6a:	e7b1      	b.n	17cd0 <le_adv_update+0x66>
			return -EINVAL;
   17d6c:	f06f 0315 	mvn.w	r3, #21
   17d70:	e7be      	b.n	17cf0 <le_adv_update+0x86>
   17d72:	f06f 0315 	mvn.w	r3, #21
   17d76:	e7bb      	b.n	17cf0 <le_adv_update+0x86>

00017d78 <valid_adv_param>:
{
   17d78:	b508      	push	{r3, lr}
	if (param->options & BT_LE_ADV_OPT_EXT_ADV) {
   17d7a:	6843      	ldr	r3, [r0, #4]
   17d7c:	f413 6f80 	tst.w	r3, #1024	; 0x400
   17d80:	d107      	bne.n	17d92 <valid_adv_param+0x1a>
	if (param->peer && !(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   17d82:	6902      	ldr	r2, [r0, #16]
   17d84:	b112      	cbz	r2, 17d8c <valid_adv_param+0x14>
   17d86:	f013 0f01 	tst.w	r3, #1
   17d8a:	d004      	beq.n	17d96 <valid_adv_param+0x1e>
	return valid_adv_ext_param(param);
   17d8c:	f7f1 f954 	bl	9038 <valid_adv_ext_param>
}
   17d90:	bd08      	pop	{r3, pc}
		return false;
   17d92:	2000      	movs	r0, #0
   17d94:	e7fc      	b.n	17d90 <valid_adv_param+0x18>
		return false;
   17d96:	2000      	movs	r0, #0
   17d98:	e7fa      	b.n	17d90 <valid_adv_param+0x18>

00017d9a <get_adv_name_type_param>:
	if (param->options & BT_LE_ADV_OPT_USE_NAME) {
   17d9a:	6843      	ldr	r3, [r0, #4]
   17d9c:	f013 0f08 	tst.w	r3, #8
   17da0:	d00b      	beq.n	17dba <get_adv_name_type_param+0x20>
		if (param->options & BT_LE_ADV_OPT_FORCE_NAME_IN_AD) {
   17da2:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   17da6:	d10a      	bne.n	17dbe <get_adv_name_type_param+0x24>
		if ((param->options & BT_LE_ADV_OPT_EXT_ADV) &&
   17da8:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
   17dac:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   17db0:	d001      	beq.n	17db6 <get_adv_name_type_param+0x1c>
		return ADV_NAME_TYPE_SD;
   17db2:	2002      	movs	r0, #2
}
   17db4:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
   17db6:	2001      	movs	r0, #1
   17db8:	4770      	bx	lr
	return ADV_NAME_TYPE_NONE;
   17dba:	2000      	movs	r0, #0
   17dbc:	4770      	bx	lr
			return ADV_NAME_TYPE_AD;
   17dbe:	2001      	movs	r0, #1
   17dc0:	4770      	bx	lr

00017dc2 <bt_le_adv_set_enable_legacy>:
{
   17dc2:	b570      	push	{r4, r5, r6, lr}
   17dc4:	b086      	sub	sp, #24
   17dc6:	4605      	mov	r5, r0
   17dc8:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
   17dca:	2101      	movs	r1, #1
   17dcc:	f242 000a 	movw	r0, #8202	; 0x200a
   17dd0:	f7ef f856 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   17dd4:	b1d0      	cbz	r0, 17e0c <bt_le_adv_set_enable_legacy+0x4a>
   17dd6:	4606      	mov	r6, r0
	if (enable) {
   17dd8:	b19c      	cbz	r4, 17e02 <bt_le_adv_set_enable_legacy+0x40>
	return net_buf_simple_add_u8(&buf->b, val);
   17dda:	2101      	movs	r1, #1
   17ddc:	3008      	adds	r0, #8
   17dde:	f002 fa1f 	bl	1a220 <net_buf_simple_add_u8>
	bt_hci_cmd_state_set_init(buf, &state, adv->flags, BT_ADV_ENABLED, enable);
   17de2:	9400      	str	r4, [sp, #0]
   17de4:	2306      	movs	r3, #6
   17de6:	f105 0210 	add.w	r2, r5, #16
   17dea:	a903      	add	r1, sp, #12
   17dec:	4630      	mov	r0, r6
   17dee:	f7ef f835 	bl	6e5c <bt_hci_cmd_state_set_init>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
   17df2:	2200      	movs	r2, #0
   17df4:	4631      	mov	r1, r6
   17df6:	f242 000a 	movw	r0, #8202	; 0x200a
   17dfa:	f7ef f87f 	bl	6efc <bt_hci_cmd_send_sync>
}
   17dfe:	b006      	add	sp, #24
   17e00:	bd70      	pop	{r4, r5, r6, pc}
   17e02:	2100      	movs	r1, #0
   17e04:	3008      	adds	r0, #8
   17e06:	f002 fa0b 	bl	1a220 <net_buf_simple_add_u8>
   17e0a:	e7ea      	b.n	17de2 <bt_le_adv_set_enable_legacy+0x20>
		return -ENOBUFS;
   17e0c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   17e10:	e7f5      	b.n	17dfe <bt_le_adv_set_enable_legacy+0x3c>

00017e12 <bt_le_adv_set_enable>:
{
   17e12:	b508      	push	{r3, lr}
	return bt_le_adv_set_enable_legacy(adv, enable);
   17e14:	f7ff ffd5 	bl	17dc2 <bt_le_adv_set_enable_legacy>
}
   17e18:	bd08      	pop	{r3, pc}

00017e1a <bt_le_lim_adv_cancel_timeout>:
{
   17e1a:	b508      	push	{r3, lr}
	return k_work_cancel_delayable(&adv->lim_adv_timeout_work);
   17e1c:	3018      	adds	r0, #24
   17e1e:	f004 fb09 	bl	1c434 <k_work_cancel_delayable>
}
   17e22:	bd08      	pop	{r3, pc}

00017e24 <bt_le_adv_resume>:
{
   17e24:	b570      	push	{r4, r5, r6, lr}
   17e26:	b082      	sub	sp, #8
	struct bt_le_ext_adv *adv = bt_le_adv_lookup_legacy();
   17e28:	f7f1 f9d2 	bl	91d0 <bt_le_adv_lookup_legacy>
	if (!adv) {
   17e2c:	b138      	cbz	r0, 17e3e <bt_le_adv_resume+0x1a>
   17e2e:	4605      	mov	r5, r0
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   17e30:	f100 0410 	add.w	r4, r0, #16
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   17e34:	e8d4 3faf 	lda	r3, [r4]
   17e38:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   17e3c:	d101      	bne.n	17e42 <bt_le_adv_resume+0x1e>
}
   17e3e:	b002      	add	sp, #8
   17e40:	bd70      	pop	{r4, r5, r6, pc}
   17e42:	e8d4 3faf 	lda	r3, [r4]
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   17e46:	f3c3 1680 	ubfx	r6, r3, #6, #1
	if (!(atomic_test_bit(adv->flags, BT_ADV_PERSIST) &&
   17e4a:	f013 0f40 	tst.w	r3, #64	; 0x40
   17e4e:	d1f6      	bne.n	17e3e <bt_le_adv_resume+0x1a>
   17e50:	e8d4 3faf 	lda	r3, [r4]
	if (!atomic_test_bit(adv->flags, BT_ADV_CONNECTABLE)) {
   17e54:	f413 7f00 	tst.w	r3, #512	; 0x200
   17e58:	d0f1      	beq.n	17e3e <bt_le_adv_resume+0x1a>
	err = le_adv_start_add_conn(adv, &conn);
   17e5a:	a901      	add	r1, sp, #4
   17e5c:	f7f1 f93a 	bl	90d4 <le_adv_start_add_conn>
	if (err) {
   17e60:	2800      	cmp	r0, #0
   17e62:	d1ec      	bne.n	17e3e <bt_le_adv_resume+0x1a>
	err = bt_le_adv_set_enable(adv, true);
   17e64:	2101      	movs	r1, #1
   17e66:	4628      	mov	r0, r5
   17e68:	f7ff ffd3 	bl	17e12 <bt_le_adv_set_enable>
	if (err) {
   17e6c:	b168      	cbz	r0, 17e8a <bt_le_adv_resume+0x66>
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   17e6e:	2100      	movs	r1, #0
   17e70:	9801      	ldr	r0, [sp, #4]
   17e72:	f7f2 f89d 	bl	9fb0 <bt_conn_set_state>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   17e76:	e8d4 6fef 	ldaex	r6, [r4]
   17e7a:	f426 5300 	bic.w	r3, r6, #8192	; 0x2000
   17e7e:	e8c4 3fe2 	stlex	r2, r3, [r4]
   17e82:	2a00      	cmp	r2, #0
   17e84:	d1f7      	bne.n	17e76 <bt_le_adv_resume+0x52>
	return (old & mask) != 0;
   17e86:	f3c6 3640 	ubfx	r6, r6, #13, #1
	bt_conn_unref(conn);
   17e8a:	9801      	ldr	r0, [sp, #4]
   17e8c:	f000 f926 	bl	180dc <bt_conn_unref>
	if (persist_paused) {
   17e90:	2e00      	cmp	r6, #0
   17e92:	d0d4      	beq.n	17e3e <bt_le_adv_resume+0x1a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   17e94:	e8d4 3fef 	ldaex	r3, [r4]
   17e98:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   17e9c:	e8c4 3fe2 	stlex	r2, r3, [r4]
   17ea0:	2a00      	cmp	r2, #0
   17ea2:	d0cc      	beq.n	17e3e <bt_le_adv_resume+0x1a>
   17ea4:	e7f6      	b.n	17e94 <bt_le_adv_resume+0x70>

00017ea6 <tx_notify>:
{
   17ea6:	b570      	push	{r4, r5, r6, lr}
   17ea8:	4604      	mov	r4, r0
	BT_DBG("conn %p", conn);
   17eaa:	e00c      	b.n	17ec6 <tx_notify+0x20>
   17eac:	f383 8811 	msr	BASEPRI, r3
   17eb0:	f3bf 8f6f 	isb	sy
		if (!tx) {
   17eb4:	b1c8      	cbz	r0, 17eea <tx_notify+0x44>
		cb = tx->cb;
   17eb6:	6845      	ldr	r5, [r0, #4]
		user_data = tx->user_data;
   17eb8:	6886      	ldr	r6, [r0, #8]
		tx_free(tx);
   17eba:	f7f1 fd1b 	bl	98f4 <tx_free>
		cb(conn, user_data, 0);
   17ebe:	2200      	movs	r2, #0
   17ec0:	4631      	mov	r1, r6
   17ec2:	4620      	mov	r0, r4
   17ec4:	47a8      	blx	r5
	__asm__ volatile(
   17ec6:	f04f 0220 	mov.w	r2, #32
   17eca:	f3ef 8311 	mrs	r3, BASEPRI
   17ece:	f382 8812 	msr	BASEPRI_MAX, r2
   17ed2:	f3bf 8f6f 	isb	sy
	return list->head;
   17ed6:	6a20      	ldr	r0, [r4, #32]
		if (!sys_slist_is_empty(&conn->tx_complete)) {
   17ed8:	2800      	cmp	r0, #0
   17eda:	d0e7      	beq.n	17eac <tx_notify+0x6>
	return node->next;
   17edc:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   17ede:	6222      	str	r2, [r4, #32]
	return list->tail;
   17ee0:	6a61      	ldr	r1, [r4, #36]	; 0x24
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   17ee2:	4281      	cmp	r1, r0
   17ee4:	d1e2      	bne.n	17eac <tx_notify+0x6>
	list->tail = node;
   17ee6:	6262      	str	r2, [r4, #36]	; 0x24
}
   17ee8:	e7e0      	b.n	17eac <tx_notify+0x6>
}
   17eea:	bd70      	pop	{r4, r5, r6, pc}

00017eec <tx_complete_work>:
{
   17eec:	b508      	push	{r3, lr}
	tx_notify(conn);
   17eee:	3828      	subs	r0, #40	; 0x28
   17ef0:	f7ff ffd9 	bl	17ea6 <tx_notify>
}
   17ef4:	bd08      	pop	{r3, pc}

00017ef6 <conn_tx_destroy>:
{
   17ef6:	b570      	push	{r4, r5, r6, lr}
   17ef8:	4604      	mov	r4, r0
   17efa:	4608      	mov	r0, r1
	bt_conn_tx_cb_t cb = tx->cb;
   17efc:	684d      	ldr	r5, [r1, #4]
	void *user_data = tx->user_data;
   17efe:	688e      	ldr	r6, [r1, #8]
	tx_free(tx);
   17f00:	f7f1 fcf8 	bl	98f4 <tx_free>
	cb(conn, user_data, -ESHUTDOWN);
   17f04:	f06f 026d 	mvn.w	r2, #109	; 0x6d
   17f08:	4631      	mov	r1, r6
   17f0a:	4620      	mov	r0, r4
   17f0c:	47a8      	blx	r5
}
   17f0e:	bd70      	pop	{r4, r5, r6, pc}

00017f10 <send_acl>:
{
   17f10:	b570      	push	{r4, r5, r6, lr}
   17f12:	4605      	mov	r5, r0
   17f14:	460c      	mov	r4, r1
	switch (flags) {
   17f16:	2a03      	cmp	r2, #3
   17f18:	d819      	bhi.n	17f4e <send_acl+0x3e>
   17f1a:	e8df f002 	tbb	[pc, r2]
   17f1e:	1602      	.short	0x1602
   17f20:	1602      	.short	0x1602
   17f22:	2600      	movs	r6, #0
	return net_buf_simple_push(&buf->b, len);
   17f24:	2104      	movs	r1, #4
   17f26:	f104 0008 	add.w	r0, r4, #8
   17f2a:	f002 f989 	bl	1a240 <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   17f2e:	f9b5 3000 	ldrsh.w	r3, [r5]
   17f32:	ea43 3306 	orr.w	r3, r3, r6, lsl #12
   17f36:	8003      	strh	r3, [r0, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   17f38:	89a3      	ldrh	r3, [r4, #12]
   17f3a:	3b04      	subs	r3, #4
   17f3c:	8043      	strh	r3, [r0, #2]
	((struct bt_buf_data *)net_buf_user_data(buf))->type = type;
   17f3e:	2302      	movs	r3, #2
   17f40:	7523      	strb	r3, [r4, #20]
	return bt_send(buf);
   17f42:	4620      	mov	r0, r4
   17f44:	f7ef ff7a 	bl	7e3c <bt_send>
}
   17f48:	bd70      	pop	{r4, r5, r6, pc}
		flags = BT_ACL_CONT;
   17f4a:	2601      	movs	r6, #1
   17f4c:	e7ea      	b.n	17f24 <send_acl+0x14>
	switch (flags) {
   17f4e:	f06f 0015 	mvn.w	r0, #21
   17f52:	e7f9      	b.n	17f48 <send_acl+0x38>

00017f54 <process_unack_tx>:
{
   17f54:	b510      	push	{r4, lr}
   17f56:	4604      	mov	r4, r0
   17f58:	e028      	b.n	17fac <process_unack_tx+0x58>
			conn->pending_no_cb--;
   17f5a:	3b01      	subs	r3, #1
   17f5c:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
   17f5e:	f382 8811 	msr	BASEPRI, r2
   17f62:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
   17f66:	4620      	mov	r0, r4
   17f68:	f7f1 fce8 	bl	993c <bt_conn_get_pkts>
	z_impl_k_sem_give(sem);
   17f6c:	f7fb fe10 	bl	13b90 <z_impl_k_sem_give>
			continue;
   17f70:	e01c      	b.n	17fac <process_unack_tx+0x58>
   17f72:	f382 8811 	msr	BASEPRI, r2
   17f76:	f3bf 8f6f 	isb	sy
		if (!node) {
   17f7a:	b361      	cbz	r1, 17fd6 <process_unack_tx+0x82>
	__asm__ volatile(
   17f7c:	f04f 0220 	mov.w	r2, #32
   17f80:	f3ef 8311 	mrs	r3, BASEPRI
   17f84:	f382 8812 	msr	BASEPRI_MAX, r2
   17f88:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
   17f8c:	68ca      	ldr	r2, [r1, #12]
   17f8e:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
   17f90:	2200      	movs	r2, #0
   17f92:	60ca      	str	r2, [r1, #12]
	__asm__ volatile(
   17f94:	f383 8811 	msr	BASEPRI, r3
   17f98:	f3bf 8f6f 	isb	sy
		conn_tx_destroy(conn, tx);
   17f9c:	4620      	mov	r0, r4
   17f9e:	f7ff ffaa 	bl	17ef6 <conn_tx_destroy>
		k_sem_give(bt_conn_get_pkts(conn));
   17fa2:	4620      	mov	r0, r4
   17fa4:	f7f1 fcca 	bl	993c <bt_conn_get_pkts>
   17fa8:	f7fb fdf2 	bl	13b90 <z_impl_k_sem_give>
	__asm__ volatile(
   17fac:	f04f 0320 	mov.w	r3, #32
   17fb0:	f3ef 8211 	mrs	r2, BASEPRI
   17fb4:	f383 8812 	msr	BASEPRI_MAX, r3
   17fb8:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
   17fbc:	69e3      	ldr	r3, [r4, #28]
   17fbe:	2b00      	cmp	r3, #0
   17fc0:	d1cb      	bne.n	17f5a <process_unack_tx+0x6>
	return list->head;
   17fc2:	6961      	ldr	r1, [r4, #20]
Z_GENLIST_GET(slist, snode)
   17fc4:	2900      	cmp	r1, #0
   17fc6:	d0d4      	beq.n	17f72 <process_unack_tx+0x1e>
	return node->next;
   17fc8:	680b      	ldr	r3, [r1, #0]
	list->head = node;
   17fca:	6163      	str	r3, [r4, #20]
	return list->tail;
   17fcc:	69a0      	ldr	r0, [r4, #24]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   17fce:	4281      	cmp	r1, r0
   17fd0:	d1cf      	bne.n	17f72 <process_unack_tx+0x1e>
	list->tail = node;
   17fd2:	61a3      	str	r3, [r4, #24]
}
   17fd4:	e7cd      	b.n	17f72 <process_unack_tx+0x1e>
}
   17fd6:	bd10      	pop	{r4, pc}

00017fd8 <bt_conn_reset_rx_state>:
{
   17fd8:	b510      	push	{r4, lr}
   17fda:	4604      	mov	r4, r0
	if (!conn->rx) {
   17fdc:	6900      	ldr	r0, [r0, #16]
   17fde:	b118      	cbz	r0, 17fe8 <bt_conn_reset_rx_state+0x10>
	net_buf_unref(conn->rx);
   17fe0:	f002 f8c3 	bl	1a16a <net_buf_unref>
	conn->rx = NULL;
   17fe4:	2300      	movs	r3, #0
   17fe6:	6123      	str	r3, [r4, #16]
}
   17fe8:	bd10      	pop	{r4, pc}

00017fea <conn_cleanup>:
{
   17fea:	b538      	push	{r3, r4, r5, lr}
   17fec:	4605      	mov	r5, r0
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
   17fee:	2200      	movs	r2, #0
   17ff0:	2300      	movs	r3, #0
   17ff2:	f105 0038 	add.w	r0, r5, #56	; 0x38
   17ff6:	f002 f82c 	bl	1a052 <net_buf_get>
   17ffa:	4603      	mov	r3, r0
   17ffc:	b160      	cbz	r0, 18018 <conn_cleanup+0x2e>
		struct bt_conn_tx *tx = tx_data(buf)->tx;
   17ffe:	695c      	ldr	r4, [r3, #20]
		tx_data(buf)->tx = NULL;
   18000:	2200      	movs	r2, #0
   18002:	615a      	str	r2, [r3, #20]
		net_buf_unref(buf);
   18004:	4618      	mov	r0, r3
   18006:	f002 f8b0 	bl	1a16a <net_buf_unref>
		if (tx) {
   1800a:	2c00      	cmp	r4, #0
   1800c:	d0ef      	beq.n	17fee <conn_cleanup+0x4>
			conn_tx_destroy(conn, tx);
   1800e:	4621      	mov	r1, r4
   18010:	4628      	mov	r0, r5
   18012:	f7ff ff70 	bl	17ef6 <conn_tx_destroy>
   18016:	e7ea      	b.n	17fee <conn_cleanup+0x4>
	bt_conn_reset_rx_state(conn);
   18018:	4628      	mov	r0, r5
   1801a:	f7ff ffdd 	bl	17fd8 <bt_conn_reset_rx_state>
	k_work_reschedule(&conn->deferred_work, K_NO_WAIT);
   1801e:	2200      	movs	r2, #0
   18020:	2300      	movs	r3, #0
   18022:	f105 0058 	add.w	r0, r5, #88	; 0x58
   18026:	f7fb ffc9 	bl	13fbc <k_work_reschedule>
}
   1802a:	bd38      	pop	{r3, r4, r5, pc}

0001802c <conn_prepare_events>:
	if (!atomic_get(&conn->ref)) {
   1802c:	f100 03b8 	add.w	r3, r0, #184	; 0xb8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   18030:	e8d3 3faf 	lda	r3, [r3]
   18034:	b31b      	cbz	r3, 1807e <conn_prepare_events+0x52>
{
   18036:	b510      	push	{r4, lr}
   18038:	460c      	mov	r4, r1
	if (conn->state == BT_CONN_DISCONNECTED &&
   1803a:	7a83      	ldrb	r3, [r0, #10]
   1803c:	b963      	cbnz	r3, 18058 <conn_prepare_events+0x2c>
	    atomic_test_and_clear_bit(conn->flags, BT_CONN_CLEANUP)) {
   1803e:	1d03      	adds	r3, r0, #4
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   18040:	e8d3 2fef 	ldaex	r2, [r3]
   18044:	f022 0140 	bic.w	r1, r2, #64	; 0x40
   18048:	e8c3 1fec 	stlex	ip, r1, [r3]
   1804c:	f1bc 0f00 	cmp.w	ip, #0
   18050:	d1f6      	bne.n	18040 <conn_prepare_events+0x14>
	if (conn->state == BT_CONN_DISCONNECTED &&
   18052:	f012 0f40 	tst.w	r2, #64	; 0x40
   18056:	d10d      	bne.n	18074 <conn_prepare_events+0x48>
	if (conn->state != BT_CONN_CONNECTED) {
   18058:	7a83      	ldrb	r3, [r0, #10]
   1805a:	2b07      	cmp	r3, #7
   1805c:	d112      	bne.n	18084 <conn_prepare_events+0x58>
	k_poll_event_init(&events[0],
   1805e:	f100 0338 	add.w	r3, r0, #56	; 0x38
   18062:	2200      	movs	r2, #0
   18064:	2104      	movs	r1, #4
   18066:	4620      	mov	r0, r4
   18068:	f004 fd19 	bl	1ca9e <k_poll_event_init>
	events[0].tag = BT_EVENT_CONN_TX_QUEUE;
   1806c:	2301      	movs	r3, #1
   1806e:	7323      	strb	r3, [r4, #12]
	return 0;
   18070:	2000      	movs	r0, #0
}
   18072:	bd10      	pop	{r4, pc}
		conn_cleanup(conn);
   18074:	f7ff ffb9 	bl	17fea <conn_cleanup>
		return -ENOTCONN;
   18078:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1807c:	e7f9      	b.n	18072 <conn_prepare_events+0x46>
		return -ENOTCONN;
   1807e:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   18082:	4770      	bx	lr
		return -ENOTCONN;
   18084:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   18088:	e7f3      	b.n	18072 <conn_prepare_events+0x46>

0001808a <bt_conn_recv>:
{
   1808a:	b570      	push	{r4, r5, r6, lr}
   1808c:	4604      	mov	r4, r0
   1808e:	460d      	mov	r5, r1
   18090:	4616      	mov	r6, r2
	tx_notify(conn);
   18092:	f7ff ff08 	bl	17ea6 <tx_notify>
		bt_acl_recv(conn, buf, flags);
   18096:	4632      	mov	r2, r6
   18098:	4629      	mov	r1, r5
   1809a:	4620      	mov	r0, r4
   1809c:	f7f1 fd60 	bl	9b60 <bt_acl_recv>
}
   180a0:	bd70      	pop	{r4, r5, r6, pc}

000180a2 <bt_conn_ref>:
		old = atomic_get(&conn->ref);
   180a2:	f100 03b8 	add.w	r3, r0, #184	; 0xb8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   180a6:	e8d3 2faf 	lda	r2, [r3]
		if (!old) {
   180aa:	b1aa      	cbz	r2, 180d8 <bt_conn_ref+0x36>
{
   180ac:	b500      	push	{lr}
   180ae:	e004      	b.n	180ba <bt_conn_ref+0x18>
		old = atomic_get(&conn->ref);
   180b0:	f100 03b8 	add.w	r3, r0, #184	; 0xb8
   180b4:	e8d3 2faf 	lda	r2, [r3]
		if (!old) {
   180b8:	b162      	cbz	r2, 180d4 <bt_conn_ref+0x32>
	} while (!atomic_cas(&conn->ref, old, old + 1));
   180ba:	1c51      	adds	r1, r2, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   180bc:	e8d3 cfef 	ldaex	ip, [r3]
   180c0:	4594      	cmp	ip, r2
   180c2:	d104      	bne.n	180ce <bt_conn_ref+0x2c>
   180c4:	e8c3 1fee 	stlex	lr, r1, [r3]
   180c8:	f1be 0f00 	cmp.w	lr, #0
   180cc:	d1f6      	bne.n	180bc <bt_conn_ref+0x1a>
   180ce:	d1ef      	bne.n	180b0 <bt_conn_ref+0xe>
}
   180d0:	f85d fb04 	ldr.w	pc, [sp], #4
			return NULL;
   180d4:	2000      	movs	r0, #0
   180d6:	e7fb      	b.n	180d0 <bt_conn_ref+0x2e>
   180d8:	2000      	movs	r0, #0
}
   180da:	4770      	bx	lr

000180dc <bt_conn_unref>:
{
   180dc:	b508      	push	{r3, lr}
	old = atomic_dec(&conn->ref);
   180de:	f100 03b8 	add.w	r3, r0, #184	; 0xb8
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   180e2:	e8d3 2fef 	ldaex	r2, [r3]
   180e6:	3a01      	subs	r2, #1
   180e8:	e8c3 2fe1 	stlex	r1, r2, [r3]
   180ec:	2900      	cmp	r1, #0
   180ee:	d1f8      	bne.n	180e2 <bt_conn_unref+0x6>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   180f0:	7882      	ldrb	r2, [r0, #2]
   180f2:	2a01      	cmp	r2, #1
   180f4:	d000      	beq.n	180f8 <bt_conn_unref+0x1c>
}
   180f6:	bd08      	pop	{r3, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   180f8:	e8d3 3faf 	lda	r3, [r3]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) && conn->type == BT_CONN_TYPE_LE &&
   180fc:	2b00      	cmp	r3, #0
   180fe:	d1fa      	bne.n	180f6 <bt_conn_unref+0x1a>
		bt_le_adv_resume();
   18100:	f7ff fe90 	bl	17e24 <bt_le_adv_resume>
}
   18104:	e7f7      	b.n	180f6 <bt_conn_unref+0x1a>

00018106 <conn_lookup_handle>:
{
   18106:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18108:	4606      	mov	r6, r0
   1810a:	460d      	mov	r5, r1
   1810c:	4617      	mov	r7, r2
	for (i = 0; i < size; i++) {
   1810e:	2400      	movs	r4, #0
   18110:	e003      	b.n	1811a <conn_lookup_handle+0x14>
			bt_conn_unref(conn);
   18112:	4660      	mov	r0, ip
   18114:	f7ff ffe2 	bl	180dc <bt_conn_unref>
	for (i = 0; i < size; i++) {
   18118:	3401      	adds	r4, #1
   1811a:	42ac      	cmp	r4, r5
   1811c:	d21c      	bcs.n	18158 <conn_lookup_handle+0x52>
		struct bt_conn *conn = bt_conn_ref(&conns[i]);
   1811e:	eb04 0044 	add.w	r0, r4, r4, lsl #1
   18122:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   18126:	f7ff ffbc 	bl	180a2 <bt_conn_ref>
		if (!conn) {
   1812a:	4684      	mov	ip, r0
   1812c:	2800      	cmp	r0, #0
   1812e:	d0f3      	beq.n	18118 <conn_lookup_handle+0x12>
/* Look up an existing connection */
struct bt_conn *bt_conn_lookup_handle(uint16_t handle);

static inline bool bt_conn_is_handle_valid(struct bt_conn *conn)
{
	switch (conn->state) {
   18130:	7a83      	ldrb	r3, [r0, #10]
   18132:	2b01      	cmp	r3, #1
   18134:	d006      	beq.n	18144 <conn_lookup_handle+0x3e>
   18136:	b25a      	sxtb	r2, r3
   18138:	2a00      	cmp	r2, #0
   1813a:	d0ea      	beq.n	18112 <conn_lookup_handle+0xc>
   1813c:	3b07      	subs	r3, #7
   1813e:	b2db      	uxtb	r3, r3
   18140:	2b01      	cmp	r3, #1
   18142:	d8e6      	bhi.n	18112 <conn_lookup_handle+0xc>
		if (conn->handle != handle) {
   18144:	f8bc 3000 	ldrh.w	r3, [ip]
   18148:	42bb      	cmp	r3, r7
   1814a:	d101      	bne.n	18150 <conn_lookup_handle+0x4a>
}
   1814c:	4660      	mov	r0, ip
   1814e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			bt_conn_unref(conn);
   18150:	4660      	mov	r0, ip
   18152:	f7ff ffc3 	bl	180dc <bt_conn_unref>
			continue;
   18156:	e7df      	b.n	18118 <conn_lookup_handle+0x12>
	return NULL;
   18158:	f04f 0c00 	mov.w	ip, #0
   1815c:	e7f6      	b.n	1814c <conn_lookup_handle+0x46>

0001815e <bt_conn_connected>:
{
   1815e:	b510      	push	{r4, lr}
   18160:	4604      	mov	r4, r0
	bt_l2cap_connected(conn);
   18162:	f7f2 fcc9 	bl	aaf8 <bt_l2cap_connected>
	notify_connected(conn);
   18166:	4620      	mov	r0, r4
   18168:	f7f1 fb80 	bl	986c <notify_connected>
}
   1816c:	bd10      	pop	{r4, pc}

0001816e <bt_conn_get_security>:
}
   1816e:	2001      	movs	r0, #1
   18170:	4770      	bx	lr

00018172 <bt_conn_add_le>:
{
   18172:	b570      	push	{r4, r5, r6, lr}
   18174:	4606      	mov	r6, r0
   18176:	460d      	mov	r5, r1
	struct bt_conn *conn = acl_conn_new();
   18178:	f7f1 fcea 	bl	9b50 <acl_conn_new>
	if (!conn) {
   1817c:	4604      	mov	r4, r0
   1817e:	b168      	cbz	r0, 1819c <bt_conn_add_le+0x2a>
	conn->id = id;
   18180:	7206      	strb	r6, [r0, #8]
	memcpy(dst, src, sizeof(*dst));
   18182:	2207      	movs	r2, #7
   18184:	4629      	mov	r1, r5
   18186:	3088      	adds	r0, #136	; 0x88
   18188:	f7ff fad2 	bl	17730 <memcpy>
	conn->type = BT_CONN_TYPE_LE;
   1818c:	2301      	movs	r3, #1
   1818e:	70a3      	strb	r3, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
   18190:	2318      	movs	r3, #24
   18192:	f8a4 30a0 	strh.w	r3, [r4, #160]	; 0xa0
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;
   18196:	2328      	movs	r3, #40	; 0x28
   18198:	f8a4 30a2 	strh.w	r3, [r4, #162]	; 0xa2
}
   1819c:	4620      	mov	r0, r4
   1819e:	bd70      	pop	{r4, r5, r6, pc}

000181a0 <bt_conn_is_peer_addr_le>:
{
   181a0:	b538      	push	{r3, r4, r5, lr}
	if (id != conn->id) {
   181a2:	7a03      	ldrb	r3, [r0, #8]
   181a4:	428b      	cmp	r3, r1
   181a6:	d001      	beq.n	181ac <bt_conn_is_peer_addr_le+0xc>
		return false;
   181a8:	2000      	movs	r0, #0
}
   181aa:	bd38      	pop	{r3, r4, r5, pc}
   181ac:	4604      	mov	r4, r0
   181ae:	4615      	mov	r5, r2
	return memcmp(a, b, sizeof(*a));
   181b0:	2207      	movs	r2, #7
   181b2:	f100 0188 	add.w	r1, r0, #136	; 0x88
   181b6:	4628      	mov	r0, r5
   181b8:	f7ff faa8 	bl	1770c <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   181bc:	b1a8      	cbz	r0, 181ea <bt_conn_is_peer_addr_le+0x4a>
	if (conn->role == BT_HCI_ROLE_CENTRAL) {
   181be:	78e3      	ldrb	r3, [r4, #3]
   181c0:	b14b      	cbz	r3, 181d6 <bt_conn_is_peer_addr_le+0x36>
   181c2:	2207      	movs	r2, #7
   181c4:	f104 018f 	add.w	r1, r4, #143	; 0x8f
   181c8:	4628      	mov	r0, r5
   181ca:	f7ff fa9f 	bl	1770c <memcmp>
	return bt_addr_le_cmp(peer, &conn->le.init_addr) == 0;
   181ce:	fab0 f080 	clz	r0, r0
   181d2:	0940      	lsrs	r0, r0, #5
   181d4:	e7e9      	b.n	181aa <bt_conn_is_peer_addr_le+0xa>
   181d6:	2207      	movs	r2, #7
   181d8:	f104 0196 	add.w	r1, r4, #150	; 0x96
   181dc:	4628      	mov	r0, r5
   181de:	f7ff fa95 	bl	1770c <memcmp>
		return bt_addr_le_cmp(peer, &conn->le.resp_addr) == 0;
   181e2:	fab0 f080 	clz	r0, r0
   181e6:	0940      	lsrs	r0, r0, #5
   181e8:	e7df      	b.n	181aa <bt_conn_is_peer_addr_le+0xa>
		return true;
   181ea:	2001      	movs	r0, #1
   181ec:	e7dd      	b.n	181aa <bt_conn_is_peer_addr_le+0xa>

000181ee <bt_conn_le_conn_update>:
{
   181ee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   181f0:	4606      	mov	r6, r0
   181f2:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   181f4:	210e      	movs	r1, #14
   181f6:	f242 0013 	movw	r0, #8211	; 0x2013
   181fa:	f7ee fe41 	bl	6e80 <bt_hci_cmd_create>
	if (!buf) {
   181fe:	b1d0      	cbz	r0, 18236 <bt_conn_le_conn_update+0x48>
   18200:	4607      	mov	r7, r0
	return net_buf_simple_add(&buf->b, len);
   18202:	210e      	movs	r1, #14
   18204:	3008      	adds	r0, #8
   18206:	f001 fffa 	bl	1a1fe <net_buf_simple_add>
   1820a:	4604      	mov	r4, r0
	(void)memset(conn_update, 0, sizeof(*conn_update));
   1820c:	220e      	movs	r2, #14
   1820e:	2100      	movs	r1, #0
   18210:	f7ff fabd 	bl	1778e <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   18214:	8833      	ldrh	r3, [r6, #0]
   18216:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   18218:	882b      	ldrh	r3, [r5, #0]
   1821a:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   1821c:	886b      	ldrh	r3, [r5, #2]
   1821e:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   18220:	88ab      	ldrh	r3, [r5, #4]
   18222:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   18224:	88eb      	ldrh	r3, [r5, #6]
   18226:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   18228:	2200      	movs	r2, #0
   1822a:	4639      	mov	r1, r7
   1822c:	f242 0013 	movw	r0, #8211	; 0x2013
   18230:	f7ee fe64 	bl	6efc <bt_hci_cmd_send_sync>
}
   18234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   18236:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1823a:	e7fb      	b.n	18234 <bt_conn_le_conn_update+0x46>

0001823c <l2cap_connected>:
}
   1823c:	4770      	bx	lr

0001823e <l2cap_disconnected>:
}
   1823e:	4770      	bx	lr

00018240 <l2cap_chan_recv>:
{
   18240:	b510      	push	{r4, lr}
   18242:	460c      	mov	r4, r1
	chan->ops->recv(chan, buf);
   18244:	6843      	ldr	r3, [r0, #4]
   18246:	691b      	ldr	r3, [r3, #16]
   18248:	4798      	blx	r3
	net_buf_unref(buf);
   1824a:	4620      	mov	r0, r4
   1824c:	f001 ff8d 	bl	1a16a <net_buf_unref>
}
   18250:	bd10      	pop	{r4, pc}

00018252 <bt_l2cap_chan_del>:
{
   18252:	b538      	push	{r3, r4, r5, lr}
   18254:	4604      	mov	r4, r0
	const struct bt_l2cap_chan_ops *ops = chan->ops;
   18256:	6845      	ldr	r5, [r0, #4]
	if (!chan->conn) {
   18258:	6803      	ldr	r3, [r0, #0]
   1825a:	b123      	cbz	r3, 18266 <bt_l2cap_chan_del+0x14>
	if (ops->disconnected) {
   1825c:	686b      	ldr	r3, [r5, #4]
   1825e:	b103      	cbz	r3, 18262 <bt_l2cap_chan_del+0x10>
		ops->disconnected(chan);
   18260:	4798      	blx	r3
	chan->conn = NULL;
   18262:	2300      	movs	r3, #0
   18264:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   18266:	68e3      	ldr	r3, [r4, #12]
   18268:	b10b      	cbz	r3, 1826e <bt_l2cap_chan_del+0x1c>
		chan->destroy(chan);
   1826a:	4620      	mov	r0, r4
   1826c:	4798      	blx	r3
	if (ops->released) {
   1826e:	69eb      	ldr	r3, [r5, #28]
   18270:	b10b      	cbz	r3, 18276 <bt_l2cap_chan_del+0x24>
		ops->released(chan);
   18272:	4620      	mov	r0, r4
   18274:	4798      	blx	r3
}
   18276:	bd38      	pop	{r3, r4, r5, pc}

00018278 <bt_l2cap_chan_add>:
{
   18278:	b410      	push	{r4}
	sys_slist_append(&conn->channels, &chan->node);
   1827a:	f101 0308 	add.w	r3, r1, #8
	parent->next = child;
   1827e:	2400      	movs	r4, #0
   18280:	608c      	str	r4, [r1, #8]
	return list->tail;
   18282:	6d44      	ldr	r4, [r0, #84]	; 0x54
Z_GENLIST_APPEND(slist, snode)
   18284:	b12c      	cbz	r4, 18292 <bt_l2cap_chan_add+0x1a>
	parent->next = child;
   18286:	6023      	str	r3, [r4, #0]
	list->tail = node;
   18288:	6543      	str	r3, [r0, #84]	; 0x54
	chan->conn = conn;
   1828a:	6008      	str	r0, [r1, #0]
	chan->destroy = destroy;
   1828c:	60ca      	str	r2, [r1, #12]
}
   1828e:	bc10      	pop	{r4}
   18290:	4770      	bx	lr
   18292:	6543      	str	r3, [r0, #84]	; 0x54
	list->head = node;
   18294:	6503      	str	r3, [r0, #80]	; 0x50
}
   18296:	e7f8      	b.n	1828a <bt_l2cap_chan_add+0x12>

00018298 <bt_l2cap_disconnected>:
{
   18298:	b510      	push	{r4, lr}
	return list->head;
   1829a:	6d00      	ldr	r0, [r0, #80]	; 0x50
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   1829c:	b140      	cbz	r0, 182b0 <bt_l2cap_disconnected+0x18>
   1829e:	3808      	subs	r0, #8
   182a0:	d008      	beq.n	182b4 <bt_l2cap_disconnected+0x1c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   182a2:	f110 0408 	adds.w	r4, r0, #8
   182a6:	d00a      	beq.n	182be <bt_l2cap_disconnected+0x26>
	return node->next;
   182a8:	6884      	ldr	r4, [r0, #8]
   182aa:	b144      	cbz	r4, 182be <bt_l2cap_disconnected+0x26>
   182ac:	3c08      	subs	r4, #8
   182ae:	e006      	b.n	182be <bt_l2cap_disconnected+0x26>
   182b0:	4604      	mov	r4, r0
   182b2:	e004      	b.n	182be <bt_l2cap_disconnected+0x26>
   182b4:	4604      	mov	r4, r0
   182b6:	e002      	b.n	182be <bt_l2cap_disconnected+0x26>
   182b8:	4623      	mov	r3, r4
   182ba:	4620      	mov	r0, r4
   182bc:	461c      	mov	r4, r3
   182be:	b158      	cbz	r0, 182d8 <bt_l2cap_disconnected+0x40>
		bt_l2cap_chan_del(chan);
   182c0:	f7ff ffc7 	bl	18252 <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   182c4:	2c00      	cmp	r4, #0
   182c6:	d0f7      	beq.n	182b8 <bt_l2cap_disconnected+0x20>
Z_GENLIST_PEEK_NEXT(slist, snode)
   182c8:	f114 0308 	adds.w	r3, r4, #8
   182cc:	d0f5      	beq.n	182ba <bt_l2cap_disconnected+0x22>
	return node->next;
   182ce:	68a3      	ldr	r3, [r4, #8]
   182d0:	2b00      	cmp	r3, #0
   182d2:	d0f2      	beq.n	182ba <bt_l2cap_disconnected+0x22>
   182d4:	3b08      	subs	r3, #8
   182d6:	e7f0      	b.n	182ba <bt_l2cap_disconnected+0x22>
}
   182d8:	bd10      	pop	{r4, pc}

000182da <bt_l2cap_create_pdu_timeout>:
{
   182da:	b508      	push	{r3, lr}
	return bt_conn_create_pdu_timeout(pool,
   182dc:	3104      	adds	r1, #4
   182de:	f7f2 f809 	bl	a2f4 <bt_conn_create_pdu_timeout>
}
   182e2:	bd08      	pop	{r3, pc}

000182e4 <bt_l2cap_send_cb>:
{
   182e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   182e6:	4605      	mov	r5, r0
   182e8:	460f      	mov	r7, r1
   182ea:	4614      	mov	r4, r2
   182ec:	461e      	mov	r6, r3
	return net_buf_simple_push(&buf->b, len);
   182ee:	2104      	movs	r1, #4
   182f0:	f102 0008 	add.w	r0, r2, #8
   182f4:	f001 ffa4 	bl	1a240 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   182f8:	89a3      	ldrh	r3, [r4, #12]
   182fa:	3b04      	subs	r3, #4
   182fc:	8003      	strh	r3, [r0, #0]
	hdr->cid = sys_cpu_to_le16(cid);
   182fe:	8047      	strh	r7, [r0, #2]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   18300:	9b06      	ldr	r3, [sp, #24]
   18302:	4632      	mov	r2, r6
   18304:	4621      	mov	r1, r4
   18306:	4628      	mov	r0, r5
   18308:	f7f1 fd7c 	bl	9e04 <bt_conn_send_cb>
}
   1830c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001830e <l2cap_send_reject>:
{
   1830e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18312:	b083      	sub	sp, #12
   18314:	4605      	mov	r5, r0
   18316:	4690      	mov	r8, r2
   18318:	461c      	mov	r4, r3
   1831a:	f89d 7028 	ldrb.w	r7, [sp, #40]	; 0x28
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   1831e:	1cbb      	adds	r3, r7, #2
   18320:	460a      	mov	r2, r1
   18322:	2101      	movs	r1, #1
   18324:	2000      	movs	r0, #0
   18326:	f7f2 fc1d 	bl	ab64 <l2cap_create_le_sig_pdu>
	if (!buf) {
   1832a:	b1b0      	cbz	r0, 1835a <l2cap_send_reject+0x4c>
   1832c:	4606      	mov	r6, r0
	return net_buf_simple_add(&buf->b, len);
   1832e:	f100 0908 	add.w	r9, r0, #8
   18332:	2102      	movs	r1, #2
   18334:	4648      	mov	r0, r9
   18336:	f001 ff62 	bl	1a1fe <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
   1833a:	f8a0 8000 	strh.w	r8, [r0]
	if (data) {
   1833e:	b124      	cbz	r4, 1834a <l2cap_send_reject+0x3c>
	return net_buf_simple_add_mem(&buf->b, mem, len);
   18340:	463a      	mov	r2, r7
   18342:	4621      	mov	r1, r4
   18344:	4648      	mov	r0, r9
   18346:	f001 ff60 	bl	1a20a <net_buf_simple_add_mem>
		     bt_conn_tx_cb_t cb, void *user_data);

static inline int bt_l2cap_send(struct bt_conn *conn, uint16_t cid,
				struct net_buf *buf)
{
	return bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
   1834a:	2300      	movs	r3, #0
   1834c:	9300      	str	r3, [sp, #0]
   1834e:	4632      	mov	r2, r6
   18350:	2105      	movs	r1, #5
   18352:	4628      	mov	r0, r5
   18354:	f7ff ffc6 	bl	182e4 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, cid, buf)) {
   18358:	b910      	cbnz	r0, 18360 <l2cap_send_reject+0x52>
}
   1835a:	b003      	add	sp, #12
   1835c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		net_buf_unref(buf);
   18360:	4630      	mov	r0, r6
   18362:	f001 ff02 	bl	1a16a <net_buf_unref>
}
   18366:	e7f8      	b.n	1835a <l2cap_send_reject+0x4c>

00018368 <bt_l2cap_le_lookup_rx_cid>:
	return list->head;
   18368:	6d00      	ldr	r0, [r0, #80]	; 0x50
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   1836a:	b110      	cbz	r0, 18372 <bt_l2cap_le_lookup_rx_cid+0xa>
   1836c:	3808      	subs	r0, #8
   1836e:	e000      	b.n	18372 <bt_l2cap_le_lookup_rx_cid+0xa>
   18370:	4618      	mov	r0, r3
   18372:	b148      	cbz	r0, 18388 <bt_l2cap_le_lookup_rx_cid+0x20>
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   18374:	8a83      	ldrh	r3, [r0, #20]
   18376:	428b      	cmp	r3, r1
   18378:	d006      	beq.n	18388 <bt_l2cap_le_lookup_rx_cid+0x20>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1837a:	f110 0308 	adds.w	r3, r0, #8
   1837e:	d0f7      	beq.n	18370 <bt_l2cap_le_lookup_rx_cid+0x8>
	return node->next;
   18380:	6880      	ldr	r0, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   18382:	b108      	cbz	r0, 18388 <bt_l2cap_le_lookup_rx_cid+0x20>
   18384:	3808      	subs	r0, #8
   18386:	e7f4      	b.n	18372 <bt_l2cap_le_lookup_rx_cid+0xa>
}
   18388:	4770      	bx	lr

0001838a <bt_l2cap_update_conn_param>:
{
   1838a:	b570      	push	{r4, r5, r6, lr}
   1838c:	b082      	sub	sp, #8
   1838e:	4605      	mov	r5, r0
   18390:	460c      	mov	r4, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   18392:	f7f2 fad1 	bl	a938 <get_ident>
   18396:	4602      	mov	r2, r0
   18398:	2308      	movs	r3, #8
   1839a:	2112      	movs	r1, #18
   1839c:	2000      	movs	r0, #0
   1839e:	f7f2 fbe1 	bl	ab64 <l2cap_create_le_sig_pdu>
	if (!buf) {
   183a2:	b1e0      	cbz	r0, 183de <bt_l2cap_update_conn_param+0x54>
   183a4:	4606      	mov	r6, r0
	return net_buf_simple_add(&buf->b, len);
   183a6:	2108      	movs	r1, #8
   183a8:	4408      	add	r0, r1
   183aa:	f001 ff28 	bl	1a1fe <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
   183ae:	8823      	ldrh	r3, [r4, #0]
   183b0:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
   183b2:	8863      	ldrh	r3, [r4, #2]
   183b4:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
   183b6:	88a3      	ldrh	r3, [r4, #4]
   183b8:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
   183ba:	88e3      	ldrh	r3, [r4, #6]
   183bc:	80c3      	strh	r3, [r0, #6]
   183be:	2300      	movs	r3, #0
   183c0:	9300      	str	r3, [sp, #0]
   183c2:	4632      	mov	r2, r6
   183c4:	2105      	movs	r1, #5
   183c6:	4628      	mov	r0, r5
   183c8:	f7ff ff8c 	bl	182e4 <bt_l2cap_send_cb>
	if (err) {
   183cc:	4604      	mov	r4, r0
   183ce:	b910      	cbnz	r0, 183d6 <bt_l2cap_update_conn_param+0x4c>
}
   183d0:	4620      	mov	r0, r4
   183d2:	b002      	add	sp, #8
   183d4:	bd70      	pop	{r4, r5, r6, pc}
		net_buf_unref(buf);
   183d6:	4630      	mov	r0, r6
   183d8:	f001 fec7 	bl	1a16a <net_buf_unref>
		return err;
   183dc:	e7f8      	b.n	183d0 <bt_l2cap_update_conn_param+0x46>
		return -ENOMEM;
   183de:	f06f 040b 	mvn.w	r4, #11
   183e2:	e7f5      	b.n	183d0 <bt_l2cap_update_conn_param+0x46>

000183e4 <bt_l2cap_init>:
#if defined(CONFIG_BT_L2CAP_DYNAMIC_CHANNEL)
	for (size_t i = 0; i < ARRAY_SIZE(l2cap_tx_meta_data); i++) {
		k_fifo_put(&free_l2cap_tx_meta_data, &l2cap_tx_meta_data[i]);
	}
#endif /* CONFIG_BT_L2CAP_DYNAMIC_CHANNEL */
}
   183e4:	4770      	bx	lr

000183e6 <get_first_req_matching_chan>:
{
   183e6:	4603      	mov	r3, r0
	return list->head;
   183e8:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
   183ea:	b120      	cbz	r0, 183f6 <get_first_req_matching_chan+0x10>
	return node->next;
   183ec:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   183ee:	601a      	str	r2, [r3, #0]
	return list->tail;
   183f0:	6859      	ldr	r1, [r3, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   183f2:	4288      	cmp	r0, r1
   183f4:	d000      	beq.n	183f8 <get_first_req_matching_chan+0x12>
}
   183f6:	4770      	bx	lr
	list->tail = node;
   183f8:	605a      	str	r2, [r3, #4]
		return ATT_REQ(node);
   183fa:	e7fc      	b.n	183f6 <get_first_req_matching_chan+0x10>

000183fc <range_is_valid>:
	if (!start || !end) {
   183fc:	b120      	cbz	r0, 18408 <range_is_valid+0xc>
   183fe:	b119      	cbz	r1, 18408 <range_is_valid+0xc>
	if (start > end) {
   18400:	4288      	cmp	r0, r1
   18402:	d806      	bhi.n	18412 <range_is_valid+0x16>
	return true;
   18404:	2001      	movs	r0, #1
}
   18406:	4770      	bx	lr
		if (err) {
   18408:	b10a      	cbz	r2, 1840e <range_is_valid+0x12>
			*err = 0U;
   1840a:	2300      	movs	r3, #0
   1840c:	8013      	strh	r3, [r2, #0]
		return false;
   1840e:	2000      	movs	r0, #0
   18410:	4770      	bx	lr
		if (err) {
   18412:	b102      	cbz	r2, 18416 <range_is_valid+0x1a>
			*err = start;
   18414:	8010      	strh	r0, [r2, #0]
		return false;
   18416:	2000      	movs	r0, #0
   18418:	4770      	bx	lr

0001841a <err_to_att>:
	if (err < 0 && err >= -0xff) {
   1841a:	f110 0fff 	cmn.w	r0, #255	; 0xff
   1841e:	d201      	bcs.n	18424 <err_to_att+0xa>
	return BT_ATT_ERR_UNLIKELY;
   18420:	200e      	movs	r0, #14
}
   18422:	4770      	bx	lr
		return -err;
   18424:	4240      	negs	r0, r0
   18426:	b2c0      	uxtb	r0, r0
   18428:	4770      	bx	lr

0001842a <attr_read_type_cb>:
{
   1842a:	b410      	push	{r4}
	if (!data->rsp->len) {
   1842c:	68d4      	ldr	r4, [r2, #12]
   1842e:	7823      	ldrb	r3, [r4, #0]
   18430:	b923      	cbnz	r3, 1843c <attr_read_type_cb+0x12>
		data->rsp->len = read + sizeof(*data->item);
   18432:	3102      	adds	r1, #2
   18434:	7021      	strb	r1, [r4, #0]
	return true;
   18436:	2001      	movs	r0, #1
}
   18438:	bc10      	pop	{r4}
   1843a:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   1843c:	3102      	adds	r1, #2
   1843e:	428b      	cmp	r3, r1
   18440:	d005      	beq.n	1844e <attr_read_type_cb+0x24>
		frag->len -= sizeof(*data->item);
   18442:	8983      	ldrh	r3, [r0, #12]
   18444:	3b02      	subs	r3, #2
   18446:	8183      	strh	r3, [r0, #12]
		data->item = NULL;
   18448:	2000      	movs	r0, #0
   1844a:	6110      	str	r0, [r2, #16]
		return false;
   1844c:	e7f4      	b.n	18438 <attr_read_type_cb+0xe>
	return true;
   1844e:	2001      	movs	r0, #1
   18450:	e7f2      	b.n	18438 <attr_read_type_cb+0xe>

00018452 <attr_read_group_cb>:
	if (!data->rsp->len) {
   18452:	68d0      	ldr	r0, [r2, #12]
   18454:	7803      	ldrb	r3, [r0, #0]
   18456:	b91b      	cbnz	r3, 18460 <attr_read_group_cb+0xe>
		data->rsp->len = read + sizeof(*data->group);
   18458:	3104      	adds	r1, #4
   1845a:	7001      	strb	r1, [r0, #0]
	return true;
   1845c:	2001      	movs	r0, #1
   1845e:	4770      	bx	lr
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   18460:	3104      	adds	r1, #4
   18462:	428b      	cmp	r3, r1
   18464:	d006      	beq.n	18474 <attr_read_group_cb+0x22>
		data->buf->len -= sizeof(*data->group);
   18466:	6891      	ldr	r1, [r2, #8]
   18468:	898b      	ldrh	r3, [r1, #12]
   1846a:	3b04      	subs	r3, #4
   1846c:	818b      	strh	r3, [r1, #12]
		data->group = NULL;
   1846e:	2000      	movs	r0, #0
   18470:	6110      	str	r0, [r2, #16]
		return false;
   18472:	4770      	bx	lr
	return true;
   18474:	2001      	movs	r0, #1
}
   18476:	4770      	bx	lr

00018478 <att_prepare_write_req>:
}
   18478:	2006      	movs	r0, #6
   1847a:	4770      	bx	lr

0001847c <att_exec_write_req>:
}
   1847c:	2006      	movs	r0, #6
   1847e:	4770      	bx	lr

00018480 <att_op_get_type>:
	switch (op) {
   18480:	1e43      	subs	r3, r0, #1
   18482:	2bd1      	cmp	r3, #209	; 0xd1
   18484:	d874      	bhi.n	18570 <att_op_get_type+0xf0>
   18486:	e8df f003 	tbb	[pc, r3]
   1848a:	696d      	.short	0x696d
   1848c:	696d696d 	.word	0x696d696d
   18490:	696d696d 	.word	0x696d696d
   18494:	696d696d 	.word	0x696d696d
   18498:	696d696d 	.word	0x696d696d
   1849c:	6973736d 	.word	0x6973736d
   184a0:	736d696d 	.word	0x736d696d
   184a4:	7871736f 	.word	0x7871736f
   184a8:	736d6973 	.word	0x736d6973
   184ac:	7373736f 	.word	0x7373736f
   184b0:	73737373 	.word	0x73737373
   184b4:	73737373 	.word	0x73737373
   184b8:	73737373 	.word	0x73737373
   184bc:	73737373 	.word	0x73737373
   184c0:	73737373 	.word	0x73737373
   184c4:	73737373 	.word	0x73737373
   184c8:	73737373 	.word	0x73737373
   184cc:	73737373 	.word	0x73737373
   184d0:	73737373 	.word	0x73737373
   184d4:	73737373 	.word	0x73737373
   184d8:	6b737373 	.word	0x6b737373
   184dc:	73737373 	.word	0x73737373
   184e0:	73737373 	.word	0x73737373
   184e4:	73737373 	.word	0x73737373
   184e8:	73737373 	.word	0x73737373
   184ec:	73737373 	.word	0x73737373
   184f0:	73737373 	.word	0x73737373
   184f4:	73737373 	.word	0x73737373
   184f8:	73737373 	.word	0x73737373
   184fc:	73737373 	.word	0x73737373
   18500:	73737373 	.word	0x73737373
   18504:	73737373 	.word	0x73737373
   18508:	73737373 	.word	0x73737373
   1850c:	73737373 	.word	0x73737373
   18510:	73737373 	.word	0x73737373
   18514:	73737373 	.word	0x73737373
   18518:	73737373 	.word	0x73737373
   1851c:	73737373 	.word	0x73737373
   18520:	73737373 	.word	0x73737373
   18524:	73737373 	.word	0x73737373
   18528:	73737373 	.word	0x73737373
   1852c:	73737373 	.word	0x73737373
   18530:	73737373 	.word	0x73737373
   18534:	73737373 	.word	0x73737373
   18538:	73737373 	.word	0x73737373
   1853c:	73737373 	.word	0x73737373
   18540:	73737373 	.word	0x73737373
   18544:	73737373 	.word	0x73737373
   18548:	73737373 	.word	0x73737373
   1854c:	73737373 	.word	0x73737373
   18550:	73737373 	.word	0x73737373
   18554:	73737373 	.word	0x73737373
   18558:	6b737373 	.word	0x6b737373
   1855c:	2001      	movs	r0, #1
   1855e:	4770      	bx	lr
		return ATT_COMMAND;
   18560:	2000      	movs	r0, #0
   18562:	4770      	bx	lr
		return ATT_RESPONSE;
   18564:	2002      	movs	r0, #2
   18566:	4770      	bx	lr
		return ATT_NOTIFICATION;
   18568:	2003      	movs	r0, #3
   1856a:	4770      	bx	lr
		return ATT_INDICATION;
   1856c:	2005      	movs	r0, #5
   1856e:	4770      	bx	lr
	if (op & ATT_CMD_MASK) {
   18570:	f010 0f40 	tst.w	r0, #64	; 0x40
   18574:	d103      	bne.n	1857e <att_op_get_type+0xfe>
	return ATT_UNKNOWN;
   18576:	2006      	movs	r0, #6
   18578:	4770      	bx	lr
		return ATT_CONFIRMATION;
   1857a:	2004      	movs	r0, #4
   1857c:	4770      	bx	lr
		return ATT_COMMAND;
   1857e:	2000      	movs	r0, #0
}
   18580:	4770      	bx	lr

00018582 <att_chan_attach>:
{
   18582:	b538      	push	{r3, r4, r5, lr}
   18584:	4604      	mov	r4, r0
   18586:	460d      	mov	r5, r1
	return list->head;
   18588:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sys_slist_is_empty(&att->chans)) {
   1858a:	b143      	cbz	r3, 1859e <att_chan_attach+0x1c>
	sys_slist_prepend(&att->chans, &chan->node);
   1858c:	f105 03e0 	add.w	r3, r5, #224	; 0xe0
   18590:	6a62      	ldr	r2, [r4, #36]	; 0x24
	parent->next = child;
   18592:	f8c5 20e0 	str.w	r2, [r5, #224]	; 0xe0
	list->head = node;
   18596:	6263      	str	r3, [r4, #36]	; 0x24
	return list->tail;
   18598:	6aa2      	ldr	r2, [r4, #40]	; 0x28
Z_GENLIST_PREPEND(slist, snode)
   1859a:	b122      	cbz	r2, 185a6 <att_chan_attach+0x24>
}
   1859c:	bd38      	pop	{r3, r4, r5, pc}
		k_fifo_init(&att->tx_queue);
   1859e:	300c      	adds	r0, #12
	z_impl_k_queue_init(queue);
   185a0:	f003 fdd6 	bl	1c150 <z_impl_k_queue_init>
}
   185a4:	e7f2      	b.n	1858c <att_chan_attach+0xa>
	list->tail = node;
   185a6:	62a3      	str	r3, [r4, #40]	; 0x28
}
   185a8:	e7f8      	b.n	1859c <att_chan_attach+0x1a>

000185aa <get_first_buf_matching_chan>:
{
   185aa:	b508      	push	{r3, lr}
		return net_buf_get(fifo, K_NO_WAIT);
   185ac:	2200      	movs	r2, #0
   185ae:	2300      	movs	r3, #0
   185b0:	f001 fd4f 	bl	1a052 <net_buf_get>
}
   185b4:	bd08      	pop	{r3, pc}

000185b6 <att_notify_mult>:
{
   185b6:	b508      	push	{r3, lr}
	bt_gatt_mult_notification(chan->att->conn, buf->data, buf->len);
   185b8:	6803      	ldr	r3, [r0, #0]
   185ba:	898a      	ldrh	r2, [r1, #12]
   185bc:	6889      	ldr	r1, [r1, #8]
   185be:	6818      	ldr	r0, [r3, #0]
   185c0:	f7f5 f9f2 	bl	d9a8 <bt_gatt_mult_notification>
}
   185c4:	2000      	movs	r0, #0
   185c6:	bd08      	pop	{r3, pc}

000185c8 <att_notify>:
{
   185c8:	b538      	push	{r3, r4, r5, lr}
   185ca:	4605      	mov	r5, r0
   185cc:	460c      	mov	r4, r1
	return net_buf_simple_pull_le16(&buf->b);
   185ce:	f101 0008 	add.w	r0, r1, #8
   185d2:	f001 fe54 	bl	1a27e <net_buf_simple_pull_le16>
   185d6:	4601      	mov	r1, r0
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   185d8:	682d      	ldr	r5, [r5, #0]
   185da:	89a3      	ldrh	r3, [r4, #12]
   185dc:	68a2      	ldr	r2, [r4, #8]
   185de:	6828      	ldr	r0, [r5, #0]
   185e0:	f001 fba2 	bl	19d28 <bt_gatt_notification>
}
   185e4:	2000      	movs	r0, #0
   185e6:	bd38      	pop	{r3, r4, r5, pc}

000185e8 <att_chan_mtu_updated>:
{
   185e8:	b570      	push	{r4, r5, r6, lr}
	struct bt_att *att = updated_chan->att;
   185ea:	6806      	ldr	r6, [r0, #0]
	return list->head;
   185ec:	6a74      	ldr	r4, [r6, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   185ee:	b14c      	cbz	r4, 18604 <att_chan_mtu_updated+0x1c>
   185f0:	3ce0      	subs	r4, #224	; 0xe0
   185f2:	d00b      	beq.n	1860c <att_chan_mtu_updated+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
   185f4:	f114 03e0 	adds.w	r3, r4, #224	; 0xe0
   185f8:	d005      	beq.n	18606 <att_chan_mtu_updated+0x1e>
	return node->next;
   185fa:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
   185fe:	b113      	cbz	r3, 18606 <att_chan_mtu_updated+0x1e>
   18600:	3be0      	subs	r3, #224	; 0xe0
   18602:	e000      	b.n	18606 <att_chan_mtu_updated+0x1e>
   18604:	4623      	mov	r3, r4
   18606:	2200      	movs	r2, #0
   18608:	4611      	mov	r1, r2
   1860a:	e004      	b.n	18616 <att_chan_mtu_updated+0x2e>
   1860c:	4623      	mov	r3, r4
   1860e:	e7fa      	b.n	18606 <att_chan_mtu_updated+0x1e>
   18610:	461d      	mov	r5, r3
   18612:	461c      	mov	r4, r3
   18614:	462b      	mov	r3, r5
   18616:	b1a4      	cbz	r4, 18642 <att_chan_mtu_updated+0x5a>
		if (chan == updated_chan) {
   18618:	4284      	cmp	r4, r0
   1861a:	d007      	beq.n	1862c <att_chan_mtu_updated+0x44>
		max_tx = MAX(max_tx, chan->chan.tx.mtu);
   1861c:	8d65      	ldrh	r5, [r4, #42]	; 0x2a
   1861e:	42a9      	cmp	r1, r5
   18620:	bf38      	it	cc
   18622:	4629      	movcc	r1, r5
		max_rx = MAX(max_rx, chan->chan.rx.mtu);
   18624:	8b64      	ldrh	r4, [r4, #26]
   18626:	42a2      	cmp	r2, r4
   18628:	bf38      	it	cc
   1862a:	4622      	movcc	r2, r4
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1862c:	2b00      	cmp	r3, #0
   1862e:	d0ef      	beq.n	18610 <att_chan_mtu_updated+0x28>
Z_GENLIST_PEEK_NEXT(slist, snode)
   18630:	f113 05e0 	adds.w	r5, r3, #224	; 0xe0
   18634:	d0ed      	beq.n	18612 <att_chan_mtu_updated+0x2a>
	return node->next;
   18636:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
   1863a:	2d00      	cmp	r5, #0
   1863c:	d0e9      	beq.n	18612 <att_chan_mtu_updated+0x2a>
   1863e:	3de0      	subs	r5, #224	; 0xe0
   18640:	e7e7      	b.n	18612 <att_chan_mtu_updated+0x2a>
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   18642:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
   18644:	428b      	cmp	r3, r1
   18646:	d802      	bhi.n	1864e <att_chan_mtu_updated+0x66>
	    (updated_chan->chan.rx.mtu > max_rx)) {
   18648:	8b44      	ldrh	r4, [r0, #26]
	if ((updated_chan->chan.tx.mtu > max_tx) ||
   1864a:	4294      	cmp	r4, r2
   1864c:	d909      	bls.n	18662 <att_chan_mtu_updated+0x7a>
		max_rx = MAX(max_rx, updated_chan->chan.rx.mtu);
   1864e:	8b40      	ldrh	r0, [r0, #26]
		bt_gatt_att_max_mtu_changed(att->conn, max_tx, max_rx);
   18650:	4282      	cmp	r2, r0
   18652:	bf38      	it	cc
   18654:	4602      	movcc	r2, r0
   18656:	4299      	cmp	r1, r3
   18658:	bf38      	it	cc
   1865a:	4619      	movcc	r1, r3
   1865c:	6830      	ldr	r0, [r6, #0]
   1865e:	f7f5 fa67 	bl	db30 <bt_gatt_att_max_mtu_changed>
}
   18662:	bd70      	pop	{r4, r5, r6, pc}

00018664 <write_cb>:
{
   18664:	b5f0      	push	{r4, r5, r6, r7, lr}
   18666:	b083      	sub	sp, #12
   18668:	4606      	mov	r6, r0
   1866a:	4614      	mov	r4, r2
	data->err = bt_gatt_check_perm(data->conn, attr,
   1866c:	f44f 7295 	mov.w	r2, #298	; 0x12a
   18670:	4601      	mov	r1, r0
   18672:	6820      	ldr	r0, [r4, #0]
   18674:	f001 fa00 	bl	19a78 <bt_gatt_check_perm>
   18678:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   1867a:	bb08      	cbnz	r0, 186c0 <write_cb+0x5c>
   1867c:	4605      	mov	r5, r0
	if (!data->req) {
   1867e:	7a23      	ldrb	r3, [r4, #8]
   18680:	b11b      	cbz	r3, 1868a <write_cb+0x26>
	} else if (data->req == BT_ATT_OP_EXEC_WRITE_REQ) {
   18682:	2b18      	cmp	r3, #24
   18684:	d016      	beq.n	186b4 <write_cb+0x50>
	uint8_t flags = 0U;
   18686:	4603      	mov	r3, r0
   18688:	e000      	b.n	1868c <write_cb+0x28>
		flags |= BT_GATT_WRITE_FLAG_CMD;
   1868a:	2302      	movs	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   1868c:	68b7      	ldr	r7, [r6, #8]
   1868e:	9301      	str	r3, [sp, #4]
   18690:	8a63      	ldrh	r3, [r4, #18]
   18692:	9300      	str	r3, [sp, #0]
   18694:	8a23      	ldrh	r3, [r4, #16]
   18696:	68e2      	ldr	r2, [r4, #12]
   18698:	4631      	mov	r1, r6
   1869a:	6820      	ldr	r0, [r4, #0]
   1869c:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   1869e:	2800      	cmp	r0, #0
   186a0:	db02      	blt.n	186a8 <write_cb+0x44>
   186a2:	8a23      	ldrh	r3, [r4, #16]
   186a4:	4298      	cmp	r0, r3
   186a6:	d007      	beq.n	186b8 <write_cb+0x54>
		data->err = err_to_att(write);
   186a8:	f7ff feb7 	bl	1841a <err_to_att>
   186ac:	7520      	strb	r0, [r4, #20]
}
   186ae:	4628      	mov	r0, r5
   186b0:	b003      	add	sp, #12
   186b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		flags |= BT_GATT_WRITE_FLAG_EXECUTE;
   186b4:	2304      	movs	r3, #4
   186b6:	e7e9      	b.n	1868c <write_cb+0x28>
	data->err = 0U;
   186b8:	2300      	movs	r3, #0
   186ba:	7523      	strb	r3, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   186bc:	2501      	movs	r5, #1
   186be:	e7f6      	b.n	186ae <write_cb+0x4a>
		return BT_GATT_ITER_STOP;
   186c0:	2500      	movs	r5, #0
   186c2:	e7f4      	b.n	186ae <write_cb+0x4a>

000186c4 <att_chan_read>:
{
   186c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   186c8:	b085      	sub	sp, #20
   186ca:	4680      	mov	r8, r0
   186cc:	4689      	mov	r9, r1
   186ce:	9202      	str	r2, [sp, #8]
   186d0:	461d      	mov	r5, r3
	struct bt_conn *conn = chan->chan.chan.conn;
   186d2:	6843      	ldr	r3, [r0, #4]
   186d4:	9303      	str	r3, [sp, #12]
	if (chan->chan.tx.mtu <= net_buf_frags_len(buf)) {
   186d6:	8d40      	ldrh	r0, [r0, #42]	; 0x2a
	while (buf) {
   186d8:	4613      	mov	r3, r2
	size_t bytes = 0;
   186da:	2200      	movs	r2, #0
	while (buf) {
   186dc:	e002      	b.n	186e4 <att_chan_read+0x20>
		bytes += buf->len;
   186de:	8999      	ldrh	r1, [r3, #12]
   186e0:	440a      	add	r2, r1
		buf = buf->frags;
   186e2:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   186e4:	2b00      	cmp	r3, #0
   186e6:	d1fa      	bne.n	186de <att_chan_read+0x1a>
   186e8:	4290      	cmp	r0, r2
   186ea:	d804      	bhi.n	186f6 <att_chan_read+0x32>
		return 0;
   186ec:	2400      	movs	r4, #0
}
   186ee:	4620      	mov	r0, r4
   186f0:	b005      	add	sp, #20
   186f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	frag = net_buf_frag_last(buf);
   186f6:	9802      	ldr	r0, [sp, #8]
   186f8:	f001 fd61 	bl	1a1be <net_buf_frag_last>
   186fc:	4607      	mov	r7, r0
	size_t len, total = 0;
   186fe:	f04f 0a00 	mov.w	sl, #0
   18702:	e082      	b.n	1880a <att_chan_read+0x146>
		bytes += buf->len;
   18704:	8999      	ldrh	r1, [r3, #12]
   18706:	440a      	add	r2, r1
		buf = buf->frags;
   18708:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1870a:	2b00      	cmp	r3, #0
   1870c:	d1fa      	bne.n	18704 <att_chan_read+0x40>
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   1870e:	1aa4      	subs	r4, r4, r2
	return net_buf_simple_tailroom(&buf->b);
   18710:	f107 0608 	add.w	r6, r7, #8
   18714:	4630      	mov	r0, r6
   18716:	f001 fdbe 	bl	1a296 <net_buf_simple_tailroom>
   1871a:	4284      	cmp	r4, r0
   1871c:	d326      	bcc.n	1876c <att_chan_read+0xa8>
   1871e:	4630      	mov	r0, r6
   18720:	f001 fdb9 	bl	1a296 <net_buf_simple_tailroom>
   18724:	4606      	mov	r6, r0
		if (!len) {
   18726:	b36e      	cbz	r6, 18784 <att_chan_read+0xc0>
		read = attr->read(conn, attr, frag->data + frag->len, len,
   18728:	f8d9 4004 	ldr.w	r4, [r9, #4]
   1872c:	68b9      	ldr	r1, [r7, #8]
   1872e:	89ba      	ldrh	r2, [r7, #12]
   18730:	9500      	str	r5, [sp, #0]
   18732:	b2b3      	uxth	r3, r6
   18734:	440a      	add	r2, r1
   18736:	4649      	mov	r1, r9
   18738:	9803      	ldr	r0, [sp, #12]
   1873a:	47a0      	blx	r4
		if (read < 0) {
   1873c:	1e04      	subs	r4, r0, #0
   1873e:	db55      	blt.n	187ec <att_chan_read+0x128>
		if (cb && !cb(frag, read, user_data)) {
   18740:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   18742:	b12b      	cbz	r3, 18750 <att_chan_read+0x8c>
   18744:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   18746:	4621      	mov	r1, r4
   18748:	4638      	mov	r0, r7
   1874a:	4798      	blx	r3
   1874c:	2800      	cmp	r0, #0
   1874e:	d061      	beq.n	18814 <att_chan_read+0x150>
		net_buf_add(frag, read);
   18750:	46a3      	mov	fp, r4
	return net_buf_simple_add(&buf->b, len);
   18752:	4621      	mov	r1, r4
   18754:	f107 0008 	add.w	r0, r7, #8
   18758:	f001 fd51 	bl	1a1fe <net_buf_simple_add>
		total += read;
   1875c:	44a2      	add	sl, r4
		offset += read;
   1875e:	4425      	add	r5, r4
   18760:	b2ad      	uxth	r5, r5
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   18762:	f8b8 002a 	ldrh.w	r0, [r8, #42]	; 0x2a
   18766:	9b02      	ldr	r3, [sp, #8]
	size_t bytes = 0;
   18768:	2200      	movs	r2, #0
   1876a:	e048      	b.n	187fe <att_chan_read+0x13a>
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   1876c:	f8b8 602a 	ldrh.w	r6, [r8, #42]	; 0x2a
	while (buf) {
   18770:	9b02      	ldr	r3, [sp, #8]
	size_t bytes = 0;
   18772:	2200      	movs	r2, #0
	while (buf) {
   18774:	e002      	b.n	1877c <att_chan_read+0xb8>
		bytes += buf->len;
   18776:	8999      	ldrh	r1, [r3, #12]
   18778:	440a      	add	r2, r1
		buf = buf->frags;
   1877a:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1877c:	2b00      	cmp	r3, #0
   1877e:	d1fa      	bne.n	18776 <att_chan_read+0xb2>
   18780:	1ab6      	subs	r6, r6, r2
   18782:	e7d0      	b.n	18726 <att_chan_read+0x62>
			frag = net_buf_alloc(net_buf_pool_get(buf->pool_id),
   18784:	9b02      	ldr	r3, [sp, #8]
   18786:	7998      	ldrb	r0, [r3, #6]
   18788:	f7f5 fa72 	bl	dc70 <net_buf_pool_get>
	return net_buf_alloc_fixed(pool, timeout);
   1878c:	2200      	movs	r2, #0
   1878e:	2300      	movs	r3, #0
   18790:	f001 fc58 	bl	1a044 <net_buf_alloc_fixed>
			if (!frag) {
   18794:	4607      	mov	r7, r0
   18796:	b150      	cbz	r0, 187ae <att_chan_read+0xea>
			net_buf_frag_add(buf, frag);
   18798:	4601      	mov	r1, r0
   1879a:	f8dd b008 	ldr.w	fp, [sp, #8]
   1879e:	4658      	mov	r0, fp
   187a0:	f001 fd1e 	bl	1a1e0 <net_buf_frag_add>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   187a4:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
	size_t bytes = 0;
   187a8:	4632      	mov	r2, r6
	while (buf) {
   187aa:	465b      	mov	r3, fp
   187ac:	e004      	b.n	187b8 <att_chan_read+0xf4>
				return total;
   187ae:	4654      	mov	r4, sl
   187b0:	e79d      	b.n	186ee <att_chan_read+0x2a>
		bytes += buf->len;
   187b2:	8999      	ldrh	r1, [r3, #12]
   187b4:	440a      	add	r2, r1
		buf = buf->frags;
   187b6:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   187b8:	2b00      	cmp	r3, #0
   187ba:	d1fa      	bne.n	187b2 <att_chan_read+0xee>
			len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   187bc:	1aa4      	subs	r4, r4, r2
	return net_buf_simple_tailroom(&buf->b);
   187be:	f107 0b08 	add.w	fp, r7, #8
   187c2:	4658      	mov	r0, fp
   187c4:	f001 fd67 	bl	1a296 <net_buf_simple_tailroom>
   187c8:	4284      	cmp	r4, r0
   187ca:	d304      	bcc.n	187d6 <att_chan_read+0x112>
   187cc:	4658      	mov	r0, fp
   187ce:	f001 fd62 	bl	1a296 <net_buf_simple_tailroom>
   187d2:	4606      	mov	r6, r0
   187d4:	e7a8      	b.n	18728 <att_chan_read+0x64>
   187d6:	f8b8 102a 	ldrh.w	r1, [r8, #42]	; 0x2a
	while (buf) {
   187da:	9b02      	ldr	r3, [sp, #8]
   187dc:	e002      	b.n	187e4 <att_chan_read+0x120>
		bytes += buf->len;
   187de:	899a      	ldrh	r2, [r3, #12]
   187e0:	4416      	add	r6, r2
		buf = buf->frags;
   187e2:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   187e4:	2b00      	cmp	r3, #0
   187e6:	d1fa      	bne.n	187de <att_chan_read+0x11a>
   187e8:	1b8e      	subs	r6, r1, r6
   187ea:	e79d      	b.n	18728 <att_chan_read+0x64>
			if (total) {
   187ec:	f1ba 0f00 	cmp.w	sl, #0
   187f0:	f43f af7d 	beq.w	186ee <att_chan_read+0x2a>
				return total;
   187f4:	4654      	mov	r4, sl
   187f6:	e77a      	b.n	186ee <att_chan_read+0x2a>
		bytes += buf->len;
   187f8:	8999      	ldrh	r1, [r3, #12]
   187fa:	440a      	add	r2, r1
		buf = buf->frags;
   187fc:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   187fe:	2b00      	cmp	r3, #0
   18800:	d1fa      	bne.n	187f8 <att_chan_read+0x134>
	} while (chan->chan.tx.mtu > net_buf_frags_len(buf) && read == len);
   18802:	4290      	cmp	r0, r2
   18804:	d906      	bls.n	18814 <att_chan_read+0x150>
   18806:	45b3      	cmp	fp, r6
   18808:	d104      	bne.n	18814 <att_chan_read+0x150>
		len = MIN(chan->chan.tx.mtu - net_buf_frags_len(buf),
   1880a:	f8b8 402a 	ldrh.w	r4, [r8, #42]	; 0x2a
   1880e:	9b02      	ldr	r3, [sp, #8]
	size_t bytes = 0;
   18810:	2200      	movs	r2, #0
	while (buf) {
   18812:	e77a      	b.n	1870a <att_chan_read+0x46>
	return total;
   18814:	4654      	mov	r4, sl
   18816:	e76a      	b.n	186ee <att_chan_read+0x2a>

00018818 <read_vl_cb>:
{
   18818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1881c:	b082      	sub	sp, #8
   1881e:	4606      	mov	r6, r0
   18820:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   18822:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   18824:	6878      	ldr	r0, [r7, #4]
	data->err = 0x00;
   18826:	2300      	movs	r3, #0
   18828:	7313      	strb	r3, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   1882a:	2295      	movs	r2, #149	; 0x95
   1882c:	4631      	mov	r1, r6
   1882e:	f001 f923 	bl	19a78 <bt_gatt_check_perm>
   18832:	7320      	strb	r0, [r4, #12]
	if (data->err) {
   18834:	b9f0      	cbnz	r0, 18874 <read_vl_cb+0x5c>
   18836:	4605      	mov	r5, r0
	if (chan->chan.tx.mtu - data->buf->len < 2) {
   18838:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   1883a:	68a0      	ldr	r0, [r4, #8]
   1883c:	8982      	ldrh	r2, [r0, #12]
   1883e:	1a9b      	subs	r3, r3, r2
   18840:	2b01      	cmp	r3, #1
   18842:	dd18      	ble.n	18876 <read_vl_cb+0x5e>
	return net_buf_simple_add(&buf->b, len);
   18844:	2102      	movs	r1, #2
   18846:	3008      	adds	r0, #8
   18848:	f001 fcd9 	bl	1a1fe <net_buf_simple_add>
   1884c:	4680      	mov	r8, r0
	read = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   1884e:	2300      	movs	r3, #0
   18850:	9301      	str	r3, [sp, #4]
   18852:	9300      	str	r3, [sp, #0]
   18854:	88a3      	ldrh	r3, [r4, #4]
   18856:	68a2      	ldr	r2, [r4, #8]
   18858:	4631      	mov	r1, r6
   1885a:	4638      	mov	r0, r7
   1885c:	f7ff ff32 	bl	186c4 <att_chan_read>
	if (read < 0) {
   18860:	2800      	cmp	r0, #0
   18862:	db03      	blt.n	1886c <read_vl_cb+0x54>
	rsp->len = read;
   18864:	f8a8 0000 	strh.w	r0, [r8]
	return BT_GATT_ITER_CONTINUE;
   18868:	2501      	movs	r5, #1
   1886a:	e004      	b.n	18876 <read_vl_cb+0x5e>
		data->err = err_to_att(read);
   1886c:	f7ff fdd5 	bl	1841a <err_to_att>
   18870:	7320      	strb	r0, [r4, #12]
		return BT_GATT_ITER_STOP;
   18872:	e000      	b.n	18876 <read_vl_cb+0x5e>
		return BT_GATT_ITER_STOP;
   18874:	2500      	movs	r5, #0
}
   18876:	4628      	mov	r0, r5
   18878:	b002      	add	sp, #8
   1887a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001887e <read_cb>:
{
   1887e:	b5f0      	push	{r4, r5, r6, r7, lr}
   18880:	b083      	sub	sp, #12
   18882:	4606      	mov	r6, r0
   18884:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   18886:	6817      	ldr	r7, [r2, #0]
	struct bt_conn *conn = chan->chan.chan.conn;
   18888:	6878      	ldr	r0, [r7, #4]
	data->err = 0x00;
   1888a:	2300      	movs	r3, #0
   1888c:	7313      	strb	r3, [r2, #12]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   1888e:	2295      	movs	r2, #149	; 0x95
   18890:	4631      	mov	r1, r6
   18892:	f001 f8f1 	bl	19a78 <bt_gatt_check_perm>
   18896:	7320      	strb	r0, [r4, #12]
	if (data->err) {
   18898:	b118      	cbz	r0, 188a2 <read_cb+0x24>
		return BT_GATT_ITER_STOP;
   1889a:	2500      	movs	r5, #0
}
   1889c:	4628      	mov	r0, r5
   1889e:	b003      	add	sp, #12
   188a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   188a2:	4605      	mov	r5, r0
	ret = att_chan_read(chan, attr, data->buf, data->offset, NULL, NULL);
   188a4:	2300      	movs	r3, #0
   188a6:	9301      	str	r3, [sp, #4]
   188a8:	9300      	str	r3, [sp, #0]
   188aa:	88a3      	ldrh	r3, [r4, #4]
   188ac:	68a2      	ldr	r2, [r4, #8]
   188ae:	4631      	mov	r1, r6
   188b0:	4638      	mov	r0, r7
   188b2:	f7ff ff07 	bl	186c4 <att_chan_read>
	if (ret < 0) {
   188b6:	2800      	cmp	r0, #0
   188b8:	db01      	blt.n	188be <read_cb+0x40>
	return BT_GATT_ITER_CONTINUE;
   188ba:	2501      	movs	r5, #1
   188bc:	e7ee      	b.n	1889c <read_cb+0x1e>
		data->err = err_to_att(ret);
   188be:	f7ff fdac 	bl	1841a <err_to_att>
   188c2:	7320      	strb	r0, [r4, #12]
		return BT_GATT_ITER_STOP;
   188c4:	e7ea      	b.n	1889c <read_cb+0x1e>

000188c6 <find_info_cb>:
{
   188c6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   188ca:	4606      	mov	r6, r0
   188cc:	460f      	mov	r7, r1
   188ce:	4614      	mov	r4, r2
	struct bt_att_chan *chan = data->chan;
   188d0:	f8d2 8000 	ldr.w	r8, [r2]
	if (!data->rsp) {
   188d4:	6893      	ldr	r3, [r2, #8]
   188d6:	b14b      	cbz	r3, 188ec <find_info_cb+0x26>
	switch (data->rsp->format) {
   188d8:	68a3      	ldr	r3, [r4, #8]
   188da:	781d      	ldrb	r5, [r3, #0]
   188dc:	2d01      	cmp	r5, #1
   188de:	d013      	beq.n	18908 <find_info_cb+0x42>
   188e0:	2d02      	cmp	r5, #2
   188e2:	d02d      	beq.n	18940 <find_info_cb+0x7a>
   188e4:	2500      	movs	r5, #0
}
   188e6:	4628      	mov	r0, r5
   188e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   188ec:	6850      	ldr	r0, [r2, #4]
   188ee:	2101      	movs	r1, #1
   188f0:	3008      	adds	r0, #8
   188f2:	f001 fc84 	bl	1a1fe <net_buf_simple_add>
   188f6:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   188f8:	6833      	ldr	r3, [r6, #0]
   188fa:	781b      	ldrb	r3, [r3, #0]
   188fc:	b913      	cbnz	r3, 18904 <find_info_cb+0x3e>
   188fe:	2301      	movs	r3, #1
   18900:	7003      	strb	r3, [r0, #0]
   18902:	e7e9      	b.n	188d8 <find_info_cb+0x12>
   18904:	2302      	movs	r3, #2
   18906:	e7fb      	b.n	18900 <find_info_cb+0x3a>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   18908:	6833      	ldr	r3, [r6, #0]
   1890a:	f893 9000 	ldrb.w	r9, [r3]
   1890e:	f1b9 0f00 	cmp.w	r9, #0
   18912:	d001      	beq.n	18918 <find_info_cb+0x52>
			return BT_GATT_ITER_STOP;
   18914:	2500      	movs	r5, #0
   18916:	e7e6      	b.n	188e6 <find_info_cb+0x20>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   18918:	6860      	ldr	r0, [r4, #4]
   1891a:	2104      	movs	r1, #4
   1891c:	3008      	adds	r0, #8
   1891e:	f001 fc6e 	bl	1a1fe <net_buf_simple_add>
   18922:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(handle);
   18924:	8007      	strh	r7, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   18926:	6832      	ldr	r2, [r6, #0]
   18928:	68e3      	ldr	r3, [r4, #12]
   1892a:	8852      	ldrh	r2, [r2, #2]
   1892c:	805a      	strh	r2, [r3, #2]
		if (chan->chan.tx.mtu - data->buf->len >
   1892e:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
   18932:	6862      	ldr	r2, [r4, #4]
   18934:	8992      	ldrh	r2, [r2, #12]
   18936:	1a9b      	subs	r3, r3, r2
   18938:	2b04      	cmp	r3, #4
   1893a:	d8d4      	bhi.n	188e6 <find_info_cb+0x20>
	return BT_GATT_ITER_STOP;
   1893c:	464d      	mov	r5, r9
   1893e:	e7d2      	b.n	188e6 <find_info_cb+0x20>
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   18940:	6833      	ldr	r3, [r6, #0]
   18942:	781b      	ldrb	r3, [r3, #0]
   18944:	2b02      	cmp	r3, #2
   18946:	d001      	beq.n	1894c <find_info_cb+0x86>
			return BT_GATT_ITER_STOP;
   18948:	2500      	movs	r5, #0
   1894a:	e7cc      	b.n	188e6 <find_info_cb+0x20>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   1894c:	6860      	ldr	r0, [r4, #4]
   1894e:	2112      	movs	r1, #18
   18950:	3008      	adds	r0, #8
   18952:	f001 fc54 	bl	1a1fe <net_buf_simple_add>
   18956:	60e0      	str	r0, [r4, #12]
		data->info128->handle = sys_cpu_to_le16(handle);
   18958:	8007      	strh	r7, [r0, #0]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   1895a:	68e0      	ldr	r0, [r4, #12]
   1895c:	6831      	ldr	r1, [r6, #0]
   1895e:	2210      	movs	r2, #16
   18960:	3101      	adds	r1, #1
   18962:	3002      	adds	r0, #2
   18964:	f7fe fee4 	bl	17730 <memcpy>
		if (chan->chan.tx.mtu - data->buf->len >
   18968:	f8b8 302a 	ldrh.w	r3, [r8, #42]	; 0x2a
   1896c:	6862      	ldr	r2, [r4, #4]
   1896e:	8992      	ldrh	r2, [r2, #12]
   18970:	1a9b      	subs	r3, r3, r2
   18972:	2b12      	cmp	r3, #18
   18974:	d801      	bhi.n	1897a <find_info_cb+0xb4>
	return BT_GATT_ITER_STOP;
   18976:	2500      	movs	r5, #0
   18978:	e7b5      	b.n	188e6 <find_info_cb+0x20>
			return BT_GATT_ITER_CONTINUE;
   1897a:	2501      	movs	r5, #1
   1897c:	e7b3      	b.n	188e6 <find_info_cb+0x20>

0001897e <bt_att_chan_send>:
{
   1897e:	b508      	push	{r3, lr}
	return chan_send(chan, buf);
   18980:	f7f2 ff28 	bl	b7d4 <chan_send>
}
   18984:	bd08      	pop	{r3, pc}

00018986 <chan_req_send>:
{
   18986:	b570      	push	{r4, r5, r6, lr}
   18988:	4605      	mov	r5, r0
   1898a:	460c      	mov	r4, r1
	if (chan->chan.tx.mtu < net_buf_frags_len(req->buf)) {
   1898c:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
   1898e:	68a3      	ldr	r3, [r4, #8]
	size_t bytes = 0;
   18990:	2200      	movs	r2, #0
	while (buf) {
   18992:	e003      	b.n	1899c <chan_req_send+0x16>
		bytes += buf->len;
   18994:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
   18998:	4462      	add	r2, ip
		buf = buf->frags;
   1899a:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   1899c:	2b00      	cmp	r3, #0
   1899e:	d1f9      	bne.n	18994 <chan_req_send+0xe>
   189a0:	4291      	cmp	r1, r2
   189a2:	d30d      	bcc.n	189c0 <chan_req_send+0x3a>
	chan->req = req;
   189a4:	f8c5 4094 	str.w	r4, [r5, #148]	; 0x94
	buf = req->buf;
   189a8:	68a6      	ldr	r6, [r4, #8]
	req->buf = NULL;
   189aa:	60a3      	str	r3, [r4, #8]
	err = bt_att_chan_send(chan, buf);
   189ac:	4631      	mov	r1, r6
   189ae:	4628      	mov	r0, r5
   189b0:	f7ff ffe5 	bl	1897e <bt_att_chan_send>
	if (err) {
   189b4:	b118      	cbz	r0, 189be <chan_req_send+0x38>
		req->buf = buf;
   189b6:	60a6      	str	r6, [r4, #8]
		chan->req = NULL;
   189b8:	2300      	movs	r3, #0
   189ba:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
}
   189be:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   189c0:	f06f 0079 	mvn.w	r0, #121	; 0x79
   189c4:	e7fb      	b.n	189be <chan_req_send+0x38>

000189c6 <bt_att_chan_req_send>:
{
   189c6:	b508      	push	{r3, lr}
	return chan_req_send(chan, req);
   189c8:	f7ff ffdd 	bl	18986 <chan_req_send>
}
   189cc:	bd08      	pop	{r3, pc}

000189ce <bt_att_status>:
{
   189ce:	b538      	push	{r3, r4, r5, lr}
   189d0:	e8d1 3faf 	lda	r3, [r1]
	if (!atomic_test_bit(status, BT_L2CAP_STATUS_OUT)) {
   189d4:	f013 0f01 	tst.w	r3, #1
   189d8:	d007      	beq.n	189ea <bt_att_status+0x1c>
   189da:	4604      	mov	r4, r0
   189dc:	3804      	subs	r0, #4
	if (!chan->att) {
   189de:	f854 3c04 	ldr.w	r3, [r4, #-4]
   189e2:	b113      	cbz	r3, 189ea <bt_att_status+0x1c>
	if (chan->req) {
   189e4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
   189e8:	b102      	cbz	r2, 189ec <bt_att_status+0x1e>
}
   189ea:	bd38      	pop	{r3, r4, r5, pc}
	return list->head;
   189ec:	685d      	ldr	r5, [r3, #4]
Z_GENLIST_GET(slist, snode)
   189ee:	2d00      	cmp	r5, #0
   189f0:	d0fb      	beq.n	189ea <bt_att_status+0x1c>
	return node->next;
   189f2:	682a      	ldr	r2, [r5, #0]
	list->head = node;
   189f4:	605a      	str	r2, [r3, #4]
	return list->tail;
   189f6:	6899      	ldr	r1, [r3, #8]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   189f8:	428d      	cmp	r5, r1
   189fa:	d00e      	beq.n	18a1a <bt_att_status+0x4c>
	if (bt_att_chan_req_send(chan, ATT_REQ(node)) >= 0) {
   189fc:	4629      	mov	r1, r5
   189fe:	f7ff ffe2 	bl	189c6 <bt_att_chan_req_send>
   18a02:	2800      	cmp	r0, #0
   18a04:	daf1      	bge.n	189ea <bt_att_status+0x1c>
	sys_slist_prepend(&chan->att->reqs, node);
   18a06:	f854 3c04 	ldr.w	r3, [r4, #-4]
	return list->head;
   18a0a:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   18a0c:	602a      	str	r2, [r5, #0]
	list->head = node;
   18a0e:	605d      	str	r5, [r3, #4]
	return list->tail;
   18a10:	689a      	ldr	r2, [r3, #8]
Z_GENLIST_PREPEND(slist, snode)
   18a12:	2a00      	cmp	r2, #0
   18a14:	d1e9      	bne.n	189ea <bt_att_status+0x1c>
	list->tail = node;
   18a16:	609d      	str	r5, [r3, #8]
}
   18a18:	e7e7      	b.n	189ea <bt_att_status+0x1c>
	list->tail = node;
   18a1a:	609a      	str	r2, [r3, #8]
}
   18a1c:	e7ee      	b.n	189fc <bt_att_status+0x2e>

00018a1e <att_req_send_process>:
{
   18a1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18a20:	4607      	mov	r7, r0
	return list->head;
   18a22:	6a45      	ldr	r5, [r0, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   18a24:	b14d      	cbz	r5, 18a3a <att_req_send_process+0x1c>
   18a26:	3de0      	subs	r5, #224	; 0xe0
   18a28:	d00b      	beq.n	18a42 <att_req_send_process+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
   18a2a:	f115 04e0 	adds.w	r4, r5, #224	; 0xe0
   18a2e:	d005      	beq.n	18a3c <att_req_send_process+0x1e>
	return node->next;
   18a30:	f8d5 40e0 	ldr.w	r4, [r5, #224]	; 0xe0
   18a34:	b114      	cbz	r4, 18a3c <att_req_send_process+0x1e>
   18a36:	3ce0      	subs	r4, #224	; 0xe0
   18a38:	e000      	b.n	18a3c <att_req_send_process+0x1e>
   18a3a:	462c      	mov	r4, r5
   18a3c:	2200      	movs	r2, #0
   18a3e:	4616      	mov	r6, r2
   18a40:	e02e      	b.n	18aa0 <att_req_send_process+0x82>
   18a42:	462c      	mov	r4, r5
   18a44:	e7fa      	b.n	18a3c <att_req_send_process+0x1e>
		if (!req && prev &&
   18a46:	b196      	cbz	r6, 18a6e <att_req_send_process+0x50>
		req = get_first_req_matching_chan(&att->reqs, chan);
   18a48:	4629      	mov	r1, r5
   18a4a:	1d38      	adds	r0, r7, #4
   18a4c:	f7ff fccb 	bl	183e6 <get_first_req_matching_chan>
		if (!req) {
   18a50:	4606      	mov	r6, r0
   18a52:	b300      	cbz	r0, 18a96 <att_req_send_process+0x78>
		if (bt_att_chan_req_send(chan, req) >= 0) {
   18a54:	4601      	mov	r1, r0
   18a56:	4628      	mov	r0, r5
   18a58:	f7ff ffb5 	bl	189c6 <bt_att_chan_req_send>
   18a5c:	2800      	cmp	r0, #0
   18a5e:	da2f      	bge.n	18ac0 <att_req_send_process+0xa2>
	return list->head;
   18a60:	687b      	ldr	r3, [r7, #4]
	parent->next = child;
   18a62:	6033      	str	r3, [r6, #0]
	list->head = node;
   18a64:	607e      	str	r6, [r7, #4]
	return list->tail;
   18a66:	68bb      	ldr	r3, [r7, #8]
Z_GENLIST_PREPEND(slist, snode)
   18a68:	b193      	cbz	r3, 18a90 <att_req_send_process+0x72>
		prev = chan;
   18a6a:	462a      	mov	r2, r5
   18a6c:	e01d      	b.n	18aaa <att_req_send_process+0x8c>
		if (!req && prev &&
   18a6e:	2a00      	cmp	r2, #0
   18a70:	d0ea      	beq.n	18a48 <att_req_send_process+0x2a>
		    (atomic_test_bit(chan->flags, ATT_ENHANCED) ==
   18a72:	f105 0390 	add.w	r3, r5, #144	; 0x90
   18a76:	e8d3 3faf 	lda	r3, [r3]
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   18a7a:	f3c3 03c0 	ubfx	r3, r3, #3, #1
		     atomic_test_bit(prev->flags, ATT_ENHANCED))) {
   18a7e:	f102 0190 	add.w	r1, r2, #144	; 0x90
   18a82:	e8d1 1faf 	lda	r1, [r1]
   18a86:	f3c1 01c0 	ubfx	r1, r1, #3, #1
		if (!req && prev &&
   18a8a:	4299      	cmp	r1, r3
   18a8c:	d1dc      	bne.n	18a48 <att_req_send_process+0x2a>
   18a8e:	e00c      	b.n	18aaa <att_req_send_process+0x8c>
	list->tail = node;
   18a90:	60be      	str	r6, [r7, #8]
		prev = chan;
   18a92:	462a      	mov	r2, r5
}
   18a94:	e009      	b.n	18aaa <att_req_send_process+0x8c>
   18a96:	462a      	mov	r2, r5
   18a98:	e007      	b.n	18aaa <att_req_send_process+0x8c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   18a9a:	4623      	mov	r3, r4
   18a9c:	4625      	mov	r5, r4
   18a9e:	461c      	mov	r4, r3
   18aa0:	b175      	cbz	r5, 18ac0 <att_req_send_process+0xa2>
		if (chan->req) {
   18aa2:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
   18aa6:	2b00      	cmp	r3, #0
   18aa8:	d0cd      	beq.n	18a46 <att_req_send_process+0x28>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   18aaa:	2c00      	cmp	r4, #0
   18aac:	d0f5      	beq.n	18a9a <att_req_send_process+0x7c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   18aae:	f114 03e0 	adds.w	r3, r4, #224	; 0xe0
   18ab2:	d0f3      	beq.n	18a9c <att_req_send_process+0x7e>
	return node->next;
   18ab4:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
   18ab8:	2b00      	cmp	r3, #0
   18aba:	d0ef      	beq.n	18a9c <att_req_send_process+0x7e>
   18abc:	3be0      	subs	r3, #224	; 0xe0
   18abe:	e7ed      	b.n	18a9c <att_req_send_process+0x7e>
}
   18ac0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00018ac2 <process_queue>:
{
   18ac2:	b570      	push	{r4, r5, r6, lr}
   18ac4:	4604      	mov	r4, r0
   18ac6:	460d      	mov	r5, r1
	buf = get_first_buf_matching_chan(queue, chan);
   18ac8:	4601      	mov	r1, r0
   18aca:	4628      	mov	r0, r5
   18acc:	f7ff fd6d 	bl	185aa <get_first_buf_matching_chan>
	if (buf) {
   18ad0:	b168      	cbz	r0, 18aee <process_queue+0x2c>
   18ad2:	4606      	mov	r6, r0
		err = bt_att_chan_send(chan, buf);
   18ad4:	4601      	mov	r1, r0
   18ad6:	4620      	mov	r0, r4
   18ad8:	f7ff ff51 	bl	1897e <bt_att_chan_send>
		if (err) {
   18adc:	4604      	mov	r4, r0
   18ade:	b908      	cbnz	r0, 18ae4 <process_queue+0x22>
}
   18ae0:	4620      	mov	r0, r4
   18ae2:	bd70      	pop	{r4, r5, r6, pc}
			k_queue_prepend(&queue->_queue, buf);
   18ae4:	4631      	mov	r1, r6
   18ae6:	4628      	mov	r0, r5
   18ae8:	f003 fb4a 	bl	1c180 <k_queue_prepend>
			return err;
   18aec:	e7f8      	b.n	18ae0 <process_queue+0x1e>
	return -ENOENT;
   18aee:	f06f 0401 	mvn.w	r4, #1
   18af2:	e7f5      	b.n	18ae0 <process_queue+0x1e>

00018af4 <bt_att_sent>:
{
   18af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18af6:	4604      	mov	r4, r0
	struct bt_att_chan *chan = ATT_CHAN(ch);
   18af8:	1f06      	subs	r6, r0, #4
	struct bt_att *att = chan->att;
   18afa:	f850 5c04 	ldr.w	r5, [r0, #-4]
	atomic_clear_bit(chan->flags, ATT_PENDING_SENT);
   18afe:	f100 038c 	add.w	r3, r0, #140	; 0x8c
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   18b02:	e8d3 2fef 	ldaex	r2, [r3]
   18b06:	f022 0210 	bic.w	r2, r2, #16
   18b0a:	e8c3 2fe1 	stlex	r1, r2, [r3]
   18b0e:	2900      	cmp	r1, #0
   18b10:	d1f7      	bne.n	18b02 <bt_att_sent+0xe>
	if (!att) {
   18b12:	b145      	cbz	r5, 18b26 <bt_att_sent+0x32>
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   18b14:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   18b18:	b133      	cbz	r3, 18b28 <bt_att_sent+0x34>
	err = process_queue(chan, &chan->tx_queue);
   18b1a:	f104 0194 	add.w	r1, r4, #148	; 0x94
   18b1e:	4630      	mov	r0, r6
   18b20:	f7ff ffcf 	bl	18ac2 <process_queue>
	if (!err) {
   18b24:	b9c0      	cbnz	r0, 18b58 <bt_att_sent+0x64>
}
   18b26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return list->head;
   18b28:	686f      	ldr	r7, [r5, #4]
	if (!chan->req && !sys_slist_is_empty(&att->reqs)) {
   18b2a:	2f00      	cmp	r7, #0
   18b2c:	d0f5      	beq.n	18b1a <bt_att_sent+0x26>
	return node->next;
   18b2e:	683b      	ldr	r3, [r7, #0]
	list->head = node;
   18b30:	606b      	str	r3, [r5, #4]
	return list->tail;
   18b32:	68aa      	ldr	r2, [r5, #8]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   18b34:	42ba      	cmp	r2, r7
   18b36:	d00d      	beq.n	18b54 <bt_att_sent+0x60>
		if (chan_req_send(chan, ATT_REQ(node)) >= 0) {
   18b38:	4639      	mov	r1, r7
   18b3a:	4630      	mov	r0, r6
   18b3c:	f7ff ff23 	bl	18986 <chan_req_send>
   18b40:	2800      	cmp	r0, #0
   18b42:	daf0      	bge.n	18b26 <bt_att_sent+0x32>
	return list->head;
   18b44:	686b      	ldr	r3, [r5, #4]
	parent->next = child;
   18b46:	603b      	str	r3, [r7, #0]
	list->head = node;
   18b48:	606f      	str	r7, [r5, #4]
	return list->tail;
   18b4a:	68ab      	ldr	r3, [r5, #8]
Z_GENLIST_PREPEND(slist, snode)
   18b4c:	2b00      	cmp	r3, #0
   18b4e:	d1e4      	bne.n	18b1a <bt_att_sent+0x26>
	list->tail = node;
   18b50:	60af      	str	r7, [r5, #8]
}
   18b52:	e7e2      	b.n	18b1a <bt_att_sent+0x26>
	list->tail = node;
   18b54:	60ab      	str	r3, [r5, #8]
}
   18b56:	e7ef      	b.n	18b38 <bt_att_sent+0x44>
	(void)process_queue(chan, &att->tx_queue);
   18b58:	f105 010c 	add.w	r1, r5, #12
   18b5c:	4630      	mov	r0, r6
   18b5e:	f7ff ffb0 	bl	18ac2 <process_queue>
   18b62:	e7e0      	b.n	18b26 <bt_att_sent+0x32>

00018b64 <att_send_process>:
{
   18b64:	b570      	push	{r4, r5, r6, lr}
   18b66:	4606      	mov	r6, r0
	return list->head;
   18b68:	6a45      	ldr	r5, [r0, #36]	; 0x24
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   18b6a:	b14d      	cbz	r5, 18b80 <att_send_process+0x1c>
   18b6c:	3de0      	subs	r5, #224	; 0xe0
   18b6e:	d00b      	beq.n	18b88 <att_send_process+0x24>
Z_GENLIST_PEEK_NEXT(slist, snode)
   18b70:	f115 04e0 	adds.w	r4, r5, #224	; 0xe0
   18b74:	d005      	beq.n	18b82 <att_send_process+0x1e>
	return node->next;
   18b76:	f8d5 40e0 	ldr.w	r4, [r5, #224]	; 0xe0
   18b7a:	b114      	cbz	r4, 18b82 <att_send_process+0x1e>
   18b7c:	3ce0      	subs	r4, #224	; 0xe0
   18b7e:	e000      	b.n	18b82 <att_send_process+0x1e>
   18b80:	462c      	mov	r4, r5
   18b82:	2200      	movs	r2, #0
   18b84:	4611      	mov	r1, r2
   18b86:	e013      	b.n	18bb0 <att_send_process+0x4c>
   18b88:	462c      	mov	r4, r5
   18b8a:	e7fa      	b.n	18b82 <att_send_process+0x1e>
		err = process_queue(chan, &att->tx_queue);
   18b8c:	f106 010c 	add.w	r1, r6, #12
   18b90:	4628      	mov	r0, r5
   18b92:	f7ff ff96 	bl	18ac2 <process_queue>
		if (!err) {
   18b96:	4602      	mov	r2, r0
   18b98:	b310      	cbz	r0, 18be0 <att_send_process+0x7c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   18b9a:	b1fc      	cbz	r4, 18bdc <att_send_process+0x78>
Z_GENLIST_PEEK_NEXT(slist, snode)
   18b9c:	f114 03e0 	adds.w	r3, r4, #224	; 0xe0
   18ba0:	d003      	beq.n	18baa <att_send_process+0x46>
	return node->next;
   18ba2:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
   18ba6:	b103      	cbz	r3, 18baa <att_send_process+0x46>
   18ba8:	3be0      	subs	r3, #224	; 0xe0
   18baa:	4629      	mov	r1, r5
   18bac:	4625      	mov	r5, r4
   18bae:	461c      	mov	r4, r3
   18bb0:	b1b5      	cbz	r5, 18be0 <att_send_process+0x7c>
		if (err == -ENOENT && prev &&
   18bb2:	f112 0f02 	cmn.w	r2, #2
   18bb6:	d1e9      	bne.n	18b8c <att_send_process+0x28>
   18bb8:	2900      	cmp	r1, #0
   18bba:	d0e7      	beq.n	18b8c <att_send_process+0x28>
		    (atomic_test_bit(chan->flags, ATT_ENHANCED) ==
   18bbc:	f105 0390 	add.w	r3, r5, #144	; 0x90
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   18bc0:	e8d3 3faf 	lda	r3, [r3]
   18bc4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
		     atomic_test_bit(prev->flags, ATT_ENHANCED))) {
   18bc8:	f101 0090 	add.w	r0, r1, #144	; 0x90
   18bcc:	e8d0 0faf 	lda	r0, [r0]
   18bd0:	f3c0 00c0 	ubfx	r0, r0, #3, #1
		if (err == -ENOENT && prev &&
   18bd4:	4298      	cmp	r0, r3
   18bd6:	d1d9      	bne.n	18b8c <att_send_process+0x28>
   18bd8:	460d      	mov	r5, r1
   18bda:	e7de      	b.n	18b9a <att_send_process+0x36>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   18bdc:	4623      	mov	r3, r4
   18bde:	e7e4      	b.n	18baa <att_send_process+0x46>
}
   18be0:	bd70      	pop	{r4, r5, r6, pc}

00018be2 <bt_att_chan_send_rsp>:
{
   18be2:	b538      	push	{r3, r4, r5, lr}
   18be4:	4604      	mov	r4, r0
   18be6:	460d      	mov	r5, r1
	err = chan_send(chan, buf);
   18be8:	f7f2 fdf4 	bl	b7d4 <chan_send>
	if (err) {
   18bec:	b900      	cbnz	r0, 18bf0 <bt_att_chan_send_rsp+0xe>
}
   18bee:	bd38      	pop	{r3, r4, r5, pc}
		net_buf_put(&chan->tx_queue, buf);
   18bf0:	4629      	mov	r1, r5
   18bf2:	f104 0098 	add.w	r0, r4, #152	; 0x98
   18bf6:	f001 faaa 	bl	1a14e <net_buf_put>
}
   18bfa:	e7f8      	b.n	18bee <bt_att_chan_send_rsp+0xc>

00018bfc <att_sent>:
{
   18bfc:	b508      	push	{r3, lr}
	struct bt_att_chan *att_chan = data->att_chan;
   18bfe:	680b      	ldr	r3, [r1, #0]
	struct bt_l2cap_chan *chan = &att_chan->chan.chan;
   18c00:	1d18      	adds	r0, r3, #4
	if (chan->ops->sent) {
   18c02:	689b      	ldr	r3, [r3, #8]
   18c04:	695b      	ldr	r3, [r3, #20]
   18c06:	b103      	cbz	r3, 18c0a <att_sent+0xe>
		chan->ops->sent(chan);
   18c08:	4798      	blx	r3
}
   18c0a:	bd08      	pop	{r3, pc}

00018c0c <att_unknown>:
{
   18c0c:	b570      	push	{r4, r5, r6, lr}
   18c0e:	4604      	mov	r4, r0
   18c10:	460d      	mov	r5, r1
	if (!err) {
   18c12:	4616      	mov	r6, r2
   18c14:	b12a      	cbz	r2, 18c22 <att_unknown+0x16>
	chan_unknown(conn, user_data, err);
   18c16:	4632      	mov	r2, r6
   18c18:	4629      	mov	r1, r5
   18c1a:	4620      	mov	r0, r4
   18c1c:	f7f2 fd60 	bl	b6e0 <chan_unknown>
}
   18c20:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   18c22:	f7ff ffeb 	bl	18bfc <att_sent>
   18c26:	e7f6      	b.n	18c16 <att_unknown+0xa>

00018c28 <att_tx_complete>:
{
   18c28:	b570      	push	{r4, r5, r6, lr}
   18c2a:	4604      	mov	r4, r0
   18c2c:	460d      	mov	r5, r1
	if (!err) {
   18c2e:	4616      	mov	r6, r2
   18c30:	b12a      	cbz	r2, 18c3e <att_tx_complete+0x16>
	chan_tx_complete(conn, user_data, err);
   18c32:	4632      	mov	r2, r6
   18c34:	4629      	mov	r1, r5
   18c36:	4620      	mov	r0, r4
   18c38:	f7f2 fda8 	bl	b78c <chan_tx_complete>
}
   18c3c:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   18c3e:	f7ff ffdd 	bl	18bfc <att_sent>
   18c42:	e7f6      	b.n	18c32 <att_tx_complete+0xa>

00018c44 <att_req_sent>:
{
   18c44:	b570      	push	{r4, r5, r6, lr}
   18c46:	4604      	mov	r4, r0
   18c48:	460d      	mov	r5, r1
	if (!err) {
   18c4a:	4616      	mov	r6, r2
   18c4c:	b12a      	cbz	r2, 18c5a <att_req_sent+0x16>
	chan_req_sent(conn, user_data, err);
   18c4e:	4632      	mov	r2, r6
   18c50:	4629      	mov	r1, r5
   18c52:	4620      	mov	r0, r4
   18c54:	f7f2 fd82 	bl	b75c <chan_req_sent>
}
   18c58:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   18c5a:	f7ff ffcf 	bl	18bfc <att_sent>
   18c5e:	e7f6      	b.n	18c4e <att_req_sent+0xa>

00018c60 <att_cfm_sent>:
{
   18c60:	b570      	push	{r4, r5, r6, lr}
   18c62:	4604      	mov	r4, r0
   18c64:	460d      	mov	r5, r1
	if (!err) {
   18c66:	4616      	mov	r6, r2
   18c68:	b12a      	cbz	r2, 18c76 <att_cfm_sent+0x16>
	chan_cfm_sent(conn, user_data, err);
   18c6a:	4632      	mov	r2, r6
   18c6c:	4629      	mov	r1, r5
   18c6e:	4620      	mov	r0, r4
   18c70:	f7f2 fd44 	bl	b6fc <chan_cfm_sent>
}
   18c74:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   18c76:	f7ff ffc1 	bl	18bfc <att_sent>
   18c7a:	e7f6      	b.n	18c6a <att_cfm_sent+0xa>

00018c7c <att_rsp_sent>:
{
   18c7c:	b570      	push	{r4, r5, r6, lr}
   18c7e:	4604      	mov	r4, r0
   18c80:	460d      	mov	r5, r1
	if (!err) {
   18c82:	4616      	mov	r6, r2
   18c84:	b12a      	cbz	r2, 18c92 <att_rsp_sent+0x16>
	chan_rsp_sent(conn, user_data, err);
   18c86:	4632      	mov	r2, r6
   18c88:	4629      	mov	r1, r5
   18c8a:	4620      	mov	r0, r4
   18c8c:	f7f2 fd4e 	bl	b72c <chan_rsp_sent>
}
   18c90:	bd70      	pop	{r4, r5, r6, pc}
		att_sent(conn, user_data);
   18c92:	f7ff ffb3 	bl	18bfc <att_sent>
   18c96:	e7f6      	b.n	18c86 <att_rsp_sent+0xa>

00018c98 <att_indicate>:
{
   18c98:	b538      	push	{r3, r4, r5, lr}
   18c9a:	4605      	mov	r5, r0
   18c9c:	460c      	mov	r4, r1
	return net_buf_simple_pull_le16(&buf->b);
   18c9e:	f101 0008 	add.w	r0, r1, #8
   18ca2:	f001 faec 	bl	1a27e <net_buf_simple_pull_le16>
   18ca6:	4601      	mov	r1, r0
	bt_gatt_notification(chan->att->conn, handle, buf->data, buf->len);
   18ca8:	89a3      	ldrh	r3, [r4, #12]
   18caa:	68a2      	ldr	r2, [r4, #8]
   18cac:	6828      	ldr	r0, [r5, #0]
   18cae:	6800      	ldr	r0, [r0, #0]
   18cb0:	f001 f83a 	bl	19d28 <bt_gatt_notification>
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_CONFIRM, 0);
   18cb4:	2200      	movs	r2, #0
   18cb6:	211e      	movs	r1, #30
   18cb8:	4628      	mov	r0, r5
   18cba:	f7f2 fe03 	bl	b8c4 <bt_att_chan_create_pdu>
	if (!buf) {
   18cbe:	b118      	cbz	r0, 18cc8 <att_indicate+0x30>
   18cc0:	4601      	mov	r1, r0
	bt_att_chan_send_rsp(chan, buf);
   18cc2:	4628      	mov	r0, r5
   18cc4:	f7ff ff8d 	bl	18be2 <bt_att_chan_send_rsp>
}
   18cc8:	2000      	movs	r0, #0
   18cca:	bd38      	pop	{r3, r4, r5, pc}

00018ccc <send_err_rsp>:
	if (!req) {
   18ccc:	b901      	cbnz	r1, 18cd0 <send_err_rsp+0x4>
   18cce:	4770      	bx	lr
{
   18cd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18cd4:	4606      	mov	r6, r0
   18cd6:	4615      	mov	r5, r2
   18cd8:	461c      	mov	r4, r3
   18cda:	460f      	mov	r7, r1
	buf = bt_att_chan_create_pdu(chan, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   18cdc:	2204      	movs	r2, #4
   18cde:	2101      	movs	r1, #1
   18ce0:	f7f2 fdf0 	bl	b8c4 <bt_att_chan_create_pdu>
	if (!buf) {
   18ce4:	4680      	mov	r8, r0
   18ce6:	b158      	cbz	r0, 18d00 <send_err_rsp+0x34>
	return net_buf_simple_add(&buf->b, len);
   18ce8:	2104      	movs	r1, #4
   18cea:	3008      	adds	r0, #8
   18cec:	f001 fa87 	bl	1a1fe <net_buf_simple_add>
	rsp->request = req;
   18cf0:	7007      	strb	r7, [r0, #0]
	rsp->handle = sys_cpu_to_le16(handle);
   18cf2:	f8a0 5001 	strh.w	r5, [r0, #1]
	rsp->error = err;
   18cf6:	70c4      	strb	r4, [r0, #3]
	bt_att_chan_send_rsp(chan, buf);
   18cf8:	4641      	mov	r1, r8
   18cfa:	4630      	mov	r0, r6
   18cfc:	f7ff ff71 	bl	18be2 <bt_att_chan_send_rsp>
}
   18d00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00018d04 <att_write_cmd>:
{
   18d04:	b530      	push	{r4, r5, lr}
   18d06:	b085      	sub	sp, #20
   18d08:	4605      	mov	r5, r0
   18d0a:	460c      	mov	r4, r1
	return net_buf_simple_pull_le16(&buf->b);
   18d0c:	f101 0008 	add.w	r0, r1, #8
   18d10:	f001 fab5 	bl	1a27e <net_buf_simple_pull_le16>
   18d14:	4603      	mov	r3, r0
	return att_write_rsp(chan, 0, 0, handle, 0, buf->data, buf->len);
   18d16:	68a2      	ldr	r2, [r4, #8]
   18d18:	89a1      	ldrh	r1, [r4, #12]
   18d1a:	9102      	str	r1, [sp, #8]
   18d1c:	9201      	str	r2, [sp, #4]
   18d1e:	2100      	movs	r1, #0
   18d20:	9100      	str	r1, [sp, #0]
   18d22:	460a      	mov	r2, r1
   18d24:	4628      	mov	r0, r5
   18d26:	f7f3 f81f 	bl	bd68 <att_write_rsp>
}
   18d2a:	b005      	add	sp, #20
   18d2c:	bd30      	pop	{r4, r5, pc}

00018d2e <att_write_req>:
{
   18d2e:	b530      	push	{r4, r5, lr}
   18d30:	b085      	sub	sp, #20
   18d32:	4605      	mov	r5, r0
   18d34:	460c      	mov	r4, r1
   18d36:	f101 0008 	add.w	r0, r1, #8
   18d3a:	f001 faa0 	bl	1a27e <net_buf_simple_pull_le16>
   18d3e:	4603      	mov	r3, r0
			     handle, 0, buf->data, buf->len);
   18d40:	68a2      	ldr	r2, [r4, #8]
	return att_write_rsp(chan, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   18d42:	89a1      	ldrh	r1, [r4, #12]
   18d44:	9102      	str	r1, [sp, #8]
   18d46:	9201      	str	r2, [sp, #4]
   18d48:	2200      	movs	r2, #0
   18d4a:	9200      	str	r2, [sp, #0]
   18d4c:	2213      	movs	r2, #19
   18d4e:	2112      	movs	r1, #18
   18d50:	4628      	mov	r0, r5
   18d52:	f7f3 f809 	bl	bd68 <att_write_rsp>
}
   18d56:	b005      	add	sp, #20
   18d58:	bd30      	pop	{r4, r5, pc}

00018d5a <att_read_group_req>:
{
   18d5a:	b5f0      	push	{r4, r5, r6, r7, lr}
   18d5c:	b089      	sub	sp, #36	; 0x24
   18d5e:	4605      	mov	r5, r0
   18d60:	4608      	mov	r0, r1
	uint8_t uuid_len = buf->len - sizeof(*req);
   18d62:	7b0c      	ldrb	r4, [r1, #12]
   18d64:	3c04      	subs	r4, #4
   18d66:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
   18d68:	2c02      	cmp	r4, #2
   18d6a:	d001      	beq.n	18d70 <att_read_group_req+0x16>
   18d6c:	2c10      	cmp	r4, #16
   18d6e:	d142      	bne.n	18df6 <att_read_group_req+0x9c>
	return net_buf_simple_pull_mem(&buf->b, len);
   18d70:	2104      	movs	r1, #4
   18d72:	3008      	adds	r0, #8
   18d74:	f001 fa7b 	bl	1a26e <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   18d78:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   18d7a:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   18d7c:	4622      	mov	r2, r4
   18d7e:	1d01      	adds	r1, r0, #4
   18d80:	a801      	add	r0, sp, #4
   18d82:	f7fe fd5b 	bl	1783c <bt_uuid_create>
   18d86:	b3c8      	cbz	r0, 18dfc <att_read_group_req+0xa2>
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   18d88:	f10d 0216 	add.w	r2, sp, #22
   18d8c:	4639      	mov	r1, r7
   18d8e:	4630      	mov	r0, r6
   18d90:	f7ff fb34 	bl	183fc <range_is_valid>
   18d94:	b1f0      	cbz	r0, 18dd4 <att_read_group_req+0x7a>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   18d96:	2300      	movs	r3, #0
   18d98:	f88d 3018 	strb.w	r3, [sp, #24]
   18d9c:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   18da0:	f8ad 301a 	strh.w	r3, [sp, #26]
   18da4:	a906      	add	r1, sp, #24
   18da6:	a801      	add	r0, sp, #4
   18da8:	f7fe fd2a 	bl	17800 <bt_uuid_cmp>
   18dac:	b158      	cbz	r0, 18dc6 <att_read_group_req+0x6c>
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
   18dae:	2300      	movs	r3, #0
   18db0:	f88d 301c 	strb.w	r3, [sp, #28]
   18db4:	f642 0301 	movw	r3, #10241	; 0x2801
   18db8:	f8ad 301e 	strh.w	r3, [sp, #30]
   18dbc:	a907      	add	r1, sp, #28
   18dbe:	a801      	add	r0, sp, #4
   18dc0:	f7fe fd1e 	bl	17800 <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   18dc4:	b978      	cbnz	r0, 18de6 <att_read_group_req+0x8c>
	return att_read_group_rsp(chan, &u.uuid, start_handle, end_handle);
   18dc6:	463b      	mov	r3, r7
   18dc8:	4632      	mov	r2, r6
   18dca:	a901      	add	r1, sp, #4
   18dcc:	4628      	mov	r0, r5
   18dce:	f7f3 f8c3 	bl	bf58 <att_read_group_rsp>
   18dd2:	e011      	b.n	18df8 <att_read_group_req+0x9e>
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, err_handle,
   18dd4:	2301      	movs	r3, #1
   18dd6:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   18dda:	2110      	movs	r1, #16
   18ddc:	4628      	mov	r0, r5
   18dde:	f7ff ff75 	bl	18ccc <send_err_rsp>
		return 0;
   18de2:	2000      	movs	r0, #0
   18de4:	e008      	b.n	18df8 <att_read_group_req+0x9e>
		send_err_rsp(chan, BT_ATT_OP_READ_GROUP_REQ, start_handle,
   18de6:	2310      	movs	r3, #16
   18de8:	4632      	mov	r2, r6
   18dea:	4619      	mov	r1, r3
   18dec:	4628      	mov	r0, r5
   18dee:	f7ff ff6d 	bl	18ccc <send_err_rsp>
		return 0;
   18df2:	2000      	movs	r0, #0
   18df4:	e000      	b.n	18df8 <att_read_group_req+0x9e>
		return BT_ATT_ERR_INVALID_PDU;
   18df6:	2004      	movs	r0, #4
}
   18df8:	b009      	add	sp, #36	; 0x24
   18dfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_ATT_ERR_UNLIKELY;
   18dfc:	200e      	movs	r0, #14
   18dfe:	e7fb      	b.n	18df8 <att_read_group_req+0x9e>

00018e00 <att_read_blob_req>:
{
   18e00:	b500      	push	{lr}
   18e02:	b083      	sub	sp, #12
	req = (void *)buf->data;
   18e04:	688a      	ldr	r2, [r1, #8]
	handle = sys_le16_to_cpu(req->handle);
   18e06:	8813      	ldrh	r3, [r2, #0]
	offset = sys_le16_to_cpu(req->offset);
   18e08:	8852      	ldrh	r2, [r2, #2]
	return att_read_rsp(chan, BT_ATT_OP_READ_BLOB_REQ,
   18e0a:	9200      	str	r2, [sp, #0]
   18e0c:	220d      	movs	r2, #13
   18e0e:	210c      	movs	r1, #12
   18e10:	f7f3 f9c0 	bl	c194 <att_read_rsp>
}
   18e14:	b003      	add	sp, #12
   18e16:	f85d fb04 	ldr.w	pc, [sp], #4

00018e1a <att_read_req>:
{
   18e1a:	b500      	push	{lr}
   18e1c:	b083      	sub	sp, #12
	req = (void *)buf->data;
   18e1e:	688b      	ldr	r3, [r1, #8]
	handle = sys_le16_to_cpu(req->handle);
   18e20:	881b      	ldrh	r3, [r3, #0]
	return att_read_rsp(chan, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   18e22:	2200      	movs	r2, #0
   18e24:	9200      	str	r2, [sp, #0]
   18e26:	220b      	movs	r2, #11
   18e28:	210a      	movs	r1, #10
   18e2a:	f7f3 f9b3 	bl	c194 <att_read_rsp>
}
   18e2e:	b003      	add	sp, #12
   18e30:	f85d fb04 	ldr.w	pc, [sp], #4

00018e34 <att_read_type_req>:
{
   18e34:	b5f0      	push	{r4, r5, r6, r7, lr}
   18e36:	b087      	sub	sp, #28
   18e38:	4605      	mov	r5, r0
   18e3a:	4608      	mov	r0, r1
	uint8_t uuid_len = buf->len - sizeof(*req);
   18e3c:	7b0c      	ldrb	r4, [r1, #12]
   18e3e:	3c04      	subs	r4, #4
   18e40:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
   18e42:	2c02      	cmp	r4, #2
   18e44:	d001      	beq.n	18e4a <att_read_type_req+0x16>
   18e46:	2c10      	cmp	r4, #16
   18e48:	d123      	bne.n	18e92 <att_read_type_req+0x5e>
   18e4a:	2104      	movs	r1, #4
   18e4c:	3008      	adds	r0, #8
   18e4e:	f001 fa0e 	bl	1a26e <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   18e52:	8806      	ldrh	r6, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   18e54:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   18e56:	4622      	mov	r2, r4
   18e58:	1d01      	adds	r1, r0, #4
   18e5a:	a801      	add	r0, sp, #4
   18e5c:	f7fe fcee 	bl	1783c <bt_uuid_create>
   18e60:	b1c8      	cbz	r0, 18e96 <att_read_type_req+0x62>
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   18e62:	f10d 0216 	add.w	r2, sp, #22
   18e66:	4639      	mov	r1, r7
   18e68:	4630      	mov	r0, r6
   18e6a:	f7ff fac7 	bl	183fc <range_is_valid>
   18e6e:	b138      	cbz	r0, 18e80 <att_read_type_req+0x4c>
	return att_read_type_rsp(chan, &u.uuid, start_handle, end_handle);
   18e70:	463b      	mov	r3, r7
   18e72:	4632      	mov	r2, r6
   18e74:	a901      	add	r1, sp, #4
   18e76:	4628      	mov	r0, r5
   18e78:	f7f3 f9f4 	bl	c264 <att_read_type_rsp>
}
   18e7c:	b007      	add	sp, #28
   18e7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		send_err_rsp(chan, BT_ATT_OP_READ_TYPE_REQ, err_handle,
   18e80:	2301      	movs	r3, #1
   18e82:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   18e86:	2108      	movs	r1, #8
   18e88:	4628      	mov	r0, r5
   18e8a:	f7ff ff1f 	bl	18ccc <send_err_rsp>
		return 0;
   18e8e:	2000      	movs	r0, #0
   18e90:	e7f4      	b.n	18e7c <att_read_type_req+0x48>
		return BT_ATT_ERR_INVALID_PDU;
   18e92:	2004      	movs	r0, #4
   18e94:	e7f2      	b.n	18e7c <att_read_type_req+0x48>
		return BT_ATT_ERR_UNLIKELY;
   18e96:	200e      	movs	r0, #14
   18e98:	e7f0      	b.n	18e7c <att_read_type_req+0x48>

00018e9a <att_find_type_req>:
{
   18e9a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   18e9e:	b087      	sub	sp, #28
   18ea0:	4607      	mov	r7, r0
   18ea2:	460c      	mov	r4, r1
   18ea4:	2106      	movs	r1, #6
   18ea6:	f104 0008 	add.w	r0, r4, #8
   18eaa:	f001 f9e0 	bl	1a26e <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   18eae:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   18eb0:	8846      	ldrh	r6, [r0, #2]
	type = sys_le16_to_cpu(req->type);
   18eb2:	f8b0 8004 	ldrh.w	r8, [r0, #4]
	value = buf->data;
   18eb6:	f8d4 9008 	ldr.w	r9, [r4, #8]
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   18eba:	f10d 020e 	add.w	r2, sp, #14
   18ebe:	4631      	mov	r1, r6
   18ec0:	4628      	mov	r0, r5
   18ec2:	f7ff fa9b 	bl	183fc <range_is_valid>
   18ec6:	b1d0      	cbz	r0, 18efe <att_find_type_req+0x64>
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   18ec8:	2300      	movs	r3, #0
   18eca:	f88d 3010 	strb.w	r3, [sp, #16]
   18ece:	f8ad 8012 	strh.w	r8, [sp, #18]
   18ed2:	f88d 3014 	strb.w	r3, [sp, #20]
   18ed6:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   18eda:	f8ad 3016 	strh.w	r3, [sp, #22]
   18ede:	a905      	add	r1, sp, #20
   18ee0:	a804      	add	r0, sp, #16
   18ee2:	f7fe fc8d 	bl	17800 <bt_uuid_cmp>
   18ee6:	b998      	cbnz	r0, 18f10 <att_find_type_req+0x76>
	return att_find_type_rsp(chan, start_handle, end_handle, value,
   18ee8:	7b23      	ldrb	r3, [r4, #12]
   18eea:	9300      	str	r3, [sp, #0]
   18eec:	464b      	mov	r3, r9
   18eee:	4632      	mov	r2, r6
   18ef0:	4629      	mov	r1, r5
   18ef2:	4638      	mov	r0, r7
   18ef4:	f7f3 fa0a 	bl	c30c <att_find_type_rsp>
}
   18ef8:	b007      	add	sp, #28
   18efa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, err_handle,
   18efe:	2301      	movs	r3, #1
   18f00:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   18f04:	2106      	movs	r1, #6
   18f06:	4638      	mov	r0, r7
   18f08:	f7ff fee0 	bl	18ccc <send_err_rsp>
		return 0;
   18f0c:	2000      	movs	r0, #0
   18f0e:	e7f3      	b.n	18ef8 <att_find_type_req+0x5e>
		send_err_rsp(chan, BT_ATT_OP_FIND_TYPE_REQ, start_handle,
   18f10:	230a      	movs	r3, #10
   18f12:	462a      	mov	r2, r5
   18f14:	2106      	movs	r1, #6
   18f16:	4638      	mov	r0, r7
   18f18:	f7ff fed8 	bl	18ccc <send_err_rsp>
		return 0;
   18f1c:	2000      	movs	r0, #0
   18f1e:	e7eb      	b.n	18ef8 <att_find_type_req+0x5e>

00018f20 <att_find_info_req>:
{
   18f20:	b570      	push	{r4, r5, r6, lr}
   18f22:	b082      	sub	sp, #8
   18f24:	4604      	mov	r4, r0
	req = (void *)buf->data;
   18f26:	688b      	ldr	r3, [r1, #8]
	start_handle = sys_le16_to_cpu(req->start_handle);
   18f28:	881d      	ldrh	r5, [r3, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   18f2a:	885e      	ldrh	r6, [r3, #2]
	if (!range_is_valid(start_handle, end_handle, &err_handle)) {
   18f2c:	f10d 0206 	add.w	r2, sp, #6
   18f30:	4631      	mov	r1, r6
   18f32:	4628      	mov	r0, r5
   18f34:	f7ff fa62 	bl	183fc <range_is_valid>
   18f38:	b130      	cbz	r0, 18f48 <att_find_info_req+0x28>
	return att_find_info_rsp(chan, start_handle, end_handle);
   18f3a:	4632      	mov	r2, r6
   18f3c:	4629      	mov	r1, r5
   18f3e:	4620      	mov	r0, r4
   18f40:	f7f3 fa38 	bl	c3b4 <att_find_info_rsp>
}
   18f44:	b002      	add	sp, #8
   18f46:	bd70      	pop	{r4, r5, r6, pc}
		send_err_rsp(chan, BT_ATT_OP_FIND_INFO_REQ, err_handle,
   18f48:	2301      	movs	r3, #1
   18f4a:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   18f4e:	2104      	movs	r1, #4
   18f50:	4620      	mov	r0, r4
   18f52:	f7ff febb 	bl	18ccc <send_err_rsp>
		return 0;
   18f56:	2000      	movs	r0, #0
   18f58:	e7f4      	b.n	18f44 <att_find_info_req+0x24>

00018f5a <att_mtu_req>:
{
   18f5a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = chan->att->conn;
   18f5e:	4603      	mov	r3, r0
   18f60:	f853 2b90 	ldr.w	r2, [r3], #144
   18f64:	6817      	ldr	r7, [r2, #0]
   18f66:	e8d3 3faf 	lda	r3, [r3]
	if (atomic_test_bit(chan->flags, ATT_ENHANCED)) {
   18f6a:	f013 0f08 	tst.w	r3, #8
   18f6e:	d12b      	bne.n	18fc8 <att_mtu_req+0x6e>
   18f70:	4604      	mov	r4, r0
	req = (void *)buf->data;
   18f72:	688b      	ldr	r3, [r1, #8]
	mtu_client = sys_le16_to_cpu(req->mtu);
   18f74:	881e      	ldrh	r6, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   18f76:	2e16      	cmp	r6, #22
   18f78:	d928      	bls.n	18fcc <att_mtu_req+0x72>
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   18f7a:	2202      	movs	r2, #2
   18f7c:	2103      	movs	r1, #3
   18f7e:	4638      	mov	r0, r7
   18f80:	f7f2 ff72 	bl	be68 <bt_att_create_pdu>
	if (!pdu) {
   18f84:	4680      	mov	r8, r0
   18f86:	b318      	cbz	r0, 18fd0 <att_mtu_req+0x76>
	return net_buf_simple_add(&buf->b, len);
   18f88:	2102      	movs	r1, #2
   18f8a:	3008      	adds	r0, #8
   18f8c:	f001 f937 	bl	1a1fe <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   18f90:	2500      	movs	r5, #0
   18f92:	2317      	movs	r3, #23
   18f94:	7003      	strb	r3, [r0, #0]
   18f96:	7045      	strb	r5, [r0, #1]
	bt_att_chan_send_rsp(chan, pdu);
   18f98:	4641      	mov	r1, r8
   18f9a:	4620      	mov	r0, r4
   18f9c:	f7ff fe21 	bl	18be2 <bt_att_chan_send_rsp>
	chan->chan.rx.mtu = MIN(mtu_client, mtu_server);
   18fa0:	2e17      	cmp	r6, #23
   18fa2:	bf28      	it	cs
   18fa4:	2617      	movcs	r6, #23
   18fa6:	8366      	strh	r6, [r4, #26]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   18fa8:	8566      	strh	r6, [r4, #42]	; 0x2a
	atomic_set_bit(conn->flags, BT_CONN_ATT_MTU_EXCHANGED);
   18faa:	3704      	adds	r7, #4
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   18fac:	e8d7 3fef 	ldaex	r3, [r7]
   18fb0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   18fb4:	e8c7 3fe2 	stlex	r2, r3, [r7]
   18fb8:	2a00      	cmp	r2, #0
   18fba:	d1f7      	bne.n	18fac <att_mtu_req+0x52>
	att_chan_mtu_updated(chan);
   18fbc:	4620      	mov	r0, r4
   18fbe:	f7ff fb13 	bl	185e8 <att_chan_mtu_updated>
	return 0;
   18fc2:	4628      	mov	r0, r5
}
   18fc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_NOT_SUPPORTED;
   18fc8:	2006      	movs	r0, #6
   18fca:	e7fb      	b.n	18fc4 <att_mtu_req+0x6a>
		return BT_ATT_ERR_INVALID_PDU;
   18fcc:	2004      	movs	r0, #4
   18fce:	e7f9      	b.n	18fc4 <att_mtu_req+0x6a>
		return BT_ATT_ERR_UNLIKELY;
   18fd0:	200e      	movs	r0, #14
   18fd2:	e7f7      	b.n	18fc4 <att_mtu_req+0x6a>

00018fd4 <att_handle_exec_write_rsp>:
{
   18fd4:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   18fd6:	2300      	movs	r3, #0
   18fd8:	898a      	ldrh	r2, [r1, #12]
   18fda:	6889      	ldr	r1, [r1, #8]
   18fdc:	f7f3 fa88 	bl	c4f0 <att_handle_rsp>
}
   18fe0:	bd08      	pop	{r3, pc}

00018fe2 <att_handle_prepare_write_rsp>:
{
   18fe2:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   18fe4:	2300      	movs	r3, #0
   18fe6:	898a      	ldrh	r2, [r1, #12]
   18fe8:	6889      	ldr	r1, [r1, #8]
   18fea:	f7f3 fa81 	bl	c4f0 <att_handle_rsp>
}
   18fee:	bd08      	pop	{r3, pc}

00018ff0 <att_handle_write_rsp>:
{
   18ff0:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   18ff2:	2300      	movs	r3, #0
   18ff4:	898a      	ldrh	r2, [r1, #12]
   18ff6:	6889      	ldr	r1, [r1, #8]
   18ff8:	f7f3 fa7a 	bl	c4f0 <att_handle_rsp>
}
   18ffc:	bd08      	pop	{r3, pc}

00018ffe <att_handle_read_group_rsp>:
{
   18ffe:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   19000:	2300      	movs	r3, #0
   19002:	898a      	ldrh	r2, [r1, #12]
   19004:	6889      	ldr	r1, [r1, #8]
   19006:	f7f3 fa73 	bl	c4f0 <att_handle_rsp>
}
   1900a:	bd08      	pop	{r3, pc}

0001900c <att_handle_read_mult_vl_rsp>:
{
   1900c:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   1900e:	2300      	movs	r3, #0
   19010:	898a      	ldrh	r2, [r1, #12]
   19012:	6889      	ldr	r1, [r1, #8]
   19014:	f7f3 fa6c 	bl	c4f0 <att_handle_rsp>
}
   19018:	bd08      	pop	{r3, pc}

0001901a <att_handle_read_mult_rsp>:
{
   1901a:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   1901c:	2300      	movs	r3, #0
   1901e:	898a      	ldrh	r2, [r1, #12]
   19020:	6889      	ldr	r1, [r1, #8]
   19022:	f7f3 fa65 	bl	c4f0 <att_handle_rsp>
}
   19026:	bd08      	pop	{r3, pc}

00019028 <att_handle_read_blob_rsp>:
{
   19028:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   1902a:	2300      	movs	r3, #0
   1902c:	898a      	ldrh	r2, [r1, #12]
   1902e:	6889      	ldr	r1, [r1, #8]
   19030:	f7f3 fa5e 	bl	c4f0 <att_handle_rsp>
}
   19034:	bd08      	pop	{r3, pc}

00019036 <att_handle_read_rsp>:
{
   19036:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   19038:	2300      	movs	r3, #0
   1903a:	898a      	ldrh	r2, [r1, #12]
   1903c:	6889      	ldr	r1, [r1, #8]
   1903e:	f7f3 fa57 	bl	c4f0 <att_handle_rsp>
}
   19042:	bd08      	pop	{r3, pc}

00019044 <att_handle_read_type_rsp>:
{
   19044:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   19046:	2300      	movs	r3, #0
   19048:	898a      	ldrh	r2, [r1, #12]
   1904a:	6889      	ldr	r1, [r1, #8]
   1904c:	f7f3 fa50 	bl	c4f0 <att_handle_rsp>
}
   19050:	bd08      	pop	{r3, pc}

00019052 <att_handle_find_type_rsp>:
{
   19052:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   19054:	2300      	movs	r3, #0
   19056:	898a      	ldrh	r2, [r1, #12]
   19058:	6889      	ldr	r1, [r1, #8]
   1905a:	f7f3 fa49 	bl	c4f0 <att_handle_rsp>
}
   1905e:	bd08      	pop	{r3, pc}

00019060 <att_handle_find_info_rsp>:
{
   19060:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   19062:	2300      	movs	r3, #0
   19064:	898a      	ldrh	r2, [r1, #12]
   19066:	6889      	ldr	r1, [r1, #8]
   19068:	f7f3 fa42 	bl	c4f0 <att_handle_rsp>
}
   1906c:	bd08      	pop	{r3, pc}

0001906e <att_mtu_rsp>:
{
   1906e:	b570      	push	{r4, r5, r6, lr}
   19070:	4604      	mov	r4, r0
	rsp = (void *)buf->data;
   19072:	688e      	ldr	r6, [r1, #8]
	mtu = sys_le16_to_cpu(rsp->mtu);
   19074:	8833      	ldrh	r3, [r6, #0]
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   19076:	2b16      	cmp	r3, #22
   19078:	d90e      	bls.n	19098 <att_mtu_rsp+0x2a>
   1907a:	460d      	mov	r5, r1
	chan->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   1907c:	2b17      	cmp	r3, #23
   1907e:	bf28      	it	cs
   19080:	2317      	movcs	r3, #23
   19082:	8343      	strh	r3, [r0, #26]
	chan->chan.tx.mtu = chan->chan.rx.mtu;
   19084:	8543      	strh	r3, [r0, #42]	; 0x2a
	att_chan_mtu_updated(chan);
   19086:	f7ff faaf 	bl	185e8 <att_chan_mtu_updated>
	return att_handle_rsp(chan, rsp, buf->len, 0);
   1908a:	2300      	movs	r3, #0
   1908c:	89aa      	ldrh	r2, [r5, #12]
   1908e:	4631      	mov	r1, r6
   19090:	4620      	mov	r0, r4
   19092:	f7f3 fa2d 	bl	c4f0 <att_handle_rsp>
}
   19096:	bd70      	pop	{r4, r5, r6, pc}
		return att_handle_rsp(chan, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   19098:	2304      	movs	r3, #4
   1909a:	2200      	movs	r2, #0
   1909c:	4611      	mov	r1, r2
   1909e:	f7f3 fa27 	bl	c4f0 <att_handle_rsp>
   190a2:	e7f8      	b.n	19096 <att_mtu_rsp+0x28>

000190a4 <att_confirm>:
{
   190a4:	b508      	push	{r3, lr}
	return att_handle_rsp(chan, buf->data, buf->len, 0);
   190a6:	2300      	movs	r3, #0
   190a8:	898a      	ldrh	r2, [r1, #12]
   190aa:	6889      	ldr	r1, [r1, #8]
   190ac:	f7f3 fa20 	bl	c4f0 <att_handle_rsp>
}
   190b0:	bd08      	pop	{r3, pc}

000190b2 <bt_att_disconnected>:
{
   190b2:	b538      	push	{r3, r4, r5, lr}
   190b4:	4604      	mov	r4, r0
	struct bt_att *att = att_chan->att;
   190b6:	f850 5c04 	ldr.w	r5, [r0, #-4]
	if (!att_chan->att) {
   190ba:	b125      	cbz	r5, 190c6 <bt_att_disconnected+0x14>
   190bc:	3804      	subs	r0, #4
	att_chan_detach(att_chan);
   190be:	f7f3 fa8d 	bl	c5dc <att_chan_detach>
	return list->head;
   190c2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	if (!sys_slist_is_empty(&att->chans)) {
   190c4:	b103      	cbz	r3, 190c8 <bt_att_disconnected+0x16>
}
   190c6:	bd38      	pop	{r3, r4, r5, pc}
	att_reset(att);
   190c8:	4628      	mov	r0, r5
   190ca:	f7f3 fad1 	bl	c670 <att_reset>
	bt_gatt_disconnected(le_chan->chan.conn);
   190ce:	6820      	ldr	r0, [r4, #0]
   190d0:	f7f4 fd4a 	bl	db68 <bt_gatt_disconnected>
   190d4:	e7f7      	b.n	190c6 <bt_att_disconnected+0x14>

000190d6 <bt_att_req_send>:
{
   190d6:	b510      	push	{r4, lr}
   190d8:	460c      	mov	r4, r1
	att = att_get(conn);
   190da:	f7f1 ff49 	bl	af70 <att_get>
	if (!att) {
   190de:	b170      	cbz	r0, 190fe <bt_att_req_send+0x28>
   190e0:	4603      	mov	r3, r0
	parent->next = child;
   190e2:	2200      	movs	r2, #0
   190e4:	6022      	str	r2, [r4, #0]
	return list->tail;
   190e6:	6882      	ldr	r2, [r0, #8]
Z_GENLIST_APPEND(slist, snode)
   190e8:	b132      	cbz	r2, 190f8 <bt_att_req_send+0x22>
	parent->next = child;
   190ea:	6014      	str	r4, [r2, #0]
	list->tail = node;
   190ec:	6084      	str	r4, [r0, #8]
	att_req_send_process(att);
   190ee:	4618      	mov	r0, r3
   190f0:	f7ff fc95 	bl	18a1e <att_req_send_process>
	return 0;
   190f4:	2000      	movs	r0, #0
}
   190f6:	bd10      	pop	{r4, pc}
   190f8:	6084      	str	r4, [r0, #8]
	list->head = node;
   190fa:	6044      	str	r4, [r0, #4]
}
   190fc:	e7f7      	b.n	190ee <bt_att_req_send+0x18>
		return -ENOTCONN;
   190fe:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   19102:	e7f8      	b.n	190f6 <bt_att_req_send+0x20>

00019104 <bt_att_req_cancel>:
	struct bt_att *att;
	struct bt_att_chan *chan, *tmp;

	BT_DBG("req %p", req);

	if (!conn || !req) {
   19104:	2800      	cmp	r0, #0
   19106:	d048      	beq.n	1919a <bt_att_req_cancel+0x96>
{
   19108:	b570      	push	{r4, r5, r6, lr}
   1910a:	460d      	mov	r5, r1
	if (!conn || !req) {
   1910c:	2900      	cmp	r1, #0
   1910e:	d03a      	beq.n	19186 <bt_att_req_cancel+0x82>
		return;
	}

	att = att_get(conn);
   19110:	f7f1 ff2e 	bl	af70 <att_get>
	if (!att) {
   19114:	4606      	mov	r6, r0
   19116:	2800      	cmp	r0, #0
   19118:	d035      	beq.n	19186 <bt_att_req_cancel+0x82>
	return list->head;
   1911a:	6a40      	ldr	r0, [r0, #36]	; 0x24
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1911c:	b148      	cbz	r0, 19132 <bt_att_req_cancel+0x2e>
   1911e:	38e0      	subs	r0, #224	; 0xe0
   19120:	d009      	beq.n	19136 <bt_att_req_cancel+0x32>
Z_GENLIST_PEEK_NEXT(slist, snode)
   19122:	f110 04e0 	adds.w	r4, r0, #224	; 0xe0
   19126:	d00b      	beq.n	19140 <bt_att_req_cancel+0x3c>
	return node->next;
   19128:	f8d0 40e0 	ldr.w	r4, [r0, #224]	; 0xe0
   1912c:	b144      	cbz	r4, 19140 <bt_att_req_cancel+0x3c>
   1912e:	3ce0      	subs	r4, #224	; 0xe0
   19130:	e006      	b.n	19140 <bt_att_req_cancel+0x3c>
   19132:	4604      	mov	r4, r0
   19134:	e004      	b.n	19140 <bt_att_req_cancel+0x3c>
   19136:	4604      	mov	r4, r0
   19138:	e002      	b.n	19140 <bt_att_req_cancel+0x3c>
   1913a:	4623      	mov	r3, r4
   1913c:	4620      	mov	r0, r4
   1913e:	461c      	mov	r4, r3
   19140:	b170      	cbz	r0, 19160 <bt_att_req_cancel+0x5c>
		/* Check if request is outstanding */
		if (bt_att_chan_req_cancel(chan, req)) {
   19142:	4629      	mov	r1, r5
   19144:	f7f3 fb06 	bl	c754 <bt_att_chan_req_cancel>
   19148:	b9e8      	cbnz	r0, 19186 <bt_att_req_cancel+0x82>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->chans, chan, tmp, node) {
   1914a:	2c00      	cmp	r4, #0
   1914c:	d0f5      	beq.n	1913a <bt_att_req_cancel+0x36>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1914e:	f114 03e0 	adds.w	r3, r4, #224	; 0xe0
   19152:	d0f3      	beq.n	1913c <bt_att_req_cancel+0x38>
	return node->next;
   19154:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
   19158:	2b00      	cmp	r3, #0
   1915a:	d0ef      	beq.n	1913c <bt_att_req_cancel+0x38>
   1915c:	3be0      	subs	r3, #224	; 0xe0
   1915e:	e7ed      	b.n	1913c <bt_att_req_cancel+0x38>
			return;
		}
	}

	/* Remove request from the list */
	sys_slist_find_and_remove(&att->reqs, &req->node);
   19160:	1d32      	adds	r2, r6, #4
	return list->head;
   19162:	6873      	ldr	r3, [r6, #4]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   19164:	b163      	cbz	r3, 19180 <bt_att_req_cancel+0x7c>
   19166:	429d      	cmp	r5, r3
   19168:	d002      	beq.n	19170 <bt_att_req_cancel+0x6c>
   1916a:	4618      	mov	r0, r3
   1916c:	681b      	ldr	r3, [r3, #0]
   1916e:	e7f9      	b.n	19164 <bt_att_req_cancel+0x60>
Z_GENLIST_REMOVE(slist, snode)
   19170:	b150      	cbz	r0, 19188 <bt_att_req_cancel+0x84>
	return node->next;
   19172:	682b      	ldr	r3, [r5, #0]
	parent->next = child;
   19174:	6003      	str	r3, [r0, #0]
	return list->tail;
   19176:	6853      	ldr	r3, [r2, #4]
Z_GENLIST_REMOVE(slist, snode)
   19178:	429d      	cmp	r5, r3
   1917a:	d00c      	beq.n	19196 <bt_att_req_cancel+0x92>
	parent->next = child;
   1917c:	2300      	movs	r3, #0
   1917e:	602b      	str	r3, [r5, #0]

	bt_att_req_free(req);
   19180:	4628      	mov	r0, r5
   19182:	f7f3 f995 	bl	c4b0 <bt_att_req_free>
}
   19186:	bd70      	pop	{r4, r5, r6, pc}
	return node->next;
   19188:	682b      	ldr	r3, [r5, #0]
	list->head = node;
   1918a:	6073      	str	r3, [r6, #4]
	return list->tail;
   1918c:	6851      	ldr	r1, [r2, #4]
Z_GENLIST_REMOVE(slist, snode)
   1918e:	428d      	cmp	r5, r1
   19190:	d1f4      	bne.n	1917c <bt_att_req_cancel+0x78>
	list->tail = node;
   19192:	6053      	str	r3, [r2, #4]
}
   19194:	e7f2      	b.n	1917c <bt_att_req_cancel+0x78>
	list->tail = node;
   19196:	6050      	str	r0, [r2, #4]
}
   19198:	e7f0      	b.n	1917c <bt_att_req_cancel+0x78>
   1919a:	4770      	bx	lr

0001919c <bt_att_find_req_by_user_data>:

struct bt_att_req *bt_att_find_req_by_user_data(struct bt_conn *conn, const void *user_data)
{
   1919c:	b510      	push	{r4, lr}
   1919e:	460c      	mov	r4, r1
	struct bt_att *att;
	struct bt_att_chan *chan;
	struct bt_att_req *req;

	att = att_get(conn);
   191a0:	f7f1 fee6 	bl	af70 <att_get>
	if (!att) {
   191a4:	4601      	mov	r1, r0
   191a6:	b1f8      	cbz	r0, 191e8 <bt_att_find_req_by_user_data+0x4c>
	return list->head;
   191a8:	6a43      	ldr	r3, [r0, #36]	; 0x24
		return NULL;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   191aa:	b113      	cbz	r3, 191b2 <bt_att_find_req_by_user_data+0x16>
   191ac:	3be0      	subs	r3, #224	; 0xe0
   191ae:	e000      	b.n	191b2 <bt_att_find_req_by_user_data+0x16>
   191b0:	4613      	mov	r3, r2
   191b2:	b163      	cbz	r3, 191ce <bt_att_find_req_by_user_data+0x32>
		if (chan->req->user_data == user_data) {
   191b4:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
   191b8:	68c2      	ldr	r2, [r0, #12]
   191ba:	42a2      	cmp	r2, r4
   191bc:	d014      	beq.n	191e8 <bt_att_find_req_by_user_data+0x4c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   191be:	f113 02e0 	adds.w	r2, r3, #224	; 0xe0
   191c2:	d0f5      	beq.n	191b0 <bt_att_find_req_by_user_data+0x14>
	return node->next;
   191c4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   191c8:	b10b      	cbz	r3, 191ce <bt_att_find_req_by_user_data+0x32>
   191ca:	3be0      	subs	r3, #224	; 0xe0
   191cc:	e7f1      	b.n	191b2 <bt_att_find_req_by_user_data+0x16>
	return list->head;
   191ce:	684b      	ldr	r3, [r1, #4]
			return chan->req;
		}
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->reqs, req, node) {
   191d0:	b14b      	cbz	r3, 191e6 <bt_att_find_req_by_user_data+0x4a>
		if (req->user_data == user_data) {
   191d2:	68da      	ldr	r2, [r3, #12]
   191d4:	42a2      	cmp	r2, r4
   191d6:	d008      	beq.n	191ea <bt_att_find_req_by_user_data+0x4e>
	SYS_SLIST_FOR_EACH_CONTAINER(&att->reqs, req, node) {
   191d8:	4618      	mov	r0, r3
Z_GENLIST_PEEK_NEXT(slist, snode)
   191da:	b12b      	cbz	r3, 191e8 <bt_att_find_req_by_user_data+0x4c>
	return node->next;
   191dc:	681b      	ldr	r3, [r3, #0]
   191de:	2b00      	cmp	r3, #0
   191e0:	d1f6      	bne.n	191d0 <bt_att_find_req_by_user_data+0x34>
			return req;
		}
	}

	return NULL;
   191e2:	4618      	mov	r0, r3
   191e4:	e000      	b.n	191e8 <bt_att_find_req_by_user_data+0x4c>
   191e6:	4618      	mov	r0, r3
}
   191e8:	bd10      	pop	{r4, pc}
   191ea:	4618      	mov	r0, r3
   191ec:	e7fc      	b.n	191e8 <bt_att_find_req_by_user_data+0x4c>

000191ee <bt_att_fixed_chan_only>:
#if defined(CONFIG_BT_EATT)
	return bt_eatt_count(conn) == 0;
#else
	return true;
#endif /* CONFIG_BT_EATT */
}
   191ee:	2001      	movs	r0, #1
   191f0:	4770      	bx	lr

000191f2 <bt_att_clear_out_of_sync_sent>:

void bt_att_clear_out_of_sync_sent(struct bt_conn *conn)
{
   191f2:	b508      	push	{r3, lr}
	struct bt_att *att = att_get(conn);
   191f4:	f7f1 febc 	bl	af70 <att_get>
	struct bt_att_chan *chan;

	if (!att) {
   191f8:	b1b8      	cbz	r0, 1922a <bt_att_clear_out_of_sync_sent+0x38>
	return list->head;
   191fa:	6a43      	ldr	r3, [r0, #36]	; 0x24
		return;
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   191fc:	b113      	cbz	r3, 19204 <bt_att_clear_out_of_sync_sent+0x12>
   191fe:	3be0      	subs	r3, #224	; 0xe0
   19200:	e000      	b.n	19204 <bt_att_clear_out_of_sync_sent+0x12>
   19202:	4613      	mov	r3, r2
   19204:	b18b      	cbz	r3, 1922a <bt_att_clear_out_of_sync_sent+0x38>
		atomic_clear_bit(chan->flags, ATT_OUT_OF_SYNC_SENT);
   19206:	f103 0290 	add.w	r2, r3, #144	; 0x90
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1920a:	e8d2 1fef 	ldaex	r1, [r2]
   1920e:	f021 0120 	bic.w	r1, r1, #32
   19212:	e8c2 1fe0 	stlex	r0, r1, [r2]
   19216:	2800      	cmp	r0, #0
   19218:	d1f7      	bne.n	1920a <bt_att_clear_out_of_sync_sent+0x18>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1921a:	f113 02e0 	adds.w	r2, r3, #224	; 0xe0
   1921e:	d0f0      	beq.n	19202 <bt_att_clear_out_of_sync_sent+0x10>
	return node->next;
   19220:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
	SYS_SLIST_FOR_EACH_CONTAINER(&att->chans, chan, node) {
   19224:	b10b      	cbz	r3, 1922a <bt_att_clear_out_of_sync_sent+0x38>
   19226:	3be0      	subs	r3, #224	; 0xe0
   19228:	e7ec      	b.n	19204 <bt_att_clear_out_of_sync_sent+0x12>
	}
}
   1922a:	bd08      	pop	{r3, pc}

0001922c <bt_att_out_of_sync_sent_on_fixed>:

bool bt_att_out_of_sync_sent_on_fixed(struct bt_conn *conn)
{
   1922c:	b508      	push	{r3, lr}
	struct bt_l2cap_chan *l2cap_chan;
	struct bt_att_chan *att_chan;

	l2cap_chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   1922e:	2104      	movs	r1, #4
   19230:	f7ff f89a 	bl	18368 <bt_l2cap_le_lookup_rx_cid>
	if (!l2cap_chan) {
   19234:	b130      	cbz	r0, 19244 <bt_att_out_of_sync_sent_on_fixed+0x18>
   19236:	4603      	mov	r3, r0
		return false;
	}

	att_chan = ATT_CHAN(l2cap_chan);
	return atomic_test_bit(att_chan->flags, ATT_OUT_OF_SYNC_SENT);
   19238:	338c      	adds	r3, #140	; 0x8c
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1923a:	e8d3 0faf 	lda	r0, [r3]
   1923e:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
   19242:	bd08      	pop	{r3, pc}
		return false;
   19244:	2000      	movs	r0, #0
   19246:	e7fc      	b.n	19242 <bt_att_out_of_sync_sent_on_fixed+0x16>

00019248 <bt_att_set_tx_meta_data>:

void bt_att_set_tx_meta_data(struct net_buf *buf, bt_gatt_complete_func_t func, void *user_data,
			     enum bt_att_chan_opt chan_opt)
{
	struct bt_att_tx_meta_data *data = bt_att_tx_meta_data(buf);
   19248:	6940      	ldr	r0, [r0, #20]

	data->func = func;
   1924a:	6081      	str	r1, [r0, #8]
	data->user_data = user_data;
   1924c:	60c2      	str	r2, [r0, #12]
	data->attr_count = 1;
   1924e:	2201      	movs	r2, #1
   19250:	8082      	strh	r2, [r0, #4]
	data->chan_opt = chan_opt;
   19252:	7403      	strb	r3, [r0, #16]
}
   19254:	4770      	bx	lr

00019256 <update_range>:
	if (new_start >= *start && new_end <= *end) {
   19256:	f8b0 c000 	ldrh.w	ip, [r0]
   1925a:	4562      	cmp	r2, ip
   1925c:	d312      	bcc.n	19284 <update_range+0x2e>
{
   1925e:	b500      	push	{lr}
	if (new_start >= *start && new_end <= *end) {
   19260:	f8b1 e000 	ldrh.w	lr, [r1]
   19264:	4573      	cmp	r3, lr
   19266:	d908      	bls.n	1927a <update_range+0x24>
	if (*start > new_start) {
   19268:	4562      	cmp	r2, ip
   1926a:	d200      	bcs.n	1926e <update_range+0x18>
		*start = new_start;
   1926c:	8002      	strh	r2, [r0, #0]
	if (*end < new_end) {
   1926e:	880a      	ldrh	r2, [r1, #0]
   19270:	4293      	cmp	r3, r2
   19272:	d904      	bls.n	1927e <update_range+0x28>
		*end = new_end;
   19274:	800b      	strh	r3, [r1, #0]
	return true;
   19276:	2001      	movs	r0, #1
   19278:	e002      	b.n	19280 <update_range+0x2a>
		return false;
   1927a:	2000      	movs	r0, #0
   1927c:	e000      	b.n	19280 <update_range+0x2a>
	return true;
   1927e:	2001      	movs	r0, #1
}
   19280:	f85d fb04 	ldr.w	pc, [sp], #4
	if (*start > new_start) {
   19284:	4562      	cmp	r2, ip
   19286:	d200      	bcs.n	1928a <update_range+0x34>
		*start = new_start;
   19288:	8002      	strh	r2, [r0, #0]
	if (*end < new_end) {
   1928a:	880a      	ldrh	r2, [r1, #0]
   1928c:	4293      	cmp	r3, r2
   1928e:	d902      	bls.n	19296 <update_range+0x40>
		*end = new_end;
   19290:	800b      	strh	r3, [r1, #0]
	return true;
   19292:	2001      	movs	r0, #1
   19294:	4770      	bx	lr
   19296:	2001      	movs	r0, #1
}
   19298:	4770      	bx	lr

0001929a <cf_set_value>:
{
   1929a:	b510      	push	{r4, lr}
	for (i = 0U; i <= CF_BIT_LAST && (i / 8) < len; i++) {
   1929c:	2300      	movs	r3, #0
   1929e:	e001      	b.n	192a4 <cf_set_value+0xa>
   192a0:	3301      	adds	r3, #1
   192a2:	b29b      	uxth	r3, r3
   192a4:	2b02      	cmp	r3, #2
   192a6:	d819      	bhi.n	192dc <cf_set_value+0x42>
   192a8:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
   192ac:	ebb2 0fd3 	cmp.w	r2, r3, lsr #3
   192b0:	d912      	bls.n	192d8 <cf_set_value+0x3e>
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   192b2:	eb00 040c 	add.w	r4, r0, ip
   192b6:	7a24      	ldrb	r4, [r4, #8]
   192b8:	f003 0e07 	and.w	lr, r3, #7
   192bc:	fa24 f40e 	lsr.w	r4, r4, lr
   192c0:	f014 0f01 	tst.w	r4, #1
   192c4:	d0ec      	beq.n	192a0 <cf_set_value+0x6>
		    !(value[i / 8] & BIT(i % 8))) {
   192c6:	f811 400c 	ldrb.w	r4, [r1, ip]
   192ca:	fa24 fe0e 	lsr.w	lr, r4, lr
		if ((cfg->data[i / 8] & BIT(i % 8)) &&
   192ce:	f01e 0f01 	tst.w	lr, #1
   192d2:	d1e5      	bne.n	192a0 <cf_set_value+0x6>
			return false;
   192d4:	2000      	movs	r0, #0
   192d6:	e017      	b.n	19308 <cf_set_value+0x6e>
   192d8:	2300      	movs	r3, #0
   192da:	e000      	b.n	192de <cf_set_value+0x44>
   192dc:	2300      	movs	r3, #0
	for (i = 0U; i < len && i < CF_NUM_BYTES; i++) {
   192de:	4293      	cmp	r3, r2
   192e0:	d211      	bcs.n	19306 <cf_set_value+0x6c>
   192e2:	b973      	cbnz	r3, 19302 <cf_set_value+0x68>
			cfg->data[i] |= value[i] & BIT_MASK(CF_NUM_BITS % 8);
   192e4:	f811 c003 	ldrb.w	ip, [r1, r3]
   192e8:	f00c 0c07 	and.w	ip, ip, #7
   192ec:	eb00 0e03 	add.w	lr, r0, r3
   192f0:	f89e 4008 	ldrb.w	r4, [lr, #8]
   192f4:	ea4c 0c04 	orr.w	ip, ip, r4
   192f8:	f88e c008 	strb.w	ip, [lr, #8]
	for (i = 0U; i < len && i < CF_NUM_BYTES; i++) {
   192fc:	3301      	adds	r3, #1
   192fe:	b29b      	uxth	r3, r3
   19300:	e7ed      	b.n	192de <cf_set_value+0x44>
	return true;
   19302:	2001      	movs	r0, #1
   19304:	e000      	b.n	19308 <cf_set_value+0x6e>
   19306:	2001      	movs	r0, #1
}
   19308:	bd10      	pop	{r4, pc}

0001930a <find_next>:
	*next = (struct bt_gatt_attr *)attr;
   1930a:	6010      	str	r0, [r2, #0]
}
   1930c:	2000      	movs	r0, #0
   1930e:	4770      	bx	lr

00019310 <gatt_ccc_changed>:
{
   19310:	b508      	push	{r3, lr}
   19312:	460a      	mov	r2, r1
	uint16_t value = 0x0000;
   19314:	2100      	movs	r1, #0
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   19316:	460b      	mov	r3, r1
   19318:	b13b      	cbz	r3, 1932a <gatt_ccc_changed+0x1a>
	if (value != ccc->value) {
   1931a:	8953      	ldrh	r3, [r2, #10]
   1931c:	4299      	cmp	r1, r3
   1931e:	d003      	beq.n	19328 <gatt_ccc_changed+0x18>
		ccc->value = value;
   19320:	8151      	strh	r1, [r2, #10]
		if (ccc->cfg_changed) {
   19322:	68d3      	ldr	r3, [r2, #12]
   19324:	b103      	cbz	r3, 19328 <gatt_ccc_changed+0x18>
			ccc->cfg_changed(attr, value);
   19326:	4798      	blx	r3
}
   19328:	bd08      	pop	{r3, pc}
		if (ccc->cfg[i].value > value) {
   1932a:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
   1932e:	eb02 0c4c 	add.w	ip, r2, ip, lsl #1
   19332:	f8bc c008 	ldrh.w	ip, [ip, #8]
   19336:	458c      	cmp	ip, r1
   19338:	d900      	bls.n	1933c <gatt_ccc_changed+0x2c>
			value = ccc->cfg[i].value;
   1933a:	4661      	mov	r1, ip
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1933c:	3301      	adds	r3, #1
   1933e:	e7eb      	b.n	19318 <gatt_ccc_changed+0x8>

00019340 <gatt_indicate_rsp>:
{
   19340:	b510      	push	{r4, lr}
   19342:	9c02      	ldr	r4, [sp, #8]
	if (params->func) {
   19344:	68a3      	ldr	r3, [r4, #8]
   19346:	b113      	cbz	r3, 1934e <gatt_indicate_rsp+0xe>
   19348:	460a      	mov	r2, r1
		params->func(conn, params, err);
   1934a:	4621      	mov	r1, r4
   1934c:	4798      	blx	r3
	params->_ref--;
   1934e:	7da3      	ldrb	r3, [r4, #22]
   19350:	3b01      	subs	r3, #1
   19352:	b2db      	uxtb	r3, r3
   19354:	75a3      	strb	r3, [r4, #22]
	if (params->destroy && (params->_ref == 0)) {
   19356:	68e2      	ldr	r2, [r4, #12]
   19358:	b112      	cbz	r2, 19360 <gatt_indicate_rsp+0x20>
   1935a:	b90b      	cbnz	r3, 19360 <gatt_indicate_rsp+0x20>
		params->destroy(params);
   1935c:	4620      	mov	r0, r4
   1935e:	4790      	blx	r2
}
   19360:	bd10      	pop	{r4, pc}

00019362 <match_uuid>:
	data->attr = attr;
   19362:	6010      	str	r0, [r2, #0]
	data->handle = handle;
   19364:	8091      	strh	r1, [r2, #4]
}
   19366:	2000      	movs	r0, #0
   19368:	4770      	bx	lr

0001936a <gatt_sub_is_empty>:
	return list->head;
   1936a:	6880      	ldr	r0, [r0, #8]
}
   1936c:	fab0 f080 	clz	r0, r0
   19370:	0940      	lsrs	r0, r0, #5
   19372:	4770      	bx	lr

00019374 <check_subscribe_security_level>:
}
   19374:	2001      	movs	r0, #1
   19376:	4770      	bx	lr

00019378 <gen_hash_m>:
{
   19378:	b5f0      	push	{r4, r5, r6, r7, lr}
   1937a:	b089      	sub	sp, #36	; 0x24
	if (attr->uuid->type != BT_UUID_TYPE_16)
   1937c:	6806      	ldr	r6, [r0, #0]
   1937e:	7835      	ldrb	r5, [r6, #0]
   19380:	2d00      	cmp	r5, #0
   19382:	d160      	bne.n	19446 <gen_hash_m+0xce>
   19384:	4607      	mov	r7, r0
   19386:	4614      	mov	r4, r2
	switch (u16->val) {
   19388:	8873      	ldrh	r3, [r6, #2]
   1938a:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   1938e:	d019      	beq.n	193c4 <gen_hash_m+0x4c>
   19390:	d913      	bls.n	193ba <gen_hash_m+0x42>
   19392:	f503 4356 	add.w	r3, r3, #54784	; 0xd600
   19396:	33ff      	adds	r3, #255	; 0xff
   19398:	b29b      	uxth	r3, r3
   1939a:	2b04      	cmp	r3, #4
   1939c:	d859      	bhi.n	19452 <gen_hash_m+0xda>
		value = sys_cpu_to_le16(handle);
   1939e:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   193a2:	2202      	movs	r2, #2
   193a4:	f10d 010a 	add.w	r1, sp, #10
   193a8:	4620      	mov	r0, r4
   193aa:	f7fd fdb8 	bl	16f1e <tc_cmac_update>
   193ae:	2800      	cmp	r0, #0
   193b0:	d139      	bne.n	19426 <gen_hash_m+0xae>
			state->err = -EINVAL;
   193b2:	f06f 0315 	mvn.w	r3, #21
   193b6:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   193b8:	e046      	b.n	19448 <gen_hash_m+0xd0>
	switch (u16->val) {
   193ba:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   193be:	b29b      	uxth	r3, r3
   193c0:	2b03      	cmp	r3, #3
   193c2:	d844      	bhi.n	1944e <gen_hash_m+0xd6>
		value = sys_cpu_to_le16(handle);
   193c4:	f8ad 100a 	strh.w	r1, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   193c8:	2202      	movs	r2, #2
   193ca:	f10d 010a 	add.w	r1, sp, #10
   193ce:	4620      	mov	r0, r4
   193d0:	f7fd fda5 	bl	16f1e <tc_cmac_update>
   193d4:	b918      	cbnz	r0, 193de <gen_hash_m+0x66>
			state->err = -EINVAL;
   193d6:	f06f 0315 	mvn.w	r3, #21
   193da:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   193dc:	e034      	b.n	19448 <gen_hash_m+0xd0>
		value = sys_cpu_to_le16(u16->val);
   193de:	8873      	ldrh	r3, [r6, #2]
   193e0:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   193e4:	2202      	movs	r2, #2
   193e6:	f10d 010a 	add.w	r1, sp, #10
   193ea:	4620      	mov	r0, r4
   193ec:	f7fd fd97 	bl	16f1e <tc_cmac_update>
   193f0:	b178      	cbz	r0, 19412 <gen_hash_m+0x9a>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   193f2:	687e      	ldr	r6, [r7, #4]
   193f4:	2000      	movs	r0, #0
   193f6:	9000      	str	r0, [sp, #0]
   193f8:	2313      	movs	r3, #19
   193fa:	aa03      	add	r2, sp, #12
   193fc:	4639      	mov	r1, r7
   193fe:	47b0      	blx	r6
		if (len < 0) {
   19400:	1e02      	subs	r2, r0, #0
   19402:	db0a      	blt.n	1941a <gen_hash_m+0xa2>
		if (tc_cmac_update(&state->state, data, len) ==
   19404:	a903      	add	r1, sp, #12
   19406:	4620      	mov	r0, r4
   19408:	f7fd fd89 	bl	16f1e <tc_cmac_update>
   1940c:	b138      	cbz	r0, 1941e <gen_hash_m+0xa6>
	return BT_GATT_ITER_CONTINUE;
   1940e:	2501      	movs	r5, #1
   19410:	e01a      	b.n	19448 <gen_hash_m+0xd0>
			state->err = -EINVAL;
   19412:	f06f 0315 	mvn.w	r3, #21
   19416:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   19418:	e016      	b.n	19448 <gen_hash_m+0xd0>
			state->err = len;
   1941a:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   1941c:	e014      	b.n	19448 <gen_hash_m+0xd0>
			state->err = -EINVAL;
   1941e:	f06f 0315 	mvn.w	r3, #21
   19422:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   19424:	e010      	b.n	19448 <gen_hash_m+0xd0>
		value = sys_cpu_to_le16(u16->val);
   19426:	8873      	ldrh	r3, [r6, #2]
   19428:	f8ad 300a 	strh.w	r3, [sp, #10]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   1942c:	2202      	movs	r2, #2
   1942e:	f10d 010a 	add.w	r1, sp, #10
   19432:	4620      	mov	r0, r4
   19434:	f7fd fd73 	bl	16f1e <tc_cmac_update>
   19438:	b108      	cbz	r0, 1943e <gen_hash_m+0xc6>
	return BT_GATT_ITER_CONTINUE;
   1943a:	2501      	movs	r5, #1
   1943c:	e004      	b.n	19448 <gen_hash_m+0xd0>
			state->err = -EINVAL;
   1943e:	f06f 0315 	mvn.w	r3, #21
   19442:	65a3      	str	r3, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   19444:	e000      	b.n	19448 <gen_hash_m+0xd0>
		return BT_GATT_ITER_CONTINUE;
   19446:	2501      	movs	r5, #1
}
   19448:	4628      	mov	r0, r5
   1944a:	b009      	add	sp, #36	; 0x24
   1944c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   1944e:	2501      	movs	r5, #1
   19450:	e7fa      	b.n	19448 <gen_hash_m+0xd0>
   19452:	2501      	movs	r5, #1
   19454:	e7f8      	b.n	19448 <gen_hash_m+0xd0>

00019456 <find_ccc_cfg>:
{
   19456:	b5f0      	push	{r4, r5, r6, r7, lr}
   19458:	b083      	sub	sp, #12
   1945a:	4607      	mov	r7, r0
   1945c:	460d      	mov	r5, r1
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1945e:	2400      	movs	r4, #0
   19460:	b11c      	cbz	r4, 1946a <find_ccc_cfg+0x14>
	return NULL;
   19462:	2600      	movs	r6, #0
}
   19464:	4630      	mov	r0, r6
   19466:	b003      	add	sp, #12
   19468:	bdf0      	pop	{r4, r5, r6, r7, pc}
		struct bt_gatt_ccc_cfg *cfg = &ccc->cfg[i];
   1946a:	eb04 0684 	add.w	r6, r4, r4, lsl #2
   1946e:	eb05 0646 	add.w	r6, r5, r6, lsl #1
		if (conn) {
   19472:	b167      	cbz	r7, 1948e <find_ccc_cfg+0x38>
						    &cfg->peer)) {
   19474:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   19478:	4632      	mov	r2, r6
			if (bt_conn_is_peer_addr_le(conn, cfg->id,
   1947a:	3201      	adds	r2, #1
   1947c:	f815 1013 	ldrb.w	r1, [r5, r3, lsl #1]
   19480:	4638      	mov	r0, r7
   19482:	f7fe fe8d 	bl	181a0 <bt_conn_is_peer_addr_le>
   19486:	2800      	cmp	r0, #0
   19488:	d1ec      	bne.n	19464 <find_ccc_cfg+0xe>
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1948a:	3401      	adds	r4, #1
   1948c:	e7e8      	b.n	19460 <find_ccc_cfg+0xa>
		} else if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   1948e:	eb04 0084 	add.w	r0, r4, r4, lsl #2
   19492:	eb05 0040 	add.w	r0, r5, r0, lsl #1
   19496:	2300      	movs	r3, #0
   19498:	9300      	str	r3, [sp, #0]
   1949a:	f8cd 3003 	str.w	r3, [sp, #3]
   1949e:	2207      	movs	r2, #7
   194a0:	4669      	mov	r1, sp
   194a2:	3001      	adds	r0, #1
   194a4:	f7fe f932 	bl	1770c <memcmp>
   194a8:	2800      	cmp	r0, #0
   194aa:	d1ee      	bne.n	1948a <find_ccc_cfg+0x34>
   194ac:	e7da      	b.n	19464 <find_ccc_cfg+0xe>

000194ae <clear_ccc_cfg>:
{
   194ae:	b530      	push	{r4, r5, lr}
   194b0:	b083      	sub	sp, #12
   194b2:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   194b4:	2500      	movs	r5, #0
   194b6:	9500      	str	r5, [sp, #0]
   194b8:	f8cd 5003 	str.w	r5, [sp, #3]
	memcpy(dst, src, sizeof(*dst));
   194bc:	2207      	movs	r2, #7
   194be:	4669      	mov	r1, sp
   194c0:	3001      	adds	r0, #1
   194c2:	f7fe f935 	bl	17730 <memcpy>
	cfg->id = 0U;
   194c6:	7025      	strb	r5, [r4, #0]
	cfg->value = 0U;
   194c8:	8125      	strh	r5, [r4, #8]
}
   194ca:	b003      	add	sp, #12
   194cc:	bd30      	pop	{r4, r5, pc}

000194ce <gatt_sub_free>:
{
   194ce:	b500      	push	{lr}
   194d0:	b083      	sub	sp, #12
	bt_addr_le_copy(&sub->peer, BT_ADDR_LE_ANY);
   194d2:	2300      	movs	r3, #0
   194d4:	9300      	str	r3, [sp, #0]
   194d6:	f8cd 3003 	str.w	r3, [sp, #3]
   194da:	2207      	movs	r2, #7
   194dc:	4669      	mov	r1, sp
   194de:	3001      	adds	r0, #1
   194e0:	f7fe f926 	bl	17730 <memcpy>
}
   194e4:	b003      	add	sp, #12
   194e6:	f85d fb04 	ldr.w	pc, [sp], #4

000194ea <gatt_sub_remove>:
{
   194ea:	b538      	push	{r3, r4, r5, lr}
   194ec:	460c      	mov	r4, r1
	if (params) {
   194ee:	b193      	cbz	r3, 19516 <gatt_sub_remove+0x2c>
   194f0:	4619      	mov	r1, r3
		sys_slist_remove(&sub->list, prev, &params->node);
   194f2:	f104 0308 	add.w	r3, r4, #8
   194f6:	f101 0518 	add.w	r5, r1, #24
Z_GENLIST_REMOVE(slist, snode)
   194fa:	b18a      	cbz	r2, 19520 <gatt_sub_remove+0x36>
	parent->next = child;
   194fc:	f8d1 c018 	ldr.w	ip, [r1, #24]
   19500:	f8c2 c000 	str.w	ip, [r2]
Z_GENLIST_REMOVE(slist, snode)
   19504:	f8d3 c004 	ldr.w	ip, [r3, #4]
   19508:	4565      	cmp	r5, ip
   1950a:	d011      	beq.n	19530 <gatt_sub_remove+0x46>
	parent->next = child;
   1950c:	2200      	movs	r2, #0
   1950e:	618a      	str	r2, [r1, #24]
		params->notify(conn, params, NULL, 0);
   19510:	680d      	ldr	r5, [r1, #0]
   19512:	4613      	mov	r3, r2
   19514:	47a8      	blx	r5
	if (gatt_sub_is_empty(sub)) {
   19516:	4620      	mov	r0, r4
   19518:	f7ff ff27 	bl	1936a <gatt_sub_is_empty>
   1951c:	b950      	cbnz	r0, 19534 <gatt_sub_remove+0x4a>
}
   1951e:	bd38      	pop	{r3, r4, r5, pc}
	return node->next;
   19520:	698a      	ldr	r2, [r1, #24]
	list->head = node;
   19522:	60a2      	str	r2, [r4, #8]
Z_GENLIST_REMOVE(slist, snode)
   19524:	f8d3 c004 	ldr.w	ip, [r3, #4]
   19528:	4565      	cmp	r5, ip
   1952a:	d1ef      	bne.n	1950c <gatt_sub_remove+0x22>
	list->tail = node;
   1952c:	605a      	str	r2, [r3, #4]
}
   1952e:	e7ed      	b.n	1950c <gatt_sub_remove+0x22>
	list->tail = node;
   19530:	605a      	str	r2, [r3, #4]
}
   19532:	e7eb      	b.n	1950c <gatt_sub_remove+0x22>
		gatt_sub_free(sub);
   19534:	4620      	mov	r0, r4
   19536:	f7ff ffca 	bl	194ce <gatt_sub_free>
}
   1953a:	e7f0      	b.n	1951e <gatt_sub_remove+0x34>

0001953c <gatt_sub_update>:
	if (sub->peer.type == BT_ADDR_LE_PUBLIC) {
   1953c:	784a      	ldrb	r2, [r1, #1]
   1953e:	b902      	cbnz	r2, 19542 <gatt_sub_update+0x6>
   19540:	4770      	bx	lr
{
   19542:	b508      	push	{r3, lr}
   19544:	460b      	mov	r3, r1
   19546:	2207      	movs	r2, #7
   19548:	f100 0188 	add.w	r1, r0, #136	; 0x88
   1954c:	1c58      	adds	r0, r3, #1
   1954e:	f7fe f8ef 	bl	17730 <memcpy>
}
   19552:	bd08      	pop	{r3, pc}

00019554 <clear_sc_cfg>:
{
   19554:	b508      	push	{r3, lr}
	memset(cfg, 0, sizeof(*cfg));
   19556:	220c      	movs	r2, #12
   19558:	2100      	movs	r1, #0
   1955a:	f7fe f918 	bl	1778e <memset>
}
   1955e:	bd08      	pop	{r3, pc}

00019560 <bt_gatt_clear_sc>:
{
   19560:	b508      	push	{r3, lr}
	cfg = find_sc_cfg(id, (bt_addr_le_t *)addr);
   19562:	f7f3 f975 	bl	c850 <find_sc_cfg>
	if (!cfg) {
   19566:	b108      	cbz	r0, 1956c <bt_gatt_clear_sc+0xc>
	clear_sc_cfg(cfg);
   19568:	f7ff fff4 	bl	19554 <clear_sc_cfg>
}
   1956c:	2000      	movs	r0, #0
   1956e:	bd08      	pop	{r3, pc}

00019570 <sc_ccc_cfg_write>:
{
   19570:	b508      	push	{r3, lr}
	if (value == BT_GATT_CCC_INDICATE) {
   19572:	2a02      	cmp	r2, #2
   19574:	d003      	beq.n	1957e <sc_ccc_cfg_write+0xe>
		sc_clear(conn);
   19576:	f7f3 fafd 	bl	cb74 <sc_clear>
}
   1957a:	2002      	movs	r0, #2
   1957c:	bd08      	pop	{r3, pc}
		sc_save(conn->id, &conn->le.dst, 0, 0);
   1957e:	2300      	movs	r3, #0
   19580:	461a      	mov	r2, r3
   19582:	f100 0188 	add.w	r1, r0, #136	; 0x88
   19586:	7a00      	ldrb	r0, [r0, #8]
   19588:	f7f3 fa18 	bl	c9bc <sc_save>
   1958c:	e7f5      	b.n	1957a <sc_ccc_cfg_write+0xa>

0001958e <sc_reset>:
{
   1958e:	b508      	push	{r3, lr}
	memset(&cfg->data, 0, sizeof(cfg->data));
   19590:	2204      	movs	r2, #4
   19592:	2100      	movs	r1, #0
   19594:	3008      	adds	r0, #8
   19596:	f7fe f8fa 	bl	1778e <memset>
}
   1959a:	bd08      	pop	{r3, pc}

0001959c <sc_restore_rsp>:
{
   1959c:	b538      	push	{r3, r4, r5, lr}
   1959e:	4605      	mov	r5, r0
   195a0:	4614      	mov	r4, r2
	if (bt_att_fixed_chan_only(conn)) {
   195a2:	f7ff fe24 	bl	191ee <bt_att_fixed_chan_only>
   195a6:	b908      	cbnz	r0, 195ac <sc_restore_rsp+0x10>
	if (!err && IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED)) {
   195a8:	b1a4      	cbz	r4, 195d4 <sc_restore_rsp+0x38>
}
   195aa:	bd38      	pop	{r3, r4, r5, pc}
		cfg = find_cf_cfg(conn);
   195ac:	4628      	mov	r0, r5
   195ae:	f7f3 f925 	bl	c7fc <find_cf_cfg>
		if (cfg && CF_ROBUST_CACHING(cfg)) {
   195b2:	4603      	mov	r3, r0
   195b4:	2800      	cmp	r0, #0
   195b6:	d0f7      	beq.n	195a8 <sc_restore_rsp+0xc>
   195b8:	7a02      	ldrb	r2, [r0, #8]
   195ba:	f012 0f01 	tst.w	r2, #1
   195be:	d0f3      	beq.n	195a8 <sc_restore_rsp+0xc>
			atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   195c0:	330c      	adds	r3, #12
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   195c2:	e8d3 2fef 	ldaex	r2, [r3]
   195c6:	f042 0201 	orr.w	r2, r2, #1
   195ca:	e8c3 2fe1 	stlex	r1, r2, [r3]
   195ce:	2900      	cmp	r1, #0
   195d0:	d0ea      	beq.n	195a8 <sc_restore_rsp+0xc>
   195d2:	e7f6      	b.n	195c2 <sc_restore_rsp+0x26>
		struct gatt_sc_cfg *sc_cfg = find_sc_cfg(conn->id, &conn->le.dst);
   195d4:	f105 0188 	add.w	r1, r5, #136	; 0x88
   195d8:	7a28      	ldrb	r0, [r5, #8]
   195da:	f7f3 f939 	bl	c850 <find_sc_cfg>
		if (sc_cfg) {
   195de:	2800      	cmp	r0, #0
   195e0:	d0e3      	beq.n	195aa <sc_restore_rsp+0xe>
			sc_reset(sc_cfg);
   195e2:	f7ff ffd4 	bl	1958e <sc_reset>
}
   195e6:	e7e0      	b.n	195aa <sc_restore_rsp+0xe>

000195e8 <gatt_foreach_iter>:
	if (handle > end_handle) {
   195e8:	4299      	cmp	r1, r3
   195ea:	d822      	bhi.n	19632 <gatt_foreach_iter+0x4a>
{
   195ec:	b538      	push	{r3, r4, r5, lr}
   195ee:	4605      	mov	r5, r0
   195f0:	460c      	mov	r4, r1
	if (handle < start_handle) {
   195f2:	4291      	cmp	r1, r2
   195f4:	d31f      	bcc.n	19636 <gatt_foreach_iter+0x4e>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   195f6:	9b04      	ldr	r3, [sp, #16]
   195f8:	b123      	cbz	r3, 19604 <gatt_foreach_iter+0x1c>
   195fa:	6801      	ldr	r1, [r0, #0]
   195fc:	4618      	mov	r0, r3
   195fe:	f7fe f8ff 	bl	17800 <bt_uuid_cmp>
   19602:	b9d0      	cbnz	r0, 1963a <gatt_foreach_iter+0x52>
	if (attr_data && attr_data != attr->user_data) {
   19604:	9b05      	ldr	r3, [sp, #20]
   19606:	b12b      	cbz	r3, 19614 <gatt_foreach_iter+0x2c>
   19608:	68eb      	ldr	r3, [r5, #12]
   1960a:	9a05      	ldr	r2, [sp, #20]
   1960c:	4293      	cmp	r3, r2
   1960e:	d001      	beq.n	19614 <gatt_foreach_iter+0x2c>
		return BT_GATT_ITER_CONTINUE;
   19610:	2001      	movs	r0, #1
   19612:	e011      	b.n	19638 <gatt_foreach_iter+0x50>
	*num_matches -= 1;
   19614:	9b06      	ldr	r3, [sp, #24]
   19616:	881b      	ldrh	r3, [r3, #0]
   19618:	3b01      	subs	r3, #1
   1961a:	9a06      	ldr	r2, [sp, #24]
   1961c:	8013      	strh	r3, [r2, #0]
	result = func(attr, handle, user_data);
   1961e:	9a08      	ldr	r2, [sp, #32]
   19620:	4621      	mov	r1, r4
   19622:	4628      	mov	r0, r5
   19624:	9b07      	ldr	r3, [sp, #28]
   19626:	4798      	blx	r3
	if (!*num_matches) {
   19628:	9b06      	ldr	r3, [sp, #24]
   1962a:	881b      	ldrh	r3, [r3, #0]
   1962c:	b923      	cbnz	r3, 19638 <gatt_foreach_iter+0x50>
		return BT_GATT_ITER_STOP;
   1962e:	2000      	movs	r0, #0
   19630:	e002      	b.n	19638 <gatt_foreach_iter+0x50>
		return BT_GATT_ITER_STOP;
   19632:	2000      	movs	r0, #0
}
   19634:	4770      	bx	lr
		return BT_GATT_ITER_CONTINUE;
   19636:	2001      	movs	r0, #1
}
   19638:	bd38      	pop	{r3, r4, r5, pc}
		return BT_GATT_ITER_CONTINUE;
   1963a:	2001      	movs	r0, #1
   1963c:	e7fc      	b.n	19638 <gatt_foreach_iter+0x50>

0001963e <gatt_req_alloc>:
{
   1963e:	b538      	push	{r3, r4, r5, lr}
   19640:	4605      	mov	r5, r0
   19642:	460c      	mov	r4, r1
	req = bt_att_req_alloc(BT_ATT_TIMEOUT);
   19644:	f44f 2070 	mov.w	r0, #983040	; 0xf0000
   19648:	2100      	movs	r1, #0
   1964a:	f7f2 ff0d 	bl	c468 <bt_att_req_alloc>
	if (!req) {
   1964e:	4603      	mov	r3, r0
   19650:	b108      	cbz	r0, 19656 <gatt_req_alloc+0x18>
	req->func = func;
   19652:	6045      	str	r5, [r0, #4]
	req->user_data = params;
   19654:	60c4      	str	r4, [r0, #12]
}
   19656:	4618      	mov	r0, r3
   19658:	bd38      	pop	{r3, r4, r5, pc}

0001965a <gatt_req_send>:
{
   1965a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1965e:	b083      	sub	sp, #12
   19660:	4606      	mov	r6, r0
   19662:	4608      	mov	r0, r1
   19664:	4615      	mov	r5, r2
   19666:	461c      	mov	r4, r3
   19668:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
   1966c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
	req = gatt_req_alloc(func, params, encode, op, len);
   1966e:	9700      	str	r7, [sp, #0]
   19670:	4643      	mov	r3, r8
   19672:	4622      	mov	r2, r4
   19674:	4629      	mov	r1, r5
   19676:	f7ff ffe2 	bl	1963e <gatt_req_alloc>
	if (!req) {
   1967a:	b368      	cbz	r0, 196d8 <gatt_req_send+0x7e>
   1967c:	4681      	mov	r9, r0
	buf = bt_att_create_pdu(conn, op, len);
   1967e:	463a      	mov	r2, r7
   19680:	4641      	mov	r1, r8
   19682:	4630      	mov	r0, r6
   19684:	f7f2 fbf0 	bl	be68 <bt_att_create_pdu>
	if (!buf) {
   19688:	4680      	mov	r8, r0
   1968a:	b1b8      	cbz	r0, 196bc <gatt_req_send+0x62>
	bt_att_set_tx_meta_data(buf, NULL, NULL, chan_opt);
   1968c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   19690:	2200      	movs	r2, #0
   19692:	4611      	mov	r1, r2
   19694:	f7ff fdd8 	bl	19248 <bt_att_set_tx_meta_data>
	req->buf = buf;
   19698:	f8c9 8008 	str.w	r8, [r9, #8]
	err = encode(buf, len, params);
   1969c:	462a      	mov	r2, r5
   1969e:	4639      	mov	r1, r7
   196a0:	4640      	mov	r0, r8
   196a2:	47a0      	blx	r4
	if (err) {
   196a4:	4604      	mov	r4, r0
   196a6:	b978      	cbnz	r0, 196c8 <gatt_req_send+0x6e>
	err = bt_att_req_send(conn, req);
   196a8:	4649      	mov	r1, r9
   196aa:	4630      	mov	r0, r6
   196ac:	f7ff fd13 	bl	190d6 <bt_att_req_send>
	if (err) {
   196b0:	4604      	mov	r4, r0
   196b2:	b968      	cbnz	r0, 196d0 <gatt_req_send+0x76>
}
   196b4:	4620      	mov	r0, r4
   196b6:	b003      	add	sp, #12
   196b8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bt_att_req_free(req);
   196bc:	4648      	mov	r0, r9
   196be:	f7f2 fef7 	bl	c4b0 <bt_att_req_free>
		return -ENOMEM;
   196c2:	f06f 040b 	mvn.w	r4, #11
   196c6:	e7f5      	b.n	196b4 <gatt_req_send+0x5a>
		bt_att_req_free(req);
   196c8:	4648      	mov	r0, r9
   196ca:	f7f2 fef1 	bl	c4b0 <bt_att_req_free>
		return err;
   196ce:	e7f1      	b.n	196b4 <gatt_req_send+0x5a>
		bt_att_req_free(req);
   196d0:	4648      	mov	r0, r9
   196d2:	f7f2 feed 	bl	c4b0 <bt_att_req_free>
   196d6:	e7ed      	b.n	196b4 <gatt_req_send+0x5a>
		return -ENOMEM;
   196d8:	f06f 040b 	mvn.w	r4, #11
   196dc:	e7ea      	b.n	196b4 <gatt_req_send+0x5a>

000196de <gatt_write_ccc_buf>:
{
   196de:	b538      	push	{r3, r4, r5, lr}
   196e0:	4614      	mov	r4, r2
   196e2:	f100 0508 	add.w	r5, r0, #8
   196e6:	2102      	movs	r1, #2
   196e8:	4628      	mov	r0, r5
   196ea:	f000 fd88 	bl	1a1fe <net_buf_simple_add>
	write_req->handle = sys_cpu_to_le16(params->ccc_handle);
   196ee:	89e3      	ldrh	r3, [r4, #14]
   196f0:	8003      	strh	r3, [r0, #0]
	net_buf_simple_add_le16(&buf->b, val);
   196f2:	8a21      	ldrh	r1, [r4, #16]
   196f4:	4628      	mov	r0, r5
   196f6:	f000 fd9a 	bl	1a22e <net_buf_simple_add_le16>
	atomic_set_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);
   196fa:	3414      	adds	r4, #20
   196fc:	e8d4 3fef 	ldaex	r3, [r4]
   19700:	f043 0304 	orr.w	r3, r3, #4
   19704:	e8c4 3fe2 	stlex	r2, r3, [r4]
   19708:	2a00      	cmp	r2, #0
   1970a:	d1f7      	bne.n	196fc <gatt_write_ccc_buf+0x1e>
}
   1970c:	2000      	movs	r0, #0
   1970e:	bd38      	pop	{r3, r4, r5, pc}

00019710 <clear_cf_cfg>:
{
   19710:	b530      	push	{r4, r5, lr}
   19712:	b083      	sub	sp, #12
   19714:	4604      	mov	r4, r0
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   19716:	2500      	movs	r5, #0
   19718:	9500      	str	r5, [sp, #0]
   1971a:	f8cd 5003 	str.w	r5, [sp, #3]
   1971e:	2207      	movs	r2, #7
   19720:	4669      	mov	r1, sp
   19722:	3001      	adds	r0, #1
   19724:	f7fe f804 	bl	17730 <memcpy>
	memset(cfg->data, 0, sizeof(cfg->data));
   19728:	2201      	movs	r2, #1
   1972a:	4629      	mov	r1, r5
   1972c:	f104 0008 	add.w	r0, r4, #8
   19730:	f7fe f82d 	bl	1778e <memset>
	atomic_set(cfg->flags, 0);
   19734:	340c      	adds	r4, #12
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   19736:	e8d4 3fef 	ldaex	r3, [r4]
   1973a:	e8c4 5fe2 	stlex	r2, r5, [r4]
   1973e:	2a00      	cmp	r2, #0
   19740:	d1f9      	bne.n	19736 <clear_cf_cfg+0x26>
}
   19742:	b003      	add	sp, #12
   19744:	bd30      	pop	{r4, r5, pc}

00019746 <remove_cf_cfg>:
{
   19746:	b570      	push	{r4, r5, r6, lr}
   19748:	4604      	mov	r4, r0
	cfg = find_cf_cfg(conn);
   1974a:	f7f3 f857 	bl	c7fc <find_cf_cfg>
	if (!cfg) {
   1974e:	b150      	cbz	r0, 19766 <remove_cf_cfg+0x20>
   19750:	4606      	mov	r6, r0
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   19752:	f104 0588 	add.w	r5, r4, #136	; 0x88
   19756:	4629      	mov	r1, r5
   19758:	7a20      	ldrb	r0, [r4, #8]
   1975a:	f7fe f9f9 	bl	17b50 <bt_addr_le_is_bonded>
   1975e:	b918      	cbnz	r0, 19768 <remove_cf_cfg+0x22>
		clear_cf_cfg(cfg);
   19760:	4630      	mov	r0, r6
   19762:	f7ff ffd5 	bl	19710 <clear_cf_cfg>
}
   19766:	bd70      	pop	{r4, r5, r6, pc}
   19768:	2207      	movs	r2, #7
   1976a:	4629      	mov	r1, r5
   1976c:	1c70      	adds	r0, r6, #1
   1976e:	f7fd ffdf 	bl	17730 <memcpy>
}
   19772:	e7f8      	b.n	19766 <remove_cf_cfg+0x20>

00019774 <add_subscriptions>:
{
   19774:	b538      	push	{r3, r4, r5, lr}
   19776:	4605      	mov	r5, r0
	sub = gatt_sub_find(conn);
   19778:	f7f3 f88e 	bl	c898 <gatt_sub_find>
	if (!sub) {
   1977c:	b1f8      	cbz	r0, 197be <add_subscriptions+0x4a>
	return list->head;
   1977e:	6884      	ldr	r4, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   19780:	b13c      	cbz	r4, 19792 <add_subscriptions+0x1e>
   19782:	3c18      	subs	r4, #24
   19784:	e005      	b.n	19792 <add_subscriptions+0x1e>
Z_GENLIST_PEEK_NEXT(slist, snode)
   19786:	f114 0318 	adds.w	r3, r4, #24
   1978a:	d016      	beq.n	197ba <add_subscriptions+0x46>
	return node->next;
   1978c:	69a4      	ldr	r4, [r4, #24]
   1978e:	b1b4      	cbz	r4, 197be <add_subscriptions+0x4a>
   19790:	3c18      	subs	r4, #24
   19792:	b1a4      	cbz	r4, 197be <add_subscriptions+0x4a>
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   19794:	f105 0188 	add.w	r1, r5, #136	; 0x88
   19798:	7a28      	ldrb	r0, [r5, #8]
   1979a:	f7fe f9d9 	bl	17b50 <bt_addr_le_is_bonded>
   1979e:	2800      	cmp	r0, #0
   197a0:	d0f1      	beq.n	19786 <add_subscriptions+0x12>
		    !atomic_test_bit(params->flags,
   197a2:	f104 0314 	add.w	r3, r4, #20
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   197a6:	e8d3 3faf 	lda	r3, [r3]
		if (bt_addr_le_is_bonded(conn->id, &conn->le.dst) &&
   197aa:	f013 0f02 	tst.w	r3, #2
   197ae:	d1ea      	bne.n	19786 <add_subscriptions+0x12>
			gatt_write_ccc(conn, params);
   197b0:	4621      	mov	r1, r4
   197b2:	4628      	mov	r0, r5
   197b4:	f7f3 fb40 	bl	ce38 <gatt_write_ccc>
   197b8:	e7e5      	b.n	19786 <add_subscriptions+0x12>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, params, node) {
   197ba:	461c      	mov	r4, r3
   197bc:	e7e9      	b.n	19792 <add_subscriptions+0x1e>
}
   197be:	bd38      	pop	{r3, r4, r5, pc}

000197c0 <remove_subscriptions>:
{
   197c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   197c4:	4606      	mov	r6, r0
	sub = gatt_sub_find(conn);
   197c6:	f7f3 f867 	bl	c898 <gatt_sub_find>
	if (!sub) {
   197ca:	2800      	cmp	r0, #0
   197cc:	d03a      	beq.n	19844 <remove_subscriptions+0x84>
   197ce:	4607      	mov	r7, r0
	return list->head;
   197d0:	6885      	ldr	r5, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   197d2:	b37d      	cbz	r5, 19834 <remove_subscriptions+0x74>
   197d4:	3d18      	subs	r5, #24
   197d6:	d031      	beq.n	1983c <remove_subscriptions+0x7c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   197d8:	f115 0418 	adds.w	r4, r5, #24
   197dc:	d02b      	beq.n	19836 <remove_subscriptions+0x76>
	return node->next;
   197de:	69ac      	ldr	r4, [r5, #24]
   197e0:	b34c      	cbz	r4, 19836 <remove_subscriptions+0x76>
   197e2:	3c18      	subs	r4, #24
   197e4:	e027      	b.n	19836 <remove_subscriptions+0x76>
			params->value = 0U;
   197e6:	2300      	movs	r3, #0
   197e8:	822b      	strh	r3, [r5, #16]
			gatt_sub_remove(conn, sub, prev, params);
   197ea:	462b      	mov	r3, r5
   197ec:	4642      	mov	r2, r8
   197ee:	4639      	mov	r1, r7
   197f0:	4630      	mov	r0, r6
   197f2:	f7ff fe7a 	bl	194ea <gatt_sub_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   197f6:	b31c      	cbz	r4, 19840 <remove_subscriptions+0x80>
Z_GENLIST_PEEK_NEXT(slist, snode)
   197f8:	f114 0318 	adds.w	r3, r4, #24
   197fc:	d002      	beq.n	19804 <remove_subscriptions+0x44>
	return node->next;
   197fe:	69a3      	ldr	r3, [r4, #24]
   19800:	b103      	cbz	r3, 19804 <remove_subscriptions+0x44>
   19802:	3b18      	subs	r3, #24
   19804:	4625      	mov	r5, r4
   19806:	461c      	mov	r4, r3
   19808:	b1e5      	cbz	r5, 19844 <remove_subscriptions+0x84>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   1980a:	f106 0188 	add.w	r1, r6, #136	; 0x88
   1980e:	7a30      	ldrb	r0, [r6, #8]
   19810:	f7fe f99e 	bl	17b50 <bt_addr_le_is_bonded>
   19814:	2800      	cmp	r0, #0
   19816:	d0e6      	beq.n	197e6 <remove_subscriptions+0x26>
		    (atomic_test_bit(params->flags,
   19818:	f105 0314 	add.w	r3, r5, #20
   1981c:	e8d3 3faf 	lda	r3, [r3]
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   19820:	f013 0f01 	tst.w	r3, #1
   19824:	d1df      	bne.n	197e6 <remove_subscriptions+0x26>
			gatt_sub_update(conn, sub);
   19826:	4639      	mov	r1, r7
   19828:	4630      	mov	r0, r6
   1982a:	f7ff fe87 	bl	1953c <gatt_sub_update>
			prev = &params->node;
   1982e:	f105 0818 	add.w	r8, r5, #24
   19832:	e7e0      	b.n	197f6 <remove_subscriptions+0x36>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   19834:	462c      	mov	r4, r5
   19836:	f04f 0800 	mov.w	r8, #0
   1983a:	e7e5      	b.n	19808 <remove_subscriptions+0x48>
   1983c:	462c      	mov	r4, r5
   1983e:	e7fa      	b.n	19836 <remove_subscriptions+0x76>
   19840:	4623      	mov	r3, r4
   19842:	e7df      	b.n	19804 <remove_subscriptions+0x44>
}
   19844:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00019848 <bt_gatt_attr_read>:
{
   19848:	b510      	push	{r4, lr}
   1984a:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1984e:	f8bd 4010 	ldrh.w	r4, [sp, #16]
	if (offset > value_len) {
   19852:	42a1      	cmp	r1, r4
   19854:	d80c      	bhi.n	19870 <bt_gatt_attr_read+0x28>
   19856:	4610      	mov	r0, r2
	len = MIN(buf_len, value_len - offset);
   19858:	1a64      	subs	r4, r4, r1
   1985a:	42a3      	cmp	r3, r4
   1985c:	bfa8      	it	ge
   1985e:	4623      	movge	r3, r4
	memcpy(buf, (uint8_t *)value + offset, len);
   19860:	b29c      	uxth	r4, r3
   19862:	4622      	mov	r2, r4
   19864:	9b03      	ldr	r3, [sp, #12]
   19866:	4419      	add	r1, r3
   19868:	f7fd ff62 	bl	17730 <memcpy>
}
   1986c:	4620      	mov	r0, r4
   1986e:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   19870:	f06f 0406 	mvn.w	r4, #6
   19874:	e7fa      	b.n	1986c <bt_gatt_attr_read+0x24>

00019876 <read_ppcp>:
{
   19876:	b510      	push	{r4, lr}
   19878:	b086      	sub	sp, #24
	ppcp.min_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MIN_INT);
   1987a:	2418      	movs	r4, #24
   1987c:	f8ad 4010 	strh.w	r4, [sp, #16]
	ppcp.max_int = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_MAX_INT);
   19880:	2428      	movs	r4, #40	; 0x28
   19882:	f8ad 4012 	strh.w	r4, [sp, #18]
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_LATENCY);
   19886:	2400      	movs	r4, #0
   19888:	f8ad 4014 	strh.w	r4, [sp, #20]
	ppcp.timeout = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_TIMEOUT);
   1988c:	242a      	movs	r4, #42	; 0x2a
   1988e:	f8ad 4016 	strh.w	r4, [sp, #22]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   19892:	2408      	movs	r4, #8
   19894:	9402      	str	r4, [sp, #8]
   19896:	ac04      	add	r4, sp, #16
   19898:	9401      	str	r4, [sp, #4]
   1989a:	f8bd 4020 	ldrh.w	r4, [sp, #32]
   1989e:	9400      	str	r4, [sp, #0]
   198a0:	f7ff ffd2 	bl	19848 <bt_gatt_attr_read>
}
   198a4:	b006      	add	sp, #24
   198a6:	bd10      	pop	{r4, pc}

000198a8 <read_appearance>:
{
   198a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   198aa:	b087      	sub	sp, #28
   198ac:	4604      	mov	r4, r0
   198ae:	460d      	mov	r5, r1
   198b0:	4616      	mov	r6, r2
   198b2:	461f      	mov	r7, r3
	uint16_t appearance = sys_cpu_to_le16(bt_get_appearance());
   198b4:	f7fe f94a 	bl	17b4c <bt_get_appearance>
   198b8:	f8ad 0016 	strh.w	r0, [sp, #22]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   198bc:	2302      	movs	r3, #2
   198be:	9302      	str	r3, [sp, #8]
   198c0:	f10d 0316 	add.w	r3, sp, #22
   198c4:	9301      	str	r3, [sp, #4]
   198c6:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   198ca:	9300      	str	r3, [sp, #0]
   198cc:	463b      	mov	r3, r7
   198ce:	4632      	mov	r2, r6
   198d0:	4629      	mov	r1, r5
   198d2:	4620      	mov	r0, r4
   198d4:	f7ff ffb8 	bl	19848 <bt_gatt_attr_read>
}
   198d8:	b007      	add	sp, #28
   198da:	bdf0      	pop	{r4, r5, r6, r7, pc}

000198dc <read_name>:
{
   198dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   198e0:	b084      	sub	sp, #16
   198e2:	4604      	mov	r4, r0
   198e4:	460d      	mov	r5, r1
   198e6:	4616      	mov	r6, r2
   198e8:	461f      	mov	r7, r3
	const char *name = bt_get_name();
   198ea:	f7ee ffed 	bl	88c8 <bt_get_name>
   198ee:	4680      	mov	r8, r0
				 strlen(name));
   198f0:	f7fd fedb 	bl	176aa <strlen>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   198f4:	b280      	uxth	r0, r0
   198f6:	9002      	str	r0, [sp, #8]
   198f8:	f8cd 8004 	str.w	r8, [sp, #4]
   198fc:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   19900:	9300      	str	r3, [sp, #0]
   19902:	463b      	mov	r3, r7
   19904:	4632      	mov	r2, r6
   19906:	4629      	mov	r1, r5
   19908:	4620      	mov	r0, r4
   1990a:	f7ff ff9d 	bl	19848 <bt_gatt_attr_read>
}
   1990e:	b004      	add	sp, #16
   19910:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00019914 <cf_read>:
{
   19914:	b5f0      	push	{r4, r5, r6, r7, lr}
   19916:	b087      	sub	sp, #28
   19918:	4604      	mov	r4, r0
   1991a:	460d      	mov	r5, r1
   1991c:	4616      	mov	r6, r2
   1991e:	461f      	mov	r7, r3
	uint8_t data[1] = {};
   19920:	2300      	movs	r3, #0
   19922:	f88d 3014 	strb.w	r3, [sp, #20]
	cfg = find_cf_cfg(conn);
   19926:	f7f2 ff69 	bl	c7fc <find_cf_cfg>
	if (cfg) {
   1992a:	b128      	cbz	r0, 19938 <cf_read+0x24>
   1992c:	4601      	mov	r1, r0
		memcpy(data, cfg->data, sizeof(data));
   1992e:	2201      	movs	r2, #1
   19930:	3108      	adds	r1, #8
   19932:	a805      	add	r0, sp, #20
   19934:	f7fd fefc 	bl	17730 <memcpy>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   19938:	2301      	movs	r3, #1
   1993a:	9302      	str	r3, [sp, #8]
   1993c:	ab05      	add	r3, sp, #20
   1993e:	9301      	str	r3, [sp, #4]
   19940:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   19944:	9300      	str	r3, [sp, #0]
   19946:	463b      	mov	r3, r7
   19948:	4632      	mov	r2, r6
   1994a:	4629      	mov	r1, r5
   1994c:	4620      	mov	r0, r4
   1994e:	f7ff ff7b 	bl	19848 <bt_gatt_attr_read>
}
   19952:	b007      	add	sp, #28
   19954:	bdf0      	pop	{r4, r5, r6, r7, pc}

00019956 <bt_gatt_attr_read_service>:
{
   19956:	b570      	push	{r4, r5, r6, lr}
   19958:	b086      	sub	sp, #24
   1995a:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
	struct bt_uuid *uuid = attr->user_data;
   1995e:	68cc      	ldr	r4, [r1, #12]
	if (uuid->type == BT_UUID_TYPE_16) {
   19960:	7826      	ldrb	r6, [r4, #0]
   19962:	b146      	cbz	r6, 19976 <bt_gatt_attr_read_service+0x20>
				 BT_UUID_128(uuid)->val, 16);
   19964:	3401      	adds	r4, #1
	return bt_gatt_attr_read(conn, attr, buf, len, offset,
   19966:	2610      	movs	r6, #16
   19968:	9602      	str	r6, [sp, #8]
   1996a:	9401      	str	r4, [sp, #4]
   1996c:	9500      	str	r5, [sp, #0]
   1996e:	f7ff ff6b 	bl	19848 <bt_gatt_attr_read>
}
   19972:	b006      	add	sp, #24
   19974:	bd70      	pop	{r4, r5, r6, pc}
		uint16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   19976:	8864      	ldrh	r4, [r4, #2]
   19978:	f8ad 4016 	strh.w	r4, [sp, #22]
		return bt_gatt_attr_read(conn, attr, buf, len, offset,
   1997c:	2402      	movs	r4, #2
   1997e:	9402      	str	r4, [sp, #8]
   19980:	f10d 0416 	add.w	r4, sp, #22
   19984:	9401      	str	r4, [sp, #4]
   19986:	9500      	str	r5, [sp, #0]
   19988:	f7ff ff5e 	bl	19848 <bt_gatt_attr_read>
   1998c:	e7f1      	b.n	19972 <bt_gatt_attr_read_service+0x1c>

0001998e <bt_gatt_attr_read_ccc>:
{
   1998e:	b5f0      	push	{r4, r5, r6, r7, lr}
   19990:	b087      	sub	sp, #28
   19992:	4605      	mov	r5, r0
   19994:	460c      	mov	r4, r1
   19996:	4616      	mov	r6, r2
   19998:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   1999a:	68c9      	ldr	r1, [r1, #12]
   1999c:	f7ff fd5b 	bl	19456 <find_ccc_cfg>
	if (cfg) {
   199a0:	b190      	cbz	r0, 199c8 <bt_gatt_attr_read_ccc+0x3a>
		value = sys_cpu_to_le16(cfg->value);
   199a2:	8903      	ldrh	r3, [r0, #8]
   199a4:	f8ad 3016 	strh.w	r3, [sp, #22]
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   199a8:	2302      	movs	r3, #2
   199aa:	9302      	str	r3, [sp, #8]
   199ac:	f10d 0316 	add.w	r3, sp, #22
   199b0:	9301      	str	r3, [sp, #4]
   199b2:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   199b6:	9300      	str	r3, [sp, #0]
   199b8:	463b      	mov	r3, r7
   199ba:	4632      	mov	r2, r6
   199bc:	4621      	mov	r1, r4
   199be:	4628      	mov	r0, r5
   199c0:	f7ff ff42 	bl	19848 <bt_gatt_attr_read>
}
   199c4:	b007      	add	sp, #28
   199c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		value = 0x0000;
   199c8:	2300      	movs	r3, #0
   199ca:	f8ad 3016 	strh.w	r3, [sp, #22]
   199ce:	e7eb      	b.n	199a8 <bt_gatt_attr_read_ccc+0x1a>

000199d0 <bt_gatt_attr_value_handle>:
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   199d0:	b1b8      	cbz	r0, 19a02 <bt_gatt_attr_value_handle+0x32>
{
   199d2:	b510      	push	{r4, lr}
   199d4:	b082      	sub	sp, #8
   199d6:	4604      	mov	r4, r0
	if (attr != NULL && bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) == 0) {
   199d8:	2300      	movs	r3, #0
   199da:	f88d 3004 	strb.w	r3, [sp, #4]
   199de:	f642 0303 	movw	r3, #10243	; 0x2803
   199e2:	f8ad 3006 	strh.w	r3, [sp, #6]
   199e6:	a901      	add	r1, sp, #4
   199e8:	6800      	ldr	r0, [r0, #0]
   199ea:	f7fd ff09 	bl	17800 <bt_uuid_cmp>
   199ee:	b950      	cbnz	r0, 19a06 <bt_gatt_attr_value_handle+0x36>
		struct bt_gatt_chrc *chrc = attr->user_data;
   199f0:	68e3      	ldr	r3, [r4, #12]
		handle = chrc->value_handle;
   199f2:	8898      	ldrh	r0, [r3, #4]
		if (handle == 0) {
   199f4:	b940      	cbnz	r0, 19a08 <bt_gatt_attr_value_handle+0x38>
			handle = bt_gatt_attr_get_handle(attr) + 1U;
   199f6:	4620      	mov	r0, r4
   199f8:	f7f3 fa62 	bl	cec0 <bt_gatt_attr_get_handle>
   199fc:	3001      	adds	r0, #1
   199fe:	b280      	uxth	r0, r0
   19a00:	e002      	b.n	19a08 <bt_gatt_attr_value_handle+0x38>
	uint16_t handle = 0;
   19a02:	2000      	movs	r0, #0
}
   19a04:	4770      	bx	lr
	uint16_t handle = 0;
   19a06:	2000      	movs	r0, #0
}
   19a08:	b002      	add	sp, #8
   19a0a:	bd10      	pop	{r4, pc}

00019a0c <bt_gatt_attr_read_chrc>:
{
   19a0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19a10:	b08a      	sub	sp, #40	; 0x28
   19a12:	4605      	mov	r5, r0
   19a14:	460c      	mov	r4, r1
   19a16:	4616      	mov	r6, r2
   19a18:	461f      	mov	r7, r3
	struct bt_gatt_chrc *chrc = attr->user_data;
   19a1a:	f8d1 800c 	ldr.w	r8, [r1, #12]
	pdu.properties = chrc->properties;
   19a1e:	f898 3006 	ldrb.w	r3, [r8, #6]
   19a22:	f88d 3014 	strb.w	r3, [sp, #20]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   19a26:	4608      	mov	r0, r1
   19a28:	f7ff ffd2 	bl	199d0 <bt_gatt_attr_value_handle>
   19a2c:	f8ad 0015 	strh.w	r0, [sp, #21]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   19a30:	f8d8 1000 	ldr.w	r1, [r8]
   19a34:	780b      	ldrb	r3, [r1, #0]
   19a36:	b993      	cbnz	r3, 19a5e <bt_gatt_attr_read_chrc+0x52>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   19a38:	884b      	ldrh	r3, [r1, #2]
   19a3a:	f8ad 3017 	strh.w	r3, [sp, #23]
		value_len += 2U;
   19a3e:	2305      	movs	r3, #5
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   19a40:	9302      	str	r3, [sp, #8]
   19a42:	ab05      	add	r3, sp, #20
   19a44:	9301      	str	r3, [sp, #4]
   19a46:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   19a4a:	9300      	str	r3, [sp, #0]
   19a4c:	463b      	mov	r3, r7
   19a4e:	4632      	mov	r2, r6
   19a50:	4621      	mov	r1, r4
   19a52:	4628      	mov	r0, r5
   19a54:	f7ff fef8 	bl	19848 <bt_gatt_attr_read>
}
   19a58:	b00a      	add	sp, #40	; 0x28
   19a5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   19a5e:	2210      	movs	r2, #16
   19a60:	3101      	adds	r1, #1
   19a62:	f10d 0017 	add.w	r0, sp, #23
   19a66:	f7fd fe63 	bl	17730 <memcpy>
		value_len += 16U;
   19a6a:	2313      	movs	r3, #19
   19a6c:	e7e8      	b.n	19a40 <bt_gatt_attr_read_chrc+0x34>

00019a6e <db_hash_process>:
{
   19a6e:	b508      	push	{r3, lr}
	db_hash_gen(true);
   19a70:	2001      	movs	r0, #1
   19a72:	f7f3 fa9f 	bl	cfb4 <db_hash_gen>
}
   19a76:	bd08      	pop	{r3, pc}

00019a78 <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   19a78:	f012 0f01 	tst.w	r2, #1
   19a7c:	d005      	beq.n	19a8a <bt_gatt_check_perm+0x12>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   19a7e:	8a4b      	ldrh	r3, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   19a80:	f013 0f95 	tst.w	r3, #149	; 0x95
   19a84:	d01e      	beq.n	19ac4 <bt_gatt_check_perm+0x4c>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   19a86:	684b      	ldr	r3, [r1, #4]
   19a88:	b1f3      	cbz	r3, 19ac8 <bt_gatt_check_perm+0x50>
	if ((mask & BT_GATT_PERM_WRITE) &&
   19a8a:	f012 0f02 	tst.w	r2, #2
   19a8e:	d005      	beq.n	19a9c <bt_gatt_check_perm+0x24>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   19a90:	8a4b      	ldrh	r3, [r1, #18]
	if ((mask & BT_GATT_PERM_WRITE) &&
   19a92:	f413 7f95 	tst.w	r3, #298	; 0x12a
   19a96:	d019      	beq.n	19acc <bt_gatt_check_perm+0x54>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   19a98:	688b      	ldr	r3, [r1, #8]
   19a9a:	b1cb      	cbz	r3, 19ad0 <bt_gatt_check_perm+0x58>
{
   19a9c:	b510      	push	{r4, lr}
	mask &= attr->perm;
   19a9e:	8a4c      	ldrh	r4, [r1, #18]
   19aa0:	4014      	ands	r4, r2
	if (mask & BT_GATT_PERM_LESC_MASK) {
   19aa2:	f414 7fc0 	tst.w	r4, #384	; 0x180
   19aa6:	d115      	bne.n	19ad4 <bt_gatt_check_perm+0x5c>
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   19aa8:	f014 0f30 	tst.w	r4, #48	; 0x30
   19aac:	d104      	bne.n	19ab8 <bt_gatt_check_perm+0x40>
	if ((mask & BT_GATT_PERM_ENCRYPT_MASK)) {
   19aae:	f014 0f0c 	tst.w	r4, #12
   19ab2:	d111      	bne.n	19ad8 <bt_gatt_check_perm+0x60>
	return 0;
   19ab4:	2000      	movs	r0, #0
}
   19ab6:	bd10      	pop	{r4, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   19ab8:	f7fe fb59 	bl	1816e <bt_conn_get_security>
   19abc:	2802      	cmp	r0, #2
   19abe:	d8f6      	bhi.n	19aae <bt_gatt_check_perm+0x36>
			return BT_ATT_ERR_AUTHENTICATION;
   19ac0:	2005      	movs	r0, #5
   19ac2:	e7f8      	b.n	19ab6 <bt_gatt_check_perm+0x3e>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   19ac4:	2002      	movs	r0, #2
   19ac6:	4770      	bx	lr
   19ac8:	2002      	movs	r0, #2
   19aca:	4770      	bx	lr
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   19acc:	2003      	movs	r0, #3
   19ace:	4770      	bx	lr
   19ad0:	2003      	movs	r0, #3
}
   19ad2:	4770      	bx	lr
			return BT_ATT_ERR_AUTHENTICATION;
   19ad4:	2005      	movs	r0, #5
   19ad6:	e7ee      	b.n	19ab6 <bt_gatt_check_perm+0x3e>
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   19ad8:	200f      	movs	r0, #15
   19ada:	e7ec      	b.n	19ab6 <bt_gatt_check_perm+0x3e>

00019adc <bt_gatt_is_subscribed>:
	if (conn->state != BT_CONN_CONNECTED) {
   19adc:	7a83      	ldrb	r3, [r0, #10]
   19ade:	2b07      	cmp	r3, #7
   19ae0:	d001      	beq.n	19ae6 <bt_gatt_is_subscribed+0xa>
		return false;
   19ae2:	2000      	movs	r0, #0
}
   19ae4:	4770      	bx	lr
{
   19ae6:	b5f0      	push	{r4, r5, r6, r7, lr}
   19ae8:	b089      	sub	sp, #36	; 0x24
   19aea:	4605      	mov	r5, r0
   19aec:	460c      	mov	r4, r1
   19aee:	4616      	mov	r6, r2
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
   19af0:	6808      	ldr	r0, [r1, #0]
   19af2:	2300      	movs	r3, #0
   19af4:	f88d 3004 	strb.w	r3, [sp, #4]
   19af8:	f642 0303 	movw	r3, #10243	; 0x2803
   19afc:	f8ad 3006 	strh.w	r3, [sp, #6]
   19b00:	a901      	add	r1, sp, #4
   19b02:	f7fd fe7d 	bl	17800 <bt_uuid_cmp>
   19b06:	b950      	cbnz	r0, 19b1e <bt_gatt_is_subscribed+0x42>
		struct bt_gatt_chrc *chrc = attr->user_data;
   19b08:	68e3      	ldr	r3, [r4, #12]
		if (!(chrc->properties &
   19b0a:	799b      	ldrb	r3, [r3, #6]
   19b0c:	f013 0f30 	tst.w	r3, #48	; 0x30
   19b10:	d101      	bne.n	19b16 <bt_gatt_is_subscribed+0x3a>
}
   19b12:	b009      	add	sp, #36	; 0x24
   19b14:	bdf0      	pop	{r4, r5, r6, r7, pc}
		attr = bt_gatt_attr_next(attr);
   19b16:	4620      	mov	r0, r4
   19b18:	f7f3 fb36 	bl	d188 <bt_gatt_attr_next>
   19b1c:	4604      	mov	r4, r0
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
   19b1e:	6820      	ldr	r0, [r4, #0]
   19b20:	2300      	movs	r3, #0
   19b22:	f88d 3008 	strb.w	r3, [sp, #8]
   19b26:	f642 1302 	movw	r3, #10498	; 0x2902
   19b2a:	f8ad 300a 	strh.w	r3, [sp, #10]
   19b2e:	a902      	add	r1, sp, #8
   19b30:	f7fd fe66 	bl	17800 <bt_uuid_cmp>
   19b34:	2800      	cmp	r0, #0
   19b36:	d136      	bne.n	19ba6 <bt_gatt_is_subscribed+0xca>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   19b38:	6820      	ldr	r0, [r4, #0]
   19b3a:	2300      	movs	r3, #0
   19b3c:	f88d 300c 	strb.w	r3, [sp, #12]
   19b40:	f642 1302 	movw	r3, #10498	; 0x2902
   19b44:	f8ad 300e 	strh.w	r3, [sp, #14]
   19b48:	a903      	add	r1, sp, #12
   19b4a:	f7fd fe59 	bl	17800 <bt_uuid_cmp>
   19b4e:	b378      	cbz	r0, 19bb0 <bt_gatt_is_subscribed+0xd4>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
   19b50:	6820      	ldr	r0, [r4, #0]
   19b52:	2300      	movs	r3, #0
   19b54:	f88d 3010 	strb.w	r3, [sp, #16]
   19b58:	f642 0303 	movw	r3, #10243	; 0x2803
   19b5c:	f8ad 3012 	strh.w	r3, [sp, #18]
   19b60:	a904      	add	r1, sp, #16
   19b62:	f7fd fe4d 	bl	17800 <bt_uuid_cmp>
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   19b66:	b318      	cbz	r0, 19bb0 <bt_gatt_is_subscribed+0xd4>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   19b68:	6820      	ldr	r0, [r4, #0]
   19b6a:	2300      	movs	r3, #0
   19b6c:	f88d 3014 	strb.w	r3, [sp, #20]
   19b70:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   19b74:	f8ad 3016 	strh.w	r3, [sp, #22]
   19b78:	a905      	add	r1, sp, #20
   19b7a:	f7fd fe41 	bl	17800 <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC) &&
   19b7e:	b1b8      	cbz	r0, 19bb0 <bt_gatt_is_subscribed+0xd4>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   19b80:	6820      	ldr	r0, [r4, #0]
   19b82:	2300      	movs	r3, #0
   19b84:	f88d 3018 	strb.w	r3, [sp, #24]
   19b88:	f642 0301 	movw	r3, #10241	; 0x2801
   19b8c:	f8ad 301a 	strh.w	r3, [sp, #26]
   19b90:	a906      	add	r1, sp, #24
   19b92:	f7fd fe35 	bl	17800 <bt_uuid_cmp>
	       bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   19b96:	b158      	cbz	r0, 19bb0 <bt_gatt_is_subscribed+0xd4>
		attr = bt_gatt_attr_next(attr);
   19b98:	4620      	mov	r0, r4
   19b9a:	f7f3 faf5 	bl	d188 <bt_gatt_attr_next>
		if (!attr) {
   19b9e:	4604      	mov	r4, r0
   19ba0:	2800      	cmp	r0, #0
   19ba2:	d1c9      	bne.n	19b38 <bt_gatt_is_subscribed+0x5c>
   19ba4:	e7b5      	b.n	19b12 <bt_gatt_is_subscribed+0x36>
		attr = bt_gatt_attr_next(attr);
   19ba6:	4620      	mov	r0, r4
   19ba8:	f7f3 faee 	bl	d188 <bt_gatt_attr_next>
   19bac:	4604      	mov	r4, r0
	while (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) &&
   19bae:	e7c3      	b.n	19b38 <bt_gatt_is_subscribed+0x5c>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CCC) != 0) {
   19bb0:	6820      	ldr	r0, [r4, #0]
   19bb2:	2300      	movs	r3, #0
   19bb4:	f88d 301c 	strb.w	r3, [sp, #28]
   19bb8:	f642 1302 	movw	r3, #10498	; 0x2902
   19bbc:	f8ad 301e 	strh.w	r3, [sp, #30]
   19bc0:	a907      	add	r1, sp, #28
   19bc2:	f7fd fe1d 	bl	17800 <bt_uuid_cmp>
   19bc6:	b920      	cbnz	r0, 19bd2 <bt_gatt_is_subscribed+0xf6>
	ccc = attr->user_data;
   19bc8:	68e7      	ldr	r7, [r4, #12]
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
   19bca:	2400      	movs	r4, #0
   19bcc:	b11c      	cbz	r4, 19bd6 <bt_gatt_is_subscribed+0xfa>
	return false;
   19bce:	2000      	movs	r0, #0
   19bd0:	e79f      	b.n	19b12 <bt_gatt_is_subscribed+0x36>
		return false;
   19bd2:	2000      	movs	r0, #0
   19bd4:	e79d      	b.n	19b12 <bt_gatt_is_subscribed+0x36>
		if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer) &&
   19bd6:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   19bda:	eb07 0243 	add.w	r2, r7, r3, lsl #1
   19bde:	3201      	adds	r2, #1
   19be0:	f817 1013 	ldrb.w	r1, [r7, r3, lsl #1]
   19be4:	4628      	mov	r0, r5
   19be6:	f7fe fadb 	bl	181a0 <bt_conn_is_peer_addr_le>
   19bea:	b130      	cbz	r0, 19bfa <bt_gatt_is_subscribed+0x11e>
		    (ccc_type & ccc->cfg[i].value)) {
   19bec:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   19bf0:	eb07 0343 	add.w	r3, r7, r3, lsl #1
   19bf4:	891b      	ldrh	r3, [r3, #8]
		if (bt_conn_is_peer_addr_le(conn, cfg->id, &cfg->peer) &&
   19bf6:	4233      	tst	r3, r6
   19bf8:	d18b      	bne.n	19b12 <bt_gatt_is_subscribed+0x36>
	for (size_t i = 0; i < BT_GATT_CCC_MAX; i++) {
   19bfa:	3401      	adds	r4, #1
   19bfc:	e7e6      	b.n	19bcc <bt_gatt_is_subscribed+0xf0>

00019bfe <bt_gatt_cancel>:
{
   19bfe:	b570      	push	{r4, r5, r6, lr}
   19c00:	b082      	sub	sp, #8
   19c02:	4604      	mov	r4, r0
   19c04:	460d      	mov	r5, r1
	k_sched_lock();
   19c06:	f7fa fa5b 	bl	140c0 <k_sched_lock>
	req = bt_att_find_req_by_user_data(conn, params);
   19c0a:	4629      	mov	r1, r5
   19c0c:	4620      	mov	r0, r4
   19c0e:	f7ff fac5 	bl	1919c <bt_att_find_req_by_user_data>
	if (req) {
   19c12:	b178      	cbz	r0, 19c34 <bt_gatt_cancel+0x36>
   19c14:	4601      	mov	r1, r0
		func = req->func;
   19c16:	6846      	ldr	r6, [r0, #4]
		bt_att_req_cancel(conn, req);
   19c18:	4620      	mov	r0, r4
   19c1a:	f7ff fa73 	bl	19104 <bt_att_req_cancel>
	k_sched_unlock();
   19c1e:	f7fa fc71 	bl	14504 <k_sched_unlock>
	if (func) {
   19c22:	b12e      	cbz	r6, 19c30 <bt_gatt_cancel+0x32>
		func(conn, BT_ATT_ERR_UNLIKELY, NULL, 0, params);
   19c24:	9500      	str	r5, [sp, #0]
   19c26:	2300      	movs	r3, #0
   19c28:	461a      	mov	r2, r3
   19c2a:	210e      	movs	r1, #14
   19c2c:	4620      	mov	r0, r4
   19c2e:	47b0      	blx	r6
}
   19c30:	b002      	add	sp, #8
   19c32:	bd70      	pop	{r4, r5, r6, pc}
	k_sched_unlock();
   19c34:	f7fa fc66 	bl	14504 <k_sched_unlock>
	if (func) {
   19c38:	e7fa      	b.n	19c30 <bt_gatt_cancel+0x32>

00019c3a <bt_gatt_unsubscribe>:
	if (conn->state != BT_CONN_CONNECTED) {
   19c3a:	7a83      	ldrb	r3, [r0, #10]
   19c3c:	2b07      	cmp	r3, #7
   19c3e:	d167      	bne.n	19d10 <bt_gatt_unsubscribe+0xd6>
{
   19c40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19c44:	4606      	mov	r6, r0
   19c46:	460d      	mov	r5, r1
	sub = gatt_sub_find(conn);
   19c48:	f7f2 fe26 	bl	c898 <gatt_sub_find>
	if (!sub) {
   19c4c:	4680      	mov	r8, r0
   19c4e:	2800      	cmp	r0, #0
   19c50:	d061      	beq.n	19d16 <bt_gatt_unsubscribe+0xdc>
	return list->head;
   19c52:	6884      	ldr	r4, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   19c54:	b104      	cbz	r4, 19c58 <bt_gatt_unsubscribe+0x1e>
   19c56:	3c18      	subs	r4, #24
   19c58:	2100      	movs	r1, #0
   19c5a:	460f      	mov	r7, r1
   19c5c:	e006      	b.n	19c6c <bt_gatt_unsubscribe+0x32>
			found = true;
   19c5e:	2101      	movs	r1, #1
Z_GENLIST_PEEK_NEXT(slist, snode)
   19c60:	f114 0318 	adds.w	r3, r4, #24
   19c64:	d00b      	beq.n	19c7e <bt_gatt_unsubscribe+0x44>
	return node->next;
   19c66:	69a4      	ldr	r4, [r4, #24]
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   19c68:	b104      	cbz	r4, 19c6c <bt_gatt_unsubscribe+0x32>
   19c6a:	3c18      	subs	r4, #24
   19c6c:	b14c      	cbz	r4, 19c82 <bt_gatt_unsubscribe+0x48>
		if (params == tmp) {
   19c6e:	42ac      	cmp	r4, r5
   19c70:	d0f5      	beq.n	19c5e <bt_gatt_unsubscribe+0x24>
		if (tmp->value_handle == params->value_handle) {
   19c72:	89a2      	ldrh	r2, [r4, #12]
   19c74:	89ab      	ldrh	r3, [r5, #12]
   19c76:	429a      	cmp	r2, r3
   19c78:	d1f2      	bne.n	19c60 <bt_gatt_unsubscribe+0x26>
			has_subscription = true;
   19c7a:	2701      	movs	r7, #1
   19c7c:	e7f0      	b.n	19c60 <bt_gatt_unsubscribe+0x26>
	SYS_SLIST_FOR_EACH_CONTAINER(&sub->list, tmp, node) {
   19c7e:	461c      	mov	r4, r3
   19c80:	e7f4      	b.n	19c6c <bt_gatt_unsubscribe+0x32>
	if (!found) {
   19c82:	2900      	cmp	r1, #0
   19c84:	d04a      	beq.n	19d1c <bt_gatt_unsubscribe+0xe2>
	if (atomic_test_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING)) {
   19c86:	f105 0314 	add.w	r3, r5, #20
   19c8a:	e8d3 3faf 	lda	r3, [r3]
   19c8e:	f013 0f04 	tst.w	r3, #4
   19c92:	d10f      	bne.n	19cb4 <bt_gatt_unsubscribe+0x7a>
	if (!has_subscription) {
   19c94:	b93f      	cbnz	r7, 19ca6 <bt_gatt_unsubscribe+0x6c>
		params->value = 0x0000;
   19c96:	2300      	movs	r3, #0
   19c98:	822b      	strh	r3, [r5, #16]
		err = gatt_write_ccc(conn, params);
   19c9a:	4629      	mov	r1, r5
   19c9c:	4630      	mov	r0, r6
   19c9e:	f7f3 f8cb 	bl	ce38 <gatt_write_ccc>
		if (err) {
   19ca2:	2800      	cmp	r0, #0
   19ca4:	d13e      	bne.n	19d24 <bt_gatt_unsubscribe+0xea>
	sys_slist_find_and_remove(&sub->list, &params->node);
   19ca6:	f108 0108 	add.w	r1, r8, #8
   19caa:	f105 0218 	add.w	r2, r5, #24
	return list->head;
   19cae:	f8d8 3008 	ldr.w	r3, [r8, #8]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   19cb2:	e010      	b.n	19cd6 <bt_gatt_unsubscribe+0x9c>
		bt_gatt_cancel(conn, params);
   19cb4:	4629      	mov	r1, r5
   19cb6:	4630      	mov	r0, r6
   19cb8:	f7ff ffa1 	bl	19bfe <bt_gatt_cancel>
   19cbc:	e7ea      	b.n	19c94 <bt_gatt_unsubscribe+0x5a>
	return node->next;
   19cbe:	69ab      	ldr	r3, [r5, #24]
	list->head = node;
   19cc0:	f8c8 3008 	str.w	r3, [r8, #8]
	return list->tail;
   19cc4:	6848      	ldr	r0, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   19cc6:	4282      	cmp	r2, r0
   19cc8:	d10f      	bne.n	19cea <bt_gatt_unsubscribe+0xb0>
	list->tail = node;
   19cca:	604b      	str	r3, [r1, #4]
}
   19ccc:	e00d      	b.n	19cea <bt_gatt_unsubscribe+0xb0>
	list->tail = node;
   19cce:	604c      	str	r4, [r1, #4]
}
   19cd0:	e00b      	b.n	19cea <bt_gatt_unsubscribe+0xb0>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   19cd2:	461c      	mov	r4, r3
   19cd4:	681b      	ldr	r3, [r3, #0]
   19cd6:	b153      	cbz	r3, 19cee <bt_gatt_unsubscribe+0xb4>
   19cd8:	429a      	cmp	r2, r3
   19cda:	d1fa      	bne.n	19cd2 <bt_gatt_unsubscribe+0x98>
Z_GENLIST_REMOVE(slist, snode)
   19cdc:	2c00      	cmp	r4, #0
   19cde:	d0ee      	beq.n	19cbe <bt_gatt_unsubscribe+0x84>
	return node->next;
   19ce0:	69ab      	ldr	r3, [r5, #24]
	parent->next = child;
   19ce2:	6023      	str	r3, [r4, #0]
	return list->tail;
   19ce4:	684b      	ldr	r3, [r1, #4]
Z_GENLIST_REMOVE(slist, snode)
   19ce6:	429a      	cmp	r2, r3
   19ce8:	d0f1      	beq.n	19cce <bt_gatt_unsubscribe+0x94>
	parent->next = child;
   19cea:	2300      	movs	r3, #0
   19cec:	61ab      	str	r3, [r5, #24]
	if (gatt_sub_is_empty(sub)) {
   19cee:	4640      	mov	r0, r8
   19cf0:	f7ff fb3b 	bl	1936a <gatt_sub_is_empty>
   19cf4:	b940      	cbnz	r0, 19d08 <bt_gatt_unsubscribe+0xce>
	if (has_subscription) {
   19cf6:	b1a7      	cbz	r7, 19d22 <bt_gatt_unsubscribe+0xe8>
		params->notify(conn, params, NULL, 0);
   19cf8:	682c      	ldr	r4, [r5, #0]
   19cfa:	2300      	movs	r3, #0
   19cfc:	461a      	mov	r2, r3
   19cfe:	4629      	mov	r1, r5
   19d00:	4630      	mov	r0, r6
   19d02:	47a0      	blx	r4
	return 0;
   19d04:	2000      	movs	r0, #0
   19d06:	e00d      	b.n	19d24 <bt_gatt_unsubscribe+0xea>
		gatt_sub_free(sub);
   19d08:	4640      	mov	r0, r8
   19d0a:	f7ff fbe0 	bl	194ce <gatt_sub_free>
   19d0e:	e7f2      	b.n	19cf6 <bt_gatt_unsubscribe+0xbc>
		return -ENOTCONN;
   19d10:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   19d14:	4770      	bx	lr
		return -EINVAL;
   19d16:	f06f 0015 	mvn.w	r0, #21
   19d1a:	e003      	b.n	19d24 <bt_gatt_unsubscribe+0xea>
		return -EINVAL;
   19d1c:	f06f 0015 	mvn.w	r0, #21
   19d20:	e000      	b.n	19d24 <bt_gatt_unsubscribe+0xea>
	return 0;
   19d22:	2000      	movs	r0, #0
}
   19d24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00019d28 <bt_gatt_notification>:
{
   19d28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19d2c:	4680      	mov	r8, r0
   19d2e:	460f      	mov	r7, r1
   19d30:	4691      	mov	r9, r2
   19d32:	469a      	mov	sl, r3
	sub = gatt_sub_find(conn);
   19d34:	f7f2 fdb0 	bl	c898 <gatt_sub_find>
	if (!sub) {
   19d38:	b380      	cbz	r0, 19d9c <bt_gatt_notification+0x74>
	return list->head;
   19d3a:	6885      	ldr	r5, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   19d3c:	b145      	cbz	r5, 19d50 <bt_gatt_notification+0x28>
   19d3e:	3d18      	subs	r5, #24
   19d40:	d008      	beq.n	19d54 <bt_gatt_notification+0x2c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   19d42:	f115 0418 	adds.w	r4, r5, #24
   19d46:	d010      	beq.n	19d6a <bt_gatt_notification+0x42>
	return node->next;
   19d48:	69ac      	ldr	r4, [r5, #24]
   19d4a:	b174      	cbz	r4, 19d6a <bt_gatt_notification+0x42>
   19d4c:	3c18      	subs	r4, #24
   19d4e:	e00c      	b.n	19d6a <bt_gatt_notification+0x42>
   19d50:	462c      	mov	r4, r5
   19d52:	e00a      	b.n	19d6a <bt_gatt_notification+0x42>
   19d54:	462c      	mov	r4, r5
   19d56:	e008      	b.n	19d6a <bt_gatt_notification+0x42>
   19d58:	b1f4      	cbz	r4, 19d98 <bt_gatt_notification+0x70>
Z_GENLIST_PEEK_NEXT(slist, snode)
   19d5a:	f114 0618 	adds.w	r6, r4, #24
   19d5e:	d002      	beq.n	19d66 <bt_gatt_notification+0x3e>
	return node->next;
   19d60:	69a6      	ldr	r6, [r4, #24]
   19d62:	b106      	cbz	r6, 19d66 <bt_gatt_notification+0x3e>
   19d64:	3e18      	subs	r6, #24
   19d66:	4625      	mov	r5, r4
   19d68:	4634      	mov	r4, r6
   19d6a:	b1bd      	cbz	r5, 19d9c <bt_gatt_notification+0x74>
		if (handle != params->value_handle) {
   19d6c:	89ab      	ldrh	r3, [r5, #12]
   19d6e:	429f      	cmp	r7, r3
   19d70:	d1f2      	bne.n	19d58 <bt_gatt_notification+0x30>
		if (check_subscribe_security_level(conn, params)) {
   19d72:	4629      	mov	r1, r5
   19d74:	4640      	mov	r0, r8
   19d76:	f7ff fafd 	bl	19374 <check_subscribe_security_level>
   19d7a:	2800      	cmp	r0, #0
   19d7c:	d0ec      	beq.n	19d58 <bt_gatt_notification+0x30>
			if (params->notify(conn, params, data, length) ==
   19d7e:	682e      	ldr	r6, [r5, #0]
   19d80:	4653      	mov	r3, sl
   19d82:	464a      	mov	r2, r9
   19d84:	4629      	mov	r1, r5
   19d86:	4640      	mov	r0, r8
   19d88:	47b0      	blx	r6
   19d8a:	2800      	cmp	r0, #0
   19d8c:	d1e4      	bne.n	19d58 <bt_gatt_notification+0x30>
				bt_gatt_unsubscribe(conn, params);
   19d8e:	4629      	mov	r1, r5
   19d90:	4640      	mov	r0, r8
   19d92:	f7ff ff52 	bl	19c3a <bt_gatt_unsubscribe>
   19d96:	e7df      	b.n	19d58 <bt_gatt_notification+0x30>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&sub->list, params, tmp, node) {
   19d98:	4626      	mov	r6, r4
   19d9a:	e7e4      	b.n	19d66 <bt_gatt_notification+0x3e>
}
   19d9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00019da0 <bt_gatt_change_aware>:
{
   19da0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19da2:	4607      	mov	r7, r0
   19da4:	460e      	mov	r6, r1
	cfg = find_cf_cfg(conn);
   19da6:	f7f2 fd29 	bl	c7fc <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   19daa:	2800      	cmp	r0, #0
   19dac:	d049      	beq.n	19e42 <bt_gatt_change_aware+0xa2>
   19dae:	7a02      	ldrb	r2, [r0, #8]
   19db0:	f012 0f01 	tst.w	r2, #1
   19db4:	d102      	bne.n	19dbc <bt_gatt_change_aware+0x1c>
		return true;
   19db6:	2401      	movs	r4, #1
}
   19db8:	4620      	mov	r0, r4
   19dba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   19dbc:	f100 050c 	add.w	r5, r0, #12
   19dc0:	e8d5 4faf 	lda	r4, [r5]
   19dc4:	f014 0401 	ands.w	r4, r4, #1
   19dc8:	d1f6      	bne.n	19db8 <bt_gatt_change_aware+0x18>
	if (!req) {
   19dca:	b90e      	cbnz	r6, 19dd0 <bt_gatt_change_aware+0x30>
		return false;
   19dcc:	4634      	mov	r4, r6
   19dce:	e7f3      	b.n	19db8 <bt_gatt_change_aware+0x18>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   19dd0:	e8d5 3fef 	ldaex	r3, [r5]
   19dd4:	f023 0202 	bic.w	r2, r3, #2
   19dd8:	e8c5 2fe1 	stlex	r1, r2, [r5]
   19ddc:	2900      	cmp	r1, #0
   19dde:	d1f7      	bne.n	19dd0 <bt_gatt_change_aware+0x30>
	return (old & mask) != 0;
   19de0:	f3c3 0440 	ubfx	r4, r3, #1, #1
	if (atomic_test_and_clear_bit(cfg->flags, CF_DB_HASH_READ)) {
   19de4:	f013 0f02 	tst.w	r3, #2
   19de8:	d11f      	bne.n	19e2a <bt_gatt_change_aware+0x8a>
	if (bt_att_fixed_chan_only(conn) && bt_att_out_of_sync_sent_on_fixed(conn)) {
   19dea:	4638      	mov	r0, r7
   19dec:	f7ff f9ff 	bl	191ee <bt_att_fixed_chan_only>
   19df0:	4604      	mov	r4, r0
   19df2:	2800      	cmp	r0, #0
   19df4:	d0e0      	beq.n	19db8 <bt_gatt_change_aware+0x18>
   19df6:	4638      	mov	r0, r7
   19df8:	f7ff fa18 	bl	1922c <bt_att_out_of_sync_sent_on_fixed>
   19dfc:	4604      	mov	r4, r0
   19dfe:	2800      	cmp	r0, #0
   19e00:	d0da      	beq.n	19db8 <bt_gatt_change_aware+0x18>
   19e02:	e8d5 3fef 	ldaex	r3, [r5]
   19e06:	f023 0302 	bic.w	r3, r3, #2
   19e0a:	e8c5 3fe2 	stlex	r2, r3, [r5]
   19e0e:	2a00      	cmp	r2, #0
   19e10:	d1f7      	bne.n	19e02 <bt_gatt_change_aware+0x62>
		bt_att_clear_out_of_sync_sent(conn);
   19e12:	4638      	mov	r0, r7
   19e14:	f7ff f9ed 	bl	191f2 <bt_att_clear_out_of_sync_sent>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   19e18:	e8d5 3fef 	ldaex	r3, [r5]
   19e1c:	f043 0301 	orr.w	r3, r3, #1
   19e20:	e8c5 3fe2 	stlex	r2, r3, [r5]
   19e24:	2a00      	cmp	r2, #0
   19e26:	d0c7      	beq.n	19db8 <bt_gatt_change_aware+0x18>
   19e28:	e7f6      	b.n	19e18 <bt_gatt_change_aware+0x78>
		bt_att_clear_out_of_sync_sent(conn);
   19e2a:	4638      	mov	r0, r7
   19e2c:	f7ff f9e1 	bl	191f2 <bt_att_clear_out_of_sync_sent>
   19e30:	e8d5 3fef 	ldaex	r3, [r5]
   19e34:	f043 0301 	orr.w	r3, r3, #1
   19e38:	e8c5 3fe2 	stlex	r2, r3, [r5]
   19e3c:	2a00      	cmp	r2, #0
   19e3e:	d0bb      	beq.n	19db8 <bt_gatt_change_aware+0x18>
   19e40:	e7f6      	b.n	19e30 <bt_gatt_change_aware+0x90>
		return true;
   19e42:	2401      	movs	r4, #1
   19e44:	e7b8      	b.n	19db8 <bt_gatt_change_aware+0x18>

00019e46 <bt_smp_recv>:
{
   19e46:	b5f0      	push	{r4, r5, r6, r7, lr}
   19e48:	b083      	sub	sp, #12
	struct bt_conn *conn = chan->conn;
   19e4a:	6807      	ldr	r7, [r0, #0]
	buf = bt_l2cap_create_pdu(NULL, 0);
   19e4c:	f04f 32ff 	mov.w	r2, #4294967295
   19e50:	f04f 33ff 	mov.w	r3, #4294967295
   19e54:	2100      	movs	r1, #0
   19e56:	4608      	mov	r0, r1
   19e58:	f7fe fa3f 	bl	182da <bt_l2cap_create_pdu_timeout>
   19e5c:	4604      	mov	r4, r0
	return net_buf_simple_add(&buf->b, len);
   19e5e:	f100 0608 	add.w	r6, r0, #8
   19e62:	2101      	movs	r1, #1
   19e64:	4630      	mov	r0, r6
   19e66:	f000 f9ca 	bl	1a1fe <net_buf_simple_add>
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   19e6a:	2505      	movs	r5, #5
   19e6c:	7005      	strb	r5, [r0, #0]
   19e6e:	2101      	movs	r1, #1
   19e70:	4630      	mov	r0, r6
   19e72:	f000 f9c4 	bl	1a1fe <net_buf_simple_add>
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   19e76:	7005      	strb	r5, [r0, #0]
   19e78:	2300      	movs	r3, #0
   19e7a:	9300      	str	r3, [sp, #0]
   19e7c:	4622      	mov	r2, r4
   19e7e:	2106      	movs	r1, #6
   19e80:	4638      	mov	r0, r7
   19e82:	f7fe fa2f 	bl	182e4 <bt_l2cap_send_cb>
	if (bt_l2cap_send(conn, BT_L2CAP_CID_SMP, buf)) {
   19e86:	b910      	cbnz	r0, 19e8e <bt_smp_recv+0x48>
}
   19e88:	2000      	movs	r0, #0
   19e8a:	b003      	add	sp, #12
   19e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		net_buf_unref(buf);
   19e8e:	4620      	mov	r0, r4
   19e90:	f000 f96b 	bl	1a16a <net_buf_unref>
   19e94:	e7f8      	b.n	19e88 <bt_smp_recv+0x42>

00019e96 <bt_smp_sign>:
}
   19e96:	f06f 0085 	mvn.w	r0, #133	; 0x85
   19e9a:	4770      	bx	lr

00019e9c <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept, NULL);

int bt_smp_init(void)
{
	return 0;
}
   19e9c:	2000      	movs	r0, #0
   19e9e:	4770      	bx	lr

00019ea0 <fixed_data_unref>:
}

static void fixed_data_unref(struct net_buf *buf, uint8_t *data)
{
	/* Nothing needed for fixed-size data pools */
}
   19ea0:	4770      	bx	lr

00019ea2 <data_alloc>:
};

#endif /* CONFIG_HEAP_MEM_POOL_SIZE > 0 */

static uint8_t *data_alloc(struct net_buf *buf, size_t *size, k_timeout_t timeout)
{
   19ea2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19ea6:	4604      	mov	r4, r0
   19ea8:	460d      	mov	r5, r1
   19eaa:	4617      	mov	r7, r2
   19eac:	461e      	mov	r6, r3
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   19eae:	7980      	ldrb	r0, [r0, #6]
   19eb0:	f7f3 fede 	bl	dc70 <net_buf_pool_get>

	return pool->alloc->cb->alloc(buf, size, timeout);
   19eb4:	6a43      	ldr	r3, [r0, #36]	; 0x24
   19eb6:	681b      	ldr	r3, [r3, #0]
   19eb8:	f8d3 8000 	ldr.w	r8, [r3]
   19ebc:	463a      	mov	r2, r7
   19ebe:	4633      	mov	r3, r6
   19ec0:	4629      	mov	r1, r5
   19ec2:	4620      	mov	r0, r4
   19ec4:	47c0      	blx	r8
}
   19ec6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00019eca <data_unref>:

	return pool->alloc->cb->ref(buf, data);
}

static void data_unref(struct net_buf *buf, uint8_t *data)
{
   19eca:	b538      	push	{r3, r4, r5, lr}
   19ecc:	4604      	mov	r4, r0
   19ece:	460d      	mov	r5, r1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   19ed0:	7980      	ldrb	r0, [r0, #6]
   19ed2:	f7f3 fecd 	bl	dc70 <net_buf_pool_get>

	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   19ed6:	7963      	ldrb	r3, [r4, #5]
   19ed8:	f013 0f02 	tst.w	r3, #2
   19edc:	d105      	bne.n	19eea <data_unref+0x20>
		return;
	}

	pool->alloc->cb->unref(buf, data);
   19ede:	6a43      	ldr	r3, [r0, #36]	; 0x24
   19ee0:	681b      	ldr	r3, [r3, #0]
   19ee2:	689b      	ldr	r3, [r3, #8]
   19ee4:	4629      	mov	r1, r5
   19ee6:	4620      	mov	r0, r4
   19ee8:	4798      	blx	r3
}
   19eea:	bd38      	pop	{r3, r4, r5, pc}

00019eec <net_buf_id>:
{
   19eec:	b510      	push	{r4, lr}
   19eee:	4604      	mov	r4, r0
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   19ef0:	7980      	ldrb	r0, [r0, #6]
   19ef2:	f7f3 febd 	bl	dc70 <net_buf_pool_get>
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   19ef6:	7f03      	ldrb	r3, [r0, #28]
   19ef8:	3317      	adds	r3, #23
   19efa:	f023 0303 	bic.w	r3, r3, #3
	ptrdiff_t offset = (uint8_t *)buf - (uint8_t *)pool->__bufs;
   19efe:	6a80      	ldr	r0, [r0, #40]	; 0x28
   19f00:	1a20      	subs	r0, r4, r0
}
   19f02:	fbb0 f0f3 	udiv	r0, r0, r3
   19f06:	bd10      	pop	{r4, pc}

00019f08 <fixed_data_alloc>:
{
   19f08:	b570      	push	{r4, r5, r6, lr}
   19f0a:	4604      	mov	r4, r0
   19f0c:	460d      	mov	r5, r1
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   19f0e:	7980      	ldrb	r0, [r0, #6]
   19f10:	f7f3 feae 	bl	dc70 <net_buf_pool_get>
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   19f14:	6a43      	ldr	r3, [r0, #36]	; 0x24
   19f16:	685b      	ldr	r3, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   19f18:	682a      	ldr	r2, [r5, #0]
   19f1a:	6819      	ldr	r1, [r3, #0]
   19f1c:	428a      	cmp	r2, r1
   19f1e:	bf28      	it	cs
   19f20:	460a      	movcs	r2, r1
   19f22:	602a      	str	r2, [r5, #0]
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   19f24:	685d      	ldr	r5, [r3, #4]
   19f26:	681e      	ldr	r6, [r3, #0]
   19f28:	4620      	mov	r0, r4
   19f2a:	f7ff ffdf 	bl	19eec <net_buf_id>
}
   19f2e:	fb00 5006 	mla	r0, r0, r6, r5
   19f32:	bd70      	pop	{r4, r5, r6, pc}

00019f34 <net_buf_reset>:
	buf->len  = 0U;
   19f34:	2300      	movs	r3, #0
   19f36:	8183      	strh	r3, [r0, #12]
	buf->data = buf->__buf;
   19f38:	6903      	ldr	r3, [r0, #16]
   19f3a:	6083      	str	r3, [r0, #8]
}
   19f3c:	4770      	bx	lr

00019f3e <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
   19f3e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19f42:	b082      	sub	sp, #8
   19f44:	4605      	mov	r5, r0
   19f46:	9101      	str	r1, [sp, #4]
   19f48:	4616      	mov	r6, r2
   19f4a:	461f      	mov	r7, r3
	uint64_t end = sys_clock_timeout_end_calc(timeout);
   19f4c:	4610      	mov	r0, r2
   19f4e:	4619      	mov	r1, r3
   19f50:	f002 fce3 	bl	1c91a <sys_clock_timeout_end_calc>
   19f54:	4680      	mov	r8, r0
   19f56:	4689      	mov	r9, r1
   19f58:	f04f 0320 	mov.w	r3, #32
   19f5c:	f3ef 8a11 	mrs	sl, BASEPRI
   19f60:	f383 8812 	msr	BASEPRI_MAX, r3
   19f64:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&pool->lock);

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   19f68:	8b6b      	ldrh	r3, [r5, #26]
   19f6a:	2b00      	cmp	r3, #0
   19f6c:	d040      	beq.n	19ff0 <net_buf_alloc_len+0xb2>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   19f6e:	8b2a      	ldrh	r2, [r5, #24]
   19f70:	4293      	cmp	r3, r2
   19f72:	d20b      	bcs.n	19f8c <net_buf_alloc_len+0x4e>
	return z_impl_k_queue_get(queue, timeout);
   19f74:	2200      	movs	r2, #0
   19f76:	2300      	movs	r3, #0
   19f78:	4628      	mov	r0, r5
   19f7a:	f7f9 fdcf 	bl	13b1c <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   19f7e:	4604      	mov	r4, r0
   19f80:	b120      	cbz	r0, 19f8c <net_buf_alloc_len+0x4e>
	__asm__ volatile(
   19f82:	f38a 8811 	msr	BASEPRI, sl
   19f86:	f3bf 8f6f 	isb	sy
				k_spin_unlock(&pool->lock, key);
				goto success;
   19f8a:	e015      	b.n	19fb8 <net_buf_alloc_len+0x7a>
			}
		}

		uninit_count = pool->uninit_count--;
   19f8c:	8b6a      	ldrh	r2, [r5, #26]
   19f8e:	1e53      	subs	r3, r2, #1
   19f90:	836b      	strh	r3, [r5, #26]
   19f92:	f38a 8811 	msr	BASEPRI, sl
   19f96:	f3bf 8f6f 	isb	sy
	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
   19f9a:	7f2c      	ldrb	r4, [r5, #28]
   19f9c:	3417      	adds	r4, #23
   19f9e:	f024 0303 	bic.w	r3, r4, #3
	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
   19fa2:	8b2c      	ldrh	r4, [r5, #24]
   19fa4:	1aa2      	subs	r2, r4, r2
	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
   19fa6:	6aac      	ldr	r4, [r5, #40]	; 0x28
   19fa8:	fb02 4403 	mla	r4, r2, r3, r4
	buf->pool_id = pool_id(pool);
   19fac:	4628      	mov	r0, r5
   19fae:	f7f3 fe53 	bl	dc58 <pool_id>
   19fb2:	71a0      	strb	r0, [r4, #6]
	buf->user_data_size = pool->user_data_size;
   19fb4:	7f2b      	ldrb	r3, [r5, #28]
   19fb6:	71e3      	strb	r3, [r4, #7]
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   19fb8:	9b01      	ldr	r3, [sp, #4]
   19fba:	b39b      	cbz	r3, 1a024 <net_buf_alloc_len+0xe6>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   19fbc:	ea56 0307 	orrs.w	r3, r6, r7
   19fc0:	d005      	beq.n	19fce <net_buf_alloc_len+0x90>
   19fc2:	f1b7 3fff 	cmp.w	r7, #4294967295
   19fc6:	bf08      	it	eq
   19fc8:	f1b6 3fff 	cmpeq.w	r6, #4294967295
   19fcc:	d11d      	bne.n	1a00a <net_buf_alloc_len+0xcc>
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   19fce:	4632      	mov	r2, r6
   19fd0:	463b      	mov	r3, r7
   19fd2:	a901      	add	r1, sp, #4
   19fd4:	4620      	mov	r0, r4
   19fd6:	f7ff ff64 	bl	19ea2 <data_alloc>
   19fda:	4605      	mov	r5, r0
   19fdc:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   19fde:	bb18      	cbnz	r0, 1a028 <net_buf_alloc_len+0xea>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   19fe0:	79a0      	ldrb	r0, [r4, #6]
   19fe2:	f7f3 fe45 	bl	dc70 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
   19fe6:	4621      	mov	r1, r4
   19fe8:	f002 f8ca 	bl	1c180 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   19fec:	462c      	mov	r4, r5
}
   19fee:	e025      	b.n	1a03c <net_buf_alloc_len+0xfe>
   19ff0:	f38a 8811 	msr	BASEPRI, sl
   19ff4:	f3bf 8f6f 	isb	sy
   19ff8:	4632      	mov	r2, r6
   19ffa:	463b      	mov	r3, r7
   19ffc:	4628      	mov	r0, r5
   19ffe:	f7f9 fd8d 	bl	13b1c <z_impl_k_queue_get>
	if (!buf) {
   1a002:	4604      	mov	r4, r0
   1a004:	2800      	cmp	r0, #0
   1a006:	d1d7      	bne.n	19fb8 <net_buf_alloc_len+0x7a>
   1a008:	e018      	b.n	1a03c <net_buf_alloc_len+0xfe>
			int64_t remaining = end - sys_clock_tick_get();
   1a00a:	f7fa fd5b 	bl	14ac4 <sys_clock_tick_get>
   1a00e:	ebb8 0600 	subs.w	r6, r8, r0
   1a012:	eb69 0701 	sbc.w	r7, r9, r1
			if (remaining <= 0) {
   1a016:	2e01      	cmp	r6, #1
   1a018:	f177 0300 	sbcs.w	r3, r7, #0
   1a01c:	dad7      	bge.n	19fce <net_buf_alloc_len+0x90>
				timeout = K_NO_WAIT;
   1a01e:	2600      	movs	r6, #0
   1a020:	4637      	mov	r7, r6
   1a022:	e7d4      	b.n	19fce <net_buf_alloc_len+0x90>

#if __ASSERT_ON
		NET_BUF_ASSERT(req_size <= size);
#endif
	} else {
		buf->__buf = NULL;
   1a024:	2300      	movs	r3, #0
   1a026:	6123      	str	r3, [r4, #16]
	}

	buf->ref   = 1U;
   1a028:	2301      	movs	r3, #1
   1a02a:	7123      	strb	r3, [r4, #4]
	buf->flags = 0U;
   1a02c:	2300      	movs	r3, #0
   1a02e:	7163      	strb	r3, [r4, #5]
	buf->frags = NULL;
   1a030:	6023      	str	r3, [r4, #0]
	buf->size  = size;
   1a032:	9b01      	ldr	r3, [sp, #4]
   1a034:	81e3      	strh	r3, [r4, #14]
	net_buf_reset(buf);
   1a036:	4620      	mov	r0, r4
   1a038:	f7ff ff7c 	bl	19f34 <net_buf_reset>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	atomic_dec(&pool->avail_count);
	__ASSERT_NO_MSG(atomic_get(&pool->avail_count) >= 0);
#endif
	return buf;
}
   1a03c:	4620      	mov	r0, r4
   1a03e:	b002      	add	sp, #8
   1a040:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001a044 <net_buf_alloc_fixed>:
				       line);
}
#else
struct net_buf *net_buf_alloc_fixed(struct net_buf_pool *pool,
				    k_timeout_t timeout)
{
   1a044:	b508      	push	{r3, lr}
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1a046:	6a41      	ldr	r1, [r0, #36]	; 0x24
   1a048:	6849      	ldr	r1, [r1, #4]

	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   1a04a:	6809      	ldr	r1, [r1, #0]
   1a04c:	f7ff ff77 	bl	19f3e <net_buf_alloc_len>
}
   1a050:	bd08      	pop	{r3, pc}

0001a052 <net_buf_get>:
struct net_buf *net_buf_get_debug(struct k_fifo *fifo, k_timeout_t timeout,
				  const char *func, int line)
#else
struct net_buf *net_buf_get(struct k_fifo *fifo, k_timeout_t timeout)
#endif
{
   1a052:	b570      	push	{r4, r5, r6, lr}
   1a054:	4605      	mov	r5, r0
   1a056:	f7f9 fd61 	bl	13b1c <z_impl_k_queue_get>
	struct net_buf *buf, *frag;

	NET_BUF_DBG("%s():%d: fifo %p", func, line, fifo);

	buf = k_fifo_get(fifo, timeout);
	if (!buf) {
   1a05a:	4606      	mov	r6, r0
   1a05c:	b190      	cbz	r0, 1a084 <net_buf_get+0x32>
	}

	NET_BUF_DBG("%s():%d: buf %p fifo %p", func, line, buf, fifo);

	/* Get any fragments belonging to this buffer */
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1a05e:	4604      	mov	r4, r0
   1a060:	e00a      	b.n	1a078 <net_buf_get+0x26>
   1a062:	2200      	movs	r2, #0
   1a064:	2300      	movs	r3, #0
   1a066:	4628      	mov	r0, r5
   1a068:	f7f9 fd58 	bl	13b1c <z_impl_k_queue_get>
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   1a06c:	6020      	str	r0, [r4, #0]
		__ASSERT_NO_MSG(frag->frags);

		/* The fragments flag is only for FIFO-internal usage */
		frag->flags &= ~NET_BUF_FRAGS;
   1a06e:	7963      	ldrb	r3, [r4, #5]
   1a070:	f023 0301 	bic.w	r3, r3, #1
   1a074:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1a076:	4604      	mov	r4, r0
   1a078:	7963      	ldrb	r3, [r4, #5]
   1a07a:	f013 0f01 	tst.w	r3, #1
   1a07e:	d1f0      	bne.n	1a062 <net_buf_get+0x10>
	}

	/* Mark the end of the fragment list */
	frag->frags = NULL;
   1a080:	2300      	movs	r3, #0
   1a082:	6023      	str	r3, [r4, #0]

	return buf;
}
   1a084:	4630      	mov	r0, r6
   1a086:	bd70      	pop	{r4, r5, r6, pc}

0001a088 <net_buf_simple_init_with_data>:

void net_buf_simple_init_with_data(struct net_buf_simple *buf,
				   void *data, size_t size)
{
	buf->__buf = data;
   1a088:	6081      	str	r1, [r0, #8]
	buf->data  = data;
   1a08a:	6001      	str	r1, [r0, #0]
	buf->size  = size;
   1a08c:	b292      	uxth	r2, r2
   1a08e:	80c2      	strh	r2, [r0, #6]
	buf->len   = size;
   1a090:	8082      	strh	r2, [r0, #4]
}
   1a092:	4770      	bx	lr

0001a094 <net_buf_simple_reserve>:
{
	__ASSERT_NO_MSG(buf);
	__ASSERT_NO_MSG(buf->len == 0U);
	NET_BUF_DBG("buf %p reserve %zu", buf, reserve);

	buf->data = buf->__buf + reserve;
   1a094:	6883      	ldr	r3, [r0, #8]
   1a096:	440b      	add	r3, r1
   1a098:	6003      	str	r3, [r0, #0]
}
   1a09a:	4770      	bx	lr

0001a09c <net_buf_slist_put>:

static struct k_spinlock net_buf_slist_lock;

void net_buf_slist_put(sys_slist_t *list, struct net_buf *buf)
{
   1a09c:	b410      	push	{r4}
	k_spinlock_key_t key;

	__ASSERT_NO_MSG(list);
	__ASSERT_NO_MSG(buf);

	for (tail = buf; tail->frags; tail = tail->frags) {
   1a09e:	460b      	mov	r3, r1
   1a0a0:	e004      	b.n	1a0ac <net_buf_slist_put+0x10>
		tail->flags |= NET_BUF_FRAGS;
   1a0a2:	795a      	ldrb	r2, [r3, #5]
   1a0a4:	f042 0201 	orr.w	r2, r2, #1
   1a0a8:	715a      	strb	r2, [r3, #5]
	for (tail = buf; tail->frags; tail = tail->frags) {
   1a0aa:	4623      	mov	r3, r4
   1a0ac:	681c      	ldr	r4, [r3, #0]
   1a0ae:	2c00      	cmp	r4, #0
   1a0b0:	d1f7      	bne.n	1a0a2 <net_buf_slist_put+0x6>
	__asm__ volatile(
   1a0b2:	f04f 0420 	mov.w	r4, #32
   1a0b6:	f3ef 8211 	mrs	r2, BASEPRI
   1a0ba:	f384 8812 	msr	BASEPRI_MAX, r4
   1a0be:	f3bf 8f6f 	isb	sy
	}

	key = k_spin_lock(&net_buf_slist_lock);
	sys_slist_append_list(list, &buf->node, &tail->node);
   1a0c2:	461c      	mov	r4, r3
Z_GENLIST_APPEND_LIST(slist, snode)
   1a0c4:	b121      	cbz	r1, 1a0d0 <net_buf_slist_put+0x34>
   1a0c6:	b11b      	cbz	r3, 1a0d0 <net_buf_slist_put+0x34>
	return list->tail;
   1a0c8:	6843      	ldr	r3, [r0, #4]
Z_GENLIST_APPEND_LIST(slist, snode)
   1a0ca:	b13b      	cbz	r3, 1a0dc <net_buf_slist_put+0x40>
	parent->next = child;
   1a0cc:	6019      	str	r1, [r3, #0]
	list->tail = node;
   1a0ce:	6044      	str	r4, [r0, #4]
	__asm__ volatile(
   1a0d0:	f382 8811 	msr	BASEPRI, r2
   1a0d4:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&net_buf_slist_lock, key);
}
   1a0d8:	bc10      	pop	{r4}
   1a0da:	4770      	bx	lr
	list->head = node;
   1a0dc:	6001      	str	r1, [r0, #0]
}
   1a0de:	e7f6      	b.n	1a0ce <net_buf_slist_put+0x32>

0001a0e0 <net_buf_slist_get>:

struct net_buf *net_buf_slist_get(sys_slist_t *list)
{
   1a0e0:	b510      	push	{r4, lr}
   1a0e2:	4684      	mov	ip, r0
	__asm__ volatile(
   1a0e4:	f04f 0320 	mov.w	r3, #32
   1a0e8:	f3ef 8e11 	mrs	lr, BASEPRI
   1a0ec:	f383 8812 	msr	BASEPRI_MAX, r3
   1a0f0:	f3bf 8f6f 	isb	sy
	return list->head;
   1a0f4:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_GET(slist, snode)
   1a0f6:	b328      	cbz	r0, 1a144 <net_buf_slist_get+0x64>
	return node->next;
   1a0f8:	6803      	ldr	r3, [r0, #0]
	list->head = node;
   1a0fa:	f8cc 3000 	str.w	r3, [ip]
	return list->tail;
   1a0fe:	f8dc 2004 	ldr.w	r2, [ip, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1a102:	4290      	cmp	r0, r2
   1a104:	d001      	beq.n	1a10a <net_buf_slist_get+0x2a>
   1a106:	4602      	mov	r2, r0
   1a108:	e008      	b.n	1a11c <net_buf_slist_get+0x3c>
	list->tail = node;
   1a10a:	f8cc 3004 	str.w	r3, [ip, #4]
}
   1a10e:	e7fa      	b.n	1a106 <net_buf_slist_get+0x26>
	buf = (void *)sys_slist_get(list);

	if (buf) {
		/* Get any fragments belonging to this buffer */
		for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
			frag->frags = (void *)sys_slist_get(list);
   1a110:	6013      	str	r3, [r2, #0]
			__ASSERT_NO_MSG(frag->frags);

			/* The fragments flag is only for list-internal usage */
			frag->flags &= ~NET_BUF_FRAGS;
   1a112:	7951      	ldrb	r1, [r2, #5]
   1a114:	f021 0101 	bic.w	r1, r1, #1
   1a118:	7151      	strb	r1, [r2, #5]
		for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   1a11a:	461a      	mov	r2, r3
   1a11c:	7953      	ldrb	r3, [r2, #5]
   1a11e:	f013 0f01 	tst.w	r3, #1
   1a122:	d00d      	beq.n	1a140 <net_buf_slist_get+0x60>
	return list->head;
   1a124:	f8dc 3000 	ldr.w	r3, [ip]
Z_GENLIST_GET(slist, snode)
   1a128:	2b00      	cmp	r3, #0
   1a12a:	d0f1      	beq.n	1a110 <net_buf_slist_get+0x30>
	return node->next;
   1a12c:	6819      	ldr	r1, [r3, #0]
	list->head = node;
   1a12e:	f8cc 1000 	str.w	r1, [ip]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1a132:	f8dc 4004 	ldr.w	r4, [ip, #4]
   1a136:	42a3      	cmp	r3, r4
   1a138:	d1ea      	bne.n	1a110 <net_buf_slist_get+0x30>
	list->tail = node;
   1a13a:	f8cc 1004 	str.w	r1, [ip, #4]
}
   1a13e:	e7e7      	b.n	1a110 <net_buf_slist_get+0x30>
		}

		/* Mark the end of the fragment list */
		frag->frags = NULL;
   1a140:	2300      	movs	r3, #0
   1a142:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   1a144:	f38e 8811 	msr	BASEPRI, lr
   1a148:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&net_buf_slist_lock, key);

	return buf;
}
   1a14c:	bd10      	pop	{r4, pc}

0001a14e <net_buf_put>:

void net_buf_put(struct k_fifo *fifo, struct net_buf *buf)
{
   1a14e:	b510      	push	{r4, lr}
	struct net_buf *tail;

	__ASSERT_NO_MSG(fifo);
	__ASSERT_NO_MSG(buf);

	for (tail = buf; tail->frags; tail = tail->frags) {
   1a150:	460a      	mov	r2, r1
   1a152:	e004      	b.n	1a15e <net_buf_put+0x10>
		tail->flags |= NET_BUF_FRAGS;
   1a154:	7953      	ldrb	r3, [r2, #5]
   1a156:	f043 0301 	orr.w	r3, r3, #1
   1a15a:	7153      	strb	r3, [r2, #5]
	for (tail = buf; tail->frags; tail = tail->frags) {
   1a15c:	4622      	mov	r2, r4
   1a15e:	6814      	ldr	r4, [r2, #0]
   1a160:	2c00      	cmp	r4, #0
   1a162:	d1f7      	bne.n	1a154 <net_buf_put+0x6>
	}

	k_fifo_put_list(fifo, buf, tail);
   1a164:	f002 f817 	bl	1c196 <k_queue_append_list>
}
   1a168:	bd10      	pop	{r4, pc}

0001a16a <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   1a16a:	b538      	push	{r3, r4, r5, lr}
   1a16c:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(buf);

	while (buf) {
   1a16e:	e00a      	b.n	1a186 <net_buf_unref+0x1c>
		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
		}

		buf->data = NULL;
   1a170:	2300      	movs	r3, #0
   1a172:	60a3      	str	r3, [r4, #8]
		buf->frags = NULL;
   1a174:	6023      	str	r3, [r4, #0]

		pool = net_buf_pool_get(buf->pool_id);
   1a176:	79a0      	ldrb	r0, [r4, #6]
   1a178:	f7f3 fd7a 	bl	dc70 <net_buf_pool_get>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		atomic_inc(&pool->avail_count);
		__ASSERT_NO_MSG(atomic_get(&pool->avail_count) <= pool->buf_count);
#endif

		if (pool->destroy) {
   1a17c:	6a03      	ldr	r3, [r0, #32]
   1a17e:	b193      	cbz	r3, 1a1a6 <net_buf_unref+0x3c>
			pool->destroy(buf);
   1a180:	4620      	mov	r0, r4
   1a182:	4798      	blx	r3
{
   1a184:	462c      	mov	r4, r5
	while (buf) {
   1a186:	b1ac      	cbz	r4, 1a1b4 <net_buf_unref+0x4a>
		struct net_buf *frags = buf->frags;
   1a188:	6825      	ldr	r5, [r4, #0]
		if (--buf->ref > 0) {
   1a18a:	7923      	ldrb	r3, [r4, #4]
   1a18c:	3b01      	subs	r3, #1
   1a18e:	b2db      	uxtb	r3, r3
   1a190:	7123      	strb	r3, [r4, #4]
   1a192:	b97b      	cbnz	r3, 1a1b4 <net_buf_unref+0x4a>
		if (buf->__buf) {
   1a194:	6921      	ldr	r1, [r4, #16]
   1a196:	2900      	cmp	r1, #0
   1a198:	d0ea      	beq.n	1a170 <net_buf_unref+0x6>
			data_unref(buf, buf->__buf);
   1a19a:	4620      	mov	r0, r4
   1a19c:	f7ff fe95 	bl	19eca <data_unref>
			buf->__buf = NULL;
   1a1a0:	2300      	movs	r3, #0
   1a1a2:	6123      	str	r3, [r4, #16]
   1a1a4:	e7e4      	b.n	1a170 <net_buf_unref+0x6>
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1a1a6:	79a0      	ldrb	r0, [r4, #6]
   1a1a8:	f7f3 fd62 	bl	dc70 <net_buf_pool_get>
	k_lifo_put(&pool->free, buf);
   1a1ac:	4621      	mov	r1, r4
   1a1ae:	f001 ffe7 	bl	1c180 <k_queue_prepend>
}
   1a1b2:	e7e7      	b.n	1a184 <net_buf_unref+0x1a>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   1a1b4:	bd38      	pop	{r3, r4, r5, pc}

0001a1b6 <net_buf_ref>:
{
	__ASSERT_NO_MSG(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   1a1b6:	7902      	ldrb	r2, [r0, #4]
   1a1b8:	3201      	adds	r2, #1
   1a1ba:	7102      	strb	r2, [r0, #4]
	return buf;
}
   1a1bc:	4770      	bx	lr

0001a1be <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
   1a1be:	4603      	mov	r3, r0
	__ASSERT_NO_MSG(buf);

	while (buf->frags) {
   1a1c0:	4618      	mov	r0, r3
   1a1c2:	681b      	ldr	r3, [r3, #0]
   1a1c4:	2b00      	cmp	r3, #0
   1a1c6:	d1fb      	bne.n	1a1c0 <net_buf_frag_last+0x2>
		buf = buf->frags;
	}

	return buf;
}
   1a1c8:	4770      	bx	lr

0001a1ca <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
   1a1ca:	b570      	push	{r4, r5, r6, lr}
   1a1cc:	4604      	mov	r4, r0
   1a1ce:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(parent);
	__ASSERT_NO_MSG(frag);

	if (parent->frags) {
   1a1d0:	6806      	ldr	r6, [r0, #0]
   1a1d2:	b11e      	cbz	r6, 1a1dc <net_buf_frag_insert+0x12>
		net_buf_frag_last(frag)->frags = parent->frags;
   1a1d4:	4608      	mov	r0, r1
   1a1d6:	f7ff fff2 	bl	1a1be <net_buf_frag_last>
   1a1da:	6006      	str	r6, [r0, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   1a1dc:	6025      	str	r5, [r4, #0]
}
   1a1de:	bd70      	pop	{r4, r5, r6, pc}

0001a1e0 <net_buf_frag_add>:

struct net_buf *net_buf_frag_add(struct net_buf *head, struct net_buf *frag)
{
   1a1e0:	b538      	push	{r3, r4, r5, lr}
   1a1e2:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(frag);

	if (!head) {
   1a1e4:	b138      	cbz	r0, 1a1f6 <net_buf_frag_add+0x16>
   1a1e6:	4604      	mov	r4, r0
		return net_buf_ref(frag);
	}

	net_buf_frag_insert(net_buf_frag_last(head), frag);
   1a1e8:	f7ff ffe9 	bl	1a1be <net_buf_frag_last>
   1a1ec:	4629      	mov	r1, r5
   1a1ee:	f7ff ffec 	bl	1a1ca <net_buf_frag_insert>

	return head;
   1a1f2:	4620      	mov	r0, r4
}
   1a1f4:	bd38      	pop	{r3, r4, r5, pc}
		return net_buf_ref(frag);
   1a1f6:	4608      	mov	r0, r1
   1a1f8:	f7ff ffdd 	bl	1a1b6 <net_buf_ref>
   1a1fc:	e7fa      	b.n	1a1f4 <net_buf_frag_add+0x14>

0001a1fe <net_buf_simple_add>:
	return buf->data + buf->len;
   1a1fe:	6802      	ldr	r2, [r0, #0]
   1a200:	8883      	ldrh	r3, [r0, #4]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   1a202:	4419      	add	r1, r3
   1a204:	8081      	strh	r1, [r0, #4]
	return tail;
}
   1a206:	18d0      	adds	r0, r2, r3
   1a208:	4770      	bx	lr

0001a20a <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   1a20a:	b538      	push	{r3, r4, r5, lr}
   1a20c:	460d      	mov	r5, r1
   1a20e:	4614      	mov	r4, r2
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   1a210:	4611      	mov	r1, r2
   1a212:	f7ff fff4 	bl	1a1fe <net_buf_simple_add>
   1a216:	4622      	mov	r2, r4
   1a218:	4629      	mov	r1, r5
   1a21a:	f7fd fa89 	bl	17730 <memcpy>
}
   1a21e:	bd38      	pop	{r3, r4, r5, pc}

0001a220 <net_buf_simple_add_u8>:

uint8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, uint8_t val)
{
   1a220:	b510      	push	{r4, lr}
   1a222:	460c      	mov	r4, r1
	uint8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
   1a224:	2101      	movs	r1, #1
   1a226:	f7ff ffea 	bl	1a1fe <net_buf_simple_add>
	*u8 = val;
   1a22a:	7004      	strb	r4, [r0, #0]

	return u8;
}
   1a22c:	bd10      	pop	{r4, pc}

0001a22e <net_buf_simple_add_le16>:

void net_buf_simple_add_le16(struct net_buf_simple *buf, uint16_t val)
{
   1a22e:	b510      	push	{r4, lr}
   1a230:	460c      	mov	r4, r1
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
   1a232:	2102      	movs	r1, #2
   1a234:	f7ff ffe3 	bl	1a1fe <net_buf_simple_add>
	dst[0] = val;
   1a238:	7004      	strb	r4, [r0, #0]
	dst[1] = val >> 8;
   1a23a:	0a24      	lsrs	r4, r4, #8
   1a23c:	7044      	strb	r4, [r0, #1]
}
   1a23e:	bd10      	pop	{r4, pc}

0001a240 <net_buf_simple_push>:

	return sys_be64_to_cpu(val);
}

void *net_buf_simple_push(struct net_buf_simple *buf, size_t len)
{
   1a240:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   1a242:	6800      	ldr	r0, [r0, #0]
   1a244:	1a40      	subs	r0, r0, r1
   1a246:	6018      	str	r0, [r3, #0]
	buf->len += len;
   1a248:	889a      	ldrh	r2, [r3, #4]
   1a24a:	4411      	add	r1, r2
   1a24c:	8099      	strh	r1, [r3, #4]
	return buf->data;
}
   1a24e:	4770      	bx	lr

0001a250 <net_buf_simple_push_u8>:

	sys_put_be16(val, net_buf_simple_push(buf, sizeof(val)));
}

void net_buf_simple_push_u8(struct net_buf_simple *buf, uint8_t val)
{
   1a250:	b510      	push	{r4, lr}
   1a252:	460c      	mov	r4, r1
	uint8_t *data = net_buf_simple_push(buf, 1);
   1a254:	2101      	movs	r1, #1
   1a256:	f7ff fff3 	bl	1a240 <net_buf_simple_push>

	*data = val;
   1a25a:	7004      	strb	r4, [r0, #0]
}
   1a25c:	bd10      	pop	{r4, pc}

0001a25e <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
   1a25e:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   1a260:	8882      	ldrh	r2, [r0, #4]
   1a262:	1a52      	subs	r2, r2, r1
   1a264:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
   1a266:	6800      	ldr	r0, [r0, #0]
   1a268:	4408      	add	r0, r1
   1a26a:	6018      	str	r0, [r3, #0]
}
   1a26c:	4770      	bx	lr

0001a26e <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   1a26e:	4603      	mov	r3, r0
	void *data = buf->data;
   1a270:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
   1a272:	889a      	ldrh	r2, [r3, #4]
   1a274:	1a52      	subs	r2, r2, r1
   1a276:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   1a278:	4401      	add	r1, r0
   1a27a:	6019      	str	r1, [r3, #0]

	return data;
}
   1a27c:	4770      	bx	lr

0001a27e <net_buf_simple_pull_le16>:

	return val;
}

uint16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   1a27e:	b510      	push	{r4, lr}
	uint16_t val;

	val = UNALIGNED_GET((uint16_t *)buf->data);
   1a280:	6803      	ldr	r3, [r0, #0]
   1a282:	881c      	ldrh	r4, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   1a284:	2102      	movs	r1, #2
   1a286:	f7ff ffea 	bl	1a25e <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   1a28a:	4620      	mov	r0, r4
   1a28c:	bd10      	pop	{r4, pc}

0001a28e <net_buf_simple_headroom>:
	return sys_be64_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   1a28e:	6802      	ldr	r2, [r0, #0]
   1a290:	6880      	ldr	r0, [r0, #8]
}
   1a292:	1a10      	subs	r0, r2, r0
   1a294:	4770      	bx	lr

0001a296 <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
   1a296:	b538      	push	{r3, r4, r5, lr}
   1a298:	4604      	mov	r4, r0
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   1a29a:	88c5      	ldrh	r5, [r0, #6]
   1a29c:	f7ff fff7 	bl	1a28e <net_buf_simple_headroom>
   1a2a0:	1a2d      	subs	r5, r5, r0
   1a2a2:	88a0      	ldrh	r0, [r4, #4]
}
   1a2a4:	1a28      	subs	r0, r5, r0
   1a2a6:	bd38      	pop	{r3, r4, r5, pc}

0001a2a8 <get_sub_data>:
	struct nrf_clock_control_data *data = dev->data;
   1a2a8:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
   1a2aa:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   1a2ae:	0089      	lsls	r1, r1, #2
   1a2b0:	3170      	adds	r1, #112	; 0x70
}
   1a2b2:	4408      	add	r0, r1
   1a2b4:	4770      	bx	lr

0001a2b6 <get_sub_config>:
	const struct nrf_clock_control_config *config =
   1a2b6:	6840      	ldr	r0, [r0, #4]
	return &config->subsys[type];
   1a2b8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
}
   1a2bc:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   1a2c0:	4770      	bx	lr

0001a2c2 <get_onoff_manager>:
	struct nrf_clock_control_data *data = dev->data;
   1a2c2:	6900      	ldr	r0, [r0, #16]
	return &data->mgr[type];
   1a2c4:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
}
   1a2c8:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   1a2cc:	4770      	bx	lr

0001a2ce <get_status>:
{
   1a2ce:	b508      	push	{r3, lr}
	return GET_STATUS(get_sub_data(dev, type)->flags);
   1a2d0:	b2c9      	uxtb	r1, r1
   1a2d2:	f7ff ffe9 	bl	1a2a8 <get_sub_data>
   1a2d6:	6880      	ldr	r0, [r0, #8]
}
   1a2d8:	f000 0007 	and.w	r0, r0, #7
   1a2dc:	bd08      	pop	{r3, pc}

0001a2de <set_off_state>:
	__asm__ volatile(
   1a2de:	f04f 0320 	mov.w	r3, #32
   1a2e2:	f3ef 8211 	mrs	r2, BASEPRI
   1a2e6:	f383 8812 	msr	BASEPRI_MAX, r3
   1a2ea:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   1a2ee:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   1a2f0:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   1a2f4:	d001      	beq.n	1a2fa <set_off_state+0x1c>
   1a2f6:	428b      	cmp	r3, r1
   1a2f8:	d107      	bne.n	1a30a <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   1a2fa:	2301      	movs	r3, #1
   1a2fc:	6003      	str	r3, [r0, #0]
	int err = 0;
   1a2fe:	2000      	movs	r0, #0
	__asm__ volatile(
   1a300:	f382 8811 	msr	BASEPRI, r2
   1a304:	f3bf 8f6f 	isb	sy
}
   1a308:	4770      	bx	lr
		err = -EPERM;
   1a30a:	f04f 30ff 	mov.w	r0, #4294967295
   1a30e:	e7f7      	b.n	1a300 <set_off_state+0x22>

0001a310 <set_starting_state>:
	__asm__ volatile(
   1a310:	f04f 0320 	mov.w	r3, #32
   1a314:	f3ef 8211 	mrs	r2, BASEPRI
   1a318:	f383 8812 	msr	BASEPRI_MAX, r3
   1a31c:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   1a320:	6803      	ldr	r3, [r0, #0]
   1a322:	f003 0cc0 	and.w	ip, r3, #192	; 0xc0
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   1a326:	f003 0307 	and.w	r3, r3, #7
   1a32a:	2b01      	cmp	r3, #1
   1a32c:	d008      	beq.n	1a340 <set_starting_state+0x30>
	} else if (current_ctx != ctx) {
   1a32e:	458c      	cmp	ip, r1
   1a330:	d009      	beq.n	1a346 <set_starting_state+0x36>
		err = -EPERM;
   1a332:	f04f 30ff 	mov.w	r0, #4294967295
	__asm__ volatile(
   1a336:	f382 8811 	msr	BASEPRI, r2
   1a33a:	f3bf 8f6f 	isb	sy
}
   1a33e:	4770      	bx	lr
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   1a340:	6001      	str	r1, [r0, #0]
	int err = 0;
   1a342:	2000      	movs	r0, #0
   1a344:	e7f7      	b.n	1a336 <set_starting_state+0x26>
		err = -EALREADY;
   1a346:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1a34a:	e7f4      	b.n	1a336 <set_starting_state+0x26>

0001a34c <set_on_state>:
	__asm__ volatile(
   1a34c:	f04f 0320 	mov.w	r3, #32
   1a350:	f3ef 8211 	mrs	r2, BASEPRI
   1a354:	f383 8812 	msr	BASEPRI_MAX, r3
   1a358:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   1a35c:	6803      	ldr	r3, [r0, #0]
   1a35e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1a362:	f043 0302 	orr.w	r3, r3, #2
   1a366:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   1a368:	f382 8811 	msr	BASEPRI, r2
   1a36c:	f3bf 8f6f 	isb	sy
}
   1a370:	4770      	bx	lr

0001a372 <clkstarted_handle>:
{
   1a372:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a374:	4606      	mov	r6, r0
   1a376:	460c      	mov	r4, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   1a378:	f7ff ff96 	bl	1a2a8 <get_sub_data>
	clock_control_cb_t callback = sub_data->cb;
   1a37c:	6805      	ldr	r5, [r0, #0]
	void *user_data = sub_data->user_data;
   1a37e:	6847      	ldr	r7, [r0, #4]
	sub_data->cb = NULL;
   1a380:	2300      	movs	r3, #0
   1a382:	f840 3b08 	str.w	r3, [r0], #8
	set_on_state(&sub_data->flags);
   1a386:	f7ff ffe1 	bl	1a34c <set_on_state>
	if (callback) {
   1a38a:	b11d      	cbz	r5, 1a394 <clkstarted_handle+0x22>
		callback(dev, (clock_control_subsys_t)type, user_data);
   1a38c:	463a      	mov	r2, r7
   1a38e:	4621      	mov	r1, r4
   1a390:	4630      	mov	r0, r6
   1a392:	47a8      	blx	r5
}
   1a394:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001a396 <stop>:
{
   1a396:	b570      	push	{r4, r5, r6, lr}
   1a398:	4606      	mov	r6, r0
   1a39a:	4615      	mov	r5, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   1a39c:	b2cc      	uxtb	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   1a39e:	4621      	mov	r1, r4
   1a3a0:	f7ff ff82 	bl	1a2a8 <get_sub_data>
	err = set_off_state(&subdata->flags, ctx);
   1a3a4:	4629      	mov	r1, r5
   1a3a6:	3008      	adds	r0, #8
   1a3a8:	f7ff ff99 	bl	1a2de <set_off_state>
	if (err < 0) {
   1a3ac:	2800      	cmp	r0, #0
   1a3ae:	db06      	blt.n	1a3be <stop+0x28>
	get_sub_config(dev, type)->stop();
   1a3b0:	4621      	mov	r1, r4
   1a3b2:	4630      	mov	r0, r6
   1a3b4:	f7ff ff7f 	bl	1a2b6 <get_sub_config>
   1a3b8:	6843      	ldr	r3, [r0, #4]
   1a3ba:	4798      	blx	r3
	return 0;
   1a3bc:	2000      	movs	r0, #0
}
   1a3be:	bd70      	pop	{r4, r5, r6, pc}

0001a3c0 <api_stop>:
{
   1a3c0:	b508      	push	{r3, lr}
	return stop(dev, subsys, CTX_API);
   1a3c2:	2280      	movs	r2, #128	; 0x80
   1a3c4:	f7ff ffe7 	bl	1a396 <stop>
}
   1a3c8:	bd08      	pop	{r3, pc}

0001a3ca <async_start>:
{
   1a3ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a3ce:	4606      	mov	r6, r0
   1a3d0:	4690      	mov	r8, r2
   1a3d2:	461f      	mov	r7, r3
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   1a3d4:	b2cd      	uxtb	r5, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   1a3d6:	4629      	mov	r1, r5
   1a3d8:	f7ff ff66 	bl	1a2a8 <get_sub_data>
   1a3dc:	4604      	mov	r4, r0
	err = set_starting_state(&subdata->flags, ctx);
   1a3de:	9906      	ldr	r1, [sp, #24]
   1a3e0:	3008      	adds	r0, #8
   1a3e2:	f7ff ff95 	bl	1a310 <set_starting_state>
	if (err < 0) {
   1a3e6:	2800      	cmp	r0, #0
   1a3e8:	db09      	blt.n	1a3fe <async_start+0x34>
	subdata->cb = cb;
   1a3ea:	f8c4 8000 	str.w	r8, [r4]
	subdata->user_data = user_data;
   1a3ee:	6067      	str	r7, [r4, #4]
	 get_sub_config(dev, type)->start();
   1a3f0:	4629      	mov	r1, r5
   1a3f2:	4630      	mov	r0, r6
   1a3f4:	f7ff ff5f 	bl	1a2b6 <get_sub_config>
   1a3f8:	6803      	ldr	r3, [r0, #0]
   1a3fa:	4798      	blx	r3
	return 0;
   1a3fc:	2000      	movs	r0, #0
}
   1a3fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001a402 <api_start>:
{
   1a402:	b510      	push	{r4, lr}
   1a404:	b082      	sub	sp, #8
	return async_start(dev, subsys, cb, user_data, CTX_API);
   1a406:	2480      	movs	r4, #128	; 0x80
   1a408:	9400      	str	r4, [sp, #0]
   1a40a:	f7ff ffde 	bl	1a3ca <async_start>
}
   1a40e:	b002      	add	sp, #8
   1a410:	bd10      	pop	{r4, pc}

0001a412 <onoff_started_callback>:
{
   1a412:	b510      	push	{r4, lr}
   1a414:	4614      	mov	r4, r2
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
   1a416:	b2c9      	uxtb	r1, r1
   1a418:	f7ff ff53 	bl	1a2c2 <get_onoff_manager>
	notify(mgr, 0);
   1a41c:	2100      	movs	r1, #0
   1a41e:	47a0      	blx	r4
}
   1a420:	bd10      	pop	{r4, pc}

0001a422 <hfclk_start>:
{
   1a422:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   1a424:	2001      	movs	r0, #1
   1a426:	f000 fd4f 	bl	1aec8 <nrfx_clock_start>
}
   1a42a:	bd08      	pop	{r3, pc}

0001a42c <hfclkaudio_start>:
{
   1a42c:	b508      	push	{r3, lr}
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   1a42e:	2003      	movs	r0, #3
   1a430:	f000 fd4a 	bl	1aec8 <nrfx_clock_start>
}
   1a434:	bd08      	pop	{r3, pc}

0001a436 <hfclk192m_start>:
{
   1a436:	b508      	push	{r3, lr}
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
   1a438:	2002      	movs	r0, #2
   1a43a:	f000 fd45 	bl	1aec8 <nrfx_clock_start>
}
   1a43e:	bd08      	pop	{r3, pc}

0001a440 <lfclk_start>:
{
   1a440:	b508      	push	{r3, lr}
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   1a442:	2000      	movs	r0, #0
   1a444:	f000 fd40 	bl	1aec8 <nrfx_clock_start>
}
   1a448:	bd08      	pop	{r3, pc}

0001a44a <hfclk_stop>:
{
   1a44a:	b508      	push	{r3, lr}
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   1a44c:	2001      	movs	r0, #1
   1a44e:	f000 fdb0 	bl	1afb2 <nrfx_clock_stop>
}
   1a452:	bd08      	pop	{r3, pc}

0001a454 <hfclkaudio_stop>:
{
   1a454:	b508      	push	{r3, lr}
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   1a456:	2003      	movs	r0, #3
   1a458:	f000 fdab 	bl	1afb2 <nrfx_clock_stop>
}
   1a45c:	bd08      	pop	{r3, pc}

0001a45e <hfclk192m_stop>:
{
   1a45e:	b508      	push	{r3, lr}
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
   1a460:	2002      	movs	r0, #2
   1a462:	f000 fda6 	bl	1afb2 <nrfx_clock_stop>
}
   1a466:	bd08      	pop	{r3, pc}

0001a468 <lfclk_stop>:
{
   1a468:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   1a46a:	2000      	movs	r0, #0
   1a46c:	f000 fda1 	bl	1afb2 <nrfx_clock_stop>
}
   1a470:	bd08      	pop	{r3, pc}

0001a472 <blocking_start_callback>:
{
   1a472:	b508      	push	{r3, lr}
   1a474:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   1a476:	f7f9 fb8b 	bl	13b90 <z_impl_k_sem_give>
}
   1a47a:	bd08      	pop	{r3, pc}

0001a47c <get_drive>:
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1a47c:	f020 00f9 	bic.w	r0, r0, #249	; 0xf9
   1a480:	0580      	lsls	r0, r0, #22
   1a482:	0d80      	lsrs	r0, r0, #22
   1a484:	f5b0 7f83 	cmp.w	r0, #262	; 0x106
   1a488:	d033      	beq.n	1a4f2 <get_drive+0x76>
   1a48a:	d816      	bhi.n	1a4ba <get_drive+0x3e>
   1a48c:	2806      	cmp	r0, #6
   1a48e:	d02c      	beq.n	1a4ea <get_drive+0x6e>
   1a490:	d906      	bls.n	1a4a0 <get_drive+0x24>
   1a492:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   1a496:	d10d      	bne.n	1a4b4 <get_drive+0x38>
		*drive = NRF_GPIO_PIN_H0S1;
   1a498:	2301      	movs	r3, #1
   1a49a:	700b      	strb	r3, [r1, #0]
	return 0;
   1a49c:	2000      	movs	r0, #0
		break;
   1a49e:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1a4a0:	b300      	cbz	r0, 1a4e4 <get_drive+0x68>
   1a4a2:	2802      	cmp	r0, #2
   1a4a4:	d103      	bne.n	1a4ae <get_drive+0x32>
		*drive = NRF_GPIO_PIN_D0S1;
   1a4a6:	2304      	movs	r3, #4
   1a4a8:	700b      	strb	r3, [r1, #0]
	return 0;
   1a4aa:	2000      	movs	r0, #0
		break;
   1a4ac:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1a4ae:	f06f 0015 	mvn.w	r0, #21
   1a4b2:	4770      	bx	lr
   1a4b4:	f06f 0015 	mvn.w	r0, #21
   1a4b8:	4770      	bx	lr
   1a4ba:	f240 2302 	movw	r3, #514	; 0x202
   1a4be:	4298      	cmp	r0, r3
   1a4c0:	d01b      	beq.n	1a4fa <get_drive+0x7e>
   1a4c2:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
   1a4c6:	d103      	bne.n	1a4d0 <get_drive+0x54>
		*drive = NRF_GPIO_PIN_H0H1;
   1a4c8:	2303      	movs	r3, #3
   1a4ca:	700b      	strb	r3, [r1, #0]
	return 0;
   1a4cc:	2000      	movs	r0, #0
		break;
   1a4ce:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1a4d0:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   1a4d4:	d103      	bne.n	1a4de <get_drive+0x62>
		*drive = NRF_GPIO_PIN_S0H1;
   1a4d6:	2302      	movs	r3, #2
   1a4d8:	700b      	strb	r3, [r1, #0]
	return 0;
   1a4da:	2000      	movs	r0, #0
		break;
   1a4dc:	4770      	bx	lr
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1a4de:	f06f 0015 	mvn.w	r0, #21
   1a4e2:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0S1;
   1a4e4:	2000      	movs	r0, #0
   1a4e6:	7008      	strb	r0, [r1, #0]
		break;
   1a4e8:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0D1;
   1a4ea:	2306      	movs	r3, #6
   1a4ec:	700b      	strb	r3, [r1, #0]
	return 0;
   1a4ee:	2000      	movs	r0, #0
		break;
   1a4f0:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_H0D1;
   1a4f2:	2307      	movs	r3, #7
   1a4f4:	700b      	strb	r3, [r1, #0]
	return 0;
   1a4f6:	2000      	movs	r0, #0
		break;
   1a4f8:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_D0H1;
   1a4fa:	2305      	movs	r3, #5
   1a4fc:	700b      	strb	r3, [r1, #0]
	return 0;
   1a4fe:	2000      	movs	r0, #0
}
   1a500:	4770      	bx	lr

0001a502 <get_pull>:
	if (flags & GPIO_PULL_UP) {
   1a502:	f010 0f10 	tst.w	r0, #16
   1a506:	d104      	bne.n	1a512 <get_pull+0x10>
	} else if (flags & GPIO_PULL_DOWN) {
   1a508:	f010 0f20 	tst.w	r0, #32
   1a50c:	d103      	bne.n	1a516 <get_pull+0x14>
	return NRF_GPIO_PIN_NOPULL;
   1a50e:	2000      	movs	r0, #0
   1a510:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLUP;
   1a512:	2003      	movs	r0, #3
   1a514:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLDOWN;
   1a516:	2001      	movs	r0, #1
}
   1a518:	4770      	bx	lr

0001a51a <gpio_nrfx_port_get_raw>:
	return port->config;
   1a51a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1a51c:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   1a51e:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   1a520:	600b      	str	r3, [r1, #0]
}
   1a522:	2000      	movs	r0, #0
   1a524:	4770      	bx	lr

0001a526 <gpio_nrfx_port_set_masked_raw>:
	return port->config;
   1a526:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1a528:	685b      	ldr	r3, [r3, #4]
	const uint32_t set_mask = value & mask;
   1a52a:	ea02 0001 	and.w	r0, r2, r1
	const uint32_t clear_mask = (~set_mask) & mask;
   1a52e:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
   1a532:	6098      	str	r0, [r3, #8]
    p_reg->OUTCLR = clr_mask;
   1a534:	60d9      	str	r1, [r3, #12]
}
   1a536:	2000      	movs	r0, #0
   1a538:	4770      	bx	lr

0001a53a <gpio_nrfx_port_set_bits_raw>:
	return port->config;
   1a53a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1a53c:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   1a53e:	6099      	str	r1, [r3, #8]
}
   1a540:	2000      	movs	r0, #0
   1a542:	4770      	bx	lr

0001a544 <gpio_nrfx_port_clear_bits_raw>:
	return port->config;
   1a544:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1a546:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   1a548:	60d9      	str	r1, [r3, #12]
}
   1a54a:	2000      	movs	r0, #0
   1a54c:	4770      	bx	lr

0001a54e <gpio_nrfx_port_toggle_bits>:
	return port->config;
   1a54e:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1a550:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   1a552:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
   1a554:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
   1a558:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
   1a55a:	6090      	str	r0, [r2, #8]
    p_reg->OUTCLR = clr_mask;
   1a55c:	60d3      	str	r3, [r2, #12]
}
   1a55e:	2000      	movs	r0, #0
   1a560:	4770      	bx	lr

0001a562 <get_trigger>:
	if (mode == GPIO_INT_MODE_LEVEL) {
   1a562:	f5b0 0f80 	cmp.w	r0, #4194304	; 0x400000
   1a566:	d007      	beq.n	1a578 <get_trigger+0x16>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1a568:	f1b1 6fc0 	cmp.w	r1, #100663296	; 0x6000000
   1a56c:	d00d      	beq.n	1a58a <get_trigger+0x28>
   1a56e:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
   1a572:	d008      	beq.n	1a586 <get_trigger+0x24>
   1a574:	2001      	movs	r0, #1
}
   1a576:	4770      	bx	lr
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   1a578:	f1b1 7f00 	cmp.w	r1, #33554432	; 0x2000000
   1a57c:	d001      	beq.n	1a582 <get_trigger+0x20>
   1a57e:	2005      	movs	r0, #5
   1a580:	4770      	bx	lr
   1a582:	2004      	movs	r0, #4
   1a584:	4770      	bx	lr
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1a586:	2002      	movs	r0, #2
   1a588:	4770      	bx	lr
   1a58a:	2003      	movs	r0, #3
   1a58c:	4770      	bx	lr

0001a58e <gpio_nrfx_manage_callback>:
{
   1a58e:	b410      	push	{r4}
	return port->data;
   1a590:	6904      	ldr	r4, [r0, #16]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1a592:	f104 0c04 	add.w	ip, r4, #4
	return list->head;
   1a596:	6863      	ldr	r3, [r4, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
   1a598:	b1fb      	cbz	r3, 1a5da <gpio_nrfx_manage_callback+0x4c>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a59a:	2000      	movs	r0, #0
   1a59c:	e00d      	b.n	1a5ba <gpio_nrfx_manage_callback+0x2c>
	return node->next;
   1a59e:	680b      	ldr	r3, [r1, #0]
	list->head = node;
   1a5a0:	6063      	str	r3, [r4, #4]
	return list->tail;
   1a5a2:	f8dc 0004 	ldr.w	r0, [ip, #4]
Z_GENLIST_REMOVE(slist, snode)
   1a5a6:	4281      	cmp	r1, r0
   1a5a8:	d112      	bne.n	1a5d0 <gpio_nrfx_manage_callback+0x42>
	list->tail = node;
   1a5aa:	f8cc 3004 	str.w	r3, [ip, #4]
}
   1a5ae:	e00f      	b.n	1a5d0 <gpio_nrfx_manage_callback+0x42>
	list->tail = node;
   1a5b0:	f8cc 0004 	str.w	r0, [ip, #4]
}
   1a5b4:	e00c      	b.n	1a5d0 <gpio_nrfx_manage_callback+0x42>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a5b6:	4618      	mov	r0, r3
   1a5b8:	681b      	ldr	r3, [r3, #0]
   1a5ba:	b163      	cbz	r3, 1a5d6 <gpio_nrfx_manage_callback+0x48>
   1a5bc:	4299      	cmp	r1, r3
   1a5be:	d1fa      	bne.n	1a5b6 <gpio_nrfx_manage_callback+0x28>
Z_GENLIST_REMOVE(slist, snode)
   1a5c0:	2800      	cmp	r0, #0
   1a5c2:	d0ec      	beq.n	1a59e <gpio_nrfx_manage_callback+0x10>
	return node->next;
   1a5c4:	680b      	ldr	r3, [r1, #0]
	parent->next = child;
   1a5c6:	6003      	str	r3, [r0, #0]
	return list->tail;
   1a5c8:	f8dc 3004 	ldr.w	r3, [ip, #4]
Z_GENLIST_REMOVE(slist, snode)
   1a5cc:	4299      	cmp	r1, r3
   1a5ce:	d0ef      	beq.n	1a5b0 <gpio_nrfx_manage_callback+0x22>
	parent->next = child;
   1a5d0:	2300      	movs	r3, #0
   1a5d2:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a5d4:	2301      	movs	r3, #1
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
   1a5d6:	b903      	cbnz	r3, 1a5da <gpio_nrfx_manage_callback+0x4c>
			if (!set) {
   1a5d8:	b162      	cbz	r2, 1a5f4 <gpio_nrfx_manage_callback+0x66>
				return -EINVAL;
			}
		}
	}

	if (set) {
   1a5da:	b172      	cbz	r2, 1a5fa <gpio_nrfx_manage_callback+0x6c>
	return list->head;
   1a5dc:	6863      	ldr	r3, [r4, #4]
	parent->next = child;
   1a5de:	600b      	str	r3, [r1, #0]
	list->head = node;
   1a5e0:	6061      	str	r1, [r4, #4]
	return list->tail;
   1a5e2:	f8dc 3004 	ldr.w	r3, [ip, #4]
Z_GENLIST_PREPEND(slist, snode)
   1a5e6:	b10b      	cbz	r3, 1a5ec <gpio_nrfx_manage_callback+0x5e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1a5e8:	2000      	movs	r0, #0
   1a5ea:	e007      	b.n	1a5fc <gpio_nrfx_manage_callback+0x6e>
	list->tail = node;
   1a5ec:	f8cc 1004 	str.w	r1, [ip, #4]
   1a5f0:	2000      	movs	r0, #0
}
   1a5f2:	e003      	b.n	1a5fc <gpio_nrfx_manage_callback+0x6e>
				return -EINVAL;
   1a5f4:	f06f 0015 	mvn.w	r0, #21
   1a5f8:	e000      	b.n	1a5fc <gpio_nrfx_manage_callback+0x6e>
	return 0;
   1a5fa:	2000      	movs	r0, #0
}
   1a5fc:	bc10      	pop	{r4}
   1a5fe:	4770      	bx	lr

0001a600 <nrfx_gpio_handler>:
{
   1a600:	b570      	push	{r4, r5, r6, lr}
    *p_pin = pin_number & 0x1F;
   1a602:	f000 041f 	and.w	r4, r0, #31
	const struct device *port = get_dev(port_id);
   1a606:	0940      	lsrs	r0, r0, #5
   1a608:	f7f3 fd00 	bl	e00c <get_dev>
	if (port == NULL) {
   1a60c:	b1d8      	cbz	r0, 1a646 <nrfx_gpio_handler+0x46>
   1a60e:	4606      	mov	r6, r0
	return port->data;
   1a610:	6903      	ldr	r3, [r0, #16]
	gpio_fire_callbacks(list, port, BIT(pin));
   1a612:	2501      	movs	r5, #1
   1a614:	40a5      	lsls	r5, r4
	return list->head;
   1a616:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1a618:	b119      	cbz	r1, 1a622 <nrfx_gpio_handler+0x22>
   1a61a:	460c      	mov	r4, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
   1a61c:	b149      	cbz	r1, 1a632 <nrfx_gpio_handler+0x32>
	return node->next;
   1a61e:	680c      	ldr	r4, [r1, #0]
   1a620:	e007      	b.n	1a632 <nrfx_gpio_handler+0x32>
   1a622:	460c      	mov	r4, r1
   1a624:	e005      	b.n	1a632 <nrfx_gpio_handler+0x32>
   1a626:	b164      	cbz	r4, 1a642 <nrfx_gpio_handler+0x42>
   1a628:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
   1a62a:	b104      	cbz	r4, 1a62e <nrfx_gpio_handler+0x2e>
	return node->next;
   1a62c:	6823      	ldr	r3, [r4, #0]
   1a62e:	4621      	mov	r1, r4
   1a630:	461c      	mov	r4, r3
   1a632:	b141      	cbz	r1, 1a646 <nrfx_gpio_handler+0x46>
		if (cb->pin_mask & pins) {
   1a634:	688a      	ldr	r2, [r1, #8]
   1a636:	402a      	ands	r2, r5
   1a638:	d0f5      	beq.n	1a626 <nrfx_gpio_handler+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   1a63a:	684b      	ldr	r3, [r1, #4]
   1a63c:	4630      	mov	r0, r6
   1a63e:	4798      	blx	r3
   1a640:	e7f1      	b.n	1a626 <nrfx_gpio_handler+0x26>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1a642:	4623      	mov	r3, r4
   1a644:	e7f3      	b.n	1a62e <nrfx_gpio_handler+0x2e>
}
   1a646:	bd70      	pop	{r4, r5, r6, pc}

0001a648 <irq_connect1>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   1a648:	b508      	push	{r3, lr}
   1a64a:	2200      	movs	r2, #0
   1a64c:	2101      	movs	r1, #1
   1a64e:	2009      	movs	r0, #9
   1a650:	f7e9 fd08 	bl	4064 <z_arm_irq_priority_set>
   1a654:	bd08      	pop	{r3, pc}

0001a656 <irq_connect3>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(3);
   1a656:	b508      	push	{r3, lr}
   1a658:	2200      	movs	r2, #0
   1a65a:	2101      	movs	r1, #1
   1a65c:	200c      	movs	r0, #12
   1a65e:	f7e9 fd01 	bl	4064 <z_arm_irq_priority_set>
   1a662:	bd08      	pop	{r3, pc}

0001a664 <spi_nrfx_release>:
{
   1a664:	b510      	push	{r4, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   1a666:	6904      	ldr	r4, [r0, #16]
	return !!(ctx->config == config);
   1a668:	6823      	ldr	r3, [r4, #0]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   1a66a:	428b      	cmp	r3, r1
   1a66c:	d131      	bne.n	1a6d2 <spi_nrfx_release+0x6e>
	if (dev_data->busy) {
   1a66e:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
   1a672:	2b00      	cmp	r3, #0
   1a674:	d130      	bne.n	1a6d8 <spi_nrfx_release+0x74>
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   1a676:	6823      	ldr	r3, [r4, #0]
   1a678:	b1c3      	cbz	r3, 1a6ac <spi_nrfx_release+0x48>
   1a67a:	689b      	ldr	r3, [r3, #8]
   1a67c:	b1b3      	cbz	r3, 1a6ac <spi_nrfx_release+0x48>
   1a67e:	681a      	ldr	r2, [r3, #0]
   1a680:	b1a2      	cbz	r2, 1a6ac <spi_nrfx_release+0x48>
			k_busy_wait(ctx->config->cs->delay);
   1a682:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
   1a684:	f002 f943 	bl	1c90e <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   1a688:	6823      	ldr	r3, [r4, #0]
   1a68a:	689b      	ldr	r3, [r3, #8]
	return gpio_pin_set(spec->port, spec->pin, value);
   1a68c:	6818      	ldr	r0, [r3, #0]
   1a68e:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
   1a690:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1a692:	681a      	ldr	r2, [r3, #0]
   1a694:	2301      	movs	r3, #1
   1a696:	408b      	lsls	r3, r1
   1a698:	421a      	tst	r2, r3
   1a69a:	d10b      	bne.n	1a6b4 <spi_nrfx_release+0x50>
   1a69c:	2300      	movs	r3, #0
	if (value != 0)	{
   1a69e:	b15b      	cbz	r3, 1a6b8 <spi_nrfx_release+0x54>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a6a0:	2301      	movs	r3, #1
   1a6a2:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a6a6:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
   1a6a8:	68db      	ldr	r3, [r3, #12]
   1a6aa:	4798      	blx	r3
   1a6ac:	69a3      	ldr	r3, [r4, #24]
	if (!k_sem_count_get(&ctx->lock)) {
   1a6ae:	b153      	cbz	r3, 1a6c6 <spi_nrfx_release+0x62>
	return 0;
   1a6b0:	2000      	movs	r0, #0
}
   1a6b2:	bd10      	pop	{r4, pc}
		value = (value != 0) ? 0 : 1;
   1a6b4:	2301      	movs	r3, #1
   1a6b6:	e7f2      	b.n	1a69e <spi_nrfx_release+0x3a>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a6b8:	2301      	movs	r3, #1
   1a6ba:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a6be:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
   1a6c0:	691b      	ldr	r3, [r3, #16]
   1a6c2:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
   1a6c4:	e7f2      	b.n	1a6ac <spi_nrfx_release+0x48>
		ctx->owner = NULL;
   1a6c6:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
   1a6c8:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
   1a6cc:	f7f9 fa60 	bl	13b90 <z_impl_k_sem_give>
}
   1a6d0:	e7ee      	b.n	1a6b0 <spi_nrfx_release+0x4c>
		return -EINVAL;
   1a6d2:	f06f 0015 	mvn.w	r0, #21
   1a6d6:	e7ec      	b.n	1a6b2 <spi_nrfx_release+0x4e>
		return -EBUSY;
   1a6d8:	f06f 000f 	mvn.w	r0, #15
   1a6dc:	e7e9      	b.n	1a6b2 <spi_nrfx_release+0x4e>

0001a6de <spi_nrfx_transceive>:
{
   1a6de:	b510      	push	{r4, lr}
   1a6e0:	b082      	sub	sp, #8
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL);
   1a6e2:	2400      	movs	r4, #0
   1a6e4:	9401      	str	r4, [sp, #4]
   1a6e6:	9400      	str	r4, [sp, #0]
   1a6e8:	f7f4 fc4e 	bl	ef88 <transceive>
}
   1a6ec:	b002      	add	sp, #8
   1a6ee:	bd10      	pop	{r4, pc}

0001a6f0 <spi_nrfx_init>:
{
   1a6f0:	b570      	push	{r4, r5, r6, lr}
   1a6f2:	b082      	sub	sp, #8
	const struct spi_nrfx_config *dev_config = dev->config;
   1a6f4:	6845      	ldr	r5, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   1a6f6:	6904      	ldr	r4, [r0, #16]
	err = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
   1a6f8:	6aae      	ldr	r6, [r5, #40]	; 0x28
	ret = pinctrl_lookup_state(config, id, &state);
   1a6fa:	aa01      	add	r2, sp, #4
   1a6fc:	2100      	movs	r1, #0
   1a6fe:	4630      	mov	r0, r6
   1a700:	f000 fae2 	bl	1acc8 <pinctrl_lookup_state>
	if (ret < 0) {
   1a704:	2800      	cmp	r0, #0
   1a706:	db05      	blt.n	1a714 <spi_nrfx_init+0x24>
	return pinctrl_apply_state_direct(config, state);
   1a708:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   1a70a:	6832      	ldr	r2, [r6, #0]
   1a70c:	7919      	ldrb	r1, [r3, #4]
   1a70e:	6818      	ldr	r0, [r3, #0]
   1a710:	f7f5 ffcc 	bl	106ac <pinctrl_configure_pins>
	if (err < 0) {
   1a714:	2800      	cmp	r0, #0
   1a716:	db24      	blt.n	1a762 <spi_nrfx_init+0x72>
	dev_config->irq_connect();
   1a718:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1a71a:	4798      	blx	r3
	err = spi_context_cs_configure_all(&dev_data->ctx);
   1a71c:	4620      	mov	r0, r4
   1a71e:	f7f4 fb07 	bl	ed30 <spi_context_cs_configure_all>
	if (err < 0) {
   1a722:	2800      	cmp	r0, #0
   1a724:	db1d      	blt.n	1a762 <spi_nrfx_init+0x72>
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   1a726:	6823      	ldr	r3, [r4, #0]
   1a728:	b1c3      	cbz	r3, 1a75c <spi_nrfx_init+0x6c>
   1a72a:	689b      	ldr	r3, [r3, #8]
   1a72c:	b1b3      	cbz	r3, 1a75c <spi_nrfx_init+0x6c>
   1a72e:	681a      	ldr	r2, [r3, #0]
   1a730:	b1a2      	cbz	r2, 1a75c <spi_nrfx_init+0x6c>
			k_busy_wait(ctx->config->cs->delay);
   1a732:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
   1a734:	f002 f8eb 	bl	1c90e <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   1a738:	6823      	ldr	r3, [r4, #0]
   1a73a:	689b      	ldr	r3, [r3, #8]
	return gpio_pin_set(spec->port, spec->pin, value);
   1a73c:	6818      	ldr	r0, [r3, #0]
   1a73e:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
   1a740:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1a742:	681a      	ldr	r2, [r3, #0]
   1a744:	2301      	movs	r3, #1
   1a746:	408b      	lsls	r3, r1
   1a748:	421a      	tst	r2, r3
   1a74a:	d10c      	bne.n	1a766 <spi_nrfx_init+0x76>
   1a74c:	2300      	movs	r3, #0
	if (value != 0)	{
   1a74e:	b163      	cbz	r3, 1a76a <spi_nrfx_init+0x7a>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a750:	2301      	movs	r3, #1
   1a752:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a756:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
   1a758:	68db      	ldr	r3, [r3, #12]
   1a75a:	4798      	blx	r3
   1a75c:	69a3      	ldr	r3, [r4, #24]
	if (!k_sem_count_get(&ctx->lock)) {
   1a75e:	b15b      	cbz	r3, 1a778 <spi_nrfx_init+0x88>
	return 0;
   1a760:	2000      	movs	r0, #0
}
   1a762:	b002      	add	sp, #8
   1a764:	bd70      	pop	{r4, r5, r6, pc}
		value = (value != 0) ? 0 : 1;
   1a766:	2301      	movs	r3, #1
   1a768:	e7f1      	b.n	1a74e <spi_nrfx_init+0x5e>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a76a:	2301      	movs	r3, #1
   1a76c:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a770:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
   1a772:	691b      	ldr	r3, [r3, #16]
   1a774:	4798      	blx	r3
	return gpio_pin_set_raw(port, pin, value);
   1a776:	e7f1      	b.n	1a75c <spi_nrfx_init+0x6c>
		ctx->owner = NULL;
   1a778:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
   1a77a:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
   1a77e:	f7f9 fa07 	bl	13b90 <z_impl_k_sem_give>
}
   1a782:	e7ed      	b.n	1a760 <spi_nrfx_init+0x70>

0001a784 <disable_sync>:
{
   1a784:	b530      	push	{r4, r5, lr}
   1a786:	b085      	sub	sp, #20
	struct driver_data_sync *data = dev->data;
   1a788:	6904      	ldr	r4, [r0, #16]
	const struct driver_config *cfg = dev->config;
   1a78a:	6845      	ldr	r5, [r0, #4]
	int rc = onoff_sync_lock(&data->srv, &key);
   1a78c:	a903      	add	r1, sp, #12
   1a78e:	4620      	mov	r0, r4
   1a790:	f7fb f926 	bl	159e0 <onoff_sync_lock>
	if  ((cfg->options & OPTION_ALWAYS_ON) != 0) {
   1a794:	7d2a      	ldrb	r2, [r5, #20]
   1a796:	f012 0f01 	tst.w	r2, #1
   1a79a:	d120      	bne.n	1a7de <disable_sync+0x5a>
   1a79c:	4603      	mov	r3, r0
	} else if (rc == 1) {
   1a79e:	2801      	cmp	r0, #1
   1a7a0:	d003      	beq.n	1a7aa <disable_sync+0x26>
	} else if (rc == 0) {
   1a7a2:	b9e8      	cbnz	r0, 1a7e0 <disable_sync+0x5c>
		rc = -EINVAL;
   1a7a4:	f06f 0315 	mvn.w	r3, #21
   1a7a8:	e01a      	b.n	1a7e0 <disable_sync+0x5c>
	return gpio_pin_set(spec->port, spec->pin, value);
   1a7aa:	68e8      	ldr	r0, [r5, #12]
   1a7ac:	7c29      	ldrb	r1, [r5, #16]
	const struct gpio_driver_data *const data =
   1a7ae:	6902      	ldr	r2, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1a7b0:	6815      	ldr	r5, [r2, #0]
   1a7b2:	2201      	movs	r2, #1
   1a7b4:	408a      	lsls	r2, r1
   1a7b6:	4215      	tst	r5, r2
   1a7b8:	d100      	bne.n	1a7bc <disable_sync+0x38>
   1a7ba:	2300      	movs	r3, #0
	if (value != 0)	{
   1a7bc:	b13b      	cbz	r3, 1a7ce <disable_sync+0x4a>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a7be:	2301      	movs	r3, #1
   1a7c0:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a7c4:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
   1a7c6:	68db      	ldr	r3, [r3, #12]
   1a7c8:	4798      	blx	r3
   1a7ca:	4603      	mov	r3, r0
   1a7cc:	e008      	b.n	1a7e0 <disable_sync+0x5c>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a7ce:	2301      	movs	r3, #1
   1a7d0:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a7d4:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
   1a7d6:	691b      	ldr	r3, [r3, #16]
   1a7d8:	4798      	blx	r3
   1a7da:	4603      	mov	r3, r0
	return ret;
   1a7dc:	e000      	b.n	1a7e0 <disable_sync+0x5c>
		rc = 0;
   1a7de:	2300      	movs	r3, #0
	return onoff_sync_finalize(&data->srv, key, NULL, rc, false);
   1a7e0:	2200      	movs	r2, #0
   1a7e2:	9200      	str	r2, [sp, #0]
   1a7e4:	9903      	ldr	r1, [sp, #12]
   1a7e6:	4620      	mov	r0, r4
   1a7e8:	f7fb f905 	bl	159f6 <onoff_sync_finalize>
}
   1a7ec:	b005      	add	sp, #20
   1a7ee:	bd30      	pop	{r4, r5, pc}

0001a7f0 <enable_sync>:
{
   1a7f0:	b570      	push	{r4, r5, r6, lr}
   1a7f2:	b084      	sub	sp, #16
   1a7f4:	460c      	mov	r4, r1
	struct driver_data_sync *data = dev->data;
   1a7f6:	6905      	ldr	r5, [r0, #16]
	const struct driver_config *cfg = dev->config;
   1a7f8:	6846      	ldr	r6, [r0, #4]
	int rc = onoff_sync_lock(&data->srv, &key);
   1a7fa:	a903      	add	r1, sp, #12
   1a7fc:	4628      	mov	r0, r5
   1a7fe:	f7fb f8ef 	bl	159e0 <onoff_sync_lock>
	if ((rc == 0)
   1a802:	4603      	mov	r3, r0
   1a804:	b918      	cbnz	r0, 1a80e <enable_sync+0x1e>
	    && ((cfg->options & OPTION_ALWAYS_ON) == 0)) {
   1a806:	7d32      	ldrb	r2, [r6, #20]
   1a808:	f012 0f01 	tst.w	r2, #1
   1a80c:	d008      	beq.n	1a820 <enable_sync+0x30>
	return onoff_sync_finalize(&data->srv, key, cli, rc, true);
   1a80e:	2201      	movs	r2, #1
   1a810:	9200      	str	r2, [sp, #0]
   1a812:	4622      	mov	r2, r4
   1a814:	9903      	ldr	r1, [sp, #12]
   1a816:	4628      	mov	r0, r5
   1a818:	f7fb f8ed 	bl	159f6 <onoff_sync_finalize>
}
   1a81c:	b004      	add	sp, #16
   1a81e:	bd70      	pop	{r4, r5, r6, pc}
	return gpio_pin_set(spec->port, spec->pin, value);
   1a820:	68f0      	ldr	r0, [r6, #12]
   1a822:	7c31      	ldrb	r1, [r6, #16]
	const struct gpio_driver_data *const data =
   1a824:	6902      	ldr	r2, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1a826:	6816      	ldr	r6, [r2, #0]
   1a828:	2201      	movs	r2, #1
   1a82a:	408a      	lsls	r2, r1
   1a82c:	4216      	tst	r6, r2
   1a82e:	d100      	bne.n	1a832 <enable_sync+0x42>
   1a830:	2301      	movs	r3, #1
	if (value != 0)	{
   1a832:	b13b      	cbz	r3, 1a844 <enable_sync+0x54>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a834:	2301      	movs	r3, #1
   1a836:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a83a:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
   1a83c:	68db      	ldr	r3, [r3, #12]
   1a83e:	4798      	blx	r3
   1a840:	4603      	mov	r3, r0
   1a842:	e7e4      	b.n	1a80e <enable_sync+0x1e>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
   1a844:	2301      	movs	r3, #1
   1a846:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
   1a84a:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
   1a84c:	691b      	ldr	r3, [r3, #16]
   1a84e:	4798      	blx	r3
   1a850:	4603      	mov	r3, r0
	return ret;
   1a852:	e7dc      	b.n	1a80e <enable_sync+0x1e>

0001a854 <endtx_isr>:
	const struct uarte_nrfx_config *config = dev->config;
   1a854:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   1a856:	681b      	ldr	r3, [r3, #0]
	__asm__ volatile(
   1a858:	f04f 0120 	mov.w	r1, #32
   1a85c:	f3ef 8211 	mrs	r2, BASEPRI
   1a860:	f381 8812 	msr	BASEPRI_MAX, r1
   1a864:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1a868:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   1a86c:	b131      	cbz	r1, 1a87c <endtx_isr+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a86e:	2100      	movs	r1, #0
   1a870:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   1a874:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1a878:	2101      	movs	r1, #1
   1a87a:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   1a87c:	f382 8811 	msr	BASEPRI, r2
   1a880:	f3bf 8f6f 	isb	sy
}
   1a884:	4770      	bx	lr

0001a886 <uarte_nrfx_isr_int>:
{
   1a886:	b538      	push	{r3, r4, r5, lr}
	const struct uarte_nrfx_config *config = dev->config;
   1a888:	6845      	ldr	r5, [r0, #4]
	return config->uarte_regs;
   1a88a:	682c      	ldr	r4, [r5, #0]
    return p_reg->INTENSET & mask;
   1a88c:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   1a890:	f413 7f80 	tst.w	r3, #256	; 0x100
   1a894:	d002      	beq.n	1a89c <uarte_nrfx_isr_int+0x16>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1a896:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
   1a89a:	b9d3      	cbnz	r3, 1a8d2 <uarte_nrfx_isr_int+0x4c>
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
   1a89c:	686b      	ldr	r3, [r5, #4]
   1a89e:	f013 0f10 	tst.w	r3, #16
   1a8a2:	d015      	beq.n	1a8d0 <uarte_nrfx_isr_int+0x4a>
	__asm__ volatile(
   1a8a4:	f04f 0220 	mov.w	r2, #32
   1a8a8:	f3ef 8311 	mrs	r3, BASEPRI
   1a8ac:	f382 8812 	msr	BASEPRI_MAX, r2
   1a8b0:	f3bf 8f6f 	isb	sy
   1a8b4:	f8d4 2158 	ldr.w	r2, [r4, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   1a8b8:	b112      	cbz	r2, 1a8c0 <uarte_nrfx_isr_int+0x3a>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   1a8ba:	2200      	movs	r2, #0
   1a8bc:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   1a8c0:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
   1a8c4:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
	__asm__ volatile(
   1a8c8:	f383 8811 	msr	BASEPRI, r3
   1a8cc:	f3bf 8f6f 	isb	sy
}
   1a8d0:	bd38      	pop	{r3, r4, r5, pc}
		endtx_isr(dev);
   1a8d2:	f7ff ffbf 	bl	1a854 <endtx_isr>
   1a8d6:	e7e1      	b.n	1a89c <uarte_nrfx_isr_int+0x16>

0001a8d8 <uarte_nrfx_configure>:
{
   1a8d8:	b570      	push	{r4, r5, r6, lr}
   1a8da:	b082      	sub	sp, #8
   1a8dc:	4605      	mov	r5, r0
   1a8de:	460c      	mov	r4, r1
	struct uarte_nrfx_data *data = dev->data;
   1a8e0:	6906      	ldr	r6, [r0, #16]
	switch (cfg->stop_bits) {
   1a8e2:	794b      	ldrb	r3, [r1, #5]
   1a8e4:	2b01      	cmp	r3, #1
   1a8e6:	d006      	beq.n	1a8f6 <uarte_nrfx_configure+0x1e>
   1a8e8:	2b03      	cmp	r3, #3
   1a8ea:	d011      	beq.n	1a910 <uarte_nrfx_configure+0x38>
   1a8ec:	f06f 0285 	mvn.w	r2, #133	; 0x85
}
   1a8f0:	4610      	mov	r0, r2
   1a8f2:	b002      	add	sp, #8
   1a8f4:	bd70      	pop	{r4, r5, r6, pc}
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
   1a8f6:	2300      	movs	r3, #0
   1a8f8:	f88d 3002 	strb.w	r3, [sp, #2]
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   1a8fc:	79a3      	ldrb	r3, [r4, #6]
   1a8fe:	2b03      	cmp	r3, #3
   1a900:	d146      	bne.n	1a990 <uarte_nrfx_configure+0xb8>
	switch (cfg->flow_ctrl) {
   1a902:	79e3      	ldrb	r3, [r4, #7]
   1a904:	b143      	cbz	r3, 1a918 <uarte_nrfx_configure+0x40>
   1a906:	2b01      	cmp	r3, #1
   1a908:	d015      	beq.n	1a936 <uarte_nrfx_configure+0x5e>
   1a90a:	f06f 0285 	mvn.w	r2, #133	; 0x85
   1a90e:	e7ef      	b.n	1a8f0 <uarte_nrfx_configure+0x18>
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   1a910:	2310      	movs	r3, #16
   1a912:	f88d 3002 	strb.w	r3, [sp, #2]
		break;
   1a916:	e7f1      	b.n	1a8fc <uarte_nrfx_configure+0x24>
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
   1a918:	2300      	movs	r3, #0
   1a91a:	f88d 3000 	strb.w	r3, [sp]
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
   1a91e:	2300      	movs	r3, #0
   1a920:	f8ad 3004 	strh.w	r3, [sp, #4]
	switch (cfg->parity) {
   1a924:	7923      	ldrb	r3, [r4, #4]
   1a926:	2b01      	cmp	r3, #1
   1a928:	d02a      	beq.n	1a980 <uarte_nrfx_configure+0xa8>
   1a92a:	2b02      	cmp	r3, #2
   1a92c:	d024      	beq.n	1a978 <uarte_nrfx_configure+0xa0>
   1a92e:	b133      	cbz	r3, 1a93e <uarte_nrfx_configure+0x66>
   1a930:	f06f 0285 	mvn.w	r2, #133	; 0x85
   1a934:	e7dc      	b.n	1a8f0 <uarte_nrfx_configure+0x18>
		uarte_cfg.hwfc = NRF_UARTE_HWFC_ENABLED;
   1a936:	2301      	movs	r3, #1
   1a938:	f88d 3000 	strb.w	r3, [sp]
		break;
   1a93c:	e7ef      	b.n	1a91e <uarte_nrfx_configure+0x46>
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
   1a93e:	f88d 3001 	strb.w	r3, [sp, #1]
	if (baudrate_set(dev, cfg->baudrate) != 0) {
   1a942:	6821      	ldr	r1, [r4, #0]
   1a944:	4628      	mov	r0, r5
   1a946:	f7f4 fdbd 	bl	f4c4 <baudrate_set>
   1a94a:	4602      	mov	r2, r0
   1a94c:	bb18      	cbnz	r0, 1a996 <uarte_nrfx_configure+0xbe>
	const struct uarte_nrfx_config *config = dev->config;
   1a94e:	686b      	ldr	r3, [r5, #4]
	return config->uarte_regs;
   1a950:	6819      	ldr	r1, [r3, #0]
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   1a952:	f89d 3001 	ldrb.w	r3, [sp, #1]
                    | (uint32_t)p_cfg->stop
   1a956:	f89d 0002 	ldrb.w	r0, [sp, #2]
   1a95a:	4303      	orrs	r3, r0
                    | (uint32_t)p_cfg->paritytype
   1a95c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
   1a960:	4303      	orrs	r3, r0
                    | (uint32_t)p_cfg->hwfc;
   1a962:	f89d 0000 	ldrb.w	r0, [sp]
   1a966:	4303      	orrs	r3, r0
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   1a968:	f8c1 356c 	str.w	r3, [r1, #1388]	; 0x56c
	data->uart_config = *cfg;
   1a96c:	3604      	adds	r6, #4
   1a96e:	e894 0003 	ldmia.w	r4, {r0, r1}
   1a972:	e886 0003 	stmia.w	r6, {r0, r1}
	return 0;
   1a976:	e7bb      	b.n	1a8f0 <uarte_nrfx_configure+0x18>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   1a978:	230e      	movs	r3, #14
   1a97a:	f88d 3001 	strb.w	r3, [sp, #1]
		break;
   1a97e:	e7e0      	b.n	1a942 <uarte_nrfx_configure+0x6a>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   1a980:	230e      	movs	r3, #14
   1a982:	f88d 3001 	strb.w	r3, [sp, #1]
		uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_ODD;
   1a986:	f44f 7380 	mov.w	r3, #256	; 0x100
   1a98a:	f8ad 3004 	strh.w	r3, [sp, #4]
		break;
   1a98e:	e7d8      	b.n	1a942 <uarte_nrfx_configure+0x6a>
		return -ENOTSUP;
   1a990:	f06f 0285 	mvn.w	r2, #133	; 0x85
   1a994:	e7ac      	b.n	1a8f0 <uarte_nrfx_configure+0x18>
		return -ENOTSUP;
   1a996:	f06f 0285 	mvn.w	r2, #133	; 0x85
   1a99a:	e7a9      	b.n	1a8f0 <uarte_nrfx_configure+0x18>

0001a99c <uarte_nrfx_config_get>:
{
   1a99c:	460a      	mov	r2, r1
	struct uarte_nrfx_data *data = dev->data;
   1a99e:	6903      	ldr	r3, [r0, #16]
	*cfg = data->uart_config;
   1a9a0:	3304      	adds	r3, #4
   1a9a2:	e893 0003 	ldmia.w	r3, {r0, r1}
   1a9a6:	e882 0003 	stmia.w	r2, {r0, r1}
}
   1a9aa:	2000      	movs	r0, #0
   1a9ac:	4770      	bx	lr

0001a9ae <uarte_nrfx_err_check>:
	const struct uarte_nrfx_config *config = dev->config;
   1a9ae:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   1a9b0:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   1a9b2:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   1a9b6:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   1a9ba:	4770      	bx	lr

0001a9bc <is_tx_ready>:
	const struct uarte_nrfx_config *config = dev->config;
   1a9bc:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   1a9be:	681a      	ldr	r2, [r3, #0]
	bool ppi_endtx = config->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   1a9c0:	685b      	ldr	r3, [r3, #4]
   1a9c2:	f003 0302 	and.w	r3, r3, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1a9c6:	f8d2 1158 	ldr.w	r1, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   1a9ca:	b929      	cbnz	r1, 1a9d8 <is_tx_ready+0x1c>
   1a9cc:	b933      	cbnz	r3, 1a9dc <is_tx_ready+0x20>
   1a9ce:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   1a9d2:	b92b      	cbnz	r3, 1a9e0 <is_tx_ready+0x24>
   1a9d4:	2000      	movs	r0, #0
   1a9d6:	4770      	bx	lr
   1a9d8:	2001      	movs	r0, #1
   1a9da:	4770      	bx	lr
   1a9dc:	2000      	movs	r0, #0
   1a9de:	4770      	bx	lr
   1a9e0:	2001      	movs	r0, #1
}
   1a9e2:	4770      	bx	lr

0001a9e4 <uarte_enable>:
	const struct uarte_nrfx_config *config = dev->config;
   1a9e4:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   1a9e6:	681b      	ldr	r3, [r3, #0]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   1a9e8:	2208      	movs	r2, #8
   1a9ea:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   1a9ee:	4770      	bx	lr

0001a9f0 <tx_start>:
{
   1a9f0:	b510      	push	{r4, lr}
	const struct uarte_nrfx_config *config = dev->config;
   1a9f2:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   1a9f4:	681c      	ldr	r4, [r3, #0]

NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1a9f6:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1a9fa:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a9fe:	2200      	movs	r2, #0
   1aa00:	f8c4 2120 	str.w	r2, [r4, #288]	; 0x120
   1aa04:	f8d4 1120 	ldr.w	r1, [r4, #288]	; 0x120
   1aa08:	f8c4 2158 	str.w	r2, [r4, #344]	; 0x158
   1aa0c:	f8d4 2158 	ldr.w	r2, [r4, #344]	; 0x158
	if (config->flags & UARTE_CFG_FLAG_LOW_POWER) {
   1aa10:	685b      	ldr	r3, [r3, #4]
   1aa12:	f013 0f10 	tst.w	r3, #16
   1aa16:	d102      	bne.n	1aa1e <tx_start+0x2e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1aa18:	2301      	movs	r3, #1
   1aa1a:	60a3      	str	r3, [r4, #8]
}
   1aa1c:	bd10      	pop	{r4, pc}
		uarte_enable(dev, UARTE_LOW_POWER_TX);
   1aa1e:	2101      	movs	r1, #1
   1aa20:	f7ff ffe0 	bl	1a9e4 <uarte_enable>
    p_reg->INTENSET = mask;
   1aa24:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1aa28:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   1aa2c:	e7f4      	b.n	1aa18 <tx_start+0x28>

0001aa2e <uarte_nrfx_poll_in>:
{
   1aa2e:	b410      	push	{r4}
	const struct uarte_nrfx_data *data = dev->data;
   1aa30:	6904      	ldr	r4, [r0, #16]
	const struct uarte_nrfx_config *config = dev->config;
   1aa32:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
   1aa34:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1aa36:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   1aa3a:	b15a      	cbz	r2, 1aa54 <uarte_nrfx_poll_in+0x26>
	*c = *data->rx_data;
   1aa3c:	6962      	ldr	r2, [r4, #20]
   1aa3e:	7812      	ldrb	r2, [r2, #0]
   1aa40:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1aa42:	2000      	movs	r0, #0
   1aa44:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   1aa48:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1aa4c:	2201      	movs	r2, #1
   1aa4e:	601a      	str	r2, [r3, #0]
}
   1aa50:	bc10      	pop	{r4}
   1aa52:	4770      	bx	lr
		return -1;
   1aa54:	f04f 30ff 	mov.w	r0, #4294967295
   1aa58:	e7fa      	b.n	1aa50 <uarte_nrfx_poll_in+0x22>

0001aa5a <wait_tx_ready>:
{
   1aa5a:	b570      	push	{r4, r5, r6, lr}
   1aa5c:	4606      	mov	r6, r0
   1aa5e:	e014      	b.n	1aa8a <wait_tx_ready+0x30>
		if (res) {
   1aa60:	b17d      	cbz	r5, 1aa82 <wait_tx_ready+0x28>
	__asm__ volatile(
   1aa62:	f04f 0320 	mov.w	r3, #32
   1aa66:	f3ef 8411 	mrs	r4, BASEPRI
   1aa6a:	f383 8812 	msr	BASEPRI_MAX, r3
   1aa6e:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   1aa72:	4630      	mov	r0, r6
   1aa74:	f7ff ffa2 	bl	1a9bc <is_tx_ready>
   1aa78:	b9a0      	cbnz	r0, 1aaa4 <wait_tx_ready+0x4a>
	__asm__ volatile(
   1aa7a:	f384 8811 	msr	BASEPRI, r4
   1aa7e:	f3bf 8f6f 	isb	sy
	return z_impl_k_sleep(timeout);
   1aa82:	2021      	movs	r0, #33	; 0x21
   1aa84:	2100      	movs	r1, #0
   1aa86:	f7f9 fe4f 	bl	14728 <z_impl_k_sleep>
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   1aa8a:	2464      	movs	r4, #100	; 0x64
   1aa8c:	4630      	mov	r0, r6
   1aa8e:	f7ff ff95 	bl	1a9bc <is_tx_ready>
   1aa92:	4605      	mov	r5, r0
   1aa94:	2800      	cmp	r0, #0
   1aa96:	d1e3      	bne.n	1aa60 <wait_tx_ready+0x6>
   1aa98:	2001      	movs	r0, #1
   1aa9a:	f000 f9e5 	bl	1ae68 <nrfx_busy_wait>
   1aa9e:	3c01      	subs	r4, #1
   1aaa0:	d1f4      	bne.n	1aa8c <wait_tx_ready+0x32>
   1aaa2:	e7dd      	b.n	1aa60 <wait_tx_ready+0x6>
}
   1aaa4:	4620      	mov	r0, r4
   1aaa6:	bd70      	pop	{r4, r5, r6, pc}

0001aaa8 <uarte_instance_init>:

static int uarte_instance_init(const struct device *dev,
			       uint8_t interrupts_active)
{
   1aaa8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1aaac:	b083      	sub	sp, #12
   1aaae:	4605      	mov	r5, r0
	const struct uarte_nrfx_config *config = dev->config;
   1aab0:	6847      	ldr	r7, [r0, #4]
	return config->uarte_regs;
   1aab2:	683e      	ldr	r6, [r7, #0]
	int err;
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
	struct uarte_nrfx_data *data = dev->data;
   1aab4:	f8d0 8010 	ldr.w	r8, [r0, #16]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   1aab8:	2100      	movs	r1, #0
   1aaba:	f8c6 1500 	str.w	r1, [r6, #1280]	; 0x500
	const struct uarte_nrfx_config *cfg = dev->config;

	nrf_uarte_disable(uarte);

	data->dev = dev;
   1aabe:	f8c8 0000 	str.w	r0, [r8]

#ifdef CONFIG_PINCTRL
	err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
   1aac2:	f8d7 900c 	ldr.w	r9, [r7, #12]
	ret = pinctrl_lookup_state(config, id, &state);
   1aac6:	aa01      	add	r2, sp, #4
   1aac8:	4648      	mov	r0, r9
   1aaca:	f000 f8fd 	bl	1acc8 <pinctrl_lookup_state>
	if (ret < 0) {
   1aace:	1e04      	subs	r4, r0, #0
   1aad0:	db07      	blt.n	1aae2 <uarte_instance_init+0x3a>
	return pinctrl_apply_state_direct(config, state);
   1aad2:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   1aad4:	f8d9 2000 	ldr.w	r2, [r9]
   1aad8:	7919      	ldrb	r1, [r3, #4]
   1aada:	6818      	ldr	r0, [r3, #0]
   1aadc:	f7f5 fde6 	bl	106ac <pinctrl_configure_pins>
   1aae0:	4604      	mov	r4, r0
	if (err < 0) {
   1aae2:	2c00      	cmp	r4, #0
   1aae4:	db35      	blt.n	1ab52 <uarte_instance_init+0xaa>
	}
#else
	uarte_nrfx_pins_configure(dev, false);
#endif /* CONFIG_PINCTRL */

	err = uarte_nrfx_configure(dev, &data->uart_config);
   1aae6:	f108 0104 	add.w	r1, r8, #4
   1aaea:	4628      	mov	r0, r5
   1aaec:	f7ff fef4 	bl	1a8d8 <uarte_nrfx_configure>
	if (err) {
   1aaf0:	4604      	mov	r4, r0
   1aaf2:	bb70      	cbnz	r0, 1ab52 <uarte_instance_init+0xaa>
		return err;
	}

	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   1aaf4:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   1aaf6:	f013 0f02 	tst.w	r3, #2
   1aafa:	d12e      	bne.n	1ab5a <uarte_instance_init+0xb2>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   1aafc:	2308      	movs	r3, #8
   1aafe:	f8c6 3500 	str.w	r3, [r6, #1280]	; 0x500
#endif
	{
		/* Enable receiver and transmitter */
		nrf_uarte_enable(uarte);

		if (!cfg->disable_rx) {
   1ab02:	7a3b      	ldrb	r3, [r7, #8]
   1ab04:	b95b      	cbnz	r3, 1ab1e <uarte_instance_init+0x76>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1ab06:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   1ab0a:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
			nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);

			nrf_uarte_rx_buffer_set(uarte, data->rx_data, 1);
   1ab0e:	f8d8 3014 	ldr.w	r3, [r8, #20]

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   1ab12:	f8c6 3534 	str.w	r3, [r6, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   1ab16:	2301      	movs	r3, #1
   1ab18:	f8c6 3538 	str.w	r3, [r6, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1ab1c:	6033      	str	r3, [r6, #0]
			nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STARTRX);
		}
	}

	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   1ab1e:	687b      	ldr	r3, [r7, #4]
   1ab20:	f013 0f02 	tst.w	r3, #2
   1ab24:	d103      	bne.n	1ab2e <uarte_instance_init+0x86>
    p_reg->INTENSET = mask;
   1ab26:	f44f 7380 	mov.w	r3, #256	; 0x100
   1ab2a:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
		nrf_uarte_int_enable(uarte, NRF_UARTE_INT_ENDTX_MASK);
	}

	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   1ab2e:	687b      	ldr	r3, [r7, #4]
   1ab30:	f013 0f10 	tst.w	r3, #16
   1ab34:	d003      	beq.n	1ab3e <uarte_instance_init+0x96>
   1ab36:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   1ab3a:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304

	/* Set TXSTOPPED event by requesting fake (zero-length) transfer.
	 * Pointer to RAM variable (data->tx_buffer) is set because otherwise
	 * such operation may result in HardFault or RAM corruption.
	 */
	nrf_uarte_tx_buffer_set(uarte, data->char_out, 0);
   1ab3e:	f8d8 3010 	ldr.w	r3, [r8, #16]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1ab42:	f8c6 3544 	str.w	r3, [r6, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1ab46:	2300      	movs	r3, #0
   1ab48:	f8c6 3548 	str.w	r3, [r6, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1ab4c:	2301      	movs	r3, #1
   1ab4e:	60b3      	str	r3, [r6, #8]
   1ab50:	60f3      	str	r3, [r6, #12]

	/* switch off transmitter to save an energy */
	nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);

	return 0;
}
   1ab52:	4620      	mov	r0, r4
   1ab54:	b003      	add	sp, #12
   1ab56:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = endtx_stoptx_ppi_init(uarte, data);
   1ab5a:	4641      	mov	r1, r8
   1ab5c:	4630      	mov	r0, r6
   1ab5e:	f7f4 fd93 	bl	f688 <endtx_stoptx_ppi_init>
		if (err < 0) {
   1ab62:	2800      	cmp	r0, #0
   1ab64:	daca      	bge.n	1aafc <uarte_instance_init+0x54>
			return err;
   1ab66:	4604      	mov	r4, r0
   1ab68:	e7f3      	b.n	1ab52 <uarte_instance_init+0xaa>

0001ab6a <uarte_0_init>:
		(__attribute__((__section__(LINKER_DT_NODE_REGION_NAME(	       \
			DT_PHANDLE(UARTE(idx), memory_regions)))))),	       \
		())

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   1ab6a:	b510      	push	{r4, lr}
   1ab6c:	4604      	mov	r4, r0
   1ab6e:	2200      	movs	r2, #0
   1ab70:	2101      	movs	r1, #1
   1ab72:	2008      	movs	r0, #8
   1ab74:	f7e9 fa76 	bl	4064 <z_arm_irq_priority_set>
   1ab78:	2008      	movs	r0, #8
   1ab7a:	f7e9 fa43 	bl	4004 <arch_irq_enable>
   1ab7e:	2100      	movs	r1, #0
   1ab80:	4620      	mov	r0, r4
   1ab82:	f7ff ff91 	bl	1aaa8 <uarte_instance_init>
   1ab86:	bd10      	pop	{r4, pc}

0001ab88 <is_hci_event_discardable>:
	uint8_t evt_type = evt_data[0];
   1ab88:	7803      	ldrb	r3, [r0, #0]
	switch (evt_type) {
   1ab8a:	2b3e      	cmp	r3, #62	; 0x3e
   1ab8c:	d001      	beq.n	1ab92 <is_hci_event_discardable+0xa>
		return false;
   1ab8e:	2000      	movs	r0, #0
   1ab90:	4770      	bx	lr
		uint8_t subevt_type = evt_data[sizeof(struct bt_hci_evt_hdr)];
   1ab92:	7883      	ldrb	r3, [r0, #2]
		switch (subevt_type) {
   1ab94:	2b02      	cmp	r3, #2
   1ab96:	d001      	beq.n	1ab9c <is_hci_event_discardable+0x14>
			return false;
   1ab98:	2000      	movs	r0, #0
}
   1ab9a:	4770      	bx	lr
			return true;
   1ab9c:	2001      	movs	r0, #1
   1ab9e:	4770      	bx	lr

0001aba0 <hci_ept_recv>:
{
   1aba0:	b508      	push	{r3, lr}
	bt_rpmsg_rx(data, len);
   1aba2:	f7f5 fa75 	bl	10090 <bt_rpmsg_rx>
}
   1aba6:	bd08      	pop	{r3, pc}

0001aba8 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   1aba8:	4770      	bx	lr

0001abaa <counter_sub>:
	return (a - b) & COUNTER_MAX;
   1abaa:	1a40      	subs	r0, r0, r1
}
   1abac:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   1abb0:	4770      	bx	lr

0001abb2 <event_clear>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   1abb2:	f100 0350 	add.w	r3, r0, #80	; 0x50
   1abb6:	009b      	lsls	r3, r3, #2
   1abb8:	b29b      	uxth	r3, r3
   1abba:	f103 2350 	add.w	r3, r3, #1342197760	; 0x50005000
   1abbe:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   1abc2:	2200      	movs	r2, #0
   1abc4:	601a      	str	r2, [r3, #0]
   1abc6:	681b      	ldr	r3, [r3, #0]
}
   1abc8:	4770      	bx	lr

0001abca <absolute_time_to_cc>:
}
   1abca:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   1abce:	4770      	bx	lr

0001abd0 <full_int_lock>:
	__asm__ volatile(
   1abd0:	f04f 0320 	mov.w	r3, #32
   1abd4:	f3ef 8011 	mrs	r0, BASEPRI
   1abd8:	f383 8812 	msr	BASEPRI_MAX, r3
   1abdc:	f3bf 8f6f 	isb	sy
}
   1abe0:	4770      	bx	lr

0001abe2 <full_int_unlock>:
	__asm__ volatile(
   1abe2:	f380 8811 	msr	BASEPRI, r0
   1abe6:	f3bf 8f6f 	isb	sy
}
   1abea:	4770      	bx	lr

0001abec <set_absolute_alarm>:
{
   1abec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1abee:	4606      	mov	r6, r0
	uint32_t cc_val = abs_val & COUNTER_MAX;
   1abf0:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	uint32_t prev_cc = get_comparator(chan);
   1abf4:	f7f5 fab0 	bl	10158 <get_comparator>
   1abf8:	4607      	mov	r7, r0
   1abfa:	e019      	b.n	1ac30 <set_absolute_alarm+0x44>
	z_impl_k_busy_wait(usec_to_wait);
   1abfc:	2013      	movs	r0, #19
   1abfe:	f001 fe86 	bl	1c90e <z_impl_k_busy_wait>
}
   1ac02:	e022      	b.n	1ac4a <set_absolute_alarm+0x5e>
		event_clear(chan);
   1ac04:	4630      	mov	r0, r6
   1ac06:	f7ff ffd4 	bl	1abb2 <event_clear>
		event_enable(chan);
   1ac0a:	4630      	mov	r0, r6
   1ac0c:	f7f5 faac 	bl	10168 <event_enable>
		set_comparator(chan, cc_val);
   1ac10:	4629      	mov	r1, r5
   1ac12:	4630      	mov	r0, r6
   1ac14:	f7f5 fa96 	bl	10144 <set_comparator>
		now2 = counter();
   1ac18:	f7f5 faba 	bl	10190 <counter>
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   1ac1c:	4284      	cmp	r4, r0
   1ac1e:	d01e      	beq.n	1ac5e <set_absolute_alarm+0x72>
   1ac20:	1c81      	adds	r1, r0, #2
   1ac22:	4628      	mov	r0, r5
   1ac24:	f7ff ffc1 	bl	1abaa <counter_sub>
	} while ((now2 != now) &&
   1ac28:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   1ac2c:	d917      	bls.n	1ac5e <set_absolute_alarm+0x72>
		prev_cc = cc_val;
   1ac2e:	462f      	mov	r7, r5
		now = counter();
   1ac30:	f7f5 faae 	bl	10190 <counter>
   1ac34:	4604      	mov	r4, r0
		set_comparator(chan, now);
   1ac36:	4601      	mov	r1, r0
   1ac38:	4630      	mov	r0, r6
   1ac3a:	f7f5 fa83 	bl	10144 <set_comparator>
		if (counter_sub(prev_cc, now) == 1) {
   1ac3e:	4621      	mov	r1, r4
   1ac40:	4638      	mov	r0, r7
   1ac42:	f7ff ffb2 	bl	1abaa <counter_sub>
   1ac46:	2801      	cmp	r0, #1
   1ac48:	d0d8      	beq.n	1abfc <set_absolute_alarm+0x10>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   1ac4a:	1ca7      	adds	r7, r4, #2
   1ac4c:	4639      	mov	r1, r7
   1ac4e:	4628      	mov	r0, r5
   1ac50:	f7ff ffab 	bl	1abaa <counter_sub>
   1ac54:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   1ac58:	d9d4      	bls.n	1ac04 <set_absolute_alarm+0x18>
			cc_val = now + 2;
   1ac5a:	463d      	mov	r5, r7
   1ac5c:	e7d2      	b.n	1ac04 <set_absolute_alarm+0x18>
}
   1ac5e:	4628      	mov	r0, r5
   1ac60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001ac62 <z_nrf_rtc_timer_capture_task_address_get>:
	if (chan == 0) {
   1ac62:	b138      	cbz	r0, 1ac74 <z_nrf_rtc_timer_capture_task_address_get+0x12>
	nrf_rtc_task_t task = offsetof(NRF_RTC_Type, TASKS_CAPTURE[chan]);
   1ac64:	3010      	adds	r0, #16
   1ac66:	0080      	lsls	r0, r0, #2
   1ac68:	b2c0      	uxtb	r0, r0
    return (uint32_t)p_reg + task;
   1ac6a:	f100 2050 	add.w	r0, r0, #1342197760	; 0x50005000
   1ac6e:	f500 3080 	add.w	r0, r0, #65536	; 0x10000
	return nrf_rtc_task_address_get(RTC, task);
   1ac72:	4770      	bx	lr
		return 0;
   1ac74:	2000      	movs	r0, #0
}
   1ac76:	4770      	bx	lr

0001ac78 <compare_set>:
{
   1ac78:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ac7a:	b083      	sub	sp, #12
   1ac7c:	4604      	mov	r4, r0
   1ac7e:	4617      	mov	r7, r2
   1ac80:	461d      	mov	r5, r3
	key = compare_int_lock(chan);
   1ac82:	f7f5 fa8b 	bl	1019c <compare_int_lock>
   1ac86:	4606      	mov	r6, r0
	int ret = compare_set_nolocks(chan, target_time, handler, user_data);
   1ac88:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1ac8a:	9301      	str	r3, [sp, #4]
   1ac8c:	9b08      	ldr	r3, [sp, #32]
   1ac8e:	9300      	str	r3, [sp, #0]
   1ac90:	463a      	mov	r2, r7
   1ac92:	462b      	mov	r3, r5
   1ac94:	4620      	mov	r0, r4
   1ac96:	f7f5 fb71 	bl	1037c <compare_set_nolocks>
   1ac9a:	4605      	mov	r5, r0
	compare_int_unlock(chan, key);
   1ac9c:	4631      	mov	r1, r6
   1ac9e:	4620      	mov	r0, r4
   1aca0:	f7f5 fad6 	bl	10250 <compare_int_unlock>
}
   1aca4:	4628      	mov	r0, r5
   1aca6:	b003      	add	sp, #12
   1aca8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001acaa <z_nrf_rtc_timer_set>:
{
   1acaa:	b500      	push	{lr}
   1acac:	b083      	sub	sp, #12
	return compare_set(chan, target_time, handler, user_data);
   1acae:	9905      	ldr	r1, [sp, #20]
   1acb0:	9101      	str	r1, [sp, #4]
   1acb2:	9904      	ldr	r1, [sp, #16]
   1acb4:	9100      	str	r1, [sp, #0]
   1acb6:	f7ff ffdf 	bl	1ac78 <compare_set>
}
   1acba:	b003      	add	sp, #12
   1acbc:	f85d fb04 	ldr.w	pc, [sp], #4

0001acc0 <sys_clock_cycle_get_32>:
{
   1acc0:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   1acc2:	f7f5 fb3b 	bl	1033c <z_nrf_rtc_timer_read>
}
   1acc6:	bd08      	pop	{r3, pc}

0001acc8 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
   1acc8:	b410      	push	{r4}
	*state = &config->states[0];
   1acca:	6843      	ldr	r3, [r0, #4]
   1accc:	6013      	str	r3, [r2, #0]
	while (*state <= &config->states[config->state_cnt - 1U]) {
   1acce:	e001      	b.n	1acd4 <pinctrl_lookup_state+0xc>
		if (id == (*state)->id) {
			return 0;
		}

		(*state)++;
   1acd0:	3408      	adds	r4, #8
   1acd2:	6014      	str	r4, [r2, #0]
	while (*state <= &config->states[config->state_cnt - 1U]) {
   1acd4:	6814      	ldr	r4, [r2, #0]
   1acd6:	7a03      	ldrb	r3, [r0, #8]
   1acd8:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   1acdc:	3b01      	subs	r3, #1
   1acde:	f8d0 c004 	ldr.w	ip, [r0, #4]
   1ace2:	eb0c 03c3 	add.w	r3, ip, r3, lsl #3
   1ace6:	429c      	cmp	r4, r3
   1ace8:	d804      	bhi.n	1acf4 <pinctrl_lookup_state+0x2c>
		if (id == (*state)->id) {
   1acea:	7963      	ldrb	r3, [r4, #5]
   1acec:	428b      	cmp	r3, r1
   1acee:	d1ef      	bne.n	1acd0 <pinctrl_lookup_state+0x8>
			return 0;
   1acf0:	2000      	movs	r0, #0
   1acf2:	e001      	b.n	1acf8 <pinctrl_lookup_state+0x30>
	}

	return -ENOENT;
   1acf4:	f06f 0001 	mvn.w	r0, #1
}
   1acf8:	bc10      	pop	{r4}
   1acfa:	4770      	bx	lr

0001acfc <mbox_nrf_register_callback>:
	struct mbox_nrf_data *data = dev->data;
   1acfc:	6900      	ldr	r0, [r0, #16]
	if (channel >= IPC_CONF_NUM) {
   1acfe:	290f      	cmp	r1, #15
   1ad00:	d806      	bhi.n	1ad10 <mbox_nrf_register_callback+0x14>
	data->cb[channel] = cb;
   1ad02:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
	data->user_data[channel] = user_data;
   1ad06:	3110      	adds	r1, #16
   1ad08:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
	return 0;
   1ad0c:	2000      	movs	r0, #0
   1ad0e:	4770      	bx	lr
		return -EINVAL;
   1ad10:	f06f 0015 	mvn.w	r0, #21
}
   1ad14:	4770      	bx	lr

0001ad16 <mbox_nrf_mtu_get>:
}
   1ad16:	2000      	movs	r0, #0
   1ad18:	4770      	bx	lr

0001ad1a <mbox_nrf_max_channels_get>:
}
   1ad1a:	2010      	movs	r0, #16
   1ad1c:	4770      	bx	lr

0001ad1e <hw_cc3xx_init_internal>:
#include <nrf_cc3xx_platform.h>

#if CONFIG_HW_CC3XX

static int hw_cc3xx_init_internal(const struct device *dev)
{
   1ad1e:	b508      	push	{r3, lr}

	/* Initialize the cc3xx HW with or without RNG support */
#if CONFIG_ENTROPY_CC3XX
	res = nrf_cc3xx_platform_init();
#else
	res = nrf_cc3xx_platform_init_no_rng();
   1ad20:	f7fa faba 	bl	15298 <nrf_cc3xx_platform_init_no_rng>
#endif

	return res;
}
   1ad24:	bd08      	pop	{r3, pc}

0001ad26 <hw_cc3xx_init>:

static int hw_cc3xx_init(const struct device *dev)
{
   1ad26:	b510      	push	{r4, lr}
   1ad28:	4604      	mov	r4, r0
	int res;

	/* Set the RTOS abort APIs */
	nrf_cc3xx_platform_abort_init();
   1ad2a:	f7e8 ff45 	bl	3bb8 <nrf_cc3xx_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc3xx_platform_mutex_init();
   1ad2e:	f7e9 f815 	bl	3d5c <nrf_cc3xx_platform_mutex_init>

	/* Enable the hardware */
	res = hw_cc3xx_init_internal(dev);
   1ad32:	4620      	mov	r0, r4
   1ad34:	f7ff fff3 	bl	1ad1e <hw_cc3xx_init_internal>
	return res;
}
   1ad38:	bd10      	pop	{r4, pc}

0001ad3a <nrf53_errata_42>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1ad3a:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1ad3e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1ad42:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
   1ad46:	2a07      	cmp	r2, #7
   1ad48:	d001      	beq.n	1ad4e <nrf53_errata_42+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
   1ad4a:	2000      	movs	r0, #0
   1ad4c:	4770      	bx	lr
                    switch(var2)
   1ad4e:	3b02      	subs	r3, #2
   1ad50:	2b00      	cmp	r3, #0
   1ad52:	d804      	bhi.n	1ad5e <nrf53_errata_42+0x24>
   1ad54:	e8df f003 	tbb	[pc, r3]
   1ad58:	01          	.byte	0x01
   1ad59:	00          	.byte	0x00
   1ad5a:	2001      	movs	r0, #1
   1ad5c:	4770      	bx	lr
                            return false;
   1ad5e:	2000      	movs	r0, #0
    #endif
}
   1ad60:	4770      	bx	lr

0001ad62 <nrf53_errata_46>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1ad62:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1ad66:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1ad6a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
   1ad6e:	2a07      	cmp	r2, #7
   1ad70:	d001      	beq.n	1ad76 <nrf53_errata_46+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
   1ad72:	2000      	movs	r0, #0
   1ad74:	4770      	bx	lr
                    switch(var2)
   1ad76:	2b04      	cmp	r3, #4
   1ad78:	d007      	beq.n	1ad8a <nrf53_errata_46+0x28>
   1ad7a:	d808      	bhi.n	1ad8e <nrf53_errata_46+0x2c>
   1ad7c:	3b02      	subs	r3, #2
   1ad7e:	2b01      	cmp	r3, #1
   1ad80:	d801      	bhi.n	1ad86 <nrf53_errata_46+0x24>
   1ad82:	2001      	movs	r0, #1
    #endif
}
   1ad84:	4770      	bx	lr
                            return false;
   1ad86:	2000      	movs	r0, #0
   1ad88:	4770      	bx	lr
                            return false;
   1ad8a:	2000      	movs	r0, #0
   1ad8c:	4770      	bx	lr
                            return false;
   1ad8e:	2000      	movs	r0, #0
   1ad90:	4770      	bx	lr

0001ad92 <nrf53_errata_49>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1ad92:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1ad96:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1ad9a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
   1ad9e:	2a07      	cmp	r2, #7
   1ada0:	d001      	beq.n	1ada6 <nrf53_errata_49+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
   1ada2:	2000      	movs	r0, #0
   1ada4:	4770      	bx	lr
                    switch(var2)
   1ada6:	3b02      	subs	r3, #2
   1ada8:	2b00      	cmp	r3, #0
   1adaa:	d804      	bhi.n	1adb6 <nrf53_errata_49+0x24>
   1adac:	e8df f003 	tbb	[pc, r3]
   1adb0:	01          	.byte	0x01
   1adb1:	00          	.byte	0x00
   1adb2:	2001      	movs	r0, #1
   1adb4:	4770      	bx	lr
                            return false;
   1adb6:	2000      	movs	r0, #0
    #endif
}
   1adb8:	4770      	bx	lr

0001adba <nrf53_errata_55>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1adba:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1adbe:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1adc2:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
   1adc6:	2a07      	cmp	r2, #7
   1adc8:	d001      	beq.n	1adce <nrf53_errata_55+0x14>
                            return true;
                    }
                }
            #endif
        #endif
        return false;
   1adca:	2000      	movs	r0, #0
   1adcc:	4770      	bx	lr
                            return true;
   1adce:	2001      	movs	r0, #1
    #endif
}
   1add0:	4770      	bx	lr

0001add2 <nrf53_errata_64>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1add2:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1add6:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1adda:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
   1adde:	2a07      	cmp	r2, #7
   1ade0:	d001      	beq.n	1ade6 <nrf53_errata_64+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
   1ade2:	2000      	movs	r0, #0
   1ade4:	4770      	bx	lr
                    switch(var2)
   1ade6:	3b02      	subs	r3, #2
   1ade8:	2b00      	cmp	r3, #0
   1adea:	d804      	bhi.n	1adf6 <nrf53_errata_64+0x24>
   1adec:	e8df f003 	tbb	[pc, r3]
   1adf0:	01          	.byte	0x01
   1adf1:	00          	.byte	0x00
   1adf2:	2001      	movs	r0, #1
   1adf4:	4770      	bx	lr
                            return false;
   1adf6:	2000      	movs	r0, #0
    #endif
}
   1adf8:	4770      	bx	lr

0001adfa <nrf53_errata_69>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1adfa:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1adfe:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1ae02:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
   1ae06:	2a07      	cmp	r2, #7
   1ae08:	d001      	beq.n	1ae0e <nrf53_errata_69+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
   1ae0a:	2000      	movs	r0, #0
   1ae0c:	4770      	bx	lr
                    switch(var2)
   1ae0e:	3b02      	subs	r3, #2
   1ae10:	2b00      	cmp	r3, #0
   1ae12:	d804      	bhi.n	1ae1e <nrf53_errata_69+0x24>
   1ae14:	e8df f003 	tbb	[pc, r3]
   1ae18:	01          	.byte	0x01
   1ae19:	00          	.byte	0x00
   1ae1a:	2001      	movs	r0, #1
   1ae1c:	4770      	bx	lr
                            return false;
   1ae1e:	2000      	movs	r0, #0
    #endif
}
   1ae20:	4770      	bx	lr

0001ae22 <nrf53_errata_97>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1ae22:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1ae26:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1ae2a:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
   1ae2e:	2a07      	cmp	r2, #7
   1ae30:	d001      	beq.n	1ae36 <nrf53_errata_97+0x14>
                            return false;
                    }
                }
            #endif
        #endif
        return false;
   1ae32:	2000      	movs	r0, #0
   1ae34:	4770      	bx	lr
                    switch(var2)
   1ae36:	3b02      	subs	r3, #2
   1ae38:	2b00      	cmp	r3, #0
   1ae3a:	d804      	bhi.n	1ae46 <nrf53_errata_97+0x24>
   1ae3c:	e8df f003 	tbb	[pc, r3]
   1ae40:	01          	.byte	0x01
   1ae41:	00          	.byte	0x00
   1ae42:	2001      	movs	r0, #1
   1ae44:	4770      	bx	lr
                            return false;
   1ae46:	2000      	movs	r0, #0
    #endif
}
   1ae48:	4770      	bx	lr

0001ae4a <nrf53_errata_140>:
            #if defined(NRF_APPLICATION)
                #if defined(NRF_TRUSTZONE_NONSECURE)
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_NS + 0x00000134ul));
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
   1ae4a:	f44f 037f 	mov.w	r3, #16711680	; 0xff0000
   1ae4e:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
   1ae52:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                #endif
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
   1ae56:	2a07      	cmp	r2, #7
   1ae58:	d001      	beq.n	1ae5e <nrf53_errata_140+0x14>
                            return true;
                    }
                }
            #endif
        #endif
        return false;
   1ae5a:	2000      	movs	r0, #0
   1ae5c:	4770      	bx	lr
                            return true;
   1ae5e:	2001      	movs	r0, #1
    #endif
}
   1ae60:	4770      	bx	lr

0001ae62 <nrfx_isr>:
#include <nrfx.h>
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
   1ae62:	b508      	push	{r3, lr}
	((nrfx_irq_handler_t)irq_handler)();
   1ae64:	4780      	blx	r0
}
   1ae66:	bd08      	pop	{r3, pc}

0001ae68 <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
   1ae68:	b508      	push	{r3, lr}
	z_impl_k_busy_wait(usec_to_wait);
   1ae6a:	f001 fd50 	bl	1c90e <z_impl_k_busy_wait>
	if (IS_ENABLED(CONFIG_SYS_CLOCK_EXISTS)) {
		k_busy_wait(usec_to_wait);
	} else {
		nrfx_coredep_delay_us(usec_to_wait);
	}
}
   1ae6e:	bd08      	pop	{r3, pc}

0001ae70 <clock_initial_lfclksrc_get>:
}
   1ae70:	2001      	movs	r0, #1
   1ae72:	4770      	bx	lr

0001ae74 <clock_lfclksrc_tweak>:
{
   1ae74:	b538      	push	{r3, r4, r5, lr}
   1ae76:	4604      	mov	r4, r0
    bool is_correct_clk = (*p_lfclksrc == NRFX_CLOCK_CONFIG_LF_SRC);
   1ae78:	7803      	ldrb	r3, [r0, #0]
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   1ae7a:	2b02      	cmp	r3, #2
   1ae7c:	d006      	beq.n	1ae8c <clock_lfclksrc_tweak+0x18>
   1ae7e:	2b01      	cmp	r3, #1
   1ae80:	d000      	beq.n	1ae84 <clock_lfclksrc_tweak+0x10>
   1ae82:	2300      	movs	r3, #0
    if (!is_correct_clk)
   1ae84:	461d      	mov	r5, r3
   1ae86:	b11b      	cbz	r3, 1ae90 <clock_lfclksrc_tweak+0x1c>
}
   1ae88:	4628      	mov	r0, r5
   1ae8a:	bd38      	pop	{r3, r4, r5, pc}
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   1ae8c:	2301      	movs	r3, #1
   1ae8e:	e7f9      	b.n	1ae84 <clock_lfclksrc_tweak+0x10>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   1ae90:	2000      	movs	r0, #0
   1ae92:	f7f6 f911 	bl	110b8 <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
   1ae96:	f7ff ffeb 	bl	1ae70 <clock_initial_lfclksrc_get>
   1ae9a:	7020      	strb	r0, [r4, #0]
   1ae9c:	e7f4      	b.n	1ae88 <clock_lfclksrc_tweak+0x14>

0001ae9e <nrfx_clock_enable>:
{
   1ae9e:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   1aea0:	2005      	movs	r0, #5
   1aea2:	f7e9 f8d1 	bl	4048 <arch_irq_is_enabled>
   1aea6:	b158      	cbz	r0, 1aec0 <nrfx_clock_enable+0x22>
    nrf_clock_lf_src_set(NRF_CLOCK, clock_initial_lfclksrc_get());
   1aea8:	f7ff ffe2 	bl	1ae70 <clock_initial_lfclksrc_get>
    p_reg->LFCLKSRC = (uint32_t)(source);
   1aeac:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1aeb0:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518
    p_reg->HFCLKSRC = (uint32_t)(source);
   1aeb4:	2201      	movs	r2, #1
   1aeb6:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
   1aeba:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
}
   1aebe:	bd08      	pop	{r3, pc}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   1aec0:	2005      	movs	r0, #5
   1aec2:	f7e9 f89f 	bl	4004 <arch_irq_enable>
   1aec6:	e7ef      	b.n	1aea8 <nrfx_clock_enable+0xa>

0001aec8 <nrfx_clock_start>:
    switch (domain)
   1aec8:	2803      	cmp	r0, #3
   1aeca:	d871      	bhi.n	1afb0 <nrfx_clock_start+0xe8>
   1aecc:	e8df f000 	tbb	[pc, r0]
   1aed0:	62544802 	.word	0x62544802
{
   1aed4:	b500      	push	{lr}
   1aed6:	b083      	sub	sp, #12
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1aed8:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
   1aedc:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
   1aee0:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
   1aee4:	f88d 3007 	strb.w	r3, [sp, #7]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1aee8:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
   1aeec:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   1aef0:	d11d      	bne.n	1af2e <nrfx_clock_start+0x66>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
   1aef2:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1aef6:	f8d3 3414 	ldr.w	r3, [r3, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
   1aefa:	f013 0f01 	tst.w	r3, #1
   1aefe:	d11b      	bne.n	1af38 <nrfx_clock_start+0x70>
                    lfclksrc = clock_initial_lfclksrc_get();
   1af00:	f7ff ffb6 	bl	1ae70 <clock_initial_lfclksrc_get>
   1af04:	f88d 0007 	strb.w	r0, [sp, #7]
                nrf_clock_lf_src_set(NRF_CLOCK, lfclksrc);
   1af08:	f89d 2007 	ldrb.w	r2, [sp, #7]
    p_reg->LFCLKSRC = (uint32_t)(source);
   1af0c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1af10:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1af14:	2200      	movs	r2, #0
   1af16:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   1af1a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    p_reg->INTENSET = mask;
   1af1e:	2202      	movs	r2, #2
   1af20:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1af24:	2201      	movs	r2, #1
   1af26:	609a      	str	r2, [r3, #8]
}
   1af28:	b003      	add	sp, #12
   1af2a:	f85d fb04 	ldr.w	pc, [sp], #4
                    (void)clock_lfclksrc_tweak(&lfclksrc);
   1af2e:	f10d 0007 	add.w	r0, sp, #7
   1af32:	f7ff ff9f 	bl	1ae74 <clock_lfclksrc_tweak>
   1af36:	e7e7      	b.n	1af08 <nrfx_clock_start+0x40>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   1af38:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1af3c:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
   1af40:	f003 0303 	and.w	r3, r3, #3
                    lfclksrc = nrf_clock_lf_srccopy_get(NRF_CLOCK);
   1af44:	f88d 3007 	strb.w	r3, [sp, #7]
                    if (clock_lfclksrc_tweak(&lfclksrc))
   1af48:	f10d 0007 	add.w	r0, sp, #7
   1af4c:	f7ff ff92 	bl	1ae74 <clock_lfclksrc_tweak>
   1af50:	2800      	cmp	r0, #0
   1af52:	d0d9      	beq.n	1af08 <nrfx_clock_start+0x40>
    p_reg->INTENSET = mask;
   1af54:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1af58:	2202      	movs	r2, #2
   1af5a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
                        break;
   1af5e:	e7e3      	b.n	1af28 <nrfx_clock_start+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1af60:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1af64:	2200      	movs	r2, #0
   1af66:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   1af6a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   1af6e:	2201      	movs	r2, #1
   1af70:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1af74:	601a      	str	r2, [r3, #0]
}
   1af76:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1af78:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1af7c:	2200      	movs	r2, #0
   1af7e:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   1af82:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENSET = mask;
   1af86:	f44f 7200 	mov.w	r2, #512	; 0x200
   1af8a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1af8e:	2201      	movs	r2, #1
   1af90:	621a      	str	r2, [r3, #32]
}
   1af92:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1af94:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   1af98:	2200      	movs	r2, #0
   1af9a:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   1af9e:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENSET = mask;
   1afa2:	f44f 7280 	mov.w	r2, #256	; 0x100
   1afa6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1afaa:	2201      	movs	r2, #1
   1afac:	619a      	str	r2, [r3, #24]
}
   1afae:	4770      	bx	lr
   1afb0:	4770      	bx	lr

0001afb2 <nrfx_clock_stop>:
{
   1afb2:	b508      	push	{r3, lr}
    clock_stop(domain);
   1afb4:	f7f6 f880 	bl	110b8 <clock_stop>
}
   1afb8:	bd08      	pop	{r3, pc}

0001afba <pin_is_task_output>:
{
   1afba:	b510      	push	{r4, lr}
   1afbc:	4604      	mov	r4, r0
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   1afbe:	f7f6 f9cf 	bl	11360 <pin_is_output>
   1afc2:	b128      	cbz	r0, 1afd0 <pin_is_task_output+0x16>
   1afc4:	4620      	mov	r0, r4
   1afc6:	f7f6 f9b5 	bl	11334 <pin_in_use_by_te>
   1afca:	b118      	cbz	r0, 1afd4 <pin_is_task_output+0x1a>
   1afcc:	2001      	movs	r0, #1
   1afce:	e000      	b.n	1afd2 <pin_is_task_output+0x18>
   1afd0:	2000      	movs	r0, #0
}
   1afd2:	bd10      	pop	{r4, pc}
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   1afd4:	2000      	movs	r0, #0
   1afd6:	e7fc      	b.n	1afd2 <pin_is_task_output+0x18>

0001afd8 <pin_is_input>:
{
   1afd8:	b508      	push	{r3, lr}
    return !pin_is_output(pin);
   1afda:	f7f6 f9c1 	bl	11360 <pin_is_output>
   1afde:	f080 0001 	eor.w	r0, r0, #1
}
   1afe2:	b2c0      	uxtb	r0, r0
   1afe4:	bd08      	pop	{r3, pc}

0001afe6 <gpiote_polarity_to_trigger>:
}
   1afe6:	4770      	bx	lr

0001afe8 <gpiote_trigger_to_polarity>:
}
   1afe8:	4770      	bx	lr

0001afea <is_level>:
}
   1afea:	2803      	cmp	r0, #3
   1afec:	bf94      	ite	ls
   1afee:	2000      	movls	r0, #0
   1aff0:	2001      	movhi	r0, #1
   1aff2:	4770      	bx	lr

0001aff4 <spim_int_enable>:
    if (!enable)
   1aff4:	b919      	cbnz	r1, 1affe <spim_int_enable+0xa>
    p_reg->INTENCLR = mask;
   1aff6:	2340      	movs	r3, #64	; 0x40
   1aff8:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
}
   1affc:	4770      	bx	lr
    p_reg->INTENSET = mask;
   1affe:	2340      	movs	r3, #64	; 0x40
   1b000:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
}
   1b004:	4770      	bx	lr

0001b006 <spim_list_enable_handle>:
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   1b006:	f011 0f01 	tst.w	r1, #1
   1b00a:	d009      	beq.n	1b020 <spim_list_enable_handle+0x1a>
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   1b00c:	2301      	movs	r3, #1
   1b00e:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   1b012:	f011 0f02 	tst.w	r1, #2
   1b016:	d007      	beq.n	1b028 <spim_list_enable_handle+0x22>
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   1b018:	2301      	movs	r3, #1
   1b01a:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
   1b01e:	4770      	bx	lr
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   1b020:	2300      	movs	r3, #0
   1b022:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
}
   1b026:	e7f4      	b.n	1b012 <spim_list_enable_handle+0xc>

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   1b028:	2300      	movs	r3, #0
   1b02a:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
   1b02e:	4770      	bx	lr

0001b030 <spim_abort>:
{
   1b030:	b570      	push	{r4, r5, r6, lr}
   1b032:	4605      	mov	r5, r0
   1b034:	460e      	mov	r6, r1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1b036:	2301      	movs	r3, #1
   1b038:	6143      	str	r3, [r0, #20]
    NRFX_WAIT_FOR(nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED), 100, 1, stopped);
   1b03a:	2464      	movs	r4, #100	; 0x64
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1b03c:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
   1b040:	b923      	cbnz	r3, 1b04c <spim_abort+0x1c>
   1b042:	2001      	movs	r0, #1
   1b044:	f7ff ff10 	bl	1ae68 <nrfx_busy_wait>
   1b048:	3c01      	subs	r4, #1
   1b04a:	d1f7      	bne.n	1b03c <spim_abort+0xc>
    p_cb->transfer_in_progress = false;
   1b04c:	2300      	movs	r3, #0
   1b04e:	7773      	strb	r3, [r6, #29]
}
   1b050:	bd70      	pop	{r4, r5, r6, pc}

0001b052 <finish_transfer>:
{
   1b052:	b510      	push	{r4, lr}
   1b054:	4604      	mov	r4, r0
    set_ss_pin_state(p_cb, false);
   1b056:	2100      	movs	r1, #0
   1b058:	f7f6 fecc 	bl	11df4 <set_ss_pin_state>
    p_cb->transfer_in_progress = false;
   1b05c:	2300      	movs	r3, #0
   1b05e:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   1b060:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   1b062:	4620      	mov	r0, r4
   1b064:	f850 3b08 	ldr.w	r3, [r0], #8
   1b068:	6861      	ldr	r1, [r4, #4]
   1b06a:	4798      	blx	r3
}
   1b06c:	bd10      	pop	{r4, pc}

0001b06e <irq_handler>:
   1b06e:	f8d0 2118 	ldr.w	r2, [r0, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   1b072:	b902      	cbnz	r2, 1b076 <irq_handler+0x8>
   1b074:	4770      	bx	lr
{
   1b076:	b508      	push	{r3, lr}
   1b078:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1b07a:	2200      	movs	r2, #0
   1b07c:	f8c0 2118 	str.w	r2, [r0, #280]	; 0x118
   1b080:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        finish_transfer(p_cb);
   1b084:	4608      	mov	r0, r1
   1b086:	f7ff ffe4 	bl	1b052 <finish_transfer>
}
   1b08a:	bd08      	pop	{r3, pc}

0001b08c <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   1b08c:	7b0b      	ldrb	r3, [r1, #12]
   1b08e:	2b03      	cmp	r3, #3
   1b090:	d839      	bhi.n	1b106 <xfer_completeness_check+0x7a>
   1b092:	e8df f003 	tbb	[pc, r3]
   1b096:	312a      	.short	0x312a
   1b098:	0216      	.short	0x0216
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   1b09a:	688b      	ldr	r3, [r1, #8]
   1b09c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   1b0a0:	d004      	beq.n	1b0ac <xfer_completeness_check+0x20>
}

NRF_STATIC_INLINE size_t nrf_twim_txd_amount_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->TXD.AMOUNT;
   1b0a2:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   1b0a6:	690a      	ldr	r2, [r1, #16]
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   1b0a8:	429a      	cmp	r2, r3
   1b0aa:	d10f      	bne.n	1b0cc <xfer_completeness_check+0x40>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   1b0ac:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   1b0ae:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   1b0b2:	d12a      	bne.n	1b10a <xfer_completeness_check+0x7e>
   1b0b4:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.secondary_length)))
   1b0b8:	694a      	ldr	r2, [r1, #20]
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   1b0ba:	429a      	cmp	r2, r3
   1b0bc:	d106      	bne.n	1b0cc <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   1b0be:	2001      	movs	r0, #1
   1b0c0:	4770      	bx	lr
   1b0c2:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   1b0c6:	690a      	ldr	r2, [r1, #16]
   1b0c8:	429a      	cmp	r2, r3
   1b0ca:	d007      	beq.n	1b0dc <xfer_completeness_check+0x50>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   1b0cc:	2300      	movs	r3, #0
   1b0ce:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   1b0d2:	2206      	movs	r2, #6
   1b0d4:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
}
   1b0d8:	4618      	mov	r0, r3
   1b0da:	4770      	bx	lr
}

NRF_STATIC_INLINE size_t nrf_twim_rxd_amount_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->RXD.AMOUNT;
   1b0dc:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
                (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.secondary_length))
   1b0e0:	694a      	ldr	r2, [r1, #20]
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   1b0e2:	429a      	cmp	r2, r3
   1b0e4:	d1f2      	bne.n	1b0cc <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   1b0e6:	2001      	movs	r0, #1
   1b0e8:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   1b0ea:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   1b0ee:	690a      	ldr	r2, [r1, #16]
   1b0f0:	429a      	cmp	r2, r3
   1b0f2:	d1eb      	bne.n	1b0cc <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   1b0f4:	2001      	movs	r0, #1
   1b0f6:	4770      	bx	lr
    return p_reg->RXD.AMOUNT;
   1b0f8:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   1b0fc:	690a      	ldr	r2, [r1, #16]
   1b0fe:	429a      	cmp	r2, r3
   1b100:	d1e4      	bne.n	1b0cc <xfer_completeness_check+0x40>
    bool transfer_complete = true;
   1b102:	2001      	movs	r0, #1
}
   1b104:	4770      	bx	lr
    switch (p_cb->xfer_desc.type)
   1b106:	2001      	movs	r0, #1
   1b108:	4770      	bx	lr
    bool transfer_complete = true;
   1b10a:	2001      	movs	r0, #1
   1b10c:	4770      	bx	lr

0001b10e <twim_list_enable_handle>:
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   1b10e:	f011 0f01 	tst.w	r1, #1
   1b112:	d009      	beq.n	1b128 <twim_list_enable_handle+0x1a>
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   1b114:	2301      	movs	r3, #1
   1b116:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   1b11a:	f011 0f02 	tst.w	r1, #2
   1b11e:	d007      	beq.n	1b130 <twim_list_enable_handle+0x22>
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   1b120:	2301      	movs	r3, #1
   1b122:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
   1b126:	4770      	bx	lr
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   1b128:	2300      	movs	r3, #0
   1b12a:	f8c0 3550 	str.w	r3, [r0, #1360]	; 0x550
}
   1b12e:	e7f4      	b.n	1b11a <twim_list_enable_handle+0xc>

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   1b130:	2300      	movs	r3, #0
   1b132:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
}
   1b136:	4770      	bx	lr

0001b138 <metal_device_open>:
	if (!bus_name || !strlen(bus_name) ||
   1b138:	b300      	cbz	r0, 1b17c <metal_device_open+0x44>
{
   1b13a:	b570      	push	{r4, r5, r6, lr}
   1b13c:	b082      	sub	sp, #8
   1b13e:	460c      	mov	r4, r1
   1b140:	4615      	mov	r5, r2
   1b142:	4606      	mov	r6, r0
	if (!bus_name || !strlen(bus_name) ||
   1b144:	f7fc fab1 	bl	176aa <strlen>
   1b148:	b190      	cbz	r0, 1b170 <metal_device_open+0x38>
   1b14a:	b18c      	cbz	r4, 1b170 <metal_device_open+0x38>
	    !dev_name || !strlen(dev_name) ||
   1b14c:	4620      	mov	r0, r4
   1b14e:	f7fc faac 	bl	176aa <strlen>
   1b152:	b168      	cbz	r0, 1b170 <metal_device_open+0x38>
   1b154:	b165      	cbz	r5, 1b170 <metal_device_open+0x38>
	error = metal_bus_find(bus_name, &bus);
   1b156:	a901      	add	r1, sp, #4
   1b158:	4630      	mov	r0, r6
   1b15a:	f7f7 fc9f 	bl	12a9c <metal_bus_find>
	if (error)
   1b15e:	b928      	cbnz	r0, 1b16c <metal_device_open+0x34>
	if (!bus->ops.dev_open)
   1b160:	9801      	ldr	r0, [sp, #4]
   1b162:	6883      	ldr	r3, [r0, #8]
   1b164:	b13b      	cbz	r3, 1b176 <metal_device_open+0x3e>
	error = (*bus->ops.dev_open)(bus, dev_name, device);
   1b166:	462a      	mov	r2, r5
   1b168:	4621      	mov	r1, r4
   1b16a:	4798      	blx	r3
}
   1b16c:	b002      	add	sp, #8
   1b16e:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   1b170:	f06f 0015 	mvn.w	r0, #21
   1b174:	e7fa      	b.n	1b16c <metal_device_open+0x34>
		return -ENODEV;
   1b176:	f06f 0012 	mvn.w	r0, #18
   1b17a:	e7f7      	b.n	1b16c <metal_device_open+0x34>
		return -EINVAL;
   1b17c:	f06f 0015 	mvn.w	r0, #21
}
   1b180:	4770      	bx	lr

0001b182 <metal_io_init>:

void metal_io_init(struct metal_io_region *io, void *virt,
	      const metal_phys_addr_t *physmap, size_t size,
	      unsigned int page_shift, unsigned int mem_flags,
	      const struct metal_io_ops *ops)
{
   1b182:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1b186:	b089      	sub	sp, #36	; 0x24
   1b188:	4604      	mov	r4, r0
   1b18a:	4688      	mov	r8, r1
   1b18c:	4617      	mov	r7, r2
   1b18e:	461e      	mov	r6, r3
   1b190:	9d10      	ldr	r5, [sp, #64]	; 0x40
	const struct metal_io_ops nops = {
   1b192:	2220      	movs	r2, #32
   1b194:	2100      	movs	r1, #0
   1b196:	4668      	mov	r0, sp
   1b198:	f7fc faf9 	bl	1778e <memset>
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
	};

	io->virt = virt;
   1b19c:	f8c4 8000 	str.w	r8, [r4]
	io->physmap = physmap;
   1b1a0:	6067      	str	r7, [r4, #4]
	io->size = size;
   1b1a2:	60a6      	str	r6, [r4, #8]
	io->page_shift = page_shift;
   1b1a4:	60e5      	str	r5, [r4, #12]
	if (page_shift >= sizeof(io->page_mask) * CHAR_BIT)
   1b1a6:	2d1f      	cmp	r5, #31
   1b1a8:	d912      	bls.n	1b1d0 <metal_io_init+0x4e>
		/* avoid overflow */
		io->page_mask = -1UL;
   1b1aa:	f04f 33ff 	mov.w	r3, #4294967295
   1b1ae:	6123      	str	r3, [r4, #16]
	else
		io->page_mask = (1UL << page_shift) - 1UL;
	io->mem_flags = mem_flags;
   1b1b0:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1b1b2:	6163      	str	r3, [r4, #20]
	io->ops = ops ? *ops : nops;
   1b1b4:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1b1b6:	b193      	cbz	r3, 1b1de <metal_io_init+0x5c>
   1b1b8:	3418      	adds	r4, #24
   1b1ba:	469c      	mov	ip, r3
   1b1bc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1b1c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1b1c2:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
   1b1c6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	metal_sys_io_mem_map(io);
}
   1b1ca:	b009      	add	sp, #36	; 0x24
   1b1cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		io->page_mask = (1UL << page_shift) - 1UL;
   1b1d0:	2301      	movs	r3, #1
   1b1d2:	fa03 f905 	lsl.w	r9, r3, r5
   1b1d6:	f109 33ff 	add.w	r3, r9, #4294967295
   1b1da:	6123      	str	r3, [r4, #16]
   1b1dc:	e7e8      	b.n	1b1b0 <metal_io_init+0x2e>
	io->ops = ops ? *ops : nops;
   1b1de:	3418      	adds	r4, #24
   1b1e0:	466d      	mov	r5, sp
   1b1e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   1b1e4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1b1e6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1b1ea:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
   1b1ee:	e7ec      	b.n	1b1ca <metal_io_init+0x48>

0001b1f0 <metal_io_block_read>:

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
   1b1f0:	b530      	push	{r4, r5, lr}
   1b1f2:	b083      	sub	sp, #12
	return (io->virt != METAL_BAD_VA && offset < io->size
   1b1f4:	6804      	ldr	r4, [r0, #0]
		: NULL);
   1b1f6:	f1b4 3fff 	cmp.w	r4, #4294967295
   1b1fa:	d032      	beq.n	1b262 <metal_io_block_read+0x72>
	return (io->virt != METAL_BAD_VA && offset < io->size
   1b1fc:	6885      	ldr	r5, [r0, #8]
   1b1fe:	42a9      	cmp	r1, r5
   1b200:	d232      	bcs.n	1b268 <metal_io_block_read+0x78>
	unsigned char *ptr = metal_io_virt(io, offset);
	unsigned char *dest = dst;
	int retlen;

	if (!ptr)
   1b202:	eb11 0c04 	adds.w	ip, r1, r4
   1b206:	d032      	beq.n	1b26e <metal_io_block_read+0x7e>
		return -ERANGE;
	if ((offset + len) > io->size)
   1b208:	185c      	adds	r4, r3, r1
   1b20a:	42ac      	cmp	r4, r5
   1b20c:	d900      	bls.n	1b210 <metal_io_block_read+0x20>
		len = io->size - offset;
   1b20e:	1a6b      	subs	r3, r5, r1
	retlen = len;
	if (io->ops.block_read) {
   1b210:	6a04      	ldr	r4, [r0, #32]
   1b212:	b124      	cbz	r4, 1b21e <metal_io_block_read+0x2e>
		retlen = (*io->ops.block_read)(
   1b214:	9300      	str	r3, [sp, #0]
   1b216:	2305      	movs	r3, #5
   1b218:	47a0      	blx	r4
		for (; len != 0; dest++, ptr++, len--)
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
	}
	return retlen;
}
   1b21a:	b003      	add	sp, #12
   1b21c:	bd30      	pop	{r4, r5, pc}
		atomic_thread_fence(memory_order_seq_cst);
   1b21e:	f3bf 8f5b 	dmb	ish
		while ( len && (
   1b222:	4619      	mov	r1, r3
   1b224:	e004      	b.n	1b230 <metal_io_block_read+0x40>
				*(const unsigned char *)ptr;
   1b226:	f81c 0b01 	ldrb.w	r0, [ip], #1
			*(unsigned char *)dest =
   1b22a:	f802 0b01 	strb.w	r0, [r2], #1
			len--;
   1b22e:	3901      	subs	r1, #1
		while ( len && (
   1b230:	b159      	cbz	r1, 1b24a <metal_io_block_read+0x5a>
   1b232:	f012 0f03 	tst.w	r2, #3
   1b236:	d1f6      	bne.n	1b226 <metal_io_block_read+0x36>
			((uintptr_t)dest % sizeof(int)) ||
   1b238:	f01c 0f03 	tst.w	ip, #3
   1b23c:	d1f3      	bne.n	1b226 <metal_io_block_read+0x36>
   1b23e:	e004      	b.n	1b24a <metal_io_block_read+0x5a>
			*(unsigned int *)dest = *(const unsigned int *)ptr;
   1b240:	f85c 0b04 	ldr.w	r0, [ip], #4
   1b244:	f842 0b04 	str.w	r0, [r2], #4
					len -= sizeof(int))
   1b248:	3904      	subs	r1, #4
		for (; len >= (int)sizeof(int); dest += sizeof(int),
   1b24a:	2903      	cmp	r1, #3
   1b24c:	dcf8      	bgt.n	1b240 <metal_io_block_read+0x50>
   1b24e:	e004      	b.n	1b25a <metal_io_block_read+0x6a>
				*(const unsigned char *)ptr;
   1b250:	f81c 0b01 	ldrb.w	r0, [ip], #1
			*(unsigned char *)dest =
   1b254:	f802 0b01 	strb.w	r0, [r2], #1
		for (; len != 0; dest++, ptr++, len--)
   1b258:	3901      	subs	r1, #1
   1b25a:	2900      	cmp	r1, #0
   1b25c:	d1f8      	bne.n	1b250 <metal_io_block_read+0x60>
	retlen = len;
   1b25e:	4618      	mov	r0, r3
   1b260:	e7db      	b.n	1b21a <metal_io_block_read+0x2a>
		return -ERANGE;
   1b262:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b266:	e7d8      	b.n	1b21a <metal_io_block_read+0x2a>
   1b268:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b26c:	e7d5      	b.n	1b21a <metal_io_block_read+0x2a>
   1b26e:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b272:	e7d2      	b.n	1b21a <metal_io_block_read+0x2a>

0001b274 <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
   1b274:	b530      	push	{r4, r5, lr}
   1b276:	b083      	sub	sp, #12
   1b278:	6804      	ldr	r4, [r0, #0]
		: NULL);
   1b27a:	f1b4 3fff 	cmp.w	r4, #4294967295
   1b27e:	d031      	beq.n	1b2e4 <metal_io_block_write+0x70>
	return (io->virt != METAL_BAD_VA && offset < io->size
   1b280:	6885      	ldr	r5, [r0, #8]
   1b282:	42a9      	cmp	r1, r5
   1b284:	d231      	bcs.n	1b2ea <metal_io_block_write+0x76>
	unsigned char *ptr = metal_io_virt(io, offset);
	const unsigned char *source = src;
	int retlen;

	if (!ptr)
   1b286:	eb11 0c04 	adds.w	ip, r1, r4
   1b28a:	d031      	beq.n	1b2f0 <metal_io_block_write+0x7c>
		return -ERANGE;
	if ((offset + len) > io->size)
   1b28c:	185c      	adds	r4, r3, r1
   1b28e:	42ac      	cmp	r4, r5
   1b290:	d900      	bls.n	1b294 <metal_io_block_write+0x20>
		len = io->size - offset;
   1b292:	1a6b      	subs	r3, r5, r1
	retlen = len;
	if (io->ops.block_write) {
   1b294:	6a44      	ldr	r4, [r0, #36]	; 0x24
   1b296:	b18c      	cbz	r4, 1b2bc <metal_io_block_write+0x48>
		retlen = (*io->ops.block_write)(
   1b298:	9300      	str	r3, [sp, #0]
   1b29a:	2305      	movs	r3, #5
   1b29c:	47a0      	blx	r4
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
		atomic_thread_fence(memory_order_seq_cst);
	}
	return retlen;
}
   1b29e:	b003      	add	sp, #12
   1b2a0:	bd30      	pop	{r4, r5, pc}
				*(const unsigned char *)source;
   1b2a2:	f812 0b01 	ldrb.w	r0, [r2], #1
			*(unsigned char *)ptr =
   1b2a6:	f80c 0b01 	strb.w	r0, [ip], #1
			len--;
   1b2aa:	3901      	subs	r1, #1
		while ( len && (
   1b2ac:	b169      	cbz	r1, 1b2ca <metal_io_block_write+0x56>
   1b2ae:	f01c 0f03 	tst.w	ip, #3
   1b2b2:	d1f6      	bne.n	1b2a2 <metal_io_block_write+0x2e>
			((uintptr_t)ptr % sizeof(int)) ||
   1b2b4:	f012 0f03 	tst.w	r2, #3
   1b2b8:	d1f3      	bne.n	1b2a2 <metal_io_block_write+0x2e>
   1b2ba:	e006      	b.n	1b2ca <metal_io_block_write+0x56>
   1b2bc:	4619      	mov	r1, r3
   1b2be:	e7f5      	b.n	1b2ac <metal_io_block_write+0x38>
			*(unsigned int *)ptr = *(const unsigned int *)source;
   1b2c0:	f852 0b04 	ldr.w	r0, [r2], #4
   1b2c4:	f84c 0b04 	str.w	r0, [ip], #4
					len -= sizeof(int))
   1b2c8:	3904      	subs	r1, #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
   1b2ca:	2903      	cmp	r1, #3
   1b2cc:	dcf8      	bgt.n	1b2c0 <metal_io_block_write+0x4c>
		for (; len != 0; ptr++, source++, len--)
   1b2ce:	b129      	cbz	r1, 1b2dc <metal_io_block_write+0x68>
				*(const unsigned char *)source;
   1b2d0:	f812 0b01 	ldrb.w	r0, [r2], #1
			*(unsigned char *)ptr =
   1b2d4:	f80c 0b01 	strb.w	r0, [ip], #1
		for (; len != 0; ptr++, source++, len--)
   1b2d8:	3901      	subs	r1, #1
   1b2da:	e7f8      	b.n	1b2ce <metal_io_block_write+0x5a>
		atomic_thread_fence(memory_order_seq_cst);
   1b2dc:	f3bf 8f5b 	dmb	ish
	retlen = len;
   1b2e0:	4618      	mov	r0, r3
   1b2e2:	e7dc      	b.n	1b29e <metal_io_block_write+0x2a>
		return -ERANGE;
   1b2e4:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b2e8:	e7d9      	b.n	1b29e <metal_io_block_write+0x2a>
   1b2ea:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b2ee:	e7d6      	b.n	1b29e <metal_io_block_write+0x2a>
   1b2f0:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b2f4:	e7d3      	b.n	1b29e <metal_io_block_write+0x2a>

0001b2f6 <metal_io_block_set>:

int metal_io_block_set(struct metal_io_region *io, unsigned long offset,
	       unsigned char value, int len)
{
   1b2f6:	b530      	push	{r4, r5, lr}
   1b2f8:	b083      	sub	sp, #12
   1b2fa:	6804      	ldr	r4, [r0, #0]
		: NULL);
   1b2fc:	f1b4 3fff 	cmp.w	r4, #4294967295
   1b300:	d034      	beq.n	1b36c <metal_io_block_set+0x76>
   1b302:	461d      	mov	r5, r3
	return (io->virt != METAL_BAD_VA && offset < io->size
   1b304:	6883      	ldr	r3, [r0, #8]
   1b306:	4299      	cmp	r1, r3
   1b308:	d233      	bcs.n	1b372 <metal_io_block_set+0x7c>
	unsigned char *ptr = metal_io_virt(io, offset);
	int retlen = len;

	if (!ptr)
   1b30a:	eb11 0c04 	adds.w	ip, r1, r4
   1b30e:	d033      	beq.n	1b378 <metal_io_block_set+0x82>
		return -ERANGE;
	if ((offset + len) > io->size)
   1b310:	186c      	adds	r4, r5, r1
   1b312:	429c      	cmp	r4, r3
   1b314:	d900      	bls.n	1b318 <metal_io_block_set+0x22>
		len = io->size - offset;
   1b316:	1a5d      	subs	r5, r3, r1
	retlen = len;
	if (io->ops.block_set) {
   1b318:	6a84      	ldr	r4, [r0, #40]	; 0x28
   1b31a:	b12c      	cbz	r4, 1b328 <metal_io_block_set+0x32>
		(*io->ops.block_set)(
   1b31c:	9500      	str	r5, [sp, #0]
   1b31e:	2305      	movs	r3, #5
   1b320:	47a0      	blx	r4
			*(unsigned int *)ptr = cint;
		for (; len != 0; ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		atomic_thread_fence(memory_order_seq_cst);
	}
	return retlen;
   1b322:	4628      	mov	r0, r5
}
   1b324:	b003      	add	sp, #12
   1b326:	bd30      	pop	{r4, r5, pc}
		unsigned int cint = value;
   1b328:	4613      	mov	r3, r2
		for (i = 1; i < sizeof(int); i++)
   1b32a:	2101      	movs	r1, #1
   1b32c:	e004      	b.n	1b338 <metal_io_block_set+0x42>
			cint |= ((unsigned int)value << (CHAR_BIT * i));
   1b32e:	00c8      	lsls	r0, r1, #3
   1b330:	fa02 f000 	lsl.w	r0, r2, r0
   1b334:	4303      	orrs	r3, r0
		for (i = 1; i < sizeof(int); i++)
   1b336:	3101      	adds	r1, #1
   1b338:	2903      	cmp	r1, #3
   1b33a:	d9f8      	bls.n	1b32e <metal_io_block_set+0x38>
   1b33c:	4629      	mov	r1, r5
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
   1b33e:	b149      	cbz	r1, 1b354 <metal_io_block_set+0x5e>
   1b340:	f01c 0f03 	tst.w	ip, #3
   1b344:	d006      	beq.n	1b354 <metal_io_block_set+0x5e>
			*(unsigned char *)ptr = (unsigned char) value;
   1b346:	f80c 2b01 	strb.w	r2, [ip], #1
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
   1b34a:	3901      	subs	r1, #1
   1b34c:	e7f7      	b.n	1b33e <metal_io_block_set+0x48>
			*(unsigned int *)ptr = cint;
   1b34e:	f84c 3b04 	str.w	r3, [ip], #4
						len -= sizeof(int))
   1b352:	3904      	subs	r1, #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
   1b354:	2903      	cmp	r1, #3
   1b356:	dcfa      	bgt.n	1b34e <metal_io_block_set+0x58>
   1b358:	e002      	b.n	1b360 <metal_io_block_set+0x6a>
			*(unsigned char *)ptr = (unsigned char) value;
   1b35a:	f80c 2b01 	strb.w	r2, [ip], #1
		for (; len != 0; ptr++, len--)
   1b35e:	3901      	subs	r1, #1
   1b360:	2900      	cmp	r1, #0
   1b362:	d1fa      	bne.n	1b35a <metal_io_block_set+0x64>
		atomic_thread_fence(memory_order_seq_cst);
   1b364:	f3bf 8f5b 	dmb	ish
	return retlen;
   1b368:	4628      	mov	r0, r5
   1b36a:	e7db      	b.n	1b324 <metal_io_block_set+0x2e>
		return -ERANGE;
   1b36c:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b370:	e7d8      	b.n	1b324 <metal_io_block_set+0x2e>
   1b372:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b376:	e7d5      	b.n	1b324 <metal_io_block_set+0x2e>
   1b378:	f06f 0021 	mvn.w	r0, #33	; 0x21
   1b37c:	e7d2      	b.n	1b324 <metal_io_block_set+0x2e>

0001b37e <metal_generic_dev_sys_open>:

	/* Since Zephyr runs bare-metal there is no mapping that needs to be
	 * done of IO regions
	 */
	return 0;
}
   1b37e:	2000      	movs	r0, #0
   1b380:	4770      	bx	lr

0001b382 <vq_ring_free_chain>:
 *
 * vq_ring_free_chain
 *
 */
static void vq_ring_free_chain(struct virtqueue *vq, uint16_t desc_idx)
{
   1b382:	b510      	push	{r4, lr}
	struct vring_desc *dp;
	struct vq_desc_extra *dxp;

	/* CACHE: desc is never written by slave, no need to invalidate */
	VQ_RING_ASSERT_VALID_IDX(vq, desc_idx);
	dp = &vq->vq_ring.desc[desc_idx];
   1b384:	6984      	ldr	r4, [r0, #24]
   1b386:	eb04 1301 	add.w	r3, r4, r1, lsl #4
	dxp = &vq->vq_descx[desc_idx];

	if (vq->vq_free_cnt == 0) {
   1b38a:	f8b0 e024 	ldrh.w	lr, [r0, #36]	; 0x24
		VQ_RING_ASSERT_CHAIN_TERM(vq);
	}

	vq->vq_free_cnt += dxp->ndescs;
   1b38e:	1d8a      	adds	r2, r1, #6
   1b390:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
   1b394:	f8b2 c008 	ldrh.w	ip, [r2, #8]
   1b398:	44e6      	add	lr, ip
   1b39a:	f8a0 e024 	strh.w	lr, [r0, #36]	; 0x24
	dxp->ndescs--;
   1b39e:	f10c 3cff 	add.w	ip, ip, #4294967295
   1b3a2:	f8a2 c008 	strh.w	ip, [r2, #8]

	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
   1b3a6:	899a      	ldrh	r2, [r3, #12]
   1b3a8:	f012 0f04 	tst.w	r2, #4
   1b3ac:	d00f      	beq.n	1b3ce <vq_ring_free_chain+0x4c>
	 * newly freed chain. If the virtqueue was completely used, then
	 * head would be VQ_RING_DESC_CHAIN_END (ASSERTed above).
	 *
	 * CACHE: desc.next is never read by slave, no need to flush it.
	 */
	dp->next = vq->vq_desc_head_idx;
   1b3ae:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
   1b3b0:	81da      	strh	r2, [r3, #14]
	vq->vq_desc_head_idx = desc_idx;
   1b3b2:	8581      	strh	r1, [r0, #44]	; 0x2c
}
   1b3b4:	bd10      	pop	{r4, pc}
			dp = &vq->vq_ring.desc[dp->next];
   1b3b6:	89db      	ldrh	r3, [r3, #14]
   1b3b8:	eb04 1303 	add.w	r3, r4, r3, lsl #4
			dxp->ndescs--;
   1b3bc:	1d8a      	adds	r2, r1, #6
   1b3be:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
   1b3c2:	f8b2 c008 	ldrh.w	ip, [r2, #8]
   1b3c6:	f10c 3cff 	add.w	ip, ip, #4294967295
   1b3ca:	f8a2 c008 	strh.w	ip, [r2, #8]
		while (dp->flags & VRING_DESC_F_NEXT) {
   1b3ce:	899a      	ldrh	r2, [r3, #12]
   1b3d0:	f012 0f01 	tst.w	r2, #1
   1b3d4:	d1ef      	bne.n	1b3b6 <vq_ring_free_chain+0x34>
   1b3d6:	e7ea      	b.n	1b3ae <vq_ring_free_chain+0x2c>

0001b3d8 <vq_ring_init>:
 *
 * vq_ring_init
 *
 */
static void vq_ring_init(struct virtqueue *vq, void *ring_mem, int alignment)
{
   1b3d8:	b410      	push	{r4}
	struct vring *vr;
	int size;

	size = vq->vq_nentries;
   1b3da:	8944      	ldrh	r4, [r0, #10]
}

static inline void
vring_init(struct vring *vr, unsigned int num, uint8_t *p, unsigned long align)
{
	vr->num = num;
   1b3dc:	6144      	str	r4, [r0, #20]
	vr->desc = (struct vring_desc *)p;
   1b3de:	6181      	str	r1, [r0, #24]
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
   1b3e0:	eb01 1104 	add.w	r1, r1, r4, lsl #4
   1b3e4:	61c1      	str	r1, [r0, #28]
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
   1b3e6:	eb01 0144 	add.w	r1, r1, r4, lsl #1
   1b3ea:	1d0b      	adds	r3, r1, #4
   1b3ec:	4413      	add	r3, r2
	      align - 1) & ~(align - 1));
   1b3ee:	3301      	adds	r3, #1
   1b3f0:	4252      	negs	r2, r2
   1b3f2:	4013      	ands	r3, r2
	vr->used = (struct vring_used *)
   1b3f4:	6203      	str	r3, [r0, #32]
	vr = &vq->vq_ring;

	vring_init(vr, size, ring_mem, alignment);

#ifndef VIRTIO_DEVICE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_DRIVER) {
   1b3f6:	6803      	ldr	r3, [r0, #0]
   1b3f8:	699b      	ldr	r3, [r3, #24]
   1b3fa:	b19b      	cbz	r3, 1b424 <vq_ring_init+0x4c>
		for (i = 0; i < size - 1; i++)
			vr->desc[i].next = i + 1;
		vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
	}
#endif /*VIRTIO_DEVICE_ONLY*/
}
   1b3fc:	bc10      	pop	{r4}
   1b3fe:	4770      	bx	lr
			vr->desc[i].next = i + 1;
   1b400:	6982      	ldr	r2, [r0, #24]
   1b402:	eb02 1203 	add.w	r2, r2, r3, lsl #4
   1b406:	1c59      	adds	r1, r3, #1
   1b408:	81d1      	strh	r1, [r2, #14]
		for (i = 0; i < size - 1; i++)
   1b40a:	460b      	mov	r3, r1
   1b40c:	1e62      	subs	r2, r4, #1
   1b40e:	429a      	cmp	r2, r3
   1b410:	dcf6      	bgt.n	1b400 <vq_ring_init+0x28>
		vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
   1b412:	6982      	ldr	r2, [r0, #24]
   1b414:	eb02 1303 	add.w	r3, r2, r3, lsl #4
   1b418:	2200      	movs	r2, #0
   1b41a:	739a      	strb	r2, [r3, #14]
   1b41c:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   1b420:	73da      	strb	r2, [r3, #15]
}
   1b422:	e7eb      	b.n	1b3fc <vq_ring_init+0x24>
		for (i = 0; i < size - 1; i++)
   1b424:	2300      	movs	r3, #0
   1b426:	e7f1      	b.n	1b40c <vq_ring_init+0x34>

0001b428 <vq_ring_must_notify>:
 */
static int vq_ring_must_notify(struct virtqueue *vq)
{
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
   1b428:	6803      	ldr	r3, [r0, #0]
   1b42a:	691a      	ldr	r2, [r3, #16]
   1b42c:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
   1b430:	d027      	beq.n	1b482 <vq_ring_must_notify+0x5a>
#ifndef VIRTIO_DEVICE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_DRIVER) {
   1b432:	699b      	ldr	r3, [r3, #24]
   1b434:	b11b      	cbz	r3, 1b43e <vq_ring_must_notify+0x16>
			return vring_need_event(event_idx, new_idx,
						prev_idx) != 0;
		}
#endif /*VIRTIO_DEVICE_ONLY*/
#ifndef VIRTIO_DRIVER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
   1b436:	2b01      	cmp	r3, #1
   1b438:	d012      	beq.n	1b460 <vq_ring_must_notify+0x38>
				VRING_AVAIL_F_NO_INTERRUPT) == 0;
		}
#endif /*VIRTIO_DRIVER_ONLY*/
	}

	return 0;
   1b43a:	2000      	movs	r0, #0
   1b43c:	4770      	bx	lr
			new_idx = vq->vq_ring.avail->idx;
   1b43e:	69c3      	ldr	r3, [r0, #28]
   1b440:	885a      	ldrh	r2, [r3, #2]
			prev_idx = new_idx - vq->vq_queued_cnt;
   1b442:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
			event_idx = vring_avail_event(&vq->vq_ring);
   1b444:	6a01      	ldr	r1, [r0, #32]
   1b446:	6940      	ldr	r0, [r0, #20]
   1b448:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
   1b44c:	8888      	ldrh	r0, [r1, #4]
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
	return (uint16_t)(new_idx - event_idx - 1) <
   1b44e:	1a10      	subs	r0, r2, r0
   1b450:	b280      	uxth	r0, r0
   1b452:	3801      	subs	r0, #1
   1b454:	b280      	uxth	r0, r0
   1b456:	4283      	cmp	r3, r0
   1b458:	bf94      	ite	ls
   1b45a:	2000      	movls	r0, #0
   1b45c:	2001      	movhi	r0, #1
						prev_idx) != 0;
   1b45e:	4770      	bx	lr
			new_idx = vq->vq_ring.used->idx;
   1b460:	6a03      	ldr	r3, [r0, #32]
   1b462:	885a      	ldrh	r2, [r3, #2]
			prev_idx = new_idx - vq->vq_queued_cnt;
   1b464:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
			event_idx = vring_used_event(&vq->vq_ring);
   1b466:	69c1      	ldr	r1, [r0, #28]
   1b468:	6940      	ldr	r0, [r0, #20]
   1b46a:	eb01 0140 	add.w	r1, r1, r0, lsl #1
   1b46e:	8888      	ldrh	r0, [r1, #4]
   1b470:	1a10      	subs	r0, r2, r0
   1b472:	b280      	uxth	r0, r0
   1b474:	3801      	subs	r0, #1
   1b476:	b280      	uxth	r0, r0
   1b478:	4283      	cmp	r3, r0
   1b47a:	bf94      	ite	ls
   1b47c:	2000      	movls	r0, #0
   1b47e:	2001      	movhi	r0, #1
						prev_idx) != 0;
   1b480:	4770      	bx	lr
		if (vq->vq_dev->role == VIRTIO_DEV_DRIVER) {
   1b482:	699b      	ldr	r3, [r3, #24]
   1b484:	b11b      	cbz	r3, 1b48e <vq_ring_must_notify+0x66>
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
   1b486:	2b01      	cmp	r3, #1
   1b488:	d008      	beq.n	1b49c <vq_ring_must_notify+0x74>
	return 0;
   1b48a:	2000      	movs	r0, #0
}
   1b48c:	4770      	bx	lr
			return (vq->vq_ring.used->flags &
   1b48e:	6a03      	ldr	r3, [r0, #32]
   1b490:	8818      	ldrh	r0, [r3, #0]
				VRING_USED_F_NO_NOTIFY) == 0;
   1b492:	f080 0001 	eor.w	r0, r0, #1
   1b496:	f000 0001 	and.w	r0, r0, #1
   1b49a:	4770      	bx	lr
			return (vq->vq_ring.avail->flags &
   1b49c:	69c3      	ldr	r3, [r0, #28]
   1b49e:	8818      	ldrh	r0, [r3, #0]
				VRING_AVAIL_F_NO_INTERRUPT) == 0;
   1b4a0:	f080 0001 	eor.w	r0, r0, #1
   1b4a4:	f000 0001 	and.w	r0, r0, #1
   1b4a8:	4770      	bx	lr

0001b4aa <vq_ring_notify>:
 *
 * vq_ring_notify
 *
 */
static void vq_ring_notify(struct virtqueue *vq)
{
   1b4aa:	b508      	push	{r3, lr}
	if (vq->notify)
   1b4ac:	6903      	ldr	r3, [r0, #16]
   1b4ae:	b103      	cbz	r3, 1b4b2 <vq_ring_notify+0x8>
		vq->notify(vq);
   1b4b0:	4798      	blx	r3
}
   1b4b2:	bd08      	pop	{r3, pc}

0001b4b4 <vq_ring_update_avail>:
{
   1b4b4:	b410      	push	{r4}
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
   1b4b6:	69c4      	ldr	r4, [r0, #28]
   1b4b8:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
   1b4bc:	8942      	ldrh	r2, [r0, #10]
   1b4be:	3a01      	subs	r2, #1
   1b4c0:	b212      	sxth	r2, r2
   1b4c2:	4013      	ands	r3, r2
   1b4c4:	b29b      	uxth	r3, r3
	vq->vq_ring.avail->ring[avail_idx] = desc_idx;
   1b4c6:	eb04 0343 	add.w	r3, r4, r3, lsl #1
   1b4ca:	8099      	strh	r1, [r3, #4]
	atomic_thread_fence(memory_order_seq_cst);
   1b4cc:	f3bf 8f5b 	dmb	ish
	vq->vq_ring.avail->idx++;
   1b4d0:	69c2      	ldr	r2, [r0, #28]
   1b4d2:	8853      	ldrh	r3, [r2, #2]
   1b4d4:	3301      	adds	r3, #1
   1b4d6:	8053      	strh	r3, [r2, #2]
	vq->vq_queued_cnt++;
   1b4d8:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
   1b4da:	3301      	adds	r3, #1
   1b4dc:	84c3      	strh	r3, [r0, #38]	; 0x26
}
   1b4de:	bc10      	pop	{r4}
   1b4e0:	4770      	bx	lr

0001b4e2 <vq_ring_add_buffer>:
{
   1b4e2:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b4e6:	4683      	mov	fp, r0
   1b4e8:	4688      	mov	r8, r1
   1b4ea:	4610      	mov	r0, r2
   1b4ec:	461f      	mov	r7, r3
	needed = readable + writable;
   1b4ee:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
   1b4f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b4f2:	441e      	add	r6, r3
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
   1b4f4:	2500      	movs	r5, #0
   1b4f6:	e01d      	b.n	1b534 <vq_ring_add_buffer+0x52>
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   1b4f8:	f04f 31ff 	mov.w	r1, #4294967295
   1b4fc:	e02b      	b.n	1b556 <vq_ring_add_buffer+0x74>
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
	if (!io->ops.offset_to_phys) {
		unsigned long page = (io->page_shift >=
   1b4fe:	68c3      	ldr	r3, [r0, #12]
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
   1b500:	2b1f      	cmp	r3, #31
   1b502:	d80d      	bhi.n	1b520 <vq_ring_add_buffer+0x3e>
   1b504:	fa21 f303 	lsr.w	r3, r1, r3
		return (io->physmap && offset < io->size
   1b508:	6842      	ldr	r2, [r0, #4]
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
   1b50a:	b15a      	cbz	r2, 1b524 <vq_ring_add_buffer+0x42>
		return (io->physmap && offset < io->size
   1b50c:	f8d0 c008 	ldr.w	ip, [r0, #8]
   1b510:	4561      	cmp	r1, ip
   1b512:	d20a      	bcs.n	1b52a <vq_ring_add_buffer+0x48>
			? io->physmap[page] + (offset & io->page_mask)
   1b514:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1b518:	6900      	ldr	r0, [r0, #16]
   1b51a:	4008      	ands	r0, r1
			: METAL_BAD_PHYS);
   1b51c:	4418      	add	r0, r3
   1b51e:	e01e      	b.n	1b55e <vq_ring_add_buffer+0x7c>
				     0 : offset >> io->page_shift);
   1b520:	2300      	movs	r3, #0
   1b522:	e7f1      	b.n	1b508 <vq_ring_add_buffer+0x26>
			: METAL_BAD_PHYS);
   1b524:	f04f 30ff 	mov.w	r0, #4294967295
   1b528:	e019      	b.n	1b55e <vq_ring_add_buffer+0x7c>
   1b52a:	f04f 30ff 	mov.w	r0, #4294967295
   1b52e:	e016      	b.n	1b55e <vq_ring_add_buffer+0x7c>
   1b530:	3501      	adds	r5, #1
   1b532:	89e0      	ldrh	r0, [r4, #14]
   1b534:	42b5      	cmp	r5, r6
   1b536:	da2a      	bge.n	1b58e <vq_ring_add_buffer+0xac>
		dp = &desc[idx];
   1b538:	ea4f 1a00 	mov.w	sl, r0, lsl #4
   1b53c:	eb08 1400 	add.w	r4, r8, r0, lsl #4
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
   1b540:	eb07 09c5 	add.w	r9, r7, r5, lsl #3
   1b544:	f857 3035 	ldr.w	r3, [r7, r5, lsl #3]
	struct metal_io_region *io = vq->shm_io;
   1b548:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
   1b54c:	6801      	ldr	r1, [r0, #0]
   1b54e:	1a59      	subs	r1, r3, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   1b550:	6883      	ldr	r3, [r0, #8]
   1b552:	4299      	cmp	r1, r3
   1b554:	d2d0      	bcs.n	1b4f8 <vq_ring_add_buffer+0x16>
	if (!io->ops.offset_to_phys) {
   1b556:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1b558:	2b00      	cmp	r3, #0
   1b55a:	d0d0      	beq.n	1b4fe <vq_ring_add_buffer+0x1c>
	}

	return io->ops.offset_to_phys(io, offset);
   1b55c:	4798      	blx	r3
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
   1b55e:	2300      	movs	r3, #0
   1b560:	f848 000a 	str.w	r0, [r8, sl]
   1b564:	6063      	str	r3, [r4, #4]
		dp->len = buf_list[i].len;
   1b566:	f8d9 2004 	ldr.w	r2, [r9, #4]
   1b56a:	60a2      	str	r2, [r4, #8]
		dp->flags = 0;
   1b56c:	7323      	strb	r3, [r4, #12]
   1b56e:	7363      	strb	r3, [r4, #13]
		if (i < needed - 1)
   1b570:	1e73      	subs	r3, r6, #1
   1b572:	42ab      	cmp	r3, r5
   1b574:	dd03      	ble.n	1b57e <vq_ring_add_buffer+0x9c>
			dp->flags |= VRING_DESC_F_NEXT;
   1b576:	2301      	movs	r3, #1
   1b578:	7323      	strb	r3, [r4, #12]
   1b57a:	2300      	movs	r3, #0
   1b57c:	7363      	strb	r3, [r4, #13]
		if (i >= readable)
   1b57e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1b580:	429d      	cmp	r5, r3
   1b582:	dbd5      	blt.n	1b530 <vq_ring_add_buffer+0x4e>
			dp->flags |= VRING_DESC_F_WRITE;
   1b584:	89a3      	ldrh	r3, [r4, #12]
   1b586:	f043 0302 	orr.w	r3, r3, #2
   1b58a:	81a3      	strh	r3, [r4, #12]
   1b58c:	e7d0      	b.n	1b530 <vq_ring_add_buffer+0x4e>
}
   1b58e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001b592 <virtqueue_create>:
{
   1b592:	b510      	push	{r4, lr}
   1b594:	4604      	mov	r4, r0
   1b596:	9804      	ldr	r0, [sp, #16]
		vq->vq_dev = virt_dev;
   1b598:	6004      	str	r4, [r0, #0]
		vq->vq_name = name;
   1b59a:	6042      	str	r2, [r0, #4]
		vq->vq_queue_index = id;
   1b59c:	8101      	strh	r1, [r0, #8]
		vq->vq_nentries = ring->num_descs;
   1b59e:	891a      	ldrh	r2, [r3, #8]
   1b5a0:	8142      	strh	r2, [r0, #10]
		vq->vq_free_cnt = vq->vq_nentries;
   1b5a2:	8482      	strh	r2, [r0, #36]	; 0x24
		vq->callback = callback;
   1b5a4:	9a02      	ldr	r2, [sp, #8]
   1b5a6:	60c2      	str	r2, [r0, #12]
		vq->notify = notify;
   1b5a8:	9a03      	ldr	r2, [sp, #12]
   1b5aa:	6102      	str	r2, [r0, #16]
		vq_ring_init(vq, ring->vaddr, ring->align);
   1b5ac:	685a      	ldr	r2, [r3, #4]
   1b5ae:	6819      	ldr	r1, [r3, #0]
   1b5b0:	f7ff ff12 	bl	1b3d8 <vq_ring_init>
}
   1b5b4:	2000      	movs	r0, #0
   1b5b6:	bd10      	pop	{r4, pc}

0001b5b8 <virtqueue_add_buffer>:
{
   1b5b8:	b570      	push	{r4, r5, r6, lr}
   1b5ba:	b082      	sub	sp, #8
   1b5bc:	4604      	mov	r4, r0
	needed = readable + writable;
   1b5be:	18d5      	adds	r5, r2, r3
		head_idx = vq->vq_desc_head_idx;
   1b5c0:	8d86      	ldrh	r6, [r0, #44]	; 0x2c
		dxp->cookie = cookie;
   1b5c2:	f106 0c06 	add.w	ip, r6, #6
   1b5c6:	eb00 0ccc 	add.w	ip, r0, ip, lsl #3
   1b5ca:	f8dd e018 	ldr.w	lr, [sp, #24]
   1b5ce:	f8cc e004 	str.w	lr, [ip, #4]
		dxp->ndescs = needed;
   1b5d2:	b2ad      	uxth	r5, r5
   1b5d4:	f8ac 5008 	strh.w	r5, [ip, #8]
		idx = vq_ring_add_buffer(vq, vq->vq_ring.desc, head_idx,
   1b5d8:	9301      	str	r3, [sp, #4]
   1b5da:	9200      	str	r2, [sp, #0]
   1b5dc:	460b      	mov	r3, r1
   1b5de:	4632      	mov	r2, r6
   1b5e0:	6981      	ldr	r1, [r0, #24]
   1b5e2:	f7ff ff7e 	bl	1b4e2 <vq_ring_add_buffer>
		vq->vq_desc_head_idx = idx;
   1b5e6:	85a0      	strh	r0, [r4, #44]	; 0x2c
		vq->vq_free_cnt -= needed;
   1b5e8:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1b5ea:	1b5d      	subs	r5, r3, r5
   1b5ec:	84a5      	strh	r5, [r4, #36]	; 0x24
		vq_ring_update_avail(vq, head_idx);
   1b5ee:	4631      	mov	r1, r6
   1b5f0:	4620      	mov	r0, r4
   1b5f2:	f7ff ff5f 	bl	1b4b4 <vq_ring_update_avail>
}
   1b5f6:	2000      	movs	r0, #0
   1b5f8:	b002      	add	sp, #8
   1b5fa:	bd70      	pop	{r4, r5, r6, pc}

0001b5fc <virtqueue_get_buffer>:
{
   1b5fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!vq || vq->vq_used_cons_idx == vq->vq_ring.used->idx)
   1b5fe:	4607      	mov	r7, r0
   1b600:	b330      	cbz	r0, 1b650 <virtqueue_get_buffer+0x54>
   1b602:	468c      	mov	ip, r1
   1b604:	4616      	mov	r6, r2
   1b606:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   1b608:	6a02      	ldr	r2, [r0, #32]
   1b60a:	8851      	ldrh	r1, [r2, #2]
   1b60c:	428b      	cmp	r3, r1
   1b60e:	d020      	beq.n	1b652 <virtqueue_get_buffer+0x56>
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
   1b610:	1c59      	adds	r1, r3, #1
   1b612:	85c1      	strh	r1, [r0, #46]	; 0x2e
   1b614:	b21b      	sxth	r3, r3
   1b616:	8945      	ldrh	r5, [r0, #10]
   1b618:	3d01      	subs	r5, #1
   1b61a:	b22d      	sxth	r5, r5
   1b61c:	401d      	ands	r5, r3
   1b61e:	b2ad      	uxth	r5, r5
	atomic_thread_fence(memory_order_seq_cst);
   1b620:	f3bf 8f5b 	dmb	ish
	desc_idx = (uint16_t)uep->id;
   1b624:	eb02 03c5 	add.w	r3, r2, r5, lsl #3
   1b628:	685c      	ldr	r4, [r3, #4]
   1b62a:	b2a1      	uxth	r1, r4
	if (len)
   1b62c:	f1bc 0f00 	cmp.w	ip, #0
   1b630:	d002      	beq.n	1b638 <virtqueue_get_buffer+0x3c>
		*len = uep->len;
   1b632:	689b      	ldr	r3, [r3, #8]
   1b634:	f8cc 3000 	str.w	r3, [ip]
	vq_ring_free_chain(vq, desc_idx);
   1b638:	4638      	mov	r0, r7
   1b63a:	f7ff fea2 	bl	1b382 <vq_ring_free_chain>
	cookie = vq->vq_descx[desc_idx].cookie;
   1b63e:	b2a4      	uxth	r4, r4
   1b640:	3406      	adds	r4, #6
   1b642:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
   1b646:	6860      	ldr	r0, [r4, #4]
	vq->vq_descx[desc_idx].cookie = NULL;
   1b648:	2300      	movs	r3, #0
   1b64a:	6063      	str	r3, [r4, #4]
	if (idx)
   1b64c:	b106      	cbz	r6, 1b650 <virtqueue_get_buffer+0x54>
		*idx = used_idx;
   1b64e:	8035      	strh	r5, [r6, #0]
}
   1b650:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
   1b652:	2000      	movs	r0, #0
   1b654:	e7fc      	b.n	1b650 <virtqueue_get_buffer+0x54>

0001b656 <virtqueue_get_buffer_length>:
	return vq->vq_ring.desc[idx].len;
   1b656:	6983      	ldr	r3, [r0, #24]
   1b658:	eb03 1301 	add.w	r3, r3, r1, lsl #4
}
   1b65c:	6898      	ldr	r0, [r3, #8]
   1b65e:	4770      	bx	lr

0001b660 <virtqueue_get_available_buffer>:
{
   1b660:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b664:	460f      	mov	r7, r1
   1b666:	4691      	mov	r9, r2
	atomic_thread_fence(memory_order_seq_cst);
   1b668:	f3bf 8f5b 	dmb	ish
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
   1b66c:	8e03      	ldrh	r3, [r0, #48]	; 0x30
   1b66e:	69c1      	ldr	r1, [r0, #28]
   1b670:	884a      	ldrh	r2, [r1, #2]
   1b672:	4293      	cmp	r3, r2
   1b674:	d063      	beq.n	1b73e <virtqueue_get_available_buffer+0xde>
   1b676:	4606      	mov	r6, r0
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
   1b678:	1c5a      	adds	r2, r3, #1
   1b67a:	8602      	strh	r2, [r0, #48]	; 0x30
   1b67c:	b21b      	sxth	r3, r3
   1b67e:	8942      	ldrh	r2, [r0, #10]
   1b680:	3a01      	subs	r2, #1
   1b682:	b212      	sxth	r2, r2
   1b684:	4013      	ands	r3, r2
   1b686:	b29b      	uxth	r3, r3
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
   1b688:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   1b68c:	889a      	ldrh	r2, [r3, #4]
   1b68e:	b293      	uxth	r3, r2
   1b690:	803a      	strh	r2, [r7, #0]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
   1b692:	6982      	ldr	r2, [r0, #24]
   1b694:	011b      	lsls	r3, r3, #4
   1b696:	f852 8003 	ldr.w	r8, [r2, r3]
	struct metal_io_region *io = vq->shm_io;
   1b69a:	6a84      	ldr	r4, [r0, #40]	; 0x28
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_phys_to_offset(struct metal_io_region *io, metal_phys_addr_t phys)
{
	if (!io->ops.phys_to_offset) {
   1b69c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   1b69e:	b1a3      	cbz	r3, 1b6ca <virtqueue_get_available_buffer+0x6a>
			offset += io->page_mask + 1;
		} while (offset < io->size);
		return METAL_BAD_OFFSET;
	}

	return (*io->ops.phys_to_offset)(io, phys);
   1b6a0:	4641      	mov	r1, r8
   1b6a2:	4620      	mov	r0, r4
   1b6a4:	4798      	blx	r3
   1b6a6:	4605      	mov	r5, r0
	return (io->virt != METAL_BAD_VA && offset < io->size
   1b6a8:	6820      	ldr	r0, [r4, #0]
		: NULL);
   1b6aa:	f1b0 3fff 	cmp.w	r0, #4294967295
   1b6ae:	d042      	beq.n	1b736 <virtqueue_get_available_buffer+0xd6>
	return (io->virt != METAL_BAD_VA && offset < io->size
   1b6b0:	68a3      	ldr	r3, [r4, #8]
   1b6b2:	42ab      	cmp	r3, r5
   1b6b4:	d941      	bls.n	1b73a <virtqueue_get_available_buffer+0xda>
		? (void *)((uintptr_t)io->virt + offset)
   1b6b6:	4428      	add	r0, r5
	*len = vq->vq_ring.desc[*avail_idx].len;
   1b6b8:	69b3      	ldr	r3, [r6, #24]
   1b6ba:	883a      	ldrh	r2, [r7, #0]
   1b6bc:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   1b6c0:	689b      	ldr	r3, [r3, #8]
   1b6c2:	f8c9 3000 	str.w	r3, [r9]
}
   1b6c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			(io->page_mask == (metal_phys_addr_t)(-1) ?
   1b6ca:	6925      	ldr	r5, [r4, #16]
			phys - io->physmap[0] :  phys & io->page_mask);
   1b6cc:	f1b5 3fff 	cmp.w	r5, #4294967295
   1b6d0:	d002      	beq.n	1b6d8 <virtqueue_get_available_buffer+0x78>
   1b6d2:	ea08 0505 	and.w	r5, r8, r5
   1b6d6:	e017      	b.n	1b708 <virtqueue_get_available_buffer+0xa8>
   1b6d8:	6863      	ldr	r3, [r4, #4]
   1b6da:	681d      	ldr	r5, [r3, #0]
   1b6dc:	eba8 0505 	sub.w	r5, r8, r5
   1b6e0:	e012      	b.n	1b708 <virtqueue_get_available_buffer+0xa8>
				     0 : offset >> io->page_shift);
   1b6e2:	2300      	movs	r3, #0
   1b6e4:	e018      	b.n	1b718 <virtqueue_get_available_buffer+0xb8>
			: METAL_BAD_PHYS);
   1b6e6:	f04f 30ff 	mov.w	r0, #4294967295
   1b6ea:	e005      	b.n	1b6f8 <virtqueue_get_available_buffer+0x98>
   1b6ec:	f04f 30ff 	mov.w	r0, #4294967295
   1b6f0:	e002      	b.n	1b6f8 <virtqueue_get_available_buffer+0x98>
	return io->ops.offset_to_phys(io, offset);
   1b6f2:	4629      	mov	r1, r5
   1b6f4:	4620      	mov	r0, r4
   1b6f6:	4798      	blx	r3
			if (metal_io_phys(io, offset) == phys)
   1b6f8:	4580      	cmp	r8, r0
   1b6fa:	d0d5      	beq.n	1b6a8 <virtqueue_get_available_buffer+0x48>
			offset += io->page_mask + 1;
   1b6fc:	6920      	ldr	r0, [r4, #16]
   1b6fe:	4428      	add	r0, r5
   1b700:	1c45      	adds	r5, r0, #1
		} while (offset < io->size);
   1b702:	68a3      	ldr	r3, [r4, #8]
   1b704:	429d      	cmp	r5, r3
   1b706:	d213      	bcs.n	1b730 <virtqueue_get_available_buffer+0xd0>
	if (!io->ops.offset_to_phys) {
   1b708:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1b70a:	2b00      	cmp	r3, #0
   1b70c:	d1f1      	bne.n	1b6f2 <virtqueue_get_available_buffer+0x92>
		unsigned long page = (io->page_shift >=
   1b70e:	68e3      	ldr	r3, [r4, #12]
				     0 : offset >> io->page_shift);
   1b710:	2b1f      	cmp	r3, #31
   1b712:	d8e6      	bhi.n	1b6e2 <virtqueue_get_available_buffer+0x82>
   1b714:	fa25 f303 	lsr.w	r3, r5, r3
		return (io->physmap && offset < io->size
   1b718:	6862      	ldr	r2, [r4, #4]
			: METAL_BAD_PHYS);
   1b71a:	2a00      	cmp	r2, #0
   1b71c:	d0e3      	beq.n	1b6e6 <virtqueue_get_available_buffer+0x86>
		return (io->physmap && offset < io->size
   1b71e:	68a1      	ldr	r1, [r4, #8]
   1b720:	428d      	cmp	r5, r1
   1b722:	d2e3      	bcs.n	1b6ec <virtqueue_get_available_buffer+0x8c>
			? io->physmap[page] + (offset & io->page_mask)
   1b724:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
   1b728:	6923      	ldr	r3, [r4, #16]
   1b72a:	402b      	ands	r3, r5
			: METAL_BAD_PHYS);
   1b72c:	4418      	add	r0, r3
   1b72e:	e7e3      	b.n	1b6f8 <virtqueue_get_available_buffer+0x98>
		return METAL_BAD_OFFSET;
   1b730:	f04f 35ff 	mov.w	r5, #4294967295
   1b734:	e7b8      	b.n	1b6a8 <virtqueue_get_available_buffer+0x48>
		: NULL);
   1b736:	2000      	movs	r0, #0
   1b738:	e7be      	b.n	1b6b8 <virtqueue_get_available_buffer+0x58>
   1b73a:	2000      	movs	r0, #0
   1b73c:	e7bc      	b.n	1b6b8 <virtqueue_get_available_buffer+0x58>
		return NULL;
   1b73e:	2000      	movs	r0, #0
   1b740:	e7c1      	b.n	1b6c6 <virtqueue_get_available_buffer+0x66>

0001b742 <virtqueue_disable_cb>:
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
   1b742:	6803      	ldr	r3, [r0, #0]
   1b744:	691a      	ldr	r2, [r3, #16]
   1b746:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
   1b74a:	d01b      	beq.n	1b784 <virtqueue_disable_cb+0x42>
		if (vq->vq_dev->role == VIRTIO_DEV_DRIVER) {
   1b74c:	699b      	ldr	r3, [r3, #24]
   1b74e:	b94b      	cbnz	r3, 1b764 <virtqueue_disable_cb+0x22>
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
   1b750:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   1b752:	8942      	ldrh	r2, [r0, #10]
   1b754:	1a9b      	subs	r3, r3, r2
   1b756:	b29b      	uxth	r3, r3
			vring_used_event(&vq->vq_ring) =
   1b758:	69c2      	ldr	r2, [r0, #28]
   1b75a:	6941      	ldr	r1, [r0, #20]
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
   1b75c:	3b01      	subs	r3, #1
			vring_used_event(&vq->vq_ring) =
   1b75e:	eb02 0241 	add.w	r2, r2, r1, lsl #1
   1b762:	8093      	strh	r3, [r2, #4]
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
   1b764:	6803      	ldr	r3, [r0, #0]
   1b766:	699b      	ldr	r3, [r3, #24]
   1b768:	2b01      	cmp	r3, #1
   1b76a:	d000      	beq.n	1b76e <virtqueue_disable_cb+0x2c>
}
   1b76c:	4770      	bx	lr
			    vq->vq_available_idx - vq->vq_nentries - 1;
   1b76e:	8e03      	ldrh	r3, [r0, #48]	; 0x30
   1b770:	8942      	ldrh	r2, [r0, #10]
   1b772:	1a9b      	subs	r3, r3, r2
   1b774:	b29b      	uxth	r3, r3
			vring_avail_event(&vq->vq_ring) =
   1b776:	6a02      	ldr	r2, [r0, #32]
   1b778:	6941      	ldr	r1, [r0, #20]
			    vq->vq_available_idx - vq->vq_nentries - 1;
   1b77a:	3b01      	subs	r3, #1
			vring_avail_event(&vq->vq_ring) =
   1b77c:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   1b780:	8093      	strh	r3, [r2, #4]
   1b782:	4770      	bx	lr
		if (vq->vq_dev->role == VIRTIO_DEV_DRIVER) {
   1b784:	699b      	ldr	r3, [r3, #24]
   1b786:	b923      	cbnz	r3, 1b792 <virtqueue_disable_cb+0x50>
			vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
   1b788:	69c2      	ldr	r2, [r0, #28]
   1b78a:	8813      	ldrh	r3, [r2, #0]
   1b78c:	f043 0301 	orr.w	r3, r3, #1
   1b790:	8013      	strh	r3, [r2, #0]
		if (vq->vq_dev->role == VIRTIO_DEV_DEVICE) {
   1b792:	6803      	ldr	r3, [r0, #0]
   1b794:	699b      	ldr	r3, [r3, #24]
   1b796:	2b01      	cmp	r3, #1
   1b798:	d1e8      	bne.n	1b76c <virtqueue_disable_cb+0x2a>
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
   1b79a:	6a02      	ldr	r2, [r0, #32]
   1b79c:	8813      	ldrh	r3, [r2, #0]
   1b79e:	f043 0301 	orr.w	r3, r3, #1
   1b7a2:	8013      	strh	r3, [r2, #0]
}
   1b7a4:	e7e2      	b.n	1b76c <virtqueue_disable_cb+0x2a>

0001b7a6 <virtqueue_kick>:
{
   1b7a6:	b510      	push	{r4, lr}
   1b7a8:	4604      	mov	r4, r0
	atomic_thread_fence(memory_order_seq_cst);
   1b7aa:	f3bf 8f5b 	dmb	ish
	if (vq_ring_must_notify(vq))
   1b7ae:	f7ff fe3b 	bl	1b428 <vq_ring_must_notify>
   1b7b2:	b910      	cbnz	r0, 1b7ba <virtqueue_kick+0x14>
	vq->vq_queued_cnt = 0;
   1b7b4:	2300      	movs	r3, #0
   1b7b6:	84e3      	strh	r3, [r4, #38]	; 0x26
}
   1b7b8:	bd10      	pop	{r4, pc}
		vq_ring_notify(vq);
   1b7ba:	4620      	mov	r0, r4
   1b7bc:	f7ff fe75 	bl	1b4aa <vq_ring_notify>
   1b7c0:	e7f8      	b.n	1b7b4 <virtqueue_kick+0xe>

0001b7c2 <virtqueue_get_desc_size>:
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
   1b7c2:	8e03      	ldrh	r3, [r0, #48]	; 0x30
   1b7c4:	69c1      	ldr	r1, [r0, #28]
   1b7c6:	884a      	ldrh	r2, [r1, #2]
   1b7c8:	4293      	cmp	r3, r2
   1b7ca:	d00d      	beq.n	1b7e8 <virtqueue_get_desc_size+0x26>
	head_idx = vq->vq_available_idx & (vq->vq_nentries - 1);
   1b7cc:	b21b      	sxth	r3, r3
   1b7ce:	8942      	ldrh	r2, [r0, #10]
   1b7d0:	3a01      	subs	r2, #1
   1b7d2:	b212      	sxth	r2, r2
   1b7d4:	4013      	ands	r3, r2
   1b7d6:	b29b      	uxth	r3, r3
	avail_idx = vq->vq_ring.avail->ring[head_idx];
   1b7d8:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   1b7dc:	889a      	ldrh	r2, [r3, #4]
	len = vq->vq_ring.desc[avail_idx].len;
   1b7de:	6983      	ldr	r3, [r0, #24]
   1b7e0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   1b7e4:	6898      	ldr	r0, [r3, #8]
	return len;
   1b7e6:	4770      	bx	lr
		return 0;
   1b7e8:	2000      	movs	r0, #0
}
   1b7ea:	4770      	bx	lr

0001b7ec <virtqueue_notification>:
{
   1b7ec:	b508      	push	{r3, lr}
	atomic_thread_fence(memory_order_seq_cst);
   1b7ee:	f3bf 8f5b 	dmb	ish
	if (vq->callback)
   1b7f2:	68c3      	ldr	r3, [r0, #12]
   1b7f4:	b103      	cbz	r3, 1b7f8 <virtqueue_notification+0xc>
		vq->callback(vq);
   1b7f6:	4798      	blx	r3
}
   1b7f8:	bd08      	pop	{r3, pc}

0001b7fa <rpmsg_get_address>:
{
   1b7fa:	b500      	push	{lr}
   1b7fc:	4686      	mov	lr, r0
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
	unsigned int bit;

	for (bit = start;
   1b7fe:	2300      	movs	r3, #0
   1b800:	e000      	b.n	1b804 <rpmsg_get_address+0xa>
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
	     bit++)
   1b802:	3301      	adds	r3, #1
	for (bit = start;
   1b804:	4299      	cmp	r1, r3
   1b806:	d909      	bls.n	1b81c <rpmsg_get_address+0x22>
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
   1b808:	095a      	lsrs	r2, r3, #5
   1b80a:	f85e 2022 	ldr.w	r2, [lr, r2, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
   1b80e:	f003 0c1f 	and.w	ip, r3, #31
   1b812:	fa22 f20c 	lsr.w	r2, r2, ip
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
   1b816:	f012 0f01 	tst.w	r2, #1
   1b81a:	d1f2      	bne.n	1b802 <rpmsg_get_address+0x8>
	if (nextbit < (uint32_t)size) {
   1b81c:	4299      	cmp	r1, r3
   1b81e:	d90e      	bls.n	1b83e <rpmsg_get_address+0x44>
		addr = RPMSG_RESERVED_ADDRESSES + nextbit;
   1b820:	f503 6080 	add.w	r0, r3, #1024	; 0x400
	bitmap[bit / METAL_BITS_PER_ULONG] |=
   1b824:	0959      	lsrs	r1, r3, #5
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
   1b826:	f003 031f 	and.w	r3, r3, #31
   1b82a:	2201      	movs	r2, #1
   1b82c:	fa02 f303 	lsl.w	r3, r2, r3
	bitmap[bit / METAL_BITS_PER_ULONG] |=
   1b830:	f85e 2021 	ldr.w	r2, [lr, r1, lsl #2]
   1b834:	431a      	orrs	r2, r3
   1b836:	f84e 2021 	str.w	r2, [lr, r1, lsl #2]
}
   1b83a:	f85d fb04 	ldr.w	pc, [sp], #4
	unsigned int addr = RPMSG_ADDR_ANY;
   1b83e:	f04f 30ff 	mov.w	r0, #4294967295
	return addr;
   1b842:	e7fa      	b.n	1b83a <rpmsg_get_address+0x40>

0001b844 <rpmsg_release_address>:
	if (addr >= 0 && addr < size)
   1b844:	f5b2 6280 	subs.w	r2, r2, #1024	; 0x400
   1b848:	d40d      	bmi.n	1b866 <rpmsg_release_address+0x22>
   1b84a:	428a      	cmp	r2, r1
   1b84c:	da0b      	bge.n	1b866 <rpmsg_release_address+0x22>
	bitmap[bit / METAL_BITS_PER_ULONG] &=
   1b84e:	0951      	lsrs	r1, r2, #5
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
   1b850:	f002 021f 	and.w	r2, r2, #31
   1b854:	2301      	movs	r3, #1
   1b856:	fa03 f202 	lsl.w	r2, r3, r2
	bitmap[bit / METAL_BITS_PER_ULONG] &=
   1b85a:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
   1b85e:	ea23 0302 	bic.w	r3, r3, r2
   1b862:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   1b866:	4770      	bx	lr

0001b868 <rpmsg_unregister_endpoint>:
{
   1b868:	b570      	push	{r4, r5, r6, lr}
   1b86a:	4604      	mov	r4, r0
	struct rpmsg_device *rdev = ept->rdev;
   1b86c:	6a06      	ldr	r6, [r0, #32]
	metal_mutex_acquire(&rdev->lock);
   1b86e:	f106 0558 	add.w	r5, r6, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   1b872:	f04f 32ff 	mov.w	r2, #4294967295
   1b876:	f04f 33ff 	mov.w	r3, #4294967295
   1b87a:	4628      	mov	r0, r5
   1b87c:	f7f8 f9b0 	bl	13be0 <z_impl_k_sem_take>
	if (ept->addr != RPMSG_ADDR_ANY)
   1b880:	6a62      	ldr	r2, [r4, #36]	; 0x24
   1b882:	f1b2 3fff 	cmp.w	r2, #4294967295
   1b886:	d10e      	bne.n	1b8a6 <rpmsg_unregister_endpoint+0x3e>
	metal_list_del(&ept->node);
   1b888:	f104 0334 	add.w	r3, r4, #52	; 0x34
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
	node->next->prev = node->prev;
   1b88c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1b88e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   1b890:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
   1b892:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1b894:	6011      	str	r1, [r2, #0]
	node->prev = node;
   1b896:	63a3      	str	r3, [r4, #56]	; 0x38
	node->next = node;
   1b898:	6363      	str	r3, [r4, #52]	; 0x34
	ept->rdev = NULL;
   1b89a:	2300      	movs	r3, #0
   1b89c:	6223      	str	r3, [r4, #32]
	z_impl_k_sem_give(sem);
   1b89e:	4628      	mov	r0, r5
   1b8a0:	f7f8 f976 	bl	13b90 <z_impl_k_sem_give>
}
   1b8a4:	bd70      	pop	{r4, r5, r6, pc}
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
   1b8a6:	2180      	movs	r1, #128	; 0x80
   1b8a8:	f106 0048 	add.w	r0, r6, #72	; 0x48
   1b8ac:	f7ff ffca 	bl	1b844 <rpmsg_release_address>
   1b8b0:	e7ea      	b.n	1b888 <rpmsg_unregister_endpoint+0x20>

0001b8b2 <rpmsg_send_ns_message>:
{
   1b8b2:	b510      	push	{r4, lr}
   1b8b4:	b08c      	sub	sp, #48	; 0x30
   1b8b6:	4604      	mov	r4, r0
	ns_msg.flags = flags;
   1b8b8:	910b      	str	r1, [sp, #44]	; 0x2c
	ns_msg.addr = ept->addr;
   1b8ba:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1b8bc:	930a      	str	r3, [sp, #40]	; 0x28
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
   1b8be:	2220      	movs	r2, #32
   1b8c0:	4601      	mov	r1, r0
   1b8c2:	a802      	add	r0, sp, #8
   1b8c4:	f7fb fed7 	bl	17676 <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
   1b8c8:	2301      	movs	r3, #1
   1b8ca:	9301      	str	r3, [sp, #4]
   1b8cc:	2328      	movs	r3, #40	; 0x28
   1b8ce:	9300      	str	r3, [sp, #0]
   1b8d0:	ab02      	add	r3, sp, #8
   1b8d2:	2235      	movs	r2, #53	; 0x35
   1b8d4:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1b8d6:	4620      	mov	r0, r4
   1b8d8:	f7f7 fa3c 	bl	12d54 <rpmsg_send_offchannel_raw>
	if (ret < 0)
   1b8dc:	2800      	cmp	r0, #0
   1b8de:	db00      	blt.n	1b8e2 <rpmsg_send_ns_message+0x30>
		return RPMSG_SUCCESS;
   1b8e0:	2000      	movs	r0, #0
}
   1b8e2:	b00c      	add	sp, #48	; 0x30
   1b8e4:	bd10      	pop	{r4, pc}

0001b8e6 <rpmsg_hold_rx_buffer>:
	if (!ept || !ept->rdev || !rxbuf)
   1b8e6:	b138      	cbz	r0, 1b8f8 <rpmsg_hold_rx_buffer+0x12>
{
   1b8e8:	b508      	push	{r3, lr}
	if (!ept || !ept->rdev || !rxbuf)
   1b8ea:	6a00      	ldr	r0, [r0, #32]
   1b8ec:	b118      	cbz	r0, 1b8f6 <rpmsg_hold_rx_buffer+0x10>
   1b8ee:	b111      	cbz	r1, 1b8f6 <rpmsg_hold_rx_buffer+0x10>
	if (rdev->ops.hold_rx_buffer)
   1b8f0:	6f83      	ldr	r3, [r0, #120]	; 0x78
   1b8f2:	b103      	cbz	r3, 1b8f6 <rpmsg_hold_rx_buffer+0x10>
		rdev->ops.hold_rx_buffer(rdev, rxbuf);
   1b8f4:	4798      	blx	r3
}
   1b8f6:	bd08      	pop	{r3, pc}
   1b8f8:	4770      	bx	lr

0001b8fa <rpmsg_release_rx_buffer>:
	if (!ept || !ept->rdev || !rxbuf)
   1b8fa:	b138      	cbz	r0, 1b90c <rpmsg_release_rx_buffer+0x12>
{
   1b8fc:	b508      	push	{r3, lr}
	if (!ept || !ept->rdev || !rxbuf)
   1b8fe:	6a00      	ldr	r0, [r0, #32]
   1b900:	b118      	cbz	r0, 1b90a <rpmsg_release_rx_buffer+0x10>
   1b902:	b111      	cbz	r1, 1b90a <rpmsg_release_rx_buffer+0x10>
	if (rdev->ops.release_rx_buffer)
   1b904:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
   1b906:	b103      	cbz	r3, 1b90a <rpmsg_release_rx_buffer+0x10>
		rdev->ops.release_rx_buffer(rdev, rxbuf);
   1b908:	4798      	blx	r3
}
   1b90a:	bd08      	pop	{r3, pc}
   1b90c:	4770      	bx	lr

0001b90e <rpmsg_get_tx_payload_buffer>:
{
   1b90e:	b508      	push	{r3, lr}
	if (!ept || !ept->rdev || !len)
   1b910:	b130      	cbz	r0, 1b920 <rpmsg_get_tx_payload_buffer+0x12>
   1b912:	6a00      	ldr	r0, [r0, #32]
   1b914:	b120      	cbz	r0, 1b920 <rpmsg_get_tx_payload_buffer+0x12>
   1b916:	b121      	cbz	r1, 1b922 <rpmsg_get_tx_payload_buffer+0x14>
	if (rdev->ops.get_tx_payload_buffer)
   1b918:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
   1b91c:	b11b      	cbz	r3, 1b926 <rpmsg_get_tx_payload_buffer+0x18>
		return rdev->ops.get_tx_payload_buffer(rdev, len, wait);
   1b91e:	4798      	blx	r3
}
   1b920:	bd08      	pop	{r3, pc}
		return NULL;
   1b922:	4608      	mov	r0, r1
   1b924:	e7fc      	b.n	1b920 <rpmsg_get_tx_payload_buffer+0x12>
	return NULL;
   1b926:	2000      	movs	r0, #0
   1b928:	e7fa      	b.n	1b920 <rpmsg_get_tx_payload_buffer+0x12>

0001b92a <rpmsg_get_endpoint>:
{
   1b92a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b92e:	4680      	mov	r8, r0
   1b930:	460e      	mov	r6, r1
   1b932:	4617      	mov	r7, r2
   1b934:	4699      	mov	r9, r3
	metal_list_for_each(&rdev->endpoints, node) {
   1b936:	6804      	ldr	r4, [r0, #0]
   1b938:	e005      	b.n	1b946 <rpmsg_get_endpoint+0x1c>
		int name_match = 0;
   1b93a:	2000      	movs	r0, #0
   1b93c:	e017      	b.n	1b96e <rpmsg_get_endpoint+0x44>
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
   1b93e:	f1b7 3fff 	cmp.w	r7, #4294967295
   1b942:	d01f      	beq.n	1b984 <rpmsg_get_endpoint+0x5a>
	metal_list_for_each(&rdev->endpoints, node) {
   1b944:	6824      	ldr	r4, [r4, #0]
   1b946:	45a0      	cmp	r8, r4
   1b948:	d021      	beq.n	1b98e <rpmsg_get_endpoint+0x64>
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
   1b94a:	f1a4 0534 	sub.w	r5, r4, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
   1b94e:	f1b7 3fff 	cmp.w	r7, #4294967295
   1b952:	d002      	beq.n	1b95a <rpmsg_get_endpoint+0x30>
   1b954:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1b956:	42bb      	cmp	r3, r7
   1b958:	d01a      	beq.n	1b990 <rpmsg_get_endpoint+0x66>
		if (name)
   1b95a:	2e00      	cmp	r6, #0
   1b95c:	d0ed      	beq.n	1b93a <rpmsg_get_endpoint+0x10>
			name_match = !strncmp(ept->name, name,
   1b95e:	2220      	movs	r2, #32
   1b960:	4631      	mov	r1, r6
   1b962:	4628      	mov	r0, r5
   1b964:	f7fb febf 	bl	176e6 <strncmp>
   1b968:	fab0 f080 	clz	r0, r0
   1b96c:	0940      	lsrs	r0, r0, #5
		if (!name || !name_match)
   1b96e:	2e00      	cmp	r6, #0
   1b970:	d0e8      	beq.n	1b944 <rpmsg_get_endpoint+0x1a>
   1b972:	2800      	cmp	r0, #0
   1b974:	d0e6      	beq.n	1b944 <rpmsg_get_endpoint+0x1a>
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
   1b976:	f1b9 3fff 	cmp.w	r9, #4294967295
   1b97a:	d0e0      	beq.n	1b93e <rpmsg_get_endpoint+0x14>
   1b97c:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1b97e:	454b      	cmp	r3, r9
   1b980:	d1dd      	bne.n	1b93e <rpmsg_get_endpoint+0x14>
   1b982:	e005      	b.n	1b990 <rpmsg_get_endpoint+0x66>
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
   1b984:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1b986:	f1b3 3fff 	cmp.w	r3, #4294967295
   1b98a:	d1db      	bne.n	1b944 <rpmsg_get_endpoint+0x1a>
   1b98c:	e000      	b.n	1b990 <rpmsg_get_endpoint+0x66>
	return NULL;
   1b98e:	2500      	movs	r5, #0
}
   1b990:	4628      	mov	r0, r5
   1b992:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001b996 <rpmsg_destroy_ept>:
 */
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
	struct rpmsg_device *rdev;

	if (!ept)
   1b996:	b1a0      	cbz	r0, 1b9c2 <rpmsg_destroy_ept+0x2c>
{
   1b998:	b510      	push	{r4, lr}
   1b99a:	4604      	mov	r4, r0
		return;

	rdev = ept->rdev;
   1b99c:	6a03      	ldr	r3, [r0, #32]
	if (!rdev)
   1b99e:	b15b      	cbz	r3, 1b9b8 <rpmsg_destroy_ept+0x22>
		return;

	if (ept->name[0] && rdev->support_ns &&
   1b9a0:	7802      	ldrb	r2, [r0, #0]
   1b9a2:	b132      	cbz	r2, 1b9b2 <rpmsg_destroy_ept+0x1c>
   1b9a4:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   1b9a8:	b11b      	cbz	r3, 1b9b2 <rpmsg_destroy_ept+0x1c>
	    ept->addr >= RPMSG_RESERVED_ADDRESSES)
   1b9aa:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (ept->name[0] && rdev->support_ns &&
   1b9ac:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1b9b0:	d203      	bcs.n	1b9ba <rpmsg_destroy_ept+0x24>
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
	rpmsg_unregister_endpoint(ept);
   1b9b2:	4620      	mov	r0, r4
   1b9b4:	f7ff ff58 	bl	1b868 <rpmsg_unregister_endpoint>
}
   1b9b8:	bd10      	pop	{r4, pc}
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
   1b9ba:	2101      	movs	r1, #1
   1b9bc:	f7ff ff79 	bl	1b8b2 <rpmsg_send_ns_message>
   1b9c0:	e7f7      	b.n	1b9b2 <rpmsg_destroy_ept+0x1c>
   1b9c2:	4770      	bx	lr

0001b9c4 <rpmsg_virtio_wait_remote_ready>:
{
   1b9c4:	b510      	push	{r4, lr}
   1b9c6:	4604      	mov	r4, r0
   1b9c8:	e005      	b.n	1b9d6 <rpmsg_virtio_wait_remote_ready+0x12>
	rvdev->vdev->func->set_status(rvdev->vdev, status);
   1b9ca:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   1b9ce:	6a03      	ldr	r3, [r0, #32]
   1b9d0:	685b      	ldr	r3, [r3, #4]
   1b9d2:	2100      	movs	r1, #0
   1b9d4:	4798      	blx	r3
	return rvdev->vdev->func->get_status(rvdev->vdev);
   1b9d6:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
   1b9da:	6a03      	ldr	r3, [r0, #32]
   1b9dc:	681b      	ldr	r3, [r3, #0]
   1b9de:	4798      	blx	r3
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
   1b9e0:	f010 0f40 	tst.w	r0, #64	; 0x40
   1b9e4:	d1f1      	bne.n	1b9ca <rpmsg_virtio_wait_remote_ready+0x6>
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
   1b9e6:	f010 0f04 	tst.w	r0, #4
   1b9ea:	d0f4      	beq.n	1b9d6 <rpmsg_virtio_wait_remote_ready+0x12>
}
   1b9ec:	2001      	movs	r0, #1
   1b9ee:	bd10      	pop	{r4, pc}

0001b9f0 <rpmsg_virtio_hold_rx_buffer>:
	rp_hdr->reserved |= RPMSG_BUF_HELD;
   1b9f0:	f851 3c08 	ldr.w	r3, [r1, #-8]
   1b9f4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1b9f8:	f841 3c08 	str.w	r3, [r1, #-8]
}
   1b9fc:	4770      	bx	lr

0001b9fe <rpmsg_virtio_tx_callback>:
}
   1b9fe:	4770      	bx	lr

0001ba00 <rpmsg_virtio_ns_callback>:
{
   1ba00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ba04:	b088      	sub	sp, #32
	struct rpmsg_device *rdev = ept->rdev;
   1ba06:	6a05      	ldr	r5, [r0, #32]
	struct metal_io_region *io = rvdev->shbuf_io;
   1ba08:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
	if (len != sizeof(*ns_msg))
   1ba0c:	2a28      	cmp	r2, #40	; 0x28
   1ba0e:	d136      	bne.n	1ba7e <rpmsg_virtio_ns_callback+0x7e>
   1ba10:	460c      	mov	r4, r1
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
   1ba12:	6801      	ldr	r1, [r0, #0]
   1ba14:	1a61      	subs	r1, r4, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   1ba16:	6883      	ldr	r3, [r0, #8]
   1ba18:	4299      	cmp	r1, r3
   1ba1a:	d227      	bcs.n	1ba6c <rpmsg_virtio_ns_callback+0x6c>
	metal_io_block_read(io,
   1ba1c:	2320      	movs	r3, #32
   1ba1e:	466a      	mov	r2, sp
   1ba20:	f7ff fbe6 	bl	1b1f0 <metal_io_block_read>
	dest = ns_msg->addr;
   1ba24:	f8d4 8020 	ldr.w	r8, [r4, #32]
	metal_mutex_acquire(&rdev->lock);
   1ba28:	f105 0758 	add.w	r7, r5, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   1ba2c:	f04f 32ff 	mov.w	r2, #4294967295
   1ba30:	f04f 33ff 	mov.w	r3, #4294967295
   1ba34:	4638      	mov	r0, r7
   1ba36:	f7f8 f8d3 	bl	13be0 <z_impl_k_sem_take>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
   1ba3a:	4643      	mov	r3, r8
   1ba3c:	f04f 32ff 	mov.w	r2, #4294967295
   1ba40:	4669      	mov	r1, sp
   1ba42:	4628      	mov	r0, r5
   1ba44:	f7ff ff71 	bl	1b92a <rpmsg_get_endpoint>
   1ba48:	4606      	mov	r6, r0
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
   1ba4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1ba4c:	f013 0f01 	tst.w	r3, #1
   1ba50:	d00f      	beq.n	1ba72 <rpmsg_virtio_ns_callback+0x72>
		if (_ept)
   1ba52:	b110      	cbz	r0, 1ba5a <rpmsg_virtio_ns_callback+0x5a>
			_ept->dest_addr = RPMSG_ADDR_ANY;
   1ba54:	f04f 33ff 	mov.w	r3, #4294967295
   1ba58:	6283      	str	r3, [r0, #40]	; 0x28
	z_impl_k_sem_give(sem);
   1ba5a:	4638      	mov	r0, r7
   1ba5c:	f7f8 f898 	bl	13b90 <z_impl_k_sem_give>
		if (_ept && _ept->ns_unbind_cb)
   1ba60:	b16e      	cbz	r6, 1ba7e <rpmsg_virtio_ns_callback+0x7e>
   1ba62:	6b33      	ldr	r3, [r6, #48]	; 0x30
   1ba64:	b15b      	cbz	r3, 1ba7e <rpmsg_virtio_ns_callback+0x7e>
			_ept->ns_unbind_cb(_ept);
   1ba66:	4630      	mov	r0, r6
   1ba68:	4798      	blx	r3
   1ba6a:	e008      	b.n	1ba7e <rpmsg_virtio_ns_callback+0x7e>
   1ba6c:	f04f 31ff 	mov.w	r1, #4294967295
   1ba70:	e7d4      	b.n	1ba1c <rpmsg_virtio_ns_callback+0x1c>
		if (!_ept) {
   1ba72:	b140      	cbz	r0, 1ba86 <rpmsg_virtio_ns_callback+0x86>
			_ept->dest_addr = dest;
   1ba74:	f8c0 8028 	str.w	r8, [r0, #40]	; 0x28
   1ba78:	4638      	mov	r0, r7
   1ba7a:	f7f8 f889 	bl	13b90 <z_impl_k_sem_give>
}
   1ba7e:	2000      	movs	r0, #0
   1ba80:	b008      	add	sp, #32
   1ba82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ba86:	4638      	mov	r0, r7
   1ba88:	f7f8 f882 	bl	13b90 <z_impl_k_sem_give>
			if (rdev->ns_bind_cb)
   1ba8c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
   1ba8e:	2b00      	cmp	r3, #0
   1ba90:	d0f5      	beq.n	1ba7e <rpmsg_virtio_ns_callback+0x7e>
				rdev->ns_bind_cb(rdev, name, dest);
   1ba92:	4642      	mov	r2, r8
   1ba94:	4669      	mov	r1, sp
   1ba96:	4628      	mov	r0, r5
   1ba98:	4798      	blx	r3
   1ba9a:	e7f0      	b.n	1ba7e <rpmsg_virtio_ns_callback+0x7e>

0001ba9c <rpmsg_virtio_return_buffer>:
{
   1ba9c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ba9e:	b085      	sub	sp, #20
   1baa0:	4604      	mov	r4, r0
   1baa2:	4615      	mov	r5, r2
   1baa4:	461e      	mov	r6, r3
	return rvdev->vdev->role;
   1baa6:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   1baaa:	699f      	ldr	r7, [r3, #24]
	if (role == RPMSG_HOST) {
   1baac:	b11f      	cbz	r7, 1bab6 <rpmsg_virtio_return_buffer+0x1a>
	if (role == RPMSG_REMOTE) {
   1baae:	2f01      	cmp	r7, #1
   1bab0:	d00c      	beq.n	1bacc <rpmsg_virtio_return_buffer+0x30>
}
   1bab2:	b005      	add	sp, #20
   1bab4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vqbuf.buf = buffer;
   1bab6:	9102      	str	r1, [sp, #8]
		vqbuf.len = len;
   1bab8:	9203      	str	r2, [sp, #12]
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
   1baba:	9100      	str	r1, [sp, #0]
   1babc:	2301      	movs	r3, #1
   1babe:	2200      	movs	r2, #0
   1bac0:	a902      	add	r1, sp, #8
   1bac2:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
   1bac6:	f7ff fd77 	bl	1b5b8 <virtqueue_add_buffer>
   1baca:	e7f0      	b.n	1baae <rpmsg_virtio_return_buffer+0x12>
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
   1bacc:	462a      	mov	r2, r5
   1bace:	4631      	mov	r1, r6
   1bad0:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
   1bad4:	f7f7 f8f0 	bl	12cb8 <virtqueue_add_consumed_buffer>
}
   1bad8:	e7eb      	b.n	1bab2 <rpmsg_virtio_return_buffer+0x16>

0001bada <rpmsg_virtio_enqueue_buffer>:
{
   1bada:	b510      	push	{r4, lr}
   1badc:	b084      	sub	sp, #16
   1bade:	f8d0 4094 	ldr.w	r4, [r0, #148]	; 0x94
   1bae2:	69a4      	ldr	r4, [r4, #24]
	if (role == RPMSG_HOST) {
   1bae4:	b124      	cbz	r4, 1baf0 <rpmsg_virtio_enqueue_buffer+0x16>
	if (role == RPMSG_REMOTE) {
   1bae6:	2c01      	cmp	r4, #1
   1bae8:	d00d      	beq.n	1bb06 <rpmsg_virtio_enqueue_buffer+0x2c>
	return 0;
   1baea:	2000      	movs	r0, #0
}
   1baec:	b004      	add	sp, #16
   1baee:	bd10      	pop	{r4, pc}
		vqbuf.buf = buffer;
   1baf0:	9102      	str	r1, [sp, #8]
		vqbuf.len = len;
   1baf2:	9203      	str	r2, [sp, #12]
		return virtqueue_add_buffer(rvdev->svq, &vqbuf, 1, 0, buffer);
   1baf4:	9100      	str	r1, [sp, #0]
   1baf6:	2300      	movs	r3, #0
   1baf8:	2201      	movs	r2, #1
   1bafa:	a902      	add	r1, sp, #8
   1bafc:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   1bb00:	f7ff fd5a 	bl	1b5b8 <virtqueue_add_buffer>
   1bb04:	e7f2      	b.n	1baec <rpmsg_virtio_enqueue_buffer+0x12>
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
   1bb06:	4619      	mov	r1, r3
   1bb08:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   1bb0c:	f7f7 f8d4 	bl	12cb8 <virtqueue_add_consumed_buffer>
   1bb10:	e7ec      	b.n	1baec <rpmsg_virtio_enqueue_buffer+0x12>

0001bb12 <rpmsg_virtio_get_rx_buffer>:
{
   1bb12:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bb14:	4604      	mov	r4, r0
   1bb16:	460e      	mov	r6, r1
   1bb18:	4615      	mov	r5, r2
   1bb1a:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   1bb1e:	699f      	ldr	r7, [r3, #24]
	if (role == RPMSG_HOST) {
   1bb20:	b11f      	cbz	r7, 1bb2a <rpmsg_virtio_get_rx_buffer+0x18>
	void *data = NULL;
   1bb22:	2000      	movs	r0, #0
	if (role == RPMSG_REMOTE) {
   1bb24:	2f01      	cmp	r7, #1
   1bb26:	d005      	beq.n	1bb34 <rpmsg_virtio_get_rx_buffer+0x22>
}
   1bb28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		data = virtqueue_get_buffer(rvdev->rvq, len, idx);
   1bb2a:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
   1bb2e:	f7ff fd65 	bl	1b5fc <virtqueue_get_buffer>
   1bb32:	e7f7      	b.n	1bb24 <rpmsg_virtio_get_rx_buffer+0x12>
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
   1bb34:	4632      	mov	r2, r6
   1bb36:	4629      	mov	r1, r5
   1bb38:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
   1bb3c:	f7ff fd90 	bl	1b660 <virtqueue_get_available_buffer>
	return data;
   1bb40:	e7f2      	b.n	1bb28 <rpmsg_virtio_get_rx_buffer+0x16>

0001bb42 <rpmsg_virtio_release_rx_buffer>:
{
   1bb42:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bb44:	4604      	mov	r4, r0
	rp_hdr = RPMSG_LOCATE_HDR(rxbuf);
   1bb46:	f1a1 0710 	sub.w	r7, r1, #16
	idx = (uint16_t)(rp_hdr->reserved & ~RPMSG_BUF_HELD);
   1bb4a:	f851 5c08 	ldr.w	r5, [r1, #-8]
   1bb4e:	b2ad      	uxth	r5, r5
	metal_mutex_acquire(&rdev->lock);
   1bb50:	f100 0658 	add.w	r6, r0, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   1bb54:	f04f 32ff 	mov.w	r2, #4294967295
   1bb58:	f04f 33ff 	mov.w	r3, #4294967295
   1bb5c:	4630      	mov	r0, r6
   1bb5e:	f7f8 f83f 	bl	13be0 <z_impl_k_sem_take>
	len = virtqueue_get_buffer_length(rvdev->rvq, idx);
   1bb62:	4629      	mov	r1, r5
   1bb64:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
   1bb68:	f7ff fd75 	bl	1b656 <virtqueue_get_buffer_length>
   1bb6c:	4602      	mov	r2, r0
	rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
   1bb6e:	462b      	mov	r3, r5
   1bb70:	4639      	mov	r1, r7
   1bb72:	4620      	mov	r0, r4
   1bb74:	f7ff ff92 	bl	1ba9c <rpmsg_virtio_return_buffer>
	z_impl_k_sem_give(sem);
   1bb78:	4630      	mov	r0, r6
   1bb7a:	f7f8 f809 	bl	13b90 <z_impl_k_sem_give>
}
   1bb7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001bb80 <rpmsg_virtio_send_offchannel_nocopy>:
{
   1bb80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bb84:	b084      	sub	sp, #16
   1bb86:	4604      	mov	r4, r0
   1bb88:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	hdr = RPMSG_LOCATE_HDR(data);
   1bb8a:	f1a3 0710 	sub.w	r7, r3, #16
	idx = hdr->reserved;
   1bb8e:	f853 5c08 	ldr.w	r5, [r3, #-8]
   1bb92:	b2ad      	uxth	r5, r5
	rp_hdr.dst = dst;
   1bb94:	9201      	str	r2, [sp, #4]
	rp_hdr.src = src;
   1bb96:	9100      	str	r1, [sp, #0]
	rp_hdr.len = len;
   1bb98:	f8ad 600c 	strh.w	r6, [sp, #12]
	rp_hdr.reserved = 0;
   1bb9c:	2300      	movs	r3, #0
   1bb9e:	9302      	str	r3, [sp, #8]
	rp_hdr.flags = 0;
   1bba0:	f8ad 300e 	strh.w	r3, [sp, #14]
	io = rvdev->shbuf_io;
   1bba4:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
	size_t offset = (uintptr_t)virt - (uintptr_t)io->virt;
   1bba8:	6801      	ldr	r1, [r0, #0]
   1bbaa:	1a79      	subs	r1, r7, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
   1bbac:	6883      	ldr	r3, [r0, #8]
   1bbae:	4299      	cmp	r1, r3
   1bbb0:	d222      	bcs.n	1bbf8 <rpmsg_virtio_send_offchannel_nocopy+0x78>
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, hdr),
   1bbb2:	2310      	movs	r3, #16
   1bbb4:	466a      	mov	r2, sp
   1bbb6:	f7ff fb5d 	bl	1b274 <metal_io_block_write>
	metal_mutex_acquire(&rdev->lock);
   1bbba:	f104 0858 	add.w	r8, r4, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   1bbbe:	f04f 32ff 	mov.w	r2, #4294967295
   1bbc2:	f04f 33ff 	mov.w	r3, #4294967295
   1bbc6:	4640      	mov	r0, r8
   1bbc8:	f7f8 f80a 	bl	13be0 <z_impl_k_sem_take>
   1bbcc:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
   1bbd0:	699b      	ldr	r3, [r3, #24]
	if (rpmsg_virtio_get_role(rvdev) == RPMSG_HOST)
   1bbd2:	b9a3      	cbnz	r3, 1bbfe <rpmsg_virtio_send_offchannel_nocopy+0x7e>
		buff_len = rvdev->config.h2r_buf_size;
   1bbd4:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
	status = rpmsg_virtio_enqueue_buffer(rvdev, hdr, buff_len, idx);
   1bbd8:	462b      	mov	r3, r5
   1bbda:	4639      	mov	r1, r7
   1bbdc:	4620      	mov	r0, r4
   1bbde:	f7ff ff7c 	bl	1bada <rpmsg_virtio_enqueue_buffer>
	virtqueue_kick(rvdev->svq);
   1bbe2:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1bbe6:	f7ff fdde 	bl	1b7a6 <virtqueue_kick>
	z_impl_k_sem_give(sem);
   1bbea:	4640      	mov	r0, r8
   1bbec:	f7f7 ffd0 	bl	13b90 <z_impl_k_sem_give>
}
   1bbf0:	4630      	mov	r0, r6
   1bbf2:	b004      	add	sp, #16
   1bbf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1bbf8:	f04f 31ff 	mov.w	r1, #4294967295
   1bbfc:	e7d9      	b.n	1bbb2 <rpmsg_virtio_send_offchannel_nocopy+0x32>
		buff_len = virtqueue_get_buffer_length(rvdev->svq, idx);
   1bbfe:	4629      	mov	r1, r5
   1bc00:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1bc04:	f7ff fd27 	bl	1b656 <virtqueue_get_buffer_length>
   1bc08:	4602      	mov	r2, r0
   1bc0a:	e7e5      	b.n	1bbd8 <rpmsg_virtio_send_offchannel_nocopy+0x58>

0001bc0c <rpmsg_virtio_rx_callback>:
{
   1bc0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bc10:	b084      	sub	sp, #16
	struct virtio_device *vdev = vq->vq_dev;
   1bc12:	6803      	ldr	r3, [r0, #0]
	struct rpmsg_virtio_device *rvdev = vdev->priv;
   1bc14:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	metal_mutex_acquire(&rdev->lock);
   1bc16:	f107 0658 	add.w	r6, r7, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   1bc1a:	f04f 32ff 	mov.w	r2, #4294967295
   1bc1e:	f04f 33ff 	mov.w	r3, #4294967295
   1bc22:	4630      	mov	r0, r6
   1bc24:	f7f7 ffdc 	bl	13be0 <z_impl_k_sem_take>
	rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
   1bc28:	f10d 020a 	add.w	r2, sp, #10
   1bc2c:	a903      	add	r1, sp, #12
   1bc2e:	4638      	mov	r0, r7
   1bc30:	f7ff ff6f 	bl	1bb12 <rpmsg_virtio_get_rx_buffer>
   1bc34:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   1bc36:	4630      	mov	r0, r6
   1bc38:	f7f7 ffaa 	bl	13b90 <z_impl_k_sem_give>
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
	__metal_mutex_release(mutex);
}
   1bc3c:	e01e      	b.n	1bc7c <rpmsg_virtio_rx_callback+0x70>
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
   1bc3e:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
					 rp_hdr->len, rp_hdr->src, ept->priv);
   1bc42:	89a2      	ldrh	r2, [r4, #12]
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
   1bc44:	4621      	mov	r1, r4
   1bc46:	f851 3b10 	ldr.w	r3, [r1], #16
   1bc4a:	6be8      	ldr	r0, [r5, #60]	; 0x3c
   1bc4c:	9000      	str	r0, [sp, #0]
   1bc4e:	4628      	mov	r0, r5
   1bc50:	47c0      	blx	r8
	return z_impl_k_sem_take(sem, timeout);
   1bc52:	f04f 32ff 	mov.w	r2, #4294967295
   1bc56:	f04f 33ff 	mov.w	r3, #4294967295
   1bc5a:	4630      	mov	r0, r6
   1bc5c:	f7f7 ffc0 	bl	13be0 <z_impl_k_sem_take>
		if (!(rp_hdr->reserved & RPMSG_BUF_HELD)) {
   1bc60:	68a3      	ldr	r3, [r4, #8]
   1bc62:	2b00      	cmp	r3, #0
   1bc64:	da29      	bge.n	1bcba <rpmsg_virtio_rx_callback+0xae>
		rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
   1bc66:	f10d 020a 	add.w	r2, sp, #10
   1bc6a:	a903      	add	r1, sp, #12
   1bc6c:	4638      	mov	r0, r7
   1bc6e:	f7ff ff50 	bl	1bb12 <rpmsg_virtio_get_rx_buffer>
		if (!rp_hdr) {
   1bc72:	4604      	mov	r4, r0
   1bc74:	b348      	cbz	r0, 1bcca <rpmsg_virtio_rx_callback+0xbe>
	z_impl_k_sem_give(sem);
   1bc76:	4630      	mov	r0, r6
   1bc78:	f7f7 ff8a 	bl	13b90 <z_impl_k_sem_give>
	while (rp_hdr) {
   1bc7c:	b354      	cbz	r4, 1bcd4 <rpmsg_virtio_rx_callback+0xc8>
		rp_hdr->reserved = idx;
   1bc7e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   1bc82:	60a3      	str	r3, [r4, #8]
	return z_impl_k_sem_take(sem, timeout);
   1bc84:	f04f 32ff 	mov.w	r2, #4294967295
   1bc88:	f04f 33ff 	mov.w	r3, #4294967295
   1bc8c:	4630      	mov	r0, r6
   1bc8e:	f7f7 ffa7 	bl	13be0 <z_impl_k_sem_take>
			     rpmsg_ns_unbind_cb ns_unbind_cb);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
   1bc92:	f04f 33ff 	mov.w	r3, #4294967295
   1bc96:	6862      	ldr	r2, [r4, #4]
   1bc98:	2100      	movs	r1, #0
   1bc9a:	4638      	mov	r0, r7
   1bc9c:	f7ff fe45 	bl	1b92a <rpmsg_get_endpoint>
   1bca0:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   1bca2:	4630      	mov	r0, r6
   1bca4:	f7f7 ff74 	bl	13b90 <z_impl_k_sem_give>
		if (ept) {
   1bca8:	2d00      	cmp	r5, #0
   1bcaa:	d0d2      	beq.n	1bc52 <rpmsg_virtio_rx_callback+0x46>
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
   1bcac:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1bcae:	f1b3 3fff 	cmp.w	r3, #4294967295
   1bcb2:	d1c4      	bne.n	1bc3e <rpmsg_virtio_rx_callback+0x32>
				ept->dest_addr = rp_hdr->src;
   1bcb4:	6823      	ldr	r3, [r4, #0]
   1bcb6:	62ab      	str	r3, [r5, #40]	; 0x28
   1bcb8:	e7c1      	b.n	1bc3e <rpmsg_virtio_rx_callback+0x32>
			rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
   1bcba:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   1bcbe:	9a03      	ldr	r2, [sp, #12]
   1bcc0:	4621      	mov	r1, r4
   1bcc2:	4638      	mov	r0, r7
   1bcc4:	f7ff feea 	bl	1ba9c <rpmsg_virtio_return_buffer>
   1bcc8:	e7cd      	b.n	1bc66 <rpmsg_virtio_rx_callback+0x5a>
			virtqueue_kick(rvdev->rvq);
   1bcca:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
   1bcce:	f7ff fd6a 	bl	1b7a6 <virtqueue_kick>
   1bcd2:	e7d0      	b.n	1bc76 <rpmsg_virtio_rx_callback+0x6a>
}
   1bcd4:	b004      	add	sp, #16
   1bcd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001bcda <rpmsg_virtio_shm_pool_get_buffer>:
{
   1bcda:	4603      	mov	r3, r0
	if (shpool->avail < size)
   1bcdc:	6842      	ldr	r2, [r0, #4]
   1bcde:	428a      	cmp	r2, r1
   1bce0:	d308      	bcc.n	1bcf4 <rpmsg_virtio_shm_pool_get_buffer+0x1a>
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
   1bce2:	6800      	ldr	r0, [r0, #0]
   1bce4:	f8d3 c008 	ldr.w	ip, [r3, #8]
   1bce8:	ebac 0c02 	sub.w	ip, ip, r2
   1bcec:	4460      	add	r0, ip
	shpool->avail -= size;
   1bcee:	1a52      	subs	r2, r2, r1
   1bcf0:	605a      	str	r2, [r3, #4]
	return buffer;
   1bcf2:	4770      	bx	lr
		return NULL;
   1bcf4:	2000      	movs	r0, #0
}
   1bcf6:	4770      	bx	lr

0001bcf8 <rpmsg_virtio_get_tx_buffer>:
{
   1bcf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bcfa:	4604      	mov	r4, r0
   1bcfc:	460f      	mov	r7, r1
   1bcfe:	4616      	mov	r6, r2
   1bd00:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   1bd04:	699d      	ldr	r5, [r3, #24]
	if (role == RPMSG_HOST) {
   1bd06:	b11d      	cbz	r5, 1bd10 <rpmsg_virtio_get_tx_buffer+0x18>
	void *data = NULL;
   1bd08:	2000      	movs	r0, #0
	if (role == RPMSG_REMOTE) {
   1bd0a:	2d01      	cmp	r5, #1
   1bd0c:	d017      	beq.n	1bd3e <rpmsg_virtio_get_tx_buffer+0x46>
}
   1bd0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		data = virtqueue_get_buffer(rvdev->svq, len, idx);
   1bd10:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   1bd14:	f7ff fc72 	bl	1b5fc <virtqueue_get_buffer>
		if (!data && rvdev->svq->vq_free_cnt) {
   1bd18:	2800      	cmp	r0, #0
   1bd1a:	d1f6      	bne.n	1bd0a <rpmsg_virtio_get_tx_buffer+0x12>
   1bd1c:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
   1bd20:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
   1bd22:	2b00      	cmp	r3, #0
   1bd24:	d0f1      	beq.n	1bd0a <rpmsg_virtio_get_tx_buffer+0x12>
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
   1bd26:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
   1bd2a:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
   1bd2e:	f7ff ffd4 	bl	1bcda <rpmsg_virtio_shm_pool_get_buffer>
			*len = rvdev->config.h2r_buf_size;
   1bd32:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   1bd36:	603b      	str	r3, [r7, #0]
			*idx = 0;
   1bd38:	2300      	movs	r3, #0
   1bd3a:	8033      	strh	r3, [r6, #0]
   1bd3c:	e7e5      	b.n	1bd0a <rpmsg_virtio_get_tx_buffer+0x12>
		data = virtqueue_get_available_buffer(rvdev->svq, idx, len);
   1bd3e:	463a      	mov	r2, r7
   1bd40:	4631      	mov	r1, r6
   1bd42:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1bd46:	f7ff fc8b 	bl	1b660 <virtqueue_get_available_buffer>
	return data;
   1bd4a:	e7e0      	b.n	1bd0e <rpmsg_virtio_get_tx_buffer+0x16>

0001bd4c <rpmsg_virtio_get_tx_payload_buffer>:
{
   1bd4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bd50:	b082      	sub	sp, #8
   1bd52:	4607      	mov	r7, r0
   1bd54:	4688      	mov	r8, r1
   1bd56:	4616      	mov	r6, r2
	return rvdev->vdev->func->get_status(rvdev->vdev);
   1bd58:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
   1bd5c:	6a03      	ldr	r3, [r0, #32]
   1bd5e:	681b      	ldr	r3, [r3, #0]
   1bd60:	4798      	blx	r3
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK))
   1bd62:	f010 0f04 	tst.w	r0, #4
   1bd66:	d02b      	beq.n	1bdc0 <rpmsg_virtio_get_tx_payload_buffer+0x74>
	if (wait)
   1bd68:	b10e      	cbz	r6, 1bd6e <rpmsg_virtio_get_tx_payload_buffer+0x22>
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
   1bd6a:	f643 2698 	movw	r6, #15000	; 0x3a98
		metal_mutex_acquire(&rdev->lock);
   1bd6e:	f107 0458 	add.w	r4, r7, #88	; 0x58
	return z_impl_k_sem_take(sem, timeout);
   1bd72:	f04f 32ff 	mov.w	r2, #4294967295
   1bd76:	f04f 33ff 	mov.w	r3, #4294967295
   1bd7a:	4620      	mov	r0, r4
   1bd7c:	f7f7 ff30 	bl	13be0 <z_impl_k_sem_take>
		rp_hdr = rpmsg_virtio_get_tx_buffer(rvdev, len, &idx);
   1bd80:	f10d 0206 	add.w	r2, sp, #6
   1bd84:	4641      	mov	r1, r8
   1bd86:	4638      	mov	r0, r7
   1bd88:	f7ff ffb6 	bl	1bcf8 <rpmsg_virtio_get_tx_buffer>
   1bd8c:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   1bd8e:	4620      	mov	r0, r4
   1bd90:	f7f7 fefe 	bl	13b90 <z_impl_k_sem_give>
		if (rp_hdr || !tick_count)
   1bd94:	b935      	cbnz	r5, 1bda4 <rpmsg_virtio_get_tx_payload_buffer+0x58>
   1bd96:	b12e      	cbz	r6, 1bda4 <rpmsg_virtio_get_tx_payload_buffer+0x58>
	return z_impl_k_sleep(timeout);
   1bd98:	2021      	movs	r0, #33	; 0x21
   1bd9a:	2100      	movs	r1, #0
   1bd9c:	f7f8 fcc4 	bl	14728 <z_impl_k_sleep>
		tick_count--;
   1bda0:	3e01      	subs	r6, #1
		metal_mutex_acquire(&rdev->lock);
   1bda2:	e7e4      	b.n	1bd6e <rpmsg_virtio_get_tx_payload_buffer+0x22>
	if (!rp_hdr)
   1bda4:	b145      	cbz	r5, 1bdb8 <rpmsg_virtio_get_tx_payload_buffer+0x6c>
	rp_hdr->reserved = idx;
   1bda6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1bdaa:	60ab      	str	r3, [r5, #8]
	*len -= sizeof(struct rpmsg_hdr);
   1bdac:	f8d8 3000 	ldr.w	r3, [r8]
   1bdb0:	3b10      	subs	r3, #16
   1bdb2:	f8c8 3000 	str.w	r3, [r8]
	return RPMSG_LOCATE_DATA(rp_hdr);
   1bdb6:	3510      	adds	r5, #16
}
   1bdb8:	4628      	mov	r0, r5
   1bdba:	b002      	add	sp, #8
   1bdbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return NULL;
   1bdc0:	2500      	movs	r5, #0
   1bdc2:	e7f9      	b.n	1bdb8 <rpmsg_virtio_get_tx_payload_buffer+0x6c>

0001bdc4 <rpmsg_virtio_init_shm_pool>:
	if (!shpool)
   1bdc4:	b110      	cbz	r0, 1bdcc <rpmsg_virtio_init_shm_pool+0x8>
	shpool->base = shb;
   1bdc6:	6001      	str	r1, [r0, #0]
	shpool->size = size;
   1bdc8:	6082      	str	r2, [r0, #8]
	shpool->avail = size;
   1bdca:	6042      	str	r2, [r0, #4]
}
   1bdcc:	4770      	bx	lr

0001bdce <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   1bdce:	b148      	cbz	r0, 1bde4 <z_device_is_ready+0x16>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   1bdd0:	68c3      	ldr	r3, [r0, #12]
   1bdd2:	8818      	ldrh	r0, [r3, #0]
   1bdd4:	f3c0 0008 	ubfx	r0, r0, #0, #9
   1bdd8:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   1bddc:	bf14      	ite	ne
   1bdde:	2000      	movne	r0, #0
   1bde0:	2001      	moveq	r0, #1
   1bde2:	4770      	bx	lr
		return false;
   1bde4:	2000      	movs	r0, #0
}
   1bde6:	4770      	bx	lr

0001bde8 <z_early_memset>:
{
   1bde8:	b508      	push	{r3, lr}
	(void) memset(dst, c, n);
   1bdea:	f7fb fcd0 	bl	1778e <memset>
}
   1bdee:	bd08      	pop	{r3, pc}

0001bdf0 <z_early_memcpy>:
{
   1bdf0:	b508      	push	{r3, lr}
	(void) memcpy(dst, src, n);
   1bdf2:	f7fb fc9d 	bl	17730 <memcpy>
}
   1bdf6:	bd08      	pop	{r3, pc}

0001bdf8 <k_heap_init>:
{
   1bdf8:	b510      	push	{r4, lr}
	sys_dlist_init(&w->waitq);
   1bdfa:	f100 040c 	add.w	r4, r0, #12
	list->head = (sys_dnode_t *)list;
   1bdfe:	60c4      	str	r4, [r0, #12]
	list->tail = (sys_dnode_t *)list;
   1be00:	6104      	str	r4, [r0, #16]
	sys_heap_init(&h->heap, mem, bytes);
   1be02:	f7fa f932 	bl	1606a <sys_heap_init>
}
   1be06:	bd10      	pop	{r4, pc}

0001be08 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   1be08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1be0c:	b085      	sub	sp, #20
   1be0e:	4607      	mov	r7, r0
   1be10:	468a      	mov	sl, r1
   1be12:	9203      	str	r2, [sp, #12]
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   1be14:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1be18:	f000 fd7f 	bl	1c91a <sys_clock_timeout_end_calc>
   1be1c:	4606      	mov	r6, r0
   1be1e:	4689      	mov	r9, r1
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   1be20:	f107 0b14 	add.w	fp, r7, #20
	__asm__ volatile(
   1be24:	f04f 0320 	mov.w	r3, #32
   1be28:	f3ef 8511 	mrs	r5, BASEPRI
   1be2c:	f383 8812 	msr	BASEPRI_MAX, r3
   1be30:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, aligned_alloc, h, timeout);

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");

	bool blocked_alloc = false;
   1be34:	f04f 0800 	mov.w	r8, #0
	void *ret = NULL;
   1be38:	4644      	mov	r4, r8

	while (ret == NULL) {
   1be3a:	e00f      	b.n	1be5c <k_heap_aligned_alloc+0x54>
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   1be3c:	9000      	str	r0, [sp, #0]
   1be3e:	9101      	str	r1, [sp, #4]
   1be40:	f107 020c 	add.w	r2, r7, #12
   1be44:	4629      	mov	r1, r5
   1be46:	4658      	mov	r0, fp
   1be48:	f7f8 faa6 	bl	14398 <z_pend_curr>
   1be4c:	f04f 0320 	mov.w	r3, #32
   1be50:	f3ef 8511 	mrs	r5, BASEPRI
   1be54:	f383 8812 	msr	BASEPRI_MAX, r3
   1be58:	f3bf 8f6f 	isb	sy
	while (ret == NULL) {
   1be5c:	b9ac      	cbnz	r4, 1be8a <k_heap_aligned_alloc+0x82>
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   1be5e:	9a03      	ldr	r2, [sp, #12]
   1be60:	4651      	mov	r1, sl
   1be62:	4638      	mov	r0, r7
   1be64:	f7fa f86d 	bl	15f42 <sys_heap_aligned_alloc>
   1be68:	4604      	mov	r4, r0
		now = sys_clock_tick_get();
   1be6a:	f7f8 fe2b 	bl	14ac4 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   1be6e:	b964      	cbnz	r4, 1be8a <k_heap_aligned_alloc+0x82>
		    (ret != NULL) || ((end - now) <= 0)) {
   1be70:	1a30      	subs	r0, r6, r0
   1be72:	eb69 0101 	sbc.w	r1, r9, r1
   1be76:	2801      	cmp	r0, #1
   1be78:	f171 0300 	sbcs.w	r3, r1, #0
   1be7c:	db05      	blt.n	1be8a <k_heap_aligned_alloc+0x82>
		if (!blocked_alloc) {
   1be7e:	f1b8 0f00 	cmp.w	r8, #0
   1be82:	d1db      	bne.n	1be3c <k_heap_aligned_alloc+0x34>
			blocked_alloc = true;
   1be84:	f04f 0801 	mov.w	r8, #1
   1be88:	e7d8      	b.n	1be3c <k_heap_aligned_alloc+0x34>
	__asm__ volatile(
   1be8a:	f385 8811 	msr	BASEPRI, r5
   1be8e:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   1be92:	4620      	mov	r0, r4
   1be94:	b005      	add	sp, #20
   1be96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001be9a <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   1be9a:	b570      	push	{r4, r5, r6, lr}
   1be9c:	4604      	mov	r4, r0
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   1be9e:	f100 0614 	add.w	r6, r0, #20
	__asm__ volatile(
   1bea2:	f04f 0320 	mov.w	r3, #32
   1bea6:	f3ef 8511 	mrs	r5, BASEPRI
   1beaa:	f383 8812 	msr	BASEPRI_MAX, r3
   1beae:	f3bf 8f6f 	isb	sy

	sys_heap_free(&h->heap, mem);
   1beb2:	f7f9 ffe2 	bl	15e7a <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   1beb6:	f104 000c 	add.w	r0, r4, #12
   1beba:	f000 fc5e 	bl	1c77a <z_unpend_all>
   1bebe:	b920      	cbnz	r0, 1beca <k_heap_free+0x30>
	__asm__ volatile(
   1bec0:	f385 8811 	msr	BASEPRI, r5
   1bec4:	f3bf 8f6f 	isb	sy
		z_reschedule(&h->lock, key);
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   1bec8:	bd70      	pop	{r4, r5, r6, pc}
		z_reschedule(&h->lock, key);
   1beca:	4629      	mov	r1, r5
   1becc:	4630      	mov	r0, r6
   1bece:	f7f8 f8db 	bl	14088 <z_reschedule>
   1bed2:	e7f9      	b.n	1bec8 <k_heap_free+0x2e>

0001bed4 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   1bed4:	68c2      	ldr	r2, [r0, #12]
   1bed6:	6903      	ldr	r3, [r0, #16]
   1bed8:	431a      	orrs	r2, r3
   1beda:	f012 0203 	ands.w	r2, r2, #3
   1bede:	d10d      	bne.n	1befc <create_free_list+0x28>
	slab->free_list = NULL;
   1bee0:	2100      	movs	r1, #0
   1bee2:	6141      	str	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1bee4:	e005      	b.n	1bef2 <create_free_list+0x1e>
		*(char **)p = slab->free_list;
   1bee6:	6941      	ldr	r1, [r0, #20]
   1bee8:	6019      	str	r1, [r3, #0]
		slab->free_list = p;
   1beea:	6143      	str	r3, [r0, #20]
		p += slab->block_size;
   1beec:	68c1      	ldr	r1, [r0, #12]
   1beee:	440b      	add	r3, r1
	for (j = 0U; j < slab->num_blocks; j++) {
   1bef0:	3201      	adds	r2, #1
   1bef2:	6881      	ldr	r1, [r0, #8]
   1bef4:	4291      	cmp	r1, r2
   1bef6:	d8f6      	bhi.n	1bee6 <create_free_list+0x12>
	return 0;
   1bef8:	2000      	movs	r0, #0
   1befa:	4770      	bx	lr
		return -EINVAL;
   1befc:	f06f 0015 	mvn.w	r0, #21
}
   1bf00:	4770      	bx	lr

0001bf02 <k_mem_slab_init>:
{
   1bf02:	b510      	push	{r4, lr}
   1bf04:	4604      	mov	r4, r0
	slab->num_blocks = num_blocks;
   1bf06:	6083      	str	r3, [r0, #8]
	slab->block_size = block_size;
   1bf08:	60c2      	str	r2, [r0, #12]
	slab->buffer = buffer;
   1bf0a:	6101      	str	r1, [r0, #16]
	slab->num_used = 0U;
   1bf0c:	2300      	movs	r3, #0
   1bf0e:	6183      	str	r3, [r0, #24]
	rc = create_free_list(slab);
   1bf10:	f7ff ffe0 	bl	1bed4 <create_free_list>
	if (rc < 0) {
   1bf14:	2800      	cmp	r0, #0
   1bf16:	db01      	blt.n	1bf1c <k_mem_slab_init+0x1a>
	list->head = (sys_dnode_t *)list;
   1bf18:	6024      	str	r4, [r4, #0]
	list->tail = (sys_dnode_t *)list;
   1bf1a:	6064      	str	r4, [r4, #4]
}
   1bf1c:	bd10      	pop	{r4, pc}

0001bf1e <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   1bf1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1bf20:	4604      	mov	r4, r0
   1bf22:	460d      	mov	r5, r1
	__asm__ volatile(
   1bf24:	f04f 0320 	mov.w	r3, #32
   1bf28:	f3ef 8611 	mrs	r6, BASEPRI
   1bf2c:	f383 8812 	msr	BASEPRI_MAX, r3
   1bf30:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   1bf34:	6943      	ldr	r3, [r0, #20]
   1bf36:	b163      	cbz	r3, 1bf52 <k_mem_slab_free+0x34>
			z_ready_thread(pending_thread);
			z_reschedule(&slab->lock, key);
			return;
		}
	}
	**(char ***) mem = slab->free_list;
   1bf38:	682b      	ldr	r3, [r5, #0]
   1bf3a:	6962      	ldr	r2, [r4, #20]
   1bf3c:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   1bf3e:	682b      	ldr	r3, [r5, #0]
   1bf40:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   1bf42:	69a3      	ldr	r3, [r4, #24]
   1bf44:	3b01      	subs	r3, #1
   1bf46:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   1bf48:	f386 8811 	msr	BASEPRI, r6
   1bf4c:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   1bf50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1bf52:	f100 0708 	add.w	r7, r0, #8
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   1bf56:	f000 fbe5 	bl	1c724 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   1bf5a:	2800      	cmp	r0, #0
   1bf5c:	d0ec      	beq.n	1bf38 <k_mem_slab_free+0x1a>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   1bf5e:	682a      	ldr	r2, [r5, #0]
   1bf60:	2100      	movs	r1, #0
   1bf62:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   1bf66:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   1bf68:	f000 fb15 	bl	1c596 <z_ready_thread>
			z_reschedule(&slab->lock, key);
   1bf6c:	4631      	mov	r1, r6
   1bf6e:	4638      	mov	r0, r7
   1bf70:	f7f8 f88a 	bl	14088 <z_reschedule>
			return;
   1bf74:	e7ec      	b.n	1bf50 <k_mem_slab_free+0x32>

0001bf76 <setup_thread_stack>:
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   1bf76:	3207      	adds	r2, #7
   1bf78:	f022 0207 	bic.w	r2, r2, #7
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
   1bf7c:	f8c0 109c 	str.w	r1, [r0, #156]	; 0x9c
	new_thread->stack_info.size = stack_buf_size;
   1bf80:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
	new_thread->stack_info.delta = delta;
   1bf84:	2300      	movs	r3, #0
   1bf86:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
}
   1bf8a:	1888      	adds	r0, r1, r2
   1bf8c:	4770      	bx	lr

0001bf8e <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1bf8e:	f3ef 8005 	mrs	r0, IPSR
}
   1bf92:	3800      	subs	r0, #0
   1bf94:	bf18      	it	ne
   1bf96:	2001      	movne	r0, #1
   1bf98:	4770      	bx	lr

0001bf9a <k_thread_name_get>:
}
   1bf9a:	3078      	adds	r0, #120	; 0x78
   1bf9c:	4770      	bx	lr

0001bf9e <z_impl_k_thread_start>:
{
   1bf9e:	b508      	push	{r3, lr}
	z_sched_start(thread);
   1bfa0:	f7f8 f9c0 	bl	14324 <z_sched_start>
}
   1bfa4:	bd08      	pop	{r3, pc}

0001bfa6 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
   1bfa6:	b410      	push	{r4}
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
   1bfa8:	2400      	movs	r4, #0
   1bfaa:	6084      	str	r4, [r0, #8]
	thread_base->user_options = (uint8_t)options;
   1bfac:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   1bfae:	7342      	strb	r2, [r0, #13]

	thread_base->prio = priority;
   1bfb0:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
   1bfb2:	73c4      	strb	r4, [r0, #15]
	node->next = NULL;
   1bfb4:	6184      	str	r4, [r0, #24]
	node->prev = NULL;
   1bfb6:	61c4      	str	r4, [r0, #28]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
   1bfb8:	bc10      	pop	{r4}
   1bfba:	4770      	bx	lr

0001bfbc <z_impl_k_thread_create>:
{
   1bfbc:	b5f0      	push	{r4, r5, r6, r7, lr}
   1bfbe:	b087      	sub	sp, #28
   1bfc0:	4604      	mov	r4, r0
   1bfc2:	9e12      	ldr	r6, [sp, #72]	; 0x48
   1bfc4:	9d13      	ldr	r5, [sp, #76]	; 0x4c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1bfc6:	2700      	movs	r7, #0
   1bfc8:	9705      	str	r7, [sp, #20]
   1bfca:	9f10      	ldr	r7, [sp, #64]	; 0x40
   1bfcc:	9704      	str	r7, [sp, #16]
   1bfce:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
   1bfd0:	9703      	str	r7, [sp, #12]
   1bfd2:	9f0e      	ldr	r7, [sp, #56]	; 0x38
   1bfd4:	9702      	str	r7, [sp, #8]
   1bfd6:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   1bfd8:	9701      	str	r7, [sp, #4]
   1bfda:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   1bfdc:	9700      	str	r7, [sp, #0]
   1bfde:	f7f7 fc09 	bl	137f4 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   1bfe2:	f1b5 3fff 	cmp.w	r5, #4294967295
   1bfe6:	bf08      	it	eq
   1bfe8:	f1b6 3fff 	cmpeq.w	r6, #4294967295
   1bfec:	d102      	bne.n	1bff4 <z_impl_k_thread_create+0x38>
}
   1bfee:	4620      	mov	r0, r4
   1bff0:	b007      	add	sp, #28
   1bff2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		schedule_new_thread(new_thread, delay);
   1bff4:	4632      	mov	r2, r6
   1bff6:	462b      	mov	r3, r5
   1bff8:	4620      	mov	r0, r4
   1bffa:	f7f7 fbed 	bl	137d8 <schedule_new_thread>
   1bffe:	e7f6      	b.n	1bfee <z_impl_k_thread_create+0x32>

0001c000 <z_pm_save_idle_exit>:
{
   1c000:	b508      	push	{r3, lr}
	pm_system_resume();
   1c002:	f7e6 ff9d 	bl	2f40 <pm_system_resume>
	sys_clock_idle_exit();
   1c006:	f7fe fdcf 	bl	1aba8 <sys_clock_idle_exit>
}
   1c00a:	bd08      	pop	{r3, pc}

0001c00c <new_prio_for_inheritance>:
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
   1c00c:	4288      	cmp	r0, r1
   1c00e:	da00      	bge.n	1c012 <new_prio_for_inheritance+0x6>
   1c010:	4601      	mov	r1, r0
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   1c012:	f111 0f7f 	cmn.w	r1, #127	; 0x7f
   1c016:	db01      	blt.n	1c01c <new_prio_for_inheritance+0x10>
   1c018:	4608      	mov	r0, r1
   1c01a:	4770      	bx	lr
   1c01c:	f06f 007e 	mvn.w	r0, #126	; 0x7e
}
   1c020:	4770      	bx	lr

0001c022 <adjust_owner_prio>:
{
   1c022:	b508      	push	{r3, lr}
	if (mutex->owner->base.prio != new_prio) {
   1c024:	6880      	ldr	r0, [r0, #8]
   1c026:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1c02a:	428b      	cmp	r3, r1
   1c02c:	d101      	bne.n	1c032 <adjust_owner_prio+0x10>
	return false;
   1c02e:	2000      	movs	r0, #0
}
   1c030:	bd08      	pop	{r3, pc}
		return z_set_prio(mutex->owner, new_prio);
   1c032:	f7f8 f9c5 	bl	143c0 <z_set_prio>
   1c036:	e7fb      	b.n	1c030 <adjust_owner_prio+0xe>

0001c038 <z_impl_k_mutex_init>:
{
   1c038:	4603      	mov	r3, r0
	mutex->owner = NULL;
   1c03a:	2000      	movs	r0, #0
   1c03c:	6098      	str	r0, [r3, #8]
	mutex->lock_count = 0U;
   1c03e:	60d8      	str	r0, [r3, #12]
	list->head = (sys_dnode_t *)list;
   1c040:	601b      	str	r3, [r3, #0]
	list->tail = (sys_dnode_t *)list;
   1c042:	605b      	str	r3, [r3, #4]
}
   1c044:	4770      	bx	lr

0001c046 <prepare_thread_to_run>:
{
   1c046:	b508      	push	{r3, lr}
   1c048:	2200      	movs	r2, #0
   1c04a:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
   1c04e:	6141      	str	r1, [r0, #20]
	z_ready_thread(thread);
   1c050:	f000 faa1 	bl	1c596 <z_ready_thread>
}
   1c054:	bd08      	pop	{r3, pc}

0001c056 <queue_insert>:
{
   1c056:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1c05a:	4605      	mov	r5, r0
   1c05c:	460e      	mov	r6, r1
   1c05e:	4614      	mov	r4, r2
   1c060:	4699      	mov	r9, r3
   1c062:	f89d 2020 	ldrb.w	r2, [sp, #32]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1c066:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
   1c06a:	f04f 0320 	mov.w	r3, #32
   1c06e:	f3ef 8811 	mrs	r8, BASEPRI
   1c072:	f383 8812 	msr	BASEPRI_MAX, r3
   1c076:	f3bf 8f6f 	isb	sy
	if (is_append) {
   1c07a:	b102      	cbz	r2, 1c07e <queue_insert+0x28>
	return list->tail;
   1c07c:	6846      	ldr	r6, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   1c07e:	4638      	mov	r0, r7
   1c080:	f000 fb50 	bl	1c724 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   1c084:	b9f8      	cbnz	r0, 1c0c6 <queue_insert+0x70>
	if (alloc) {
   1c086:	f1b9 0f00 	cmp.w	r9, #0
   1c08a:	d125      	bne.n	1c0d8 <queue_insert+0x82>
	node->next_and_flags = flags;
   1c08c:	2300      	movs	r3, #0
   1c08e:	6023      	str	r3, [r4, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1c090:	b39e      	cbz	r6, 1c0fa <queue_insert+0xa4>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1c092:	6833      	ldr	r3, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1c094:	f033 0303 	bics.w	r3, r3, #3
   1c098:	d03b      	beq.n	1c112 <queue_insert+0xbc>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c09a:	6822      	ldr	r2, [r4, #0]
   1c09c:	f002 0203 	and.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   1c0a0:	4313      	orrs	r3, r2
   1c0a2:	6023      	str	r3, [r4, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c0a4:	6833      	ldr	r3, [r6, #0]
   1c0a6:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   1c0aa:	431c      	orrs	r4, r3
   1c0ac:	6034      	str	r4, [r6, #0]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1c0ae:	2104      	movs	r1, #4
   1c0b0:	f105 0010 	add.w	r0, r5, #16
   1c0b4:	f000 fd0b 	bl	1cace <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   1c0b8:	4641      	mov	r1, r8
   1c0ba:	4638      	mov	r0, r7
   1c0bc:	f7f7 ffe4 	bl	14088 <z_reschedule>
	return 0;
   1c0c0:	2000      	movs	r0, #0
}
   1c0c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		prepare_thread_to_run(first_pending_thread, data);
   1c0c6:	4621      	mov	r1, r4
   1c0c8:	f7ff ffbd 	bl	1c046 <prepare_thread_to_run>
		z_reschedule(&queue->lock, key);
   1c0cc:	4641      	mov	r1, r8
   1c0ce:	4638      	mov	r0, r7
   1c0d0:	f7f7 ffda 	bl	14088 <z_reschedule>
		return 0;
   1c0d4:	2000      	movs	r0, #0
   1c0d6:	e7f4      	b.n	1c0c2 <queue_insert+0x6c>
	return z_thread_aligned_alloc(0, size);
   1c0d8:	2108      	movs	r1, #8
   1c0da:	2000      	movs	r0, #0
   1c0dc:	f7f9 f8b8 	bl	15250 <z_thread_aligned_alloc>
		if (anode == NULL) {
   1c0e0:	b120      	cbz	r0, 1c0ec <queue_insert+0x96>
		anode->data = data;
   1c0e2:	6044      	str	r4, [r0, #4]
	node->next_and_flags = flags;
   1c0e4:	2201      	movs	r2, #1
   1c0e6:	6002      	str	r2, [r0, #0]
		data = anode;
   1c0e8:	4604      	mov	r4, r0
   1c0ea:	e7d1      	b.n	1c090 <queue_insert+0x3a>
	__asm__ volatile(
   1c0ec:	f388 8811 	msr	BASEPRI, r8
   1c0f0:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   1c0f4:	f06f 000b 	mvn.w	r0, #11
   1c0f8:	e7e3      	b.n	1c0c2 <queue_insert+0x6c>
	return list->head;
   1c0fa:	682a      	ldr	r2, [r5, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c0fc:	6823      	ldr	r3, [r4, #0]
   1c0fe:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   1c102:	4313      	orrs	r3, r2
   1c104:	6023      	str	r3, [r4, #0]
	list->head = node;
   1c106:	602c      	str	r4, [r5, #0]
	return list->tail;
   1c108:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_PREPEND(sflist, sfnode)
   1c10a:	2b00      	cmp	r3, #0
   1c10c:	d1cf      	bne.n	1c0ae <queue_insert+0x58>
	list->tail = node;
   1c10e:	606c      	str	r4, [r5, #4]
}
   1c110:	e7cd      	b.n	1c0ae <queue_insert+0x58>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c112:	6823      	ldr	r3, [r4, #0]
   1c114:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   1c118:	6023      	str	r3, [r4, #0]
	return list->tail;
   1c11a:	686a      	ldr	r2, [r5, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   1c11c:	b132      	cbz	r2, 1c12c <queue_insert+0xd6>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c11e:	6813      	ldr	r3, [r2, #0]
   1c120:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   1c124:	4323      	orrs	r3, r4
   1c126:	6013      	str	r3, [r2, #0]
	list->tail = node;
   1c128:	606c      	str	r4, [r5, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   1c12a:	e7c0      	b.n	1c0ae <queue_insert+0x58>
	list->tail = node;
   1c12c:	606c      	str	r4, [r5, #4]
	list->head = node;
   1c12e:	602c      	str	r4, [r5, #0]
}
   1c130:	e7bd      	b.n	1c0ae <queue_insert+0x58>

0001c132 <z_queue_node_peek>:
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   1c132:	b160      	cbz	r0, 1c14e <z_queue_node_peek+0x1c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c134:	6803      	ldr	r3, [r0, #0]
   1c136:	f013 0f03 	tst.w	r3, #3
   1c13a:	d008      	beq.n	1c14e <z_queue_node_peek+0x1c>
{
   1c13c:	b510      	push	{r4, lr}
		ret = anode->data;
   1c13e:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   1c140:	b909      	cbnz	r1, 1c146 <z_queue_node_peek+0x14>
		ret = anode->data;
   1c142:	4620      	mov	r0, r4
}
   1c144:	bd10      	pop	{r4, pc}
			k_free(anode);
   1c146:	f000 fcf0 	bl	1cb2a <k_free>
		ret = anode->data;
   1c14a:	4620      	mov	r0, r4
   1c14c:	e7fa      	b.n	1c144 <z_queue_node_peek+0x12>
}
   1c14e:	4770      	bx	lr

0001c150 <z_impl_k_queue_init>:
	list->head = NULL;
   1c150:	2300      	movs	r3, #0
   1c152:	6003      	str	r3, [r0, #0]
	list->tail = NULL;
   1c154:	6043      	str	r3, [r0, #4]
   1c156:	f100 0308 	add.w	r3, r0, #8
	list->head = (sys_dnode_t *)list;
   1c15a:	6083      	str	r3, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   1c15c:	60c3      	str	r3, [r0, #12]
	sys_dlist_init(&queue->poll_events);
   1c15e:	f100 0310 	add.w	r3, r0, #16
	list->head = (sys_dnode_t *)list;
   1c162:	6103      	str	r3, [r0, #16]
	list->tail = (sys_dnode_t *)list;
   1c164:	6143      	str	r3, [r0, #20]
}
   1c166:	4770      	bx	lr

0001c168 <k_queue_append>:
{
   1c168:	b500      	push	{lr}
   1c16a:	b083      	sub	sp, #12
   1c16c:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   1c16e:	2301      	movs	r3, #1
   1c170:	9300      	str	r3, [sp, #0]
   1c172:	2300      	movs	r3, #0
   1c174:	4619      	mov	r1, r3
   1c176:	f7ff ff6e 	bl	1c056 <queue_insert>
}
   1c17a:	b003      	add	sp, #12
   1c17c:	f85d fb04 	ldr.w	pc, [sp], #4

0001c180 <k_queue_prepend>:
{
   1c180:	b500      	push	{lr}
   1c182:	b083      	sub	sp, #12
   1c184:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, false);
   1c186:	2100      	movs	r1, #0
   1c188:	9100      	str	r1, [sp, #0]
   1c18a:	460b      	mov	r3, r1
   1c18c:	f7ff ff63 	bl	1c056 <queue_insert>
}
   1c190:	b003      	add	sp, #12
   1c192:	f85d fb04 	ldr.w	pc, [sp], #4

0001c196 <k_queue_append_list>:
	CHECKIF(head == NULL || tail == NULL) {
   1c196:	2900      	cmp	r1, #0
   1c198:	d036      	beq.n	1c208 <k_queue_append_list+0x72>
{
   1c19a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c19e:	4606      	mov	r6, r0
   1c1a0:	4617      	mov	r7, r2
   1c1a2:	460c      	mov	r4, r1
	CHECKIF(head == NULL || tail == NULL) {
   1c1a4:	b39a      	cbz	r2, 1c20e <k_queue_append_list+0x78>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1c1a6:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   1c1aa:	f04f 0320 	mov.w	r3, #32
   1c1ae:	f3ef 8811 	mrs	r8, BASEPRI
   1c1b2:	f383 8812 	msr	BASEPRI_MAX, r3
   1c1b6:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
   1c1ba:	4628      	mov	r0, r5
   1c1bc:	f000 fab2 	bl	1c724 <z_unpend_first_thread>
   1c1c0:	e006      	b.n	1c1d0 <k_queue_append_list+0x3a>
		prepare_thread_to_run(thread, head);
   1c1c2:	4621      	mov	r1, r4
   1c1c4:	f7ff ff3f 	bl	1c046 <prepare_thread_to_run>
		head = *(void **)head;
   1c1c8:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
   1c1ca:	4628      	mov	r0, r5
   1c1cc:	f000 faaa 	bl	1c724 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
   1c1d0:	b10c      	cbz	r4, 1c1d6 <k_queue_append_list+0x40>
   1c1d2:	2800      	cmp	r0, #0
   1c1d4:	d1f5      	bne.n	1c1c2 <k_queue_append_list+0x2c>
	if (head != NULL) {
   1c1d6:	b14c      	cbz	r4, 1c1ec <k_queue_append_list+0x56>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   1c1d8:	b144      	cbz	r4, 1c1ec <k_queue_append_list+0x56>
   1c1da:	b13f      	cbz	r7, 1c1ec <k_queue_append_list+0x56>
	return list->tail;
   1c1dc:	6872      	ldr	r2, [r6, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   1c1de:	b18a      	cbz	r2, 1c204 <k_queue_append_list+0x6e>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1c1e0:	6813      	ldr	r3, [r2, #0]
   1c1e2:	f003 0303 	and.w	r3, r3, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   1c1e6:	431c      	orrs	r4, r3
   1c1e8:	6014      	str	r4, [r2, #0]
	list->tail = node;
   1c1ea:	6077      	str	r7, [r6, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1c1ec:	2104      	movs	r1, #4
   1c1ee:	f106 0010 	add.w	r0, r6, #16
   1c1f2:	f000 fc6c 	bl	1cace <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   1c1f6:	4641      	mov	r1, r8
   1c1f8:	4628      	mov	r0, r5
   1c1fa:	f7f7 ff45 	bl	14088 <z_reschedule>
	return 0;
   1c1fe:	2000      	movs	r0, #0
}
   1c200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	list->head = node;
   1c204:	6034      	str	r4, [r6, #0]
}
   1c206:	e7f0      	b.n	1c1ea <k_queue_append_list+0x54>
		return -EINVAL;
   1c208:	f06f 0015 	mvn.w	r0, #21
}
   1c20c:	4770      	bx	lr
		return -EINVAL;
   1c20e:	f06f 0015 	mvn.w	r0, #21
   1c212:	e7f5      	b.n	1c200 <k_queue_append_list+0x6a>

0001c214 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   1c214:	b15a      	cbz	r2, 1c22e <z_impl_k_sem_init+0x1a>
   1c216:	428a      	cmp	r2, r1
   1c218:	d30c      	bcc.n	1c234 <z_impl_k_sem_init+0x20>
	sem->count = initial_count;
   1c21a:	6081      	str	r1, [r0, #8]
	sem->limit = limit;
   1c21c:	60c2      	str	r2, [r0, #12]
	list->head = (sys_dnode_t *)list;
   1c21e:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   1c220:	6040      	str	r0, [r0, #4]
	sys_dlist_init(&sem->poll_events);
   1c222:	f100 0310 	add.w	r3, r0, #16
	list->head = (sys_dnode_t *)list;
   1c226:	6103      	str	r3, [r0, #16]
	list->tail = (sys_dnode_t *)list;
   1c228:	6143      	str	r3, [r0, #20]
	return 0;
   1c22a:	2000      	movs	r0, #0
   1c22c:	4770      	bx	lr
		return -EINVAL;
   1c22e:	f06f 0015 	mvn.w	r0, #21
   1c232:	4770      	bx	lr
   1c234:	f06f 0015 	mvn.w	r0, #21
}
   1c238:	4770      	bx	lr

0001c23a <cancel_async_locked>:
{
   1c23a:	4603      	mov	r3, r0
	return (*flagp & BIT(bit)) != 0U;
   1c23c:	68c2      	ldr	r2, [r0, #12]
	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   1c23e:	f012 0f02 	tst.w	r2, #2
   1c242:	d009      	beq.n	1c258 <cancel_async_locked+0x1e>
	return *flagp;
   1c244:	68da      	ldr	r2, [r3, #12]
	if (ret != 0) {
   1c246:	f012 000f 	ands.w	r0, r2, #15
   1c24a:	d004      	beq.n	1c256 <cancel_async_locked+0x1c>
	*flagp |= BIT(bit);
   1c24c:	f042 0202 	orr.w	r2, r2, #2
   1c250:	60da      	str	r2, [r3, #12]
	return flags_get(&work->flags) & K_WORK_MASK;
   1c252:	f002 000f 	and.w	r0, r2, #15
}
   1c256:	4770      	bx	lr
		queue_remove_locked(work->queue, work);
   1c258:	6880      	ldr	r0, [r0, #8]
	*flagp &= ~BIT(bit);
   1c25a:	f022 0104 	bic.w	r1, r2, #4
   1c25e:	60d9      	str	r1, [r3, #12]
	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
   1c260:	f012 0f04 	tst.w	r2, #4
   1c264:	d0ee      	beq.n	1c244 <cancel_async_locked+0xa>
		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
   1c266:	f100 0cb8 	add.w	ip, r0, #184	; 0xb8
	return list->head;
   1c26a:	f8d0 20b8 	ldr.w	r2, [r0, #184]	; 0xb8
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1c26e:	2100      	movs	r1, #0
   1c270:	2a00      	cmp	r2, #0
   1c272:	d0e7      	beq.n	1c244 <cancel_async_locked+0xa>
   1c274:	4293      	cmp	r3, r2
   1c276:	d002      	beq.n	1c27e <cancel_async_locked+0x44>
   1c278:	4611      	mov	r1, r2
   1c27a:	6812      	ldr	r2, [r2, #0]
   1c27c:	e7f8      	b.n	1c270 <cancel_async_locked+0x36>
Z_GENLIST_REMOVE(slist, snode)
   1c27e:	b141      	cbz	r1, 1c292 <cancel_async_locked+0x58>
	return node->next;
   1c280:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   1c282:	600a      	str	r2, [r1, #0]
	return list->tail;
   1c284:	f8dc 2004 	ldr.w	r2, [ip, #4]
Z_GENLIST_REMOVE(slist, snode)
   1c288:	4293      	cmp	r3, r2
   1c28a:	d00c      	beq.n	1c2a6 <cancel_async_locked+0x6c>
	parent->next = child;
   1c28c:	2200      	movs	r2, #0
   1c28e:	601a      	str	r2, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c290:	e7d8      	b.n	1c244 <cancel_async_locked+0xa>
	return node->next;
   1c292:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   1c294:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
	return list->tail;
   1c298:	f8dc 1004 	ldr.w	r1, [ip, #4]
Z_GENLIST_REMOVE(slist, snode)
   1c29c:	428b      	cmp	r3, r1
   1c29e:	d1f5      	bne.n	1c28c <cancel_async_locked+0x52>
	list->tail = node;
   1c2a0:	f8cc 2004 	str.w	r2, [ip, #4]
}
   1c2a4:	e7f2      	b.n	1c28c <cancel_async_locked+0x52>
	list->tail = node;
   1c2a6:	f8cc 1004 	str.w	r1, [ip, #4]
}
   1c2aa:	e7ef      	b.n	1c28c <cancel_async_locked+0x52>

0001c2ac <work_timeout>:
{
   1c2ac:	b510      	push	{r4, lr}
   1c2ae:	b082      	sub	sp, #8
   1c2b0:	4603      	mov	r3, r0
   1c2b2:	f04f 0220 	mov.w	r2, #32
   1c2b6:	f3ef 8411 	mrs	r4, BASEPRI
   1c2ba:	f382 8812 	msr	BASEPRI_MAX, r2
   1c2be:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   1c2c2:	2200      	movs	r2, #0
   1c2c4:	9201      	str	r2, [sp, #4]
	return (*flagp & BIT(bit)) != 0U;
   1c2c6:	f850 2c04 	ldr.w	r2, [r0, #-4]
	*flagp &= ~BIT(bit);
   1c2ca:	f022 0108 	bic.w	r1, r2, #8
   1c2ce:	f840 1c04 	str.w	r1, [r0, #-4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   1c2d2:	f012 0f08 	tst.w	r2, #8
   1c2d6:	d105      	bne.n	1c2e4 <work_timeout+0x38>
	__asm__ volatile(
   1c2d8:	f384 8811 	msr	BASEPRI, r4
   1c2dc:	f3bf 8f6f 	isb	sy
}
   1c2e0:	b002      	add	sp, #8
   1c2e2:	bd10      	pop	{r4, pc}
   1c2e4:	3810      	subs	r0, #16
		queue = dw->queue;
   1c2e6:	699b      	ldr	r3, [r3, #24]
   1c2e8:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   1c2ea:	a901      	add	r1, sp, #4
   1c2ec:	f7f7 fcba 	bl	13c64 <submit_to_queue_locked>
   1c2f0:	e7f2      	b.n	1c2d8 <work_timeout+0x2c>

0001c2f2 <cancel_delayable_async_locked>:
{
   1c2f2:	b510      	push	{r4, lr}
   1c2f4:	4604      	mov	r4, r0
	return (*flagp & BIT(bit)) != 0U;
   1c2f6:	68c3      	ldr	r3, [r0, #12]
	*flagp &= ~BIT(bit);
   1c2f8:	f023 0208 	bic.w	r2, r3, #8
   1c2fc:	60c2      	str	r2, [r0, #12]
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   1c2fe:	f013 0f08 	tst.w	r3, #8
   1c302:	d103      	bne.n	1c30c <cancel_delayable_async_locked+0x1a>
	return cancel_async_locked(&dwork->work);
   1c304:	4620      	mov	r0, r4
   1c306:	f7ff ff98 	bl	1c23a <cancel_async_locked>
}
   1c30a:	bd10      	pop	{r4, pc}
		z_abort_timeout(&dwork->timeout);
   1c30c:	3010      	adds	r0, #16
   1c30e:	f000 fa96 	bl	1c83e <z_abort_timeout>
		ret = true;
   1c312:	e7f7      	b.n	1c304 <cancel_delayable_async_locked+0x12>

0001c314 <k_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1c314:	2300      	movs	r3, #0
   1c316:	6003      	str	r3, [r0, #0]
   1c318:	6043      	str	r3, [r0, #4]
   1c31a:	6083      	str	r3, [r0, #8]
   1c31c:	60c3      	str	r3, [r0, #12]
   1c31e:	6041      	str	r1, [r0, #4]
}
   1c320:	4770      	bx	lr

0001c322 <z_work_submit_to_queue>:
{
   1c322:	b510      	push	{r4, lr}
   1c324:	b082      	sub	sp, #8
   1c326:	9001      	str	r0, [sp, #4]
   1c328:	4608      	mov	r0, r1
	__asm__ volatile(
   1c32a:	f04f 0320 	mov.w	r3, #32
   1c32e:	f3ef 8411 	mrs	r4, BASEPRI
   1c332:	f383 8812 	msr	BASEPRI_MAX, r3
   1c336:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   1c33a:	a901      	add	r1, sp, #4
   1c33c:	f7f7 fc92 	bl	13c64 <submit_to_queue_locked>
	__asm__ volatile(
   1c340:	f384 8811 	msr	BASEPRI, r4
   1c344:	f3bf 8f6f 	isb	sy
}
   1c348:	b002      	add	sp, #8
   1c34a:	bd10      	pop	{r4, pc}

0001c34c <k_work_submit_to_queue>:
{
   1c34c:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
   1c34e:	f7ff ffe8 	bl	1c322 <z_work_submit_to_queue>
	if (ret > 0) {
   1c352:	1e04      	subs	r4, r0, #0
   1c354:	dc01      	bgt.n	1c35a <k_work_submit_to_queue+0xe>
}
   1c356:	4620      	mov	r0, r4
   1c358:	bd10      	pop	{r4, pc}
	__asm__ volatile(
   1c35a:	f04f 0320 	mov.w	r3, #32
   1c35e:	f3ef 8011 	mrs	r0, BASEPRI
   1c362:	f383 8812 	msr	BASEPRI_MAX, r3
   1c366:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1c36a:	f000 f8cc 	bl	1c506 <z_reschedule_irqlock>
	return ret;
   1c36e:	e7f2      	b.n	1c356 <k_work_submit_to_queue+0xa>

0001c370 <k_work_queue_init>:
{
   1c370:	b508      	push	{r3, lr}
	*queue = (struct k_work_q) {
   1c372:	22d8      	movs	r2, #216	; 0xd8
   1c374:	2100      	movs	r1, #0
   1c376:	f7fb fa0a 	bl	1778e <memset>
}
   1c37a:	bd08      	pop	{r3, pc}

0001c37c <k_work_init_delayable>:
{
   1c37c:	b538      	push	{r3, r4, r5, lr}
   1c37e:	4604      	mov	r4, r0
   1c380:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   1c382:	2230      	movs	r2, #48	; 0x30
   1c384:	2100      	movs	r1, #0
   1c386:	f7fb fa02 	bl	1778e <memset>
   1c38a:	6065      	str	r5, [r4, #4]
   1c38c:	f44f 7380 	mov.w	r3, #256	; 0x100
   1c390:	60e3      	str	r3, [r4, #12]
}
   1c392:	bd38      	pop	{r3, r4, r5, pc}

0001c394 <k_work_delayable_busy_get>:
   1c394:	f04f 0220 	mov.w	r2, #32
   1c398:	f3ef 8311 	mrs	r3, BASEPRI
   1c39c:	f382 8812 	msr	BASEPRI_MAX, r2
   1c3a0:	f3bf 8f6f 	isb	sy
	return *flagp;
   1c3a4:	68c0      	ldr	r0, [r0, #12]
	return flags_get(&dwork->work.flags) & K_WORK_MASK;
   1c3a6:	f000 000f 	and.w	r0, r0, #15
	__asm__ volatile(
   1c3aa:	f383 8811 	msr	BASEPRI, r3
   1c3ae:	f3bf 8f6f 	isb	sy
}
   1c3b2:	4770      	bx	lr

0001c3b4 <k_work_schedule_for_queue>:
{
   1c3b4:	b510      	push	{r4, lr}
   1c3b6:	b082      	sub	sp, #8
   1c3b8:	9001      	str	r0, [sp, #4]
	__asm__ volatile(
   1c3ba:	f04f 0020 	mov.w	r0, #32
   1c3be:	f3ef 8411 	mrs	r4, BASEPRI
   1c3c2:	f380 8812 	msr	BASEPRI_MAX, r0
   1c3c6:	f3bf 8f6f 	isb	sy
	return *flagp;
   1c3ca:	68c8      	ldr	r0, [r1, #12]
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   1c3cc:	f010 0f0e 	tst.w	r0, #14
   1c3d0:	d006      	beq.n	1c3e0 <k_work_schedule_for_queue+0x2c>
	int ret = 0;
   1c3d2:	2000      	movs	r0, #0
	__asm__ volatile(
   1c3d4:	f384 8811 	msr	BASEPRI, r4
   1c3d8:	f3bf 8f6f 	isb	sy
}
   1c3dc:	b002      	add	sp, #8
   1c3de:	bd10      	pop	{r4, pc}
		ret = schedule_for_queue_locked(&queue, dwork, delay);
   1c3e0:	a801      	add	r0, sp, #4
   1c3e2:	f7f7 fccd 	bl	13d80 <schedule_for_queue_locked>
   1c3e6:	e7f5      	b.n	1c3d4 <k_work_schedule_for_queue+0x20>

0001c3e8 <k_work_reschedule_for_queue>:
{
   1c3e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c3ea:	b083      	sub	sp, #12
   1c3ec:	9001      	str	r0, [sp, #4]
   1c3ee:	460c      	mov	r4, r1
   1c3f0:	4616      	mov	r6, r2
   1c3f2:	461d      	mov	r5, r3
	__asm__ volatile(
   1c3f4:	f04f 0320 	mov.w	r3, #32
   1c3f8:	f3ef 8711 	mrs	r7, BASEPRI
   1c3fc:	f383 8812 	msr	BASEPRI_MAX, r3
   1c400:	f3bf 8f6f 	isb	sy
	return (*flagp & BIT(bit)) != 0U;
   1c404:	68cb      	ldr	r3, [r1, #12]
	*flagp &= ~BIT(bit);
   1c406:	f023 0208 	bic.w	r2, r3, #8
   1c40a:	60ca      	str	r2, [r1, #12]
	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
   1c40c:	f013 0f08 	tst.w	r3, #8
   1c410:	d10b      	bne.n	1c42a <k_work_reschedule_for_queue+0x42>
	ret = schedule_for_queue_locked(&queue, dwork, delay);
   1c412:	4632      	mov	r2, r6
   1c414:	462b      	mov	r3, r5
   1c416:	4621      	mov	r1, r4
   1c418:	a801      	add	r0, sp, #4
   1c41a:	f7f7 fcb1 	bl	13d80 <schedule_for_queue_locked>
	__asm__ volatile(
   1c41e:	f387 8811 	msr	BASEPRI, r7
   1c422:	f3bf 8f6f 	isb	sy
}
   1c426:	b003      	add	sp, #12
   1c428:	bdf0      	pop	{r4, r5, r6, r7, pc}
		z_abort_timeout(&dwork->timeout);
   1c42a:	f101 0010 	add.w	r0, r1, #16
   1c42e:	f000 fa06 	bl	1c83e <z_abort_timeout>
		ret = true;
   1c432:	e7ee      	b.n	1c412 <k_work_reschedule_for_queue+0x2a>

0001c434 <k_work_cancel_delayable>:

int k_work_cancel_delayable(struct k_work_delayable *dwork)
{
   1c434:	b510      	push	{r4, lr}
	__asm__ volatile(
   1c436:	f04f 0320 	mov.w	r3, #32
   1c43a:	f3ef 8411 	mrs	r4, BASEPRI
   1c43e:	f383 8812 	msr	BASEPRI_MAX, r3
   1c442:	f3bf 8f6f 	isb	sy
	__ASSERT_NO_MSG(dwork != NULL);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable, dwork);

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = cancel_delayable_async_locked(dwork);
   1c446:	f7ff ff54 	bl	1c2f2 <cancel_delayable_async_locked>
	__asm__ volatile(
   1c44a:	f384 8811 	msr	BASEPRI, r4
   1c44e:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable, dwork, ret);

	return ret;
}
   1c452:	bd10      	pop	{r4, pc}

0001c454 <k_work_cancel_delayable_sync>:

bool k_work_cancel_delayable_sync(struct k_work_delayable *dwork,
				  struct k_work_sync *sync)
{
   1c454:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c456:	460f      	mov	r7, r1
	__asm__ volatile(
   1c458:	f04f 0320 	mov.w	r3, #32
   1c45c:	f3ef 8611 	mrs	r6, BASEPRI
   1c460:	f383 8812 	msr	BASEPRI_MAX, r3
   1c464:	f3bf 8f6f 	isb	sy
	return *flagp;
   1c468:	68c3      	ldr	r3, [r0, #12]
	return flags_get(&dwork->work.flags) & K_WORK_MASK;
   1c46a:	f003 030f 	and.w	r3, r3, #15

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_work, cancel_delayable_sync, dwork, sync);

	struct z_work_canceller *canceller = &sync->canceller;
	k_spinlock_key_t key = k_spin_lock(&lock);
	bool pending = (work_delayable_busy_get_locked(dwork) != 0U);
   1c46e:	2b00      	cmp	r3, #0
   1c470:	bf14      	ite	ne
   1c472:	2501      	movne	r5, #1
   1c474:	2500      	moveq	r5, #0
	bool need_wait = false;

	if (pending) {
   1c476:	d107      	bne.n	1c488 <k_work_cancel_delayable_sync+0x34>
	bool need_wait = false;
   1c478:	2000      	movs	r0, #0
	__asm__ volatile(
   1c47a:	f386 8811 	msr	BASEPRI, r6
   1c47e:	f3bf 8f6f 	isb	sy
		need_wait = cancel_sync_locked(&dwork->work, canceller);
	}

	k_spin_unlock(&lock, key);

	if (need_wait) {
   1c482:	b948      	cbnz	r0, 1c498 <k_work_cancel_delayable_sync+0x44>
		k_sem_take(&canceller->sem, K_FOREVER);
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, cancel_delayable_sync, dwork, sync, pending);
	return pending;
}
   1c484:	4628      	mov	r0, r5
   1c486:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c488:	4604      	mov	r4, r0
		(void)cancel_delayable_async_locked(dwork);
   1c48a:	f7ff ff32 	bl	1c2f2 <cancel_delayable_async_locked>
		need_wait = cancel_sync_locked(&dwork->work, canceller);
   1c48e:	4639      	mov	r1, r7
   1c490:	4620      	mov	r0, r4
   1c492:	f7f7 fc53 	bl	13d3c <cancel_sync_locked>
   1c496:	e7f0      	b.n	1c47a <k_work_cancel_delayable_sync+0x26>
		k_sem_take(&canceller->sem, K_FOREVER);
   1c498:	f107 0008 	add.w	r0, r7, #8
	return z_impl_k_sem_take(sem, timeout);
   1c49c:	f04f 32ff 	mov.w	r2, #4294967295
   1c4a0:	f04f 33ff 	mov.w	r3, #4294967295
   1c4a4:	f7f7 fb9c 	bl	13be0 <z_impl_k_sem_take>
   1c4a8:	e7ec      	b.n	1c484 <k_work_cancel_delayable_sync+0x30>

0001c4aa <thread_active_elsewhere>:
}
   1c4aa:	2000      	movs	r0, #0
   1c4ac:	4770      	bx	lr

0001c4ae <pended_on_thread>:
}
   1c4ae:	6880      	ldr	r0, [r0, #8]
   1c4b0:	4770      	bx	lr

0001c4b2 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
   1c4b2:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   1c4b6:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
   1c4ba:	4283      	cmp	r3, r0
   1c4bc:	d001      	beq.n	1c4c2 <z_sched_prio_cmp+0x10>
		return b2 - b1;
   1c4be:	1ac0      	subs	r0, r0, r3
   1c4c0:	4770      	bx	lr
	return 0;
   1c4c2:	2000      	movs	r0, #0
}
   1c4c4:	4770      	bx	lr

0001c4c6 <z_unpend_thread_no_timeout>:
{
   1c4c6:	b538      	push	{r3, r4, r5, lr}
   1c4c8:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
   1c4ca:	2300      	movs	r3, #0
	__asm__ volatile(
   1c4cc:	f04f 0220 	mov.w	r2, #32
   1c4d0:	f3ef 8511 	mrs	r5, BASEPRI
   1c4d4:	f382 8812 	msr	BASEPRI_MAX, r2
   1c4d8:	f3bf 8f6f 	isb	sy
   1c4dc:	e010      	b.n	1c500 <z_unpend_thread_no_timeout+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   1c4de:	4620      	mov	r0, r4
   1c4e0:	f7ff ffe5 	bl	1c4ae <pended_on_thread>
   1c4e4:	4621      	mov	r1, r4
   1c4e6:	f000 f823 	bl	1c530 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1c4ea:	7b63      	ldrb	r3, [r4, #13]
   1c4ec:	f023 0302 	bic.w	r3, r3, #2
   1c4f0:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   1c4f2:	2300      	movs	r3, #0
   1c4f4:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   1c4f6:	f385 8811 	msr	BASEPRI, r5
   1c4fa:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c4fe:	2301      	movs	r3, #1
   1c500:	2b00      	cmp	r3, #0
   1c502:	d0ec      	beq.n	1c4de <z_unpend_thread_no_timeout+0x18>
}
   1c504:	bd38      	pop	{r3, r4, r5, pc}

0001c506 <z_reschedule_irqlock>:
{
   1c506:	b508      	push	{r3, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1c508:	4603      	mov	r3, r0
   1c50a:	b920      	cbnz	r0, 1c516 <z_reschedule_irqlock+0x10>
   1c50c:	f3ef 8205 	mrs	r2, IPSR
   1c510:	b942      	cbnz	r2, 1c524 <z_reschedule_irqlock+0x1e>
   1c512:	2201      	movs	r2, #1
   1c514:	e000      	b.n	1c518 <z_reschedule_irqlock+0x12>
   1c516:	2200      	movs	r2, #0
	if (resched(key)) {
   1c518:	b932      	cbnz	r2, 1c528 <z_reschedule_irqlock+0x22>
   1c51a:	f383 8811 	msr	BASEPRI, r3
   1c51e:	f3bf 8f6f 	isb	sy
}
   1c522:	bd08      	pop	{r3, pc}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1c524:	2200      	movs	r2, #0
   1c526:	e7f7      	b.n	1c518 <z_reschedule_irqlock+0x12>
	ret = arch_swap(key);
   1c528:	4618      	mov	r0, r3
   1c52a:	f7e7 fdd1 	bl	40d0 <arch_swap>
	return ret;
   1c52e:	e7f8      	b.n	1c522 <z_reschedule_irqlock+0x1c>

0001c530 <z_priq_dumb_remove>:
	sys_dnode_t *const prev = node->prev;
   1c530:	684a      	ldr	r2, [r1, #4]
	sys_dnode_t *const next = node->next;
   1c532:	680b      	ldr	r3, [r1, #0]
	prev->next = next;
   1c534:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   1c536:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1c538:	2300      	movs	r3, #0
   1c53a:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
   1c53c:	604b      	str	r3, [r1, #4]
}
   1c53e:	4770      	bx	lr

0001c540 <z_unpend_thread>:
{
   1c540:	b538      	push	{r3, r4, r5, lr}
   1c542:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
   1c544:	2300      	movs	r3, #0
	__asm__ volatile(
   1c546:	f04f 0220 	mov.w	r2, #32
   1c54a:	f3ef 8511 	mrs	r5, BASEPRI
   1c54e:	f382 8812 	msr	BASEPRI_MAX, r2
   1c552:	f3bf 8f6f 	isb	sy
   1c556:	e010      	b.n	1c57a <z_unpend_thread+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   1c558:	4620      	mov	r0, r4
   1c55a:	f7ff ffa8 	bl	1c4ae <pended_on_thread>
   1c55e:	4621      	mov	r1, r4
   1c560:	f7ff ffe6 	bl	1c530 <z_priq_dumb_remove>
   1c564:	7b63      	ldrb	r3, [r4, #13]
   1c566:	f023 0302 	bic.w	r3, r3, #2
   1c56a:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   1c56c:	2300      	movs	r3, #0
   1c56e:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   1c570:	f385 8811 	msr	BASEPRI, r5
   1c574:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c578:	2301      	movs	r3, #1
   1c57a:	2b00      	cmp	r3, #0
   1c57c:	d0ec      	beq.n	1c558 <z_unpend_thread+0x18>
	return z_abort_timeout(&thread->base.timeout);
   1c57e:	f104 0018 	add.w	r0, r4, #24
   1c582:	f000 f95c 	bl	1c83e <z_abort_timeout>
}
   1c586:	bd38      	pop	{r3, r4, r5, pc}

0001c588 <z_priq_dumb_best>:
{
   1c588:	4603      	mov	r3, r0
	return list->head == list;
   1c58a:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1c58c:	4283      	cmp	r3, r0
   1c58e:	d000      	beq.n	1c592 <z_priq_dumb_best+0xa>
}
   1c590:	4770      	bx	lr
	struct k_thread *thread = NULL;
   1c592:	2000      	movs	r0, #0
	return thread;
   1c594:	e7fc      	b.n	1c590 <z_priq_dumb_best+0x8>

0001c596 <z_ready_thread>:
{
   1c596:	b538      	push	{r3, r4, r5, lr}
   1c598:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
   1c59a:	2300      	movs	r3, #0
	__asm__ volatile(
   1c59c:	f04f 0220 	mov.w	r2, #32
   1c5a0:	f3ef 8511 	mrs	r5, BASEPRI
   1c5a4:	f382 8812 	msr	BASEPRI_MAX, r2
   1c5a8:	f3bf 8f6f 	isb	sy
   1c5ac:	e004      	b.n	1c5b8 <z_ready_thread+0x22>
	__asm__ volatile(
   1c5ae:	f385 8811 	msr	BASEPRI, r5
   1c5b2:	f3bf 8f6f 	isb	sy
   1c5b6:	2301      	movs	r3, #1
   1c5b8:	b943      	cbnz	r3, 1c5cc <z_ready_thread+0x36>
		if (!thread_active_elsewhere(thread)) {
   1c5ba:	4620      	mov	r0, r4
   1c5bc:	f7ff ff75 	bl	1c4aa <thread_active_elsewhere>
   1c5c0:	2800      	cmp	r0, #0
   1c5c2:	d1f4      	bne.n	1c5ae <z_ready_thread+0x18>
			ready_thread(thread);
   1c5c4:	4620      	mov	r0, r4
   1c5c6:	f7f7 fe6d 	bl	142a4 <ready_thread>
   1c5ca:	e7f0      	b.n	1c5ae <z_ready_thread+0x18>
}
   1c5cc:	bd38      	pop	{r3, r4, r5, pc}

0001c5ce <z_thread_timeout>:
{
   1c5ce:	b570      	push	{r4, r5, r6, lr}
   1c5d0:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   1c5d2:	f1a0 0518 	sub.w	r5, r0, #24
	LOCKED(&sched_spinlock) {
   1c5d6:	2300      	movs	r3, #0
	__asm__ volatile(
   1c5d8:	f04f 0220 	mov.w	r2, #32
   1c5dc:	f3ef 8611 	mrs	r6, BASEPRI
   1c5e0:	f382 8812 	msr	BASEPRI_MAX, r2
   1c5e4:	f3bf 8f6f 	isb	sy
   1c5e8:	e011      	b.n	1c60e <z_thread_timeout+0x40>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1c5ea:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   1c5ee:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   1c5f2:	f804 3c0b 	strb.w	r3, [r4, #-11]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1c5f6:	f023 0310 	bic.w	r3, r3, #16
   1c5fa:	f804 3c0b 	strb.w	r3, [r4, #-11]
			ready_thread(thread);
   1c5fe:	4628      	mov	r0, r5
   1c600:	f7f7 fe50 	bl	142a4 <ready_thread>
	__asm__ volatile(
   1c604:	f386 8811 	msr	BASEPRI, r6
   1c608:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c60c:	2301      	movs	r3, #1
   1c60e:	b9ab      	cbnz	r3, 1c63c <z_thread_timeout+0x6e>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
   1c610:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
		if (!killed) {
   1c614:	f013 0f28 	tst.w	r3, #40	; 0x28
   1c618:	d1f4      	bne.n	1c604 <z_thread_timeout+0x36>
			if (thread->base.pended_on != NULL) {
   1c61a:	f854 3c10 	ldr.w	r3, [r4, #-16]
   1c61e:	2b00      	cmp	r3, #0
   1c620:	d0e3      	beq.n	1c5ea <z_thread_timeout+0x1c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   1c622:	4628      	mov	r0, r5
   1c624:	f7ff ff43 	bl	1c4ae <pended_on_thread>
   1c628:	4629      	mov	r1, r5
   1c62a:	f7ff ff81 	bl	1c530 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1c62e:	7b6b      	ldrb	r3, [r5, #13]
   1c630:	f023 0302 	bic.w	r3, r3, #2
   1c634:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
   1c636:	2300      	movs	r3, #0
   1c638:	60ab      	str	r3, [r5, #8]
}
   1c63a:	e7d6      	b.n	1c5ea <z_thread_timeout+0x1c>
}
   1c63c:	bd70      	pop	{r4, r5, r6, pc}

0001c63e <add_to_waitq_locked>:
{
   1c63e:	b570      	push	{r4, r5, r6, lr}
   1c640:	4605      	mov	r5, r0
   1c642:	460e      	mov	r6, r1
	unready_thread(thread);
   1c644:	f7f7 fe8c 	bl	14360 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   1c648:	7b6b      	ldrb	r3, [r5, #13]
   1c64a:	f043 0302 	orr.w	r3, r3, #2
   1c64e:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
   1c650:	b1b6      	cbz	r6, 1c680 <add_to_waitq_locked+0x42>
		thread->base.pended_on = wait_q;
   1c652:	60ae      	str	r6, [r5, #8]
	return list->head == list;
   1c654:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1c656:	42a6      	cmp	r6, r4
   1c658:	d019      	beq.n	1c68e <add_to_waitq_locked+0x50>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1c65a:	b164      	cbz	r4, 1c676 <add_to_waitq_locked+0x38>
		if (z_sched_prio_cmp(thread, t) > 0) {
   1c65c:	4621      	mov	r1, r4
   1c65e:	4628      	mov	r0, r5
   1c660:	f7ff ff27 	bl	1c4b2 <z_sched_prio_cmp>
   1c664:	2800      	cmp	r0, #0
   1c666:	dc0c      	bgt.n	1c682 <add_to_waitq_locked+0x44>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1c668:	b12c      	cbz	r4, 1c676 <add_to_waitq_locked+0x38>
	return (node == list->tail) ? NULL : node->next;
   1c66a:	6873      	ldr	r3, [r6, #4]
   1c66c:	429c      	cmp	r4, r3
   1c66e:	d002      	beq.n	1c676 <add_to_waitq_locked+0x38>
   1c670:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1c672:	2c00      	cmp	r4, #0
   1c674:	d1f1      	bne.n	1c65a <add_to_waitq_locked+0x1c>
	sys_dnode_t *const tail = list->tail;
   1c676:	6873      	ldr	r3, [r6, #4]
	node->next = list;
   1c678:	602e      	str	r6, [r5, #0]
	node->prev = tail;
   1c67a:	606b      	str	r3, [r5, #4]
	tail->next = node;
   1c67c:	601d      	str	r5, [r3, #0]
	list->tail = node;
   1c67e:	6075      	str	r5, [r6, #4]
}
   1c680:	bd70      	pop	{r4, r5, r6, pc}
	sys_dnode_t *const prev = successor->prev;
   1c682:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
   1c684:	606b      	str	r3, [r5, #4]
	node->next = successor;
   1c686:	602c      	str	r4, [r5, #0]
	prev->next = node;
   1c688:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   1c68a:	6065      	str	r5, [r4, #4]
}
   1c68c:	e7f8      	b.n	1c680 <add_to_waitq_locked+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1c68e:	2400      	movs	r4, #0
   1c690:	e7e3      	b.n	1c65a <add_to_waitq_locked+0x1c>

0001c692 <pend>:
{
   1c692:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1c696:	4605      	mov	r5, r0
   1c698:	460e      	mov	r6, r1
   1c69a:	4691      	mov	r9, r2
   1c69c:	4698      	mov	r8, r3
	LOCKED(&sched_spinlock) {
   1c69e:	2400      	movs	r4, #0
	__asm__ volatile(
   1c6a0:	f04f 0320 	mov.w	r3, #32
   1c6a4:	f3ef 8711 	mrs	r7, BASEPRI
   1c6a8:	f383 8812 	msr	BASEPRI_MAX, r3
   1c6ac:	f3bf 8f6f 	isb	sy
   1c6b0:	e008      	b.n	1c6c4 <pend+0x32>
		add_to_waitq_locked(thread, wait_q);
   1c6b2:	4631      	mov	r1, r6
   1c6b4:	4628      	mov	r0, r5
   1c6b6:	f7ff ffc2 	bl	1c63e <add_to_waitq_locked>
	__asm__ volatile(
   1c6ba:	f387 8811 	msr	BASEPRI, r7
   1c6be:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c6c2:	2401      	movs	r4, #1
   1c6c4:	2c00      	cmp	r4, #0
   1c6c6:	d0f4      	beq.n	1c6b2 <pend+0x20>
	add_thread_timeout(thread, timeout);
   1c6c8:	464a      	mov	r2, r9
   1c6ca:	4643      	mov	r3, r8
   1c6cc:	4628      	mov	r0, r5
   1c6ce:	f7f7 fc7d 	bl	13fcc <add_thread_timeout>
}
   1c6d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001c6d6 <z_unpend1_no_timeout>:
{
   1c6d6:	b570      	push	{r4, r5, r6, lr}
   1c6d8:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
   1c6da:	2300      	movs	r3, #0
	__asm__ volatile(
   1c6dc:	f04f 0220 	mov.w	r2, #32
   1c6e0:	f3ef 8611 	mrs	r6, BASEPRI
   1c6e4:	f382 8812 	msr	BASEPRI_MAX, r2
   1c6e8:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
   1c6ec:	461c      	mov	r4, r3
   1c6ee:	e004      	b.n	1c6fa <z_unpend1_no_timeout+0x24>
	__asm__ volatile(
   1c6f0:	f386 8811 	msr	BASEPRI, r6
   1c6f4:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c6f8:	2301      	movs	r3, #1
   1c6fa:	b98b      	cbnz	r3, 1c720 <z_unpend1_no_timeout+0x4a>
		thread = _priq_wait_best(&wait_q->waitq);
   1c6fc:	4628      	mov	r0, r5
   1c6fe:	f7ff ff43 	bl	1c588 <z_priq_dumb_best>
		if (thread != NULL) {
   1c702:	4604      	mov	r4, r0
   1c704:	2800      	cmp	r0, #0
   1c706:	d0f3      	beq.n	1c6f0 <z_unpend1_no_timeout+0x1a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   1c708:	f7ff fed1 	bl	1c4ae <pended_on_thread>
   1c70c:	4621      	mov	r1, r4
   1c70e:	f7ff ff0f 	bl	1c530 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1c712:	7b63      	ldrb	r3, [r4, #13]
   1c714:	f023 0302 	bic.w	r3, r3, #2
   1c718:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   1c71a:	2300      	movs	r3, #0
   1c71c:	60a3      	str	r3, [r4, #8]
}
   1c71e:	e7e7      	b.n	1c6f0 <z_unpend1_no_timeout+0x1a>
}
   1c720:	4620      	mov	r0, r4
   1c722:	bd70      	pop	{r4, r5, r6, pc}

0001c724 <z_unpend_first_thread>:
{
   1c724:	b570      	push	{r4, r5, r6, lr}
   1c726:	4605      	mov	r5, r0
	LOCKED(&sched_spinlock) {
   1c728:	2300      	movs	r3, #0
	__asm__ volatile(
   1c72a:	f04f 0220 	mov.w	r2, #32
   1c72e:	f3ef 8611 	mrs	r6, BASEPRI
   1c732:	f382 8812 	msr	BASEPRI_MAX, r2
   1c736:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
   1c73a:	461c      	mov	r4, r3
   1c73c:	e004      	b.n	1c748 <z_unpend_first_thread+0x24>
	__asm__ volatile(
   1c73e:	f386 8811 	msr	BASEPRI, r6
   1c742:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c746:	2301      	movs	r3, #1
   1c748:	b9ab      	cbnz	r3, 1c776 <z_unpend_first_thread+0x52>
		thread = _priq_wait_best(&wait_q->waitq);
   1c74a:	4628      	mov	r0, r5
   1c74c:	f7ff ff1c 	bl	1c588 <z_priq_dumb_best>
		if (thread != NULL) {
   1c750:	4604      	mov	r4, r0
   1c752:	2800      	cmp	r0, #0
   1c754:	d0f3      	beq.n	1c73e <z_unpend_first_thread+0x1a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   1c756:	f7ff feaa 	bl	1c4ae <pended_on_thread>
   1c75a:	4621      	mov	r1, r4
   1c75c:	f7ff fee8 	bl	1c530 <z_priq_dumb_remove>
   1c760:	7b63      	ldrb	r3, [r4, #13]
   1c762:	f023 0302 	bic.w	r3, r3, #2
   1c766:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   1c768:	2300      	movs	r3, #0
   1c76a:	60a3      	str	r3, [r4, #8]
   1c76c:	f104 0018 	add.w	r0, r4, #24
   1c770:	f000 f865 	bl	1c83e <z_abort_timeout>
   1c774:	e7e3      	b.n	1c73e <z_unpend_first_thread+0x1a>
}
   1c776:	4620      	mov	r0, r4
   1c778:	bd70      	pop	{r4, r5, r6, pc}

0001c77a <z_unpend_all>:
{
   1c77a:	b538      	push	{r3, r4, r5, lr}
   1c77c:	4605      	mov	r5, r0
	int need_sched = 0;
   1c77e:	2000      	movs	r0, #0
	return list->head == list;
   1c780:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1c782:	42a5      	cmp	r5, r4
   1c784:	d008      	beq.n	1c798 <z_unpend_all+0x1e>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   1c786:	b13c      	cbz	r4, 1c798 <z_unpend_all+0x1e>
		z_unpend_thread(thread);
   1c788:	4620      	mov	r0, r4
   1c78a:	f7ff fed9 	bl	1c540 <z_unpend_thread>
		z_ready_thread(thread);
   1c78e:	4620      	mov	r0, r4
   1c790:	f7ff ff01 	bl	1c596 <z_ready_thread>
		need_sched = 1;
   1c794:	2001      	movs	r0, #1
   1c796:	e7f3      	b.n	1c780 <z_unpend_all+0x6>
}
   1c798:	bd38      	pop	{r3, r4, r5, pc}

0001c79a <init_ready_q>:
	sys_dlist_init(&rq->runq);
   1c79a:	1d03      	adds	r3, r0, #4
	list->head = (sys_dnode_t *)list;
   1c79c:	6043      	str	r3, [r0, #4]
	list->tail = (sys_dnode_t *)list;
   1c79e:	6083      	str	r3, [r0, #8]
}
   1c7a0:	4770      	bx	lr

0001c7a2 <z_sched_wake>:
{
   1c7a2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1c7a6:	4605      	mov	r5, r0
   1c7a8:	4688      	mov	r8, r1
   1c7aa:	4617      	mov	r7, r2
	LOCKED(&sched_spinlock) {
   1c7ac:	2300      	movs	r3, #0
	__asm__ volatile(
   1c7ae:	f04f 0220 	mov.w	r2, #32
   1c7b2:	f3ef 8611 	mrs	r6, BASEPRI
   1c7b6:	f382 8812 	msr	BASEPRI_MAX, r2
   1c7ba:	f3bf 8f6f 	isb	sy
	bool ret = false;
   1c7be:	4699      	mov	r9, r3
   1c7c0:	e004      	b.n	1c7cc <z_sched_wake+0x2a>
	__asm__ volatile(
   1c7c2:	f386 8811 	msr	BASEPRI, r6
   1c7c6:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
   1c7ca:	2301      	movs	r3, #1
   1c7cc:	b9eb      	cbnz	r3, 1c80a <z_sched_wake+0x68>
		thread = _priq_wait_best(&wait_q->waitq);
   1c7ce:	4628      	mov	r0, r5
   1c7d0:	f7ff feda 	bl	1c588 <z_priq_dumb_best>
		if (thread != NULL) {
   1c7d4:	4604      	mov	r4, r0
   1c7d6:	2800      	cmp	r0, #0
   1c7d8:	d0f3      	beq.n	1c7c2 <z_sched_wake+0x20>
   1c7da:	f8c0 80b0 	str.w	r8, [r0, #176]	; 0xb0
	thread->base.swap_data = data;
   1c7de:	6147      	str	r7, [r0, #20]
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
   1c7e0:	f7ff fe65 	bl	1c4ae <pended_on_thread>
   1c7e4:	4621      	mov	r1, r4
   1c7e6:	f7ff fea3 	bl	1c530 <z_priq_dumb_remove>
   1c7ea:	7b63      	ldrb	r3, [r4, #13]
   1c7ec:	f023 0302 	bic.w	r3, r3, #2
   1c7f0:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
   1c7f2:	2300      	movs	r3, #0
   1c7f4:	60a3      	str	r3, [r4, #8]
   1c7f6:	f104 0018 	add.w	r0, r4, #24
   1c7fa:	f000 f820 	bl	1c83e <z_abort_timeout>
			ready_thread(thread);
   1c7fe:	4620      	mov	r0, r4
   1c800:	f7f7 fd50 	bl	142a4 <ready_thread>
			ret = true;
   1c804:	f04f 0901 	mov.w	r9, #1
   1c808:	e7db      	b.n	1c7c2 <z_sched_wake+0x20>
}
   1c80a:	4648      	mov	r0, r9
   1c80c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001c810 <remove_timeout>:
{
   1c810:	b510      	push	{r4, lr}
   1c812:	4604      	mov	r4, r0
	if (next(t) != NULL) {
   1c814:	f7f8 f82a 	bl	1486c <next>
   1c818:	b148      	cbz	r0, 1c82e <remove_timeout+0x1e>
   1c81a:	4602      	mov	r2, r0
		next(t)->dticks += t->dticks;
   1c81c:	6920      	ldr	r0, [r4, #16]
   1c81e:	6961      	ldr	r1, [r4, #20]
   1c820:	6913      	ldr	r3, [r2, #16]
   1c822:	181b      	adds	r3, r3, r0
   1c824:	6950      	ldr	r0, [r2, #20]
   1c826:	eb41 0100 	adc.w	r1, r1, r0
   1c82a:	6113      	str	r3, [r2, #16]
   1c82c:	6151      	str	r1, [r2, #20]
	sys_dnode_t *const prev = node->prev;
   1c82e:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
   1c830:	6823      	ldr	r3, [r4, #0]
	prev->next = next;
   1c832:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   1c834:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1c836:	2300      	movs	r3, #0
   1c838:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
   1c83a:	6063      	str	r3, [r4, #4]
}
   1c83c:	bd10      	pop	{r4, pc}

0001c83e <z_abort_timeout>:
{
   1c83e:	b570      	push	{r4, r5, r6, lr}
   1c840:	4604      	mov	r4, r0
	LOCKED(&timeout_lock) {
   1c842:	2300      	movs	r3, #0
	__asm__ volatile(
   1c844:	f04f 0220 	mov.w	r2, #32
   1c848:	f3ef 8611 	mrs	r6, BASEPRI
   1c84c:	f382 8812 	msr	BASEPRI_MAX, r2
   1c850:	f3bf 8f6f 	isb	sy
	int ret = -EINVAL;
   1c854:	f06f 0015 	mvn.w	r0, #21
   1c858:	e004      	b.n	1c864 <z_abort_timeout+0x26>
	__asm__ volatile(
   1c85a:	f386 8811 	msr	BASEPRI, r6
   1c85e:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   1c862:	2301      	movs	r3, #1
   1c864:	461d      	mov	r5, r3
   1c866:	b93b      	cbnz	r3, 1c878 <z_abort_timeout+0x3a>
	return node->next != NULL;
   1c868:	6823      	ldr	r3, [r4, #0]
		if (sys_dnode_is_linked(&to->node)) {
   1c86a:	2b00      	cmp	r3, #0
   1c86c:	d0f5      	beq.n	1c85a <z_abort_timeout+0x1c>
			remove_timeout(to);
   1c86e:	4620      	mov	r0, r4
   1c870:	f7ff ffce 	bl	1c810 <remove_timeout>
			ret = 0;
   1c874:	4628      	mov	r0, r5
   1c876:	e7f0      	b.n	1c85a <z_abort_timeout+0x1c>
}
   1c878:	bd70      	pop	{r4, r5, r6, pc}

0001c87a <z_get_next_timeout_expiry>:
{
   1c87a:	b510      	push	{r4, lr}
	LOCKED(&timeout_lock) {
   1c87c:	2300      	movs	r3, #0
	__asm__ volatile(
   1c87e:	f04f 0220 	mov.w	r2, #32
   1c882:	f3ef 8411 	mrs	r4, BASEPRI
   1c886:	f382 8812 	msr	BASEPRI_MAX, r2
   1c88a:	f3bf 8f6f 	isb	sy
	int32_t ret = (int32_t) K_TICKS_FOREVER;
   1c88e:	f04f 30ff 	mov.w	r0, #4294967295
   1c892:	e006      	b.n	1c8a2 <z_get_next_timeout_expiry+0x28>
		ret = next_timeout();
   1c894:	f7f8 f802 	bl	1489c <next_timeout>
	__asm__ volatile(
   1c898:	f384 8811 	msr	BASEPRI, r4
   1c89c:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   1c8a0:	2301      	movs	r3, #1
   1c8a2:	2b00      	cmp	r3, #0
   1c8a4:	d0f6      	beq.n	1c894 <z_get_next_timeout_expiry+0x1a>
}
   1c8a6:	bd10      	pop	{r4, pc}

0001c8a8 <z_set_timeout_expiry>:
{
   1c8a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c8aa:	4605      	mov	r5, r0
   1c8ac:	460f      	mov	r7, r1
	LOCKED(&timeout_lock) {
   1c8ae:	2300      	movs	r3, #0
	__asm__ volatile(
   1c8b0:	f04f 0220 	mov.w	r2, #32
   1c8b4:	f3ef 8611 	mrs	r6, BASEPRI
   1c8b8:	f382 8812 	msr	BASEPRI_MAX, r2
   1c8bc:	f3bf 8f6f 	isb	sy
   1c8c0:	e00a      	b.n	1c8d8 <z_set_timeout_expiry+0x30>
			      || (ticks <= next_to);
   1c8c2:	2401      	movs	r4, #1
		bool sooner = (next_to == K_TICKS_FOREVER)
   1c8c4:	f004 0401 	and.w	r4, r4, #1
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   1c8c8:	2801      	cmp	r0, #1
   1c8ca:	dd00      	ble.n	1c8ce <z_set_timeout_expiry+0x26>
   1c8cc:	b97c      	cbnz	r4, 1c8ee <z_set_timeout_expiry+0x46>
	__asm__ volatile(
   1c8ce:	f386 8811 	msr	BASEPRI, r6
   1c8d2:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
   1c8d6:	2301      	movs	r3, #1
   1c8d8:	461c      	mov	r4, r3
   1c8da:	b97b      	cbnz	r3, 1c8fc <z_set_timeout_expiry+0x54>
		int next_to = next_timeout();
   1c8dc:	f7f7 ffde 	bl	1489c <next_timeout>
			      || (ticks <= next_to);
   1c8e0:	f1b0 3fff 	cmp.w	r0, #4294967295
   1c8e4:	d0ed      	beq.n	1c8c2 <z_set_timeout_expiry+0x1a>
   1c8e6:	42a8      	cmp	r0, r5
   1c8e8:	dbec      	blt.n	1c8c4 <z_set_timeout_expiry+0x1c>
   1c8ea:	2401      	movs	r4, #1
   1c8ec:	e7ea      	b.n	1c8c4 <z_set_timeout_expiry+0x1c>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   1c8ee:	4639      	mov	r1, r7
   1c8f0:	42a8      	cmp	r0, r5
   1c8f2:	bfa8      	it	ge
   1c8f4:	4628      	movge	r0, r5
   1c8f6:	f7f3 fe79 	bl	105ec <sys_clock_set_timeout>
   1c8fa:	e7e8      	b.n	1c8ce <z_set_timeout_expiry+0x26>
}
   1c8fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0001c8fe <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   1c8fe:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   1c900:	f7f8 f8e0 	bl	14ac4 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   1c904:	bd08      	pop	{r3, pc}

0001c906 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
   1c906:	b508      	push	{r3, lr}
	return sys_clock_tick_get();
   1c908:	f7f8 f8dc 	bl	14ac4 <sys_clock_tick_get>
}
   1c90c:	bd08      	pop	{r3, pc}

0001c90e <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   1c90e:	b900      	cbnz	r0, 1c912 <z_impl_k_busy_wait+0x4>
   1c910:	4770      	bx	lr
{
   1c912:	b508      	push	{r3, lr}
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   1c914:	f7e5 f8a6 	bl	1a64 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   1c918:	bd08      	pop	{r3, pc}

0001c91a <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1c91a:	f1b1 3fff 	cmp.w	r1, #4294967295
   1c91e:	bf08      	it	eq
   1c920:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   1c924:	d021      	beq.n	1c96a <sys_clock_timeout_end_calc+0x50>
{
   1c926:	b538      	push	{r3, r4, r5, lr}
   1c928:	4605      	mov	r5, r0
   1c92a:	460c      	mov	r4, r1
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1c92c:	ea51 0300 	orrs.w	r3, r1, r0
   1c930:	d009      	beq.n	1c946 <sys_clock_timeout_end_calc+0x2c>
		return sys_clock_tick_get();
	} else {

		dt = timeout.ticks;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   1c932:	f06f 0301 	mvn.w	r3, #1
   1c936:	1a18      	subs	r0, r3, r0
   1c938:	f04f 33ff 	mov.w	r3, #4294967295
   1c93c:	eb63 0101 	sbc.w	r1, r3, r1
   1c940:	2900      	cmp	r1, #0
   1c942:	db03      	blt.n	1c94c <sys_clock_timeout_end_calc+0x32>
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   1c944:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get();
   1c946:	f7f8 f8bd 	bl	14ac4 <sys_clock_tick_get>
   1c94a:	e7fb      	b.n	1c944 <sys_clock_timeout_end_calc+0x2a>
		return sys_clock_tick_get() + MAX(1, dt);
   1c94c:	f7f8 f8ba 	bl	14ac4 <sys_clock_tick_get>
   1c950:	4603      	mov	r3, r0
   1c952:	4628      	mov	r0, r5
   1c954:	4622      	mov	r2, r4
   1c956:	2d01      	cmp	r5, #1
   1c958:	f174 0400 	sbcs.w	r4, r4, #0
   1c95c:	da01      	bge.n	1c962 <sys_clock_timeout_end_calc+0x48>
   1c95e:	2001      	movs	r0, #1
   1c960:	2200      	movs	r2, #0
   1c962:	1818      	adds	r0, r3, r0
   1c964:	eb41 0102 	adc.w	r1, r1, r2
   1c968:	e7ec      	b.n	1c944 <sys_clock_timeout_end_calc+0x2a>
		return UINT64_MAX;
   1c96a:	f04f 30ff 	mov.w	r0, #4294967295
   1c96e:	4601      	mov	r1, r0
}
   1c970:	4770      	bx	lr

0001c972 <k_timer_init>:
	timer->expiry_fn = expiry_fn;
   1c972:	6201      	str	r1, [r0, #32]
	timer->stop_fn = stop_fn;
   1c974:	6242      	str	r2, [r0, #36]	; 0x24
	timer->status = 0U;
   1c976:	2300      	movs	r3, #0
   1c978:	6303      	str	r3, [r0, #48]	; 0x30
   1c97a:	f100 0218 	add.w	r2, r0, #24
	list->head = (sys_dnode_t *)list;
   1c97e:	6182      	str	r2, [r0, #24]
	list->tail = (sys_dnode_t *)list;
   1c980:	61c2      	str	r2, [r0, #28]
	node->next = NULL;
   1c982:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   1c984:	6043      	str	r3, [r0, #4]
	timer->user_data = NULL;
   1c986:	6343      	str	r3, [r0, #52]	; 0x34
}
   1c988:	4770      	bx	lr

0001c98a <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   1c98a:	b510      	push	{r4, lr}
   1c98c:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
   1c98e:	f7ff ff56 	bl	1c83e <z_abort_timeout>

	if (inactive) {
   1c992:	b9a0      	cbnz	r0, 1c9be <z_impl_k_timer_stop+0x34>
		return;
	}

	if (timer->stop_fn != NULL) {
   1c994:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1c996:	b10b      	cbz	r3, 1c99c <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   1c998:	4620      	mov	r0, r4
   1c99a:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   1c99c:	f104 0018 	add.w	r0, r4, #24
   1c9a0:	f7ff fe99 	bl	1c6d6 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   1c9a4:	b158      	cbz	r0, 1c9be <z_impl_k_timer_stop+0x34>
			z_ready_thread(pending_thread);
   1c9a6:	f7ff fdf6 	bl	1c596 <z_ready_thread>
	__asm__ volatile(
   1c9aa:	f04f 0320 	mov.w	r3, #32
   1c9ae:	f3ef 8011 	mrs	r0, BASEPRI
   1c9b2:	f383 8812 	msr	BASEPRI_MAX, r3
   1c9b6:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1c9ba:	f7ff fda4 	bl	1c506 <z_reschedule_irqlock>
			z_reschedule_unlocked();
		}
	}
}
   1c9be:	bd10      	pop	{r4, pc}

0001c9c0 <poller_thread>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
   1c9c0:	b108      	cbz	r0, 1c9c6 <poller_thread+0x6>
   1c9c2:	3860      	subs	r0, #96	; 0x60
   1c9c4:	4770      	bx	lr
}
   1c9c6:	4770      	bx	lr

0001c9c8 <signal_poller>:
{
   1c9c8:	b538      	push	{r3, r4, r5, lr}
   1c9ca:	460d      	mov	r5, r1
	struct k_thread *thread = poller_thread(event->poller);
   1c9cc:	6880      	ldr	r0, [r0, #8]
   1c9ce:	f7ff fff7 	bl	1c9c0 <poller_thread>
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
   1c9d2:	7b43      	ldrb	r3, [r0, #13]
	if (!z_is_thread_pending(thread)) {
   1c9d4:	f013 0f02 	tst.w	r3, #2
   1c9d8:	d025      	beq.n	1ca26 <signal_poller+0x5e>
   1c9da:	4604      	mov	r4, r0
	return thread->base.timeout.dticks == _EXPIRED;
   1c9dc:	6a82      	ldr	r2, [r0, #40]	; 0x28
   1c9de:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
	if (z_is_thread_timeout_expired(thread)) {
   1c9e0:	f1b3 3fff 	cmp.w	r3, #4294967295
   1c9e4:	bf08      	it	eq
   1c9e6:	f112 0f02 	cmneq.w	r2, #2
   1c9ea:	d01e      	beq.n	1ca2a <signal_poller+0x62>
	z_unpend_thread(thread);
   1c9ec:	f7ff fda8 	bl	1c540 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   1c9f0:	2d08      	cmp	r5, #8
   1c9f2:	d00a      	beq.n	1ca0a <signal_poller+0x42>
   1c9f4:	2300      	movs	r3, #0
   1c9f6:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
	uint8_t state = thread->base.thread_state;
   1c9fa:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   1c9fc:	f013 0f1f 	tst.w	r3, #31
   1ca00:	d108      	bne.n	1ca14 <signal_poller+0x4c>
	return node->next != NULL;
   1ca02:	69a3      	ldr	r3, [r4, #24]
   1ca04:	b123      	cbz	r3, 1ca10 <signal_poller+0x48>
   1ca06:	2300      	movs	r3, #0
   1ca08:	e005      	b.n	1ca16 <signal_poller+0x4e>
   1ca0a:	f06f 0303 	mvn.w	r3, #3
   1ca0e:	e7f2      	b.n	1c9f6 <signal_poller+0x2e>
   1ca10:	2301      	movs	r3, #1
   1ca12:	e000      	b.n	1ca16 <signal_poller+0x4e>
   1ca14:	2300      	movs	r3, #0
	if (!z_is_thread_ready(thread)) {
   1ca16:	b90b      	cbnz	r3, 1ca1c <signal_poller+0x54>
		return 0;
   1ca18:	2000      	movs	r0, #0
   1ca1a:	e005      	b.n	1ca28 <signal_poller+0x60>
	z_ready_thread(thread);
   1ca1c:	4620      	mov	r0, r4
   1ca1e:	f7ff fdba 	bl	1c596 <z_ready_thread>
	return 0;
   1ca22:	2000      	movs	r0, #0
   1ca24:	e000      	b.n	1ca28 <signal_poller+0x60>
		return 0;
   1ca26:	2000      	movs	r0, #0
}
   1ca28:	bd38      	pop	{r3, r4, r5, pc}
		return -EAGAIN;
   1ca2a:	f06f 000a 	mvn.w	r0, #10
   1ca2e:	e7fb      	b.n	1ca28 <signal_poller+0x60>

0001ca30 <signal_triggered_work>:

extern int z_work_submit_to_queue(struct k_work_q *queue,
			 struct k_work *work);

static int signal_triggered_work(struct k_poll_event *event, uint32_t status)
{
   1ca30:	b570      	push	{r4, r5, r6, lr}
	struct z_poller *poller = event->poller;
   1ca32:	6884      	ldr	r4, [r0, #8]
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
   1ca34:	7823      	ldrb	r3, [r4, #0]
   1ca36:	b173      	cbz	r3, 1ca56 <signal_triggered_work+0x26>
   1ca38:	f854 5c04 	ldr.w	r5, [r4, #-4]
   1ca3c:	b15d      	cbz	r5, 1ca56 <signal_triggered_work+0x26>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
   1ca3e:	f1a4 0614 	sub.w	r6, r4, #20
   1ca42:	f104 0014 	add.w	r0, r4, #20
   1ca46:	f7ff fefa 	bl	1c83e <z_abort_timeout>
		twork->poll_result = 0;
   1ca4a:	2300      	movs	r3, #0
   1ca4c:	62e3      	str	r3, [r4, #44]	; 0x2c
		z_work_submit_to_queue(work_q, &twork->work);
   1ca4e:	4631      	mov	r1, r6
   1ca50:	4628      	mov	r0, r5
   1ca52:	f7ff fc66 	bl	1c322 <z_work_submit_to_queue>
	}

	return 0;
}
   1ca56:	2000      	movs	r0, #0
   1ca58:	bd70      	pop	{r4, r5, r6, pc}

0001ca5a <signal_poll_event>:
{
   1ca5a:	b570      	push	{r4, r5, r6, lr}
   1ca5c:	4604      	mov	r4, r0
   1ca5e:	460d      	mov	r5, r1
	struct z_poller *poller = event->poller;
   1ca60:	6886      	ldr	r6, [r0, #8]
	if (poller != NULL) {
   1ca62:	b1d6      	cbz	r6, 1ca9a <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
   1ca64:	7873      	ldrb	r3, [r6, #1]
   1ca66:	2b01      	cmp	r3, #1
   1ca68:	d00d      	beq.n	1ca86 <signal_poll_event+0x2c>
		} else if (poller->mode == MODE_TRIGGERED) {
   1ca6a:	2b02      	cmp	r3, #2
   1ca6c:	d012      	beq.n	1ca94 <signal_poll_event+0x3a>
		poller->is_polling = false;
   1ca6e:	2000      	movs	r0, #0
   1ca70:	7030      	strb	r0, [r6, #0]
	event->poller = NULL;
   1ca72:	2300      	movs	r3, #0
   1ca74:	60a3      	str	r3, [r4, #8]
	event->state |= state;
   1ca76:	68e3      	ldr	r3, [r4, #12]
   1ca78:	f3c3 3145 	ubfx	r1, r3, #13, #6
   1ca7c:	430d      	orrs	r5, r1
   1ca7e:	f365 3352 	bfi	r3, r5, #13, #6
   1ca82:	60e3      	str	r3, [r4, #12]
}
   1ca84:	bd70      	pop	{r4, r5, r6, pc}
			retcode = signal_poller(event, state);
   1ca86:	f7ff ff9f 	bl	1c9c8 <signal_poller>
		poller->is_polling = false;
   1ca8a:	2300      	movs	r3, #0
   1ca8c:	7033      	strb	r3, [r6, #0]
		if (retcode < 0) {
   1ca8e:	4298      	cmp	r0, r3
   1ca90:	daef      	bge.n	1ca72 <signal_poll_event+0x18>
   1ca92:	e7f7      	b.n	1ca84 <signal_poll_event+0x2a>
			retcode = signal_triggered_work(event, state);
   1ca94:	f7ff ffcc 	bl	1ca30 <signal_triggered_work>
   1ca98:	e7f7      	b.n	1ca8a <signal_poll_event+0x30>
	int retcode = 0;
   1ca9a:	2000      	movs	r0, #0
   1ca9c:	e7e9      	b.n	1ca72 <signal_poll_event+0x18>

0001ca9e <k_poll_event_init>:
{
   1ca9e:	b410      	push	{r4}
	event->poller = NULL;
   1caa0:	2400      	movs	r4, #0
   1caa2:	6084      	str	r4, [r0, #8]
	event->type = type;
   1caa4:	f890 c00d 	ldrb.w	ip, [r0, #13]
   1caa8:	f361 0c04 	bfi	ip, r1, #0, #5
   1caac:	f880 c00d 	strb.w	ip, [r0, #13]
	event->state = K_POLL_STATE_NOT_READY;
   1cab0:	68c1      	ldr	r1, [r0, #12]
   1cab2:	f364 3152 	bfi	r1, r4, #13, #6
   1cab6:	60c1      	str	r1, [r0, #12]
	event->mode = mode;
   1cab8:	7b81      	ldrb	r1, [r0, #14]
   1caba:	f362 01c3 	bfi	r1, r2, #3, #1
   1cabe:	7381      	strb	r1, [r0, #14]
	event->unused = 0U;
   1cac0:	89c2      	ldrh	r2, [r0, #14]
   1cac2:	f364 120f 	bfi	r2, r4, #4, #12
   1cac6:	81c2      	strh	r2, [r0, #14]
	event->obj = obj;
   1cac8:	6103      	str	r3, [r0, #16]
}
   1caca:	bc10      	pop	{r4}
   1cacc:	4770      	bx	lr

0001cace <z_handle_obj_poll_events>:
{
   1cace:	b508      	push	{r3, lr}
   1cad0:	4603      	mov	r3, r0
	return list->head == list;
   1cad2:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   1cad4:	4283      	cmp	r3, r0
   1cad6:	d009      	beq.n	1caec <z_handle_obj_poll_events+0x1e>
	sys_dnode_t *const prev = node->prev;
   1cad8:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;
   1cada:	6803      	ldr	r3, [r0, #0]
	prev->next = next;
   1cadc:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   1cade:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1cae0:	2300      	movs	r3, #0
   1cae2:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
   1cae4:	6043      	str	r3, [r0, #4]
	if (poll_event != NULL) {
   1cae6:	b108      	cbz	r0, 1caec <z_handle_obj_poll_events+0x1e>
		(void) signal_poll_event(poll_event, state);
   1cae8:	f7ff ffb7 	bl	1ca5a <signal_poll_event>
}
   1caec:	bd08      	pop	{r3, pc}

0001caee <z_impl_k_poll_signal_init>:
	list->head = (sys_dnode_t *)list;
   1caee:	6000      	str	r0, [r0, #0]
	list->tail = (sys_dnode_t *)list;
   1caf0:	6040      	str	r0, [r0, #4]
	sig->signaled = 0U;
   1caf2:	2300      	movs	r3, #0
   1caf4:	6083      	str	r3, [r0, #8]
}
   1caf6:	4770      	bx	lr

0001caf8 <z_heap_aligned_alloc>:
{
   1caf8:	b5d0      	push	{r4, r6, r7, lr}
   1cafa:	b082      	sub	sp, #8
   1cafc:	4604      	mov	r4, r0
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   1cafe:	2300      	movs	r3, #0
   1cb00:	3204      	adds	r2, #4
   1cb02:	d20e      	bcs.n	1cb22 <z_heap_aligned_alloc+0x2a>
	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
   1cb04:	b97b      	cbnz	r3, 1cb26 <z_heap_aligned_alloc+0x2e>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   1cb06:	2600      	movs	r6, #0
   1cb08:	2700      	movs	r7, #0
   1cb0a:	e9cd 6700 	strd	r6, r7, [sp]
   1cb0e:	f041 0104 	orr.w	r1, r1, #4
   1cb12:	4620      	mov	r0, r4
   1cb14:	f7ff f978 	bl	1be08 <k_heap_aligned_alloc>
	if (mem == NULL) {
   1cb18:	b108      	cbz	r0, 1cb1e <z_heap_aligned_alloc+0x26>
	*heap_ref = heap;
   1cb1a:	f840 4b04 	str.w	r4, [r0], #4
}
   1cb1e:	b002      	add	sp, #8
   1cb20:	bdd0      	pop	{r4, r6, r7, pc}
   1cb22:	2301      	movs	r3, #1
   1cb24:	e7ee      	b.n	1cb04 <z_heap_aligned_alloc+0xc>
		return NULL;
   1cb26:	2000      	movs	r0, #0
   1cb28:	e7f9      	b.n	1cb1e <z_heap_aligned_alloc+0x26>

0001cb2a <k_free>:
	if (ptr != NULL) {
   1cb2a:	b130      	cbz	r0, 1cb3a <k_free+0x10>
{
   1cb2c:	b508      	push	{r3, lr}
		k_heap_free(*heap_ref, ptr);
   1cb2e:	1f01      	subs	r1, r0, #4
   1cb30:	f850 0c04 	ldr.w	r0, [r0, #-4]
   1cb34:	f7ff f9b1 	bl	1be9a <k_heap_free>
}
   1cb38:	bd08      	pop	{r3, pc}
   1cb3a:	4770      	bx	lr

0001cb3c <k_malloc>:
{
   1cb3c:	b508      	push	{r3, lr}
   1cb3e:	4601      	mov	r1, r0
	void *ret = k_aligned_alloc(sizeof(void *), size);
   1cb40:	2004      	movs	r0, #4
   1cb42:	f7f8 fb75 	bl	15230 <k_aligned_alloc>
}
   1cb46:	bd08      	pop	{r3, pc}

0001cb48 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   1cb48:	4770      	bx	lr
